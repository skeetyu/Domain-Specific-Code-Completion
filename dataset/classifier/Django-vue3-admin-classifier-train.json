{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> ", "gt": "if file_path :"}
{"input": "import os <EOL> exclude = [ \"<STR_LIT>\" ] <EOL> for root , dirs , files in os . walk ( '<STR_LIT>' ) : <EOL> dirs [ : ] = list ( set ( dirs ) - set ( exclude ) ) <EOL> if '<STR_LIT>' in dirs : <EOL> dir = dirs [ dirs . index ( '<STR_LIT>' ) ] <EOL> for root_j , dirs_j , files_j in os . walk ( os . path . join ( root , dir ) ) : <EOL> for file_k in files_j : <EOL> if file_k != '<STR_LIT>' : <EOL> ", "gt": "dst_file = os . path . join ( root_j , file_k )"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> var_name = body . get ( '<STR_LIT>' , None ) <EOL> table = body . get ( '<STR_LIT>' , None ) <EOL> instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> relation_id = body . get ( '<STR_LIT>' , None ) <EOL> relationIds = [ ] <EOL> if relation_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = [ relation_id ] <EOL> elif instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = relation_id . split ( '<STR_LIT>' ) <EOL> queryset = SystemConfig . objects . filter ( value__in = relationIds ) . first ( ) <EOL> if queryset is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> serializer = SystemConfigChinldernSerializer ( queryset . parent ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = serializer . data ) <EOL> class InitSettingsViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def filter_system_config_values ( self , data : dict ) : <EOL> if not self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> return data <EOL> new_data = { } <EOL> for key in self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) . split ( '<STR_LIT>' ) : <EOL> if key : <EOL> new_data . update ( ** dict ( filter ( lambda x : x [ <NUM_LIT> ] . startswith ( key ) , data . items ( ) ) ) ) <EOL> return new_data <EOL> ", "gt": "def get ( self , request ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_name ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_user_id ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> @ property <EOL> def errors ( self ) : <EOL> errors = super ( ) . errors <EOL> ", "gt": "verbose_errors = { }"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import MenuButton , RoleMenuButtonPermission <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuButtonSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuButton . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuButtonSerializer <EOL> create_serializer_class = MenuButtonCreateUpdateSerializer <EOL> update_serializer_class = MenuButtonCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) . order_by ( '<STR_LIT>' ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( serializer . data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def menu_button_all_permission ( self , request ) : <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> role_id = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = RoleMenuButtonPermission . objects . filter ( role__in = role_id ) . values_list ( '<STR_LIT>' , flat = True ) . distinct ( ) <EOL> ", "gt": "return DetailResponse ( data = queryset )"}
{"input": "from functools import wraps <EOL> from django . db . models import Func , F , OuterRef , Exists <EOL> from django . test import TestCase <EOL> import django <EOL> import os <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . system . models import Menu , RoleMenuPermission , RoleMenuButtonPermission , MenuButton <EOL> import time <EOL> def timing_decorator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = func ( * args , ** kwargs ) <EOL> end_time = time . time ( ) <EOL> run_time = end_time - start_time <EOL> print ( f\"<STR_LIT>\" ) <EOL> return result <EOL> return wrapper <EOL> @ timing_decorator <EOL> def getMenu ( ) : <EOL> data = [ ] <EOL> queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> for item in queryset : <EOL> parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) <EOL> names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] <EOL> completeName = \"<STR_LIT>\" . join ( names ) <EOL> isCheck = RoleMenuPermission . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> role__id = <NUM_LIT> , <EOL> ) . exists ( ) <EOL> mbCheck = RoleMenuButtonPermission . objects . filter ( <EOL> menu_button = OuterRef ( \"<STR_LIT>\" ) , <EOL> role__id = <NUM_LIT> , <EOL> ) <EOL> btns = MenuButton . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> ) . annotate ( isCheck = Exists ( mbCheck ) ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , data_range = F ( '<STR_LIT>' ) ) <EOL> ", "gt": "dicts = {"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> ", "gt": "elif item == <NUM_LIT> :"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> api_white_list = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return False <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> userApiList = RoleMenuButtonPermission . objects . filter ( role__in = role_id_list ) . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> ApiList = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in userApiList if item . get ( '<STR_LIT>' ) ] <EOL> new_api_ist = api_white_list + ApiList <EOL> new_api = api + \"<STR_LIT>\" + str ( method ) <EOL> for item in new_api_ist : <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> ", "gt": "return True"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> ", "gt": "search_fields = setting . get ( '<STR_LIT>' )"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . method == \"<STR_LIT>\" : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return self . readiness ( request ) <EOL> elif request . path == \"<STR_LIT>\" : <EOL> return self . healthz ( request ) <EOL> return self . get_response ( request ) <EOL> def healthz ( self , request ) : <EOL> return HttpResponse ( \"<STR_LIT>\" ) <EOL> def readiness ( self , request ) : <EOL> try : <EOL> from django . db import connections <EOL> ", "gt": "for name in connections :"}
{"input": "from django . urls import path <EOL> from rest_framework import routers <EOL> from dvadmin . system . views . api_white_list import ApiWhiteListViewSet <EOL> from dvadmin . system . views . area import AreaViewSet <EOL> from dvadmin . system . views . clause import PrivacyView , TermsServiceView <EOL> from dvadmin . system . views . dept import DeptViewSet <EOL> from dvadmin . system . views . dictionary import DictionaryViewSet <EOL> from dvadmin . system . views . file_list import FileViewSet <EOL> from dvadmin . system . views . login_log import LoginLogViewSet <EOL> from dvadmin . system . views . menu import MenuViewSet <EOL> from dvadmin . system . views . menu_button import MenuButtonViewSet <EOL> from dvadmin . system . views . message_center import MessageCenterViewSet <EOL> from dvadmin . system . views . operation_log import OperationLogViewSet <EOL> from dvadmin . system . views . role import RoleViewSet <EOL> from dvadmin . system . views . role_menu import RoleMenuPermissionViewSet <EOL> from dvadmin . system . views . role_menu_button_permission import RoleMenuButtonPermissionViewSet <EOL> from dvadmin . system . views . system_config import SystemConfigViewSet <EOL> from dvadmin . system . views . user import UserViewSet <EOL> from dvadmin . system . views . menu_field import MenuFieldViewSet <EOL> system_url = routers . SimpleRouter ( ) <EOL> system_url . register ( r'<STR_LIT>' , MenuViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuButtonViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DeptViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , UserViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , OperationLogViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DictionaryViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , AreaViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , FileViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , ApiWhiteListViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , SystemConfigViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MessageCenterViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuButtonPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuPermissionViewSet ) <EOL> ", "gt": "system_url . register ( r'<STR_LIT>' , MenuFieldViewSet )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> return queryset <EOL> else : <EOL> return self . queryset <EOL> class InitDictionaryViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> queryset = Dictionary . objects . all ( ) <EOL> def get ( self , request ) : <EOL> dictionary_key = self . request . query_params . get ( '<STR_LIT>' ) <EOL> if dictionary_key : <EOL> if dictionary_key == '<STR_LIT>' : <EOL> data = [ ele for ele in dispatch . get_dictionary_config ( ) . values ( ) ] <EOL> if not data : <EOL> dispatch . refresh_dictionary ( ) <EOL> data = [ ele for ele in dispatch . get_dictionary_config ( ) . values ( ) ] <EOL> else : <EOL> data = self . queryset . filter ( parent__value = dictionary_key , status = True ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> ", "gt": "return SuccessResponse ( data = data , msg = \"<STR_LIT>\" )"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . method == \"<STR_LIT>\" : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return self . readiness ( request ) <EOL> elif request . path == \"<STR_LIT>\" : <EOL> return self . healthz ( request ) <EOL> return self . get_response ( request ) <EOL> def healthz ( self , request ) : <EOL> return HttpResponse ( \"<STR_LIT>\" ) <EOL> def readiness ( self , request ) : <EOL> try : <EOL> from django . db import connections <EOL> for name in connections : <EOL> cursor = connections [ name ] . cursor ( ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> row = cursor . fetchone ( ) <EOL> ", "gt": "if row is None :"}
{"input": "from django . db . models import Q <EOL> from rest_framework import serializers <EOL> from dvadmin . system . models import Area <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class AreaSerializer ( CustomModelSerializer ) : <EOL> pcode_count = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_pcode_count ( self , instance : Area ) : <EOL> return Area . objects . filter ( pcode = instance ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Area . objects . filter ( pcode = instance . code ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Area <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class AreaCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Area <EOL> fields = '<STR_LIT>' <EOL> class AreaViewSet ( CustomModelViewSet ) : <EOL> queryset = Area . objects . all ( ) <EOL> serializer_class = AreaSerializer <EOL> extra_filter_class = [ ] <EOL> def get_queryset ( self ) : <EOL> self . request . query_params . _mutable = True <EOL> params = self . request . query_params <EOL> pcode = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and pcode : <EOL> queryset = self . queryset . filter ( enable = True , pcode = pcode ) <EOL> else : <EOL> queryset = self . queryset . filter ( enable = True ) <EOL> ", "gt": "return queryset"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import RoleMenuPermission , Menu , MenuButton <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleMenuPermissionSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionInitSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionViewSet ( CustomModelViewSet ) : <EOL> queryset = RoleMenuPermission . objects . all ( ) <EOL> serializer_class = RoleMenuPermissionSerializer <EOL> create_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> update_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def save_auth ( self , request ) : <EOL> body = request . data <EOL> role_id = body . get ( '<STR_LIT>' , None ) <EOL> if role_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> menu_list = body . get ( '<STR_LIT>' , None ) <EOL> if menu_list is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> obj_list = RoleMenuPermission . objects . filter ( role__id = role_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> old_set = set ( obj_list ) <EOL> new_set = set ( menu_list ) <EOL> ", "gt": "need_del = old_set . difference ( new_set )"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> var_name = body . get ( '<STR_LIT>' , None ) <EOL> table = body . get ( '<STR_LIT>' , None ) <EOL> instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> relation_id = body . get ( '<STR_LIT>' , None ) <EOL> relationIds = [ ] <EOL> if relation_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = [ relation_id ] <EOL> elif instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = relation_id . split ( '<STR_LIT>' ) <EOL> queryset = SystemConfig . objects . filter ( value__in = relationIds ) . first ( ) <EOL> if queryset is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> ", "gt": "serializer = SystemConfigChinldernSerializer ( queryset . parent )"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import MenuButton , RoleMenuButtonPermission <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuButtonSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuButton . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuButtonSerializer <EOL> create_serializer_class = MenuButtonCreateUpdateSerializer <EOL> update_serializer_class = MenuButtonCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) . order_by ( '<STR_LIT>' ) <EOL> ", "gt": "serializer = self . get_serializer ( queryset , many = True , request = request )"}
{"input": "from django . db . models import Q <EOL> from rest_framework import serializers <EOL> from dvadmin . system . models import Area <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class AreaSerializer ( CustomModelSerializer ) : <EOL> pcode_count = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_pcode_count ( self , instance : Area ) : <EOL> return Area . objects . filter ( pcode = instance ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Area . objects . filter ( pcode = instance . code ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Area <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class AreaCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Area <EOL> fields = '<STR_LIT>' <EOL> ", "gt": "class AreaViewSet ( CustomModelViewSet ) :"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> ", "gt": "serializer = Serializer ( instance , data = data , request = self . request )"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> ", "gt": "finded = True"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> ", "gt": "queryset = self . queryset . filter ( parent__isnull = True )"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = self . get_serializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> ", "gt": "instance = self . get_object ( )"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> ", "gt": "print ( f\"<STR_LIT>\" )"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> fields = ALL_FIELDS <EOL> if fields == ALL_FIELDS : <EOL> fields = cls . get_all_model_fields ( model ) <EOL> exclude = exclude or [ ] <EOL> if not isinstance ( fields , dict ) : <EOL> fields = [ ( f , [ settings . DEFAULT_LOOKUP_EXPR ] ) for f in fields if f not in exclude ] <EOL> else : <EOL> fields = [ ( f , lookups ) for f , lookups in fields . items ( ) if f not in exclude ] <EOL> return OrderedDict ( fields ) <EOL> @ classmethod <EOL> def get_filters ( cls ) : <EOL> if not cls . _meta . model : <EOL> return cls . declared_filters . copy ( ) <EOL> filters = OrderedDict ( ) <EOL> fields = cls . get_fields ( ) <EOL> undefined = [ ] <EOL> for field_name , lookups in fields . items ( ) : <EOL> field = get_model_field ( cls . _meta . model , field_name ) <EOL> from django . db import models <EOL> from timezone_field import TimeZoneField <EOL> if isinstance ( field , ( models . JSONField , TimeZoneField ) ) : <EOL> continue <EOL> if field is None : <EOL> undefined . append ( field_name ) <EOL> if ( <EOL> isinstance ( field , ( models . CharField ) ) <EOL> and filterset_fields == \"<STR_LIT>\" <EOL> and lookups == [ \"<STR_LIT>\" ] <EOL> ) : <EOL> lookups = [ \"<STR_LIT>\" ] <EOL> for lookup_expr in lookups : <EOL> filter_name = cls . get_filter_name ( field_name , lookup_expr ) <EOL> if filter_name in cls . declared_filters : <EOL> filters [ filter_name ] = cls . declared_filters [ filter_name ] <EOL> continue <EOL> if field is not None : <EOL> filters [ filter_name ] = cls . filter_for_field ( field , field_name , lookup_expr ) <EOL> if isinstance ( cls . _meta . fields , ( list , tuple ) ) : <EOL> undefined = [ f for f in undefined if f not in cls . declared_filters ] <EOL> if undefined : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" % \"<STR_LIT>\" . join ( undefined ) <EOL> ) <EOL> filters . update ( cls . declared_filters ) <EOL> return filters <EOL> class Meta ( MetaBase ) : <EOL> model = queryset . model <EOL> fields = filterset_fields <EOL> return AutoFilterSet <EOL> return None <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> filterset = self . get_filterset ( request , queryset , view ) <EOL> if filterset is None : <EOL> return queryset <EOL> if filterset . __class__ . __name__ == \"<STR_LIT>\" : <EOL> queryset = filterset . queryset <EOL> filter_fields = filterset . filters if self . filter_fields == \"<STR_LIT>\" else self . filter_fields <EOL> orm_lookup_dict = dict ( <EOL> zip ( <EOL> [ field for field in filter_fields ] , <EOL> [ filterset . filters [ lookup ] . lookup_expr for lookup in filterset . filters . keys ( ) ] , <EOL> ) <EOL> ) <EOL> orm_lookups = [ <EOL> self . construct_search ( lookup , lookup_expr ) for lookup , lookup_expr in orm_lookup_dict . items ( ) <EOL> ] <EOL> conditions = [ ] <EOL> queries = [ ] <EOL> for search_term_key in filterset . data . keys ( ) : <EOL> orm_lookup = self . find_filter_lookups ( orm_lookups , search_term_key ) <EOL> if not orm_lookup or filterset . data . get ( search_term_key ) == '<STR_LIT>' : <EOL> continue <EOL> filterset_data_len = len ( filterset . data . getlist ( search_term_key ) ) <EOL> if filterset_data_len == <NUM_LIT> : <EOL> query = Q ( ** { orm_lookup : filterset . data [ search_term_key ] } ) <EOL> queries . append ( query ) <EOL> elif filterset_data_len == <NUM_LIT> : <EOL> ", "gt": "orm_lookup += '<STR_LIT>'"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> ", "gt": "\"<STR_LIT>\" : item . __name__ ,"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> next_menu = Dept . objects . filter ( sort__gt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if next_menu : <EOL> next_menu . sort , dept . sort = dept . sort , next_menu . sort <EOL> next_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def dept_info ( self , request ) : <EOL> def inner ( did , li ) : <EOL> sub = Dept . objects . filter ( parent_id = did ) <EOL> if not sub . exists ( ) : <EOL> return li <EOL> for i in sub : <EOL> li . append ( i . pk ) <EOL> inner ( i , li ) <EOL> ", "gt": "return li"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> queryset = self . queryset . filter ( status = <NUM_LIT> ) <EOL> else : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def get_all_menu ( self , request ) : <EOL> user = request . user <EOL> queryset = self . queryset . all ( ) <EOL> if not user . is_superuser : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def move_up ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> menu = Menu . objects . get ( id = menu_id ) <EOL> ", "gt": "except Menu . DoesNotExist :"}
{"input": "from django . urls import path <EOL> from rest_framework import routers <EOL> from dvadmin . system . views . api_white_list import ApiWhiteListViewSet <EOL> from dvadmin . system . views . area import AreaViewSet <EOL> from dvadmin . system . views . clause import PrivacyView , TermsServiceView <EOL> from dvadmin . system . views . dept import DeptViewSet <EOL> from dvadmin . system . views . dictionary import DictionaryViewSet <EOL> from dvadmin . system . views . file_list import FileViewSet <EOL> from dvadmin . system . views . login_log import LoginLogViewSet <EOL> from dvadmin . system . views . menu import MenuViewSet <EOL> from dvadmin . system . views . menu_button import MenuButtonViewSet <EOL> from dvadmin . system . views . message_center import MessageCenterViewSet <EOL> from dvadmin . system . views . operation_log import OperationLogViewSet <EOL> from dvadmin . system . views . role import RoleViewSet <EOL> from dvadmin . system . views . role_menu import RoleMenuPermissionViewSet <EOL> from dvadmin . system . views . role_menu_button_permission import RoleMenuButtonPermissionViewSet <EOL> from dvadmin . system . views . system_config import SystemConfigViewSet <EOL> from dvadmin . system . views . user import UserViewSet <EOL> from dvadmin . system . views . menu_field import MenuFieldViewSet <EOL> system_url = routers . SimpleRouter ( ) <EOL> system_url . register ( r'<STR_LIT>' , MenuViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuButtonViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DeptViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , UserViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , OperationLogViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DictionaryViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , AreaViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , FileViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , ApiWhiteListViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , SystemConfigViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MessageCenterViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuButtonPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuFieldViewSet ) <EOL> urlpatterns = [ <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , } ) ) , <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , LoginLogViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , LoginLogViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , DeptViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , PrivacyView . as_view ( ) ) , <EOL> path ( '<STR_LIT>' , TermsServiceView . as_view ( ) ) , <EOL> ] <EOL> ", "gt": "urlpatterns += system_url . urls"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> api_white_list = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return False <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> userApiList = RoleMenuButtonPermission . objects . filter ( role__in = role_id_list ) . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> ApiList = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in userApiList if item . get ( '<STR_LIT>' ) ] <EOL> new_api_ist = api_white_list + ApiList <EOL> new_api = api + \"<STR_LIT>\" + str ( method ) <EOL> for item in new_api_ist : <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> ", "gt": "if matchObj is None :"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> ", "gt": "api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) )"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> ", "gt": "users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True )"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> return settings . ALL_MODELS_OBJECTS [ model_name ] or { } <EOL> return settings . ALL_MODELS_OBJECTS or { } <EOL> def get_model_from_app ( app_name ) : <EOL> model_module = import_module ( app_name + '<STR_LIT>' ) <EOL> filter_model = [ <EOL> getattr ( model_module , item ) for item in dir ( model_module ) <EOL> if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) <EOL> ] <EOL> model_list = [ ] <EOL> for model in filter_model : <EOL> if model . __name__ == '<STR_LIT>' : <EOL> continue <EOL> fields = [ <EOL> { '<STR_LIT>' : field . verbose_name , '<STR_LIT>' : field . name , '<STR_LIT>' : field } <EOL> for field in model . _meta . fields <EOL> ] <EOL> model_list . append ( { <EOL> ", "gt": "'<STR_LIT>' : app_name ,"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> ", "gt": "method = request . method"}
{"input": "from rest_framework . views import APIView <EOL> from django . shortcuts import render <EOL> class PrivacyView ( APIView ) : <EOL> permission_classes = [ ] <EOL> def get ( self , request , * args , ** kwargs ) : <EOL> ", "gt": "return render ( request , '<STR_LIT>' )"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> ", "gt": "return settings . ALL_MODELS_OBJECTS [ model_name ] or { }"}
{"input": "from functools import wraps <EOL> from django . db . models import Func , F , OuterRef , Exists <EOL> from django . test import TestCase <EOL> import django <EOL> import os <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . system . models import Menu , RoleMenuPermission , RoleMenuButtonPermission , MenuButton <EOL> import time <EOL> def timing_decorator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = func ( * args , ** kwargs ) <EOL> end_time = time . time ( ) <EOL> run_time = end_time - start_time <EOL> print ( f\"<STR_LIT>\" ) <EOL> return result <EOL> return wrapper <EOL> @ timing_decorator <EOL> def getMenu ( ) : <EOL> data = [ ] <EOL> queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> for item in queryset : <EOL> parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) <EOL> names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] <EOL> completeName = \"<STR_LIT>\" . join ( names ) <EOL> isCheck = RoleMenuPermission . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> role__id = <NUM_LIT> , <EOL> ) . exists ( ) <EOL> mbCheck = RoleMenuButtonPermission . objects . filter ( <EOL> menu_button = OuterRef ( \"<STR_LIT>\" ) , <EOL> role__id = <NUM_LIT> , <EOL> ) <EOL> btns = MenuButton . objects . filter ( <EOL> ", "gt": "menu__id = item [ '<STR_LIT>' ] ,"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> obj . objects . all ( ) . delete ( ) <EOL> settings . INITIALIZE_RESET_LIST . append ( obj ) <EOL> except Exception : <EOL> pass <EOL> for ele in data : <EOL> m2m_dict = { } <EOL> new_data = { } <EOL> for key , value in ele . items ( ) : <EOL> if isinstance ( value , list ) and value and isinstance ( value [ <NUM_LIT> ] , int ) : <EOL> m2m_dict [ key ] = value <EOL> else : <EOL> ", "gt": "new_data [ key ] = value"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> ", "gt": "if setting is None :"}
{"input": "from rest_framework . views import APIView <EOL> from django . shortcuts import render <EOL> class PrivacyView ( APIView ) : <EOL> permission_classes = [ ] <EOL> def get ( self , request , * args , ** kwargs ) : <EOL> return render ( request , '<STR_LIT>' ) <EOL> class TermsServiceView ( APIView ) : <EOL> permission_classes = [ ] <EOL> def get ( self , request , * args , ** kwargs ) : <EOL> ", "gt": "return render ( request , '<STR_LIT>' )"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import RoleMenuPermission , Menu , MenuButton <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleMenuPermissionSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionInitSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionViewSet ( CustomModelViewSet ) : <EOL> queryset = RoleMenuPermission . objects . all ( ) <EOL> serializer_class = RoleMenuPermissionSerializer <EOL> create_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> update_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def save_auth ( self , request ) : <EOL> body = request . data <EOL> role_id = body . get ( '<STR_LIT>' , None ) <EOL> if role_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> menu_list = body . get ( '<STR_LIT>' , None ) <EOL> if menu_list is None : <EOL> ", "gt": "return ErrorResponse ( msg = \"<STR_LIT>\" )"}
{"input": "import hashlib <EOL> import logging <EOL> from django . contrib . auth import get_user_model <EOL> from django . contrib . auth . backends import ModelBackend <EOL> from django . contrib . auth . hashers import check_password <EOL> from django . utils import timezone <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> logger = logging . getLogger ( __name__ ) <EOL> UserModel = get_user_model ( ) <EOL> class CustomBackend ( ModelBackend ) : <EOL> def authenticate ( self , request , username = None , password = None , ** kwargs ) : <EOL> msg = '<STR_LIT>' % username <EOL> logger . info ( msg ) <EOL> if username is None : <EOL> username = kwargs . get ( UserModel . USERNAME_FIELD ) <EOL> try : <EOL> user = UserModel . _default_manager . get_by_natural_key ( username ) <EOL> except UserModel . DoesNotExist : <EOL> UserModel ( ) . set_password ( password ) <EOL> else : <EOL> verify_password = check_password ( password , user . password ) <EOL> if not verify_password : <EOL> password = hashlib . md5 ( password . encode ( encoding = '<STR_LIT>' ) ) . hexdigest ( ) <EOL> verify_password = check_password ( password , user . password ) <EOL> if verify_password : <EOL> if self . user_can_authenticate ( user ) : <EOL> user . last_login = timezone . now ( ) <EOL> ", "gt": "user . save ( )"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> ", "gt": "else :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> ", "gt": "try :"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> ", "gt": "model_name = request . data . get ( '<STR_LIT>' )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> queryset = self . queryset . filter ( status = <NUM_LIT> ) <EOL> else : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def get_all_menu ( self , request ) : <EOL> ", "gt": "user = request . user"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> model = Users <EOL> ", "gt": "fields = \"<STR_LIT>\""}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_name ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_user_id ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> @ property <EOL> def errors ( self ) : <EOL> errors = super ( ) . errors <EOL> verbose_errors = { } <EOL> fields = { field . name : field . verbose_name for field in <EOL> self . Meta . model . _meta . get_fields ( ) if hasattr ( field , '<STR_LIT>' ) } <EOL> for field_name , error in errors . items ( ) : <EOL> if field_name in fields : <EOL> ", "gt": "verbose_errors [ str ( fields [ field_name ] ) ] = error"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> api_white_list = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] <EOL> ", "gt": "if not hasattr ( request . user , \"<STR_LIT>\" ) :"}
{"input": "import functools <EOL> import os <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from django . conf import settings <EOL> from celery import platforms <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from tenant_schemas_celery . app import CeleryApp as TenantAwareCeleryApp <EOL> app = TenantAwareCeleryApp ( ) <EOL> else : <EOL> from celery import Celery <EOL> app = Celery ( f\"<STR_LIT>\" ) <EOL> app . config_from_object ( '<STR_LIT>' ) <EOL> ", "gt": "app . autodiscover_tasks ( lambda : settings . INSTALLED_APPS )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_name ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> ", "gt": "return None"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> model_name = request . data . get ( '<STR_LIT>' ) <EOL> if not menu_id or not model_name : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] != model_name : <EOL> continue <EOL> for field in model [ '<STR_LIT>' ] : <EOL> if MenuField . objects . filter ( <EOL> menu_id = menu_id , model = model_name , field_name = field [ '<STR_LIT>' ] <EOL> ) . exists ( ) : <EOL> continue <EOL> ", "gt": "data = {"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import RoleMenuPermission , Menu , MenuButton <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleMenuPermissionSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionInitSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionViewSet ( CustomModelViewSet ) : <EOL> queryset = RoleMenuPermission . objects . all ( ) <EOL> serializer_class = RoleMenuPermissionSerializer <EOL> ", "gt": "create_serializer_class = RoleMenuPermissionCreateUpdateSerializer"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> class FieldPermissionMixin : <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def field_permission ( self , request ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is self . serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded : <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> user = request . user <EOL> if user . is_superuser == <NUM_LIT> : <EOL> data = MenuField . objects . filter ( model = model [ '<STR_LIT>' ] ) . values ( '<STR_LIT>' ) <EOL> for item in data : <EOL> ", "gt": "item [ '<STR_LIT>' ] = True"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> ", "gt": "serializer . save ( )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> ", "gt": "if params :"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> model_name = request . data . get ( '<STR_LIT>' ) <EOL> if not menu_id or not model_name : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] != model_name : <EOL> continue <EOL> for field in model [ '<STR_LIT>' ] : <EOL> if MenuField . objects . filter ( <EOL> menu_id = menu_id , model = model_name , field_name = field [ '<STR_LIT>' ] <EOL> ) . exists ( ) : <EOL> continue <EOL> data = { <EOL> '<STR_LIT>' : menu_id , <EOL> '<STR_LIT>' : model_name , <EOL> '<STR_LIT>' : field [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : str ( field [ '<STR_LIT>' ] ) , <EOL> ", "gt": "}"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> if not getattr ( settings , \"<STR_LIT>\" , False ) : <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginTokenView ( TokenObtainPairView ) : <EOL> serializer_class = LoginTokenSerializer <EOL> permission_classes = [ ] <EOL> class LogoutView ( APIView ) : <EOL> def post ( self , request ) : <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> class ApiLoginSerializer ( CustomModelSerializer ) : <EOL> username = serializers . CharField ( ) <EOL> password = serializers . CharField ( ) <EOL> class Meta : <EOL> model = Users <EOL> fields = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class ApiLogin ( APIView ) : <EOL> serializer_class = ApiLoginSerializer <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def post ( self , request ) : <EOL> username = request . data . get ( \"<STR_LIT>\" ) <EOL> password = request . data . get ( \"<STR_LIT>\" ) <EOL> user_obj = auth . authenticate ( <EOL> request , <EOL> username = username , <EOL> password = hashlib . md5 ( password . encode ( encoding = \"<STR_LIT>\" ) ) . hexdigest ( ) , <EOL> ) <EOL> if user_obj : <EOL> login ( request , user_obj ) <EOL> return redirect ( \"<STR_LIT>\" ) <EOL> ", "gt": "else :"}
{"input": "from django . db import DataError <EOL> from rest_framework . exceptions import APIException <EOL> from rest_framework . validators import UniqueValidator <EOL> class CustomValidationError ( APIException ) : <EOL> def __init__ ( self , detail ) : <EOL> self . detail = detail <EOL> def qs_exists ( queryset ) : <EOL> try : <EOL> return queryset . exists ( ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return False <EOL> def qs_filter ( queryset , ** kwargs ) : <EOL> try : <EOL> return queryset . filter ( ** kwargs ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return queryset . none ( ) <EOL> class CustomUniqueValidator ( UniqueValidator ) : <EOL> def filter_queryset ( self , value , queryset , field_name ) : <EOL> filter_kwargs = { '<STR_LIT>' % ( field_name , self . lookup ) : value } <EOL> return qs_filter ( queryset , ** filter_kwargs ) <EOL> def exclude_current_instance ( self , queryset , instance ) : <EOL> if instance is not None : <EOL> return queryset . exclude ( pk = instance . pk ) <EOL> return queryset <EOL> ", "gt": "def __call__ ( self , value , serializer_field ) :"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> target_role = None , message : dict = None , request = Request ) : <EOL> if message is None : <EOL> message = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> if target_role is None : <EOL> target_role = [ ] <EOL> if target_dept is None : <EOL> target_dept = [ ] <EOL> data = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : content , <EOL> \"<STR_LIT>\" : target_type , <EOL> \"<STR_LIT>\" : target_user , <EOL> \"<STR_LIT>\" : target_dept , <EOL> \"<STR_LIT>\" : target_role <EOL> } <EOL> message_center_instance = MessageCreateSerializer ( data = data , request = request ) <EOL> message_center_instance . is_valid ( raise_exception = True ) <EOL> message_center_instance . save ( ) <EOL> users = target_user or [ ] <EOL> if target_type in [ <NUM_LIT> ] : <EOL> ", "gt": "users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True )"}
{"input": "import logging <EOL> import traceback <EOL> from django . db . models import ProtectedError <EOL> from django . http import Http404 <EOL> from rest_framework . exceptions import APIException as DRFAPIException , AuthenticationFailed , NotAuthenticated <EOL> from rest_framework . status import HTTP_401_UNAUTHORIZED <EOL> from rest_framework . views import set_rollback , exception_handler <EOL> from dvadmin . utils . json_response import ErrorResponse <EOL> logger = logging . getLogger ( __name__ ) <EOL> class CustomAuthenticationFailed ( NotAuthenticated ) : <EOL> status_code = <NUM_LIT> <EOL> def CustomExceptionHandler ( ex , context ) : <EOL> msg = '<STR_LIT>' <EOL> code = <NUM_LIT> <EOL> response = exception_handler ( ex , context ) <EOL> if isinstance ( ex , AuthenticationFailed ) : <EOL> if response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> return ErrorResponse ( status = HTTP_401_UNAUTHORIZED ) <EOL> else : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif isinstance ( ex , Http404 ) : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> elif isinstance ( ex , DRFAPIException ) : <EOL> set_rollback ( ) <EOL> ", "gt": "msg = ex . detail"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> elif value_type == '<STR_LIT>' : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) <EOL> else : <EOL> ", "gt": "if type ( cell_value ) is float and str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] == \"<STR_LIT>\" :"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> ", "gt": "if isinstance ( request . user , AnonymousUser ) :"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . method == \"<STR_LIT>\" : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return self . readiness ( request ) <EOL> elif request . path == \"<STR_LIT>\" : <EOL> return self . healthz ( request ) <EOL> ", "gt": "return self . get_response ( request )"}
{"input": "import logging <EOL> from django . core . management . base import BaseCommand <EOL> from application import settings <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> nargs = \"<STR_LIT>\" , <EOL> type = str , <EOL> ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> def handle ( self , * args , ** options ) : <EOL> reset = False <EOL> ", "gt": "if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) :"}
{"input": "import hashlib <EOL> import logging <EOL> from django . contrib . auth import get_user_model <EOL> from django . contrib . auth . backends import ModelBackend <EOL> from django . contrib . auth . hashers import check_password <EOL> from django . utils import timezone <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> logger = logging . getLogger ( __name__ ) <EOL> UserModel = get_user_model ( ) <EOL> class CustomBackend ( ModelBackend ) : <EOL> def authenticate ( self , request , username = None , password = None , ** kwargs ) : <EOL> msg = '<STR_LIT>' % username <EOL> logger . info ( msg ) <EOL> if username is None : <EOL> username = kwargs . get ( UserModel . USERNAME_FIELD ) <EOL> try : <EOL> user = UserModel . _default_manager . get_by_natural_key ( username ) <EOL> except UserModel . DoesNotExist : <EOL> UserModel ( ) . set_password ( password ) <EOL> else : <EOL> verify_password = check_password ( password , user . password ) <EOL> if not verify_password : <EOL> ", "gt": "password = hashlib . md5 ( password . encode ( encoding = '<STR_LIT>' ) ) . hexdigest ( )"}
{"input": "import logging <EOL> import traceback <EOL> from django . db . models import ProtectedError <EOL> from django . http import Http404 <EOL> from rest_framework . exceptions import APIException as DRFAPIException , AuthenticationFailed , NotAuthenticated <EOL> from rest_framework . status import HTTP_401_UNAUTHORIZED <EOL> from rest_framework . views import set_rollback , exception_handler <EOL> from dvadmin . utils . json_response import ErrorResponse <EOL> logger = logging . getLogger ( __name__ ) <EOL> class CustomAuthenticationFailed ( NotAuthenticated ) : <EOL> status_code = <NUM_LIT> <EOL> def CustomExceptionHandler ( ex , context ) : <EOL> msg = '<STR_LIT>' <EOL> code = <NUM_LIT> <EOL> response = exception_handler ( ex , context ) <EOL> if isinstance ( ex , AuthenticationFailed ) : <EOL> if response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> return ErrorResponse ( status = HTTP_401_UNAUTHORIZED ) <EOL> ", "gt": "else :"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> return settings . ALL_MODELS_OBJECTS [ model_name ] or { } <EOL> return settings . ALL_MODELS_OBJECTS or { } <EOL> def get_model_from_app ( app_name ) : <EOL> model_module = import_module ( app_name + '<STR_LIT>' ) <EOL> filter_model = [ <EOL> getattr ( model_module , item ) for item in dir ( model_module ) <EOL> if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) <EOL> ] <EOL> model_list = [ ] <EOL> for model in filter_model : <EOL> if model . __name__ == '<STR_LIT>' : <EOL> continue <EOL> fields = [ <EOL> ", "gt": "{ '<STR_LIT>' : field . verbose_name , '<STR_LIT>' : field . name , '<STR_LIT>' : field }"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> ", "gt": "try :"}
{"input": "import multiprocessing <EOL> workers = multiprocessing . cpu_count ( ) * <NUM_LIT> + <NUM_LIT> <EOL> threads = <NUM_LIT> <EOL> bind = '<STR_LIT>' <EOL> daemon = '<STR_LIT>' <EOL> worker_class = '<STR_LIT>' <EOL> worker_connections = <NUM_LIT> <EOL> max_requests = <NUM_LIT> <EOL> max_requests_jitter = <NUM_LIT> <EOL> pidfile = '<STR_LIT>' <EOL> loglevel = '<STR_LIT>' <EOL> access_log_format = '<STR_LIT>' <EOL> backlog = <NUM_LIT> <EOL> ", "gt": "proc_name = '<STR_LIT>'"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> return queryset <EOL> else : <EOL> return self . queryset <EOL> class InitDictionaryViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> queryset = Dictionary . objects . all ( ) <EOL> def get ( self , request ) : <EOL> dictionary_key = self . request . query_params . get ( '<STR_LIT>' ) <EOL> if dictionary_key : <EOL> if dictionary_key == '<STR_LIT>' : <EOL> data = [ ele for ele in dispatch . get_dictionary_config ( ) . values ( ) ] <EOL> if not data : <EOL> ", "gt": "dispatch . refresh_dictionary ( )"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = self . get_serializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def update ( self , request , * args , ** kwargs ) : <EOL> partial = kwargs . pop ( '<STR_LIT>' , False ) <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance , data = request . data , request = request , partial = partial ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_update ( serializer ) <EOL> if getattr ( instance , '<STR_LIT>' , None ) : <EOL> instance . _prefetched_objects_cache = { } <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def destroy ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> instance . delete ( ) <EOL> return DetailResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> keys = openapi . Schema ( description = '<STR_LIT>' , type = openapi . TYPE_ARRAY , items = openapi . TYPE_STRING ) <EOL> @ swagger_auto_schema ( request_body = openapi . Schema ( <EOL> type = openapi . TYPE_OBJECT , <EOL> required = [ '<STR_LIT>' ] , <EOL> properties = { '<STR_LIT>' : keys } <EOL> ) , operation_summary = '<STR_LIT>' ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def multiple_delete ( self , request , * args , ** kwargs ) : <EOL> ", "gt": "request_data = request . data"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> ", "gt": "else :"}
{"input": "import logging <EOL> from django . core . management . base import BaseCommand <EOL> from application import settings <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> nargs = \"<STR_LIT>\" , <EOL> type = str , <EOL> ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> def handle ( self , * args , ** options ) : <EOL> reset = False <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = True <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = False <EOL> for app in settings . INSTALLED_APPS : <EOL> try : <EOL> ", "gt": "exec ("}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> ", "gt": "await self . channel_layer . group_send ("}
{"input": "import multiprocessing <EOL> workers = multiprocessing . cpu_count ( ) * <NUM_LIT> + <NUM_LIT> <EOL> threads = <NUM_LIT> <EOL> bind = '<STR_LIT>' <EOL> daemon = '<STR_LIT>' <EOL> worker_class = '<STR_LIT>' <EOL> worker_connections = <NUM_LIT> <EOL> max_requests = <NUM_LIT> <EOL> max_requests_jitter = <NUM_LIT> <EOL> pidfile = '<STR_LIT>' <EOL> ", "gt": "loglevel = '<STR_LIT>'"}
{"input": "import multiprocessing <EOL> workers = multiprocessing . cpu_count ( ) * <NUM_LIT> + <NUM_LIT> <EOL> threads = <NUM_LIT> <EOL> bind = '<STR_LIT>' <EOL> daemon = '<STR_LIT>' <EOL> worker_class = '<STR_LIT>' <EOL> worker_connections = <NUM_LIT> <EOL> max_requests = <NUM_LIT> <EOL> max_requests_jitter = <NUM_LIT> <EOL> pidfile = '<STR_LIT>' <EOL> loglevel = '<STR_LIT>' <EOL> ", "gt": "access_log_format = '<STR_LIT>'"}
{"input": "import functools <EOL> import os <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from django . conf import settings <EOL> from celery import platforms <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from tenant_schemas_celery . app import CeleryApp as TenantAwareCeleryApp <EOL> app = TenantAwareCeleryApp ( ) <EOL> else : <EOL> from celery import Celery <EOL> app = Celery ( f\"<STR_LIT>\" ) <EOL> app . config_from_object ( '<STR_LIT>' ) <EOL> app . autodiscover_tasks ( lambda : settings . INSTALLED_APPS ) <EOL> platforms . C_FORCE_ROOT = True <EOL> def retry_base_task_error ( ) : <EOL> def wraps ( func ) : <EOL> @ app . task ( bind = True , retry_delay = <NUM_LIT> , max_retries = <NUM_LIT> ) <EOL> @ functools . wraps ( func ) <EOL> def wrapper ( self , * args , ** kwargs ) : <EOL> try : <EOL> return func ( * args , ** kwargs ) <EOL> except Exception as exc : <EOL> ", "gt": "raise self . retry ( exc = exc )"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ", "gt": ")"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> model_name = request . data . get ( '<STR_LIT>' ) <EOL> if not menu_id or not model_name : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] != model_name : <EOL> continue <EOL> ", "gt": "for field in model [ '<STR_LIT>' ] :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MenuButtonPermissionSerializer ( CustomModelSerializer ) : <EOL> ", "gt": "isCheck = serializers . SerializerMethodField ( )"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> target_role = None , message : dict = None , request = Request ) : <EOL> ", "gt": "if message is None :"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> ", "gt": "return [ ]"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> ", "gt": "validated_data [ '<STR_LIT>' ] = file_path"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MenuButtonPermissionSerializer ( CustomModelSerializer ) : <EOL> isCheck = serializers . SerializerMethodField ( ) <EOL> def get_isCheck ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> ", "gt": "return True"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> fields = ALL_FIELDS <EOL> if fields == ALL_FIELDS : <EOL> fields = cls . get_all_model_fields ( model ) <EOL> exclude = exclude or [ ] <EOL> if not isinstance ( fields , dict ) : <EOL> fields = [ ( f , [ settings . DEFAULT_LOOKUP_EXPR ] ) for f in fields if f not in exclude ] <EOL> else : <EOL> fields = [ ( f , lookups ) for f , lookups in fields . items ( ) if f not in exclude ] <EOL> return OrderedDict ( fields ) <EOL> @ classmethod <EOL> def get_filters ( cls ) : <EOL> if not cls . _meta . model : <EOL> return cls . declared_filters . copy ( ) <EOL> filters = OrderedDict ( ) <EOL> fields = cls . get_fields ( ) <EOL> undefined = [ ] <EOL> for field_name , lookups in fields . items ( ) : <EOL> field = get_model_field ( cls . _meta . model , field_name ) <EOL> from django . db import models <EOL> from timezone_field import TimeZoneField <EOL> if isinstance ( field , ( models . JSONField , TimeZoneField ) ) : <EOL> continue <EOL> if field is None : <EOL> undefined . append ( field_name ) <EOL> if ( <EOL> isinstance ( field , ( models . CharField ) ) <EOL> and filterset_fields == \"<STR_LIT>\" <EOL> and lookups == [ \"<STR_LIT>\" ] <EOL> ) : <EOL> lookups = [ \"<STR_LIT>\" ] <EOL> for lookup_expr in lookups : <EOL> filter_name = cls . get_filter_name ( field_name , lookup_expr ) <EOL> if filter_name in cls . declared_filters : <EOL> filters [ filter_name ] = cls . declared_filters [ filter_name ] <EOL> continue <EOL> if field is not None : <EOL> filters [ filter_name ] = cls . filter_for_field ( field , field_name , lookup_expr ) <EOL> if isinstance ( cls . _meta . fields , ( list , tuple ) ) : <EOL> undefined = [ f for f in undefined if f not in cls . declared_filters ] <EOL> if undefined : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" % \"<STR_LIT>\" . join ( undefined ) <EOL> ) <EOL> filters . update ( cls . declared_filters ) <EOL> return filters <EOL> class Meta ( MetaBase ) : <EOL> model = queryset . model <EOL> fields = filterset_fields <EOL> return AutoFilterSet <EOL> return None <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> filterset = self . get_filterset ( request , queryset , view ) <EOL> if filterset is None : <EOL> return queryset <EOL> if filterset . __class__ . __name__ == \"<STR_LIT>\" : <EOL> queryset = filterset . queryset <EOL> filter_fields = filterset . filters if self . filter_fields == \"<STR_LIT>\" else self . filter_fields <EOL> orm_lookup_dict = dict ( <EOL> zip ( <EOL> [ field for field in filter_fields ] , <EOL> [ filterset . filters [ lookup ] . lookup_expr for lookup in filterset . filters . keys ( ) ] , <EOL> ) <EOL> ) <EOL> orm_lookups = [ <EOL> self . construct_search ( lookup , lookup_expr ) for lookup , lookup_expr in orm_lookup_dict . items ( ) <EOL> ", "gt": "]"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> api_white_list = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return False <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> userApiList = RoleMenuButtonPermission . objects . filter ( role__in = role_id_list ) . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> ApiList = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in userApiList if item . get ( '<STR_LIT>' ) ] <EOL> new_api_ist = api_white_list + ApiList <EOL> new_api = api + \"<STR_LIT>\" + str ( method ) <EOL> for item in new_api_ist : <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> ", "gt": "else :"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterViewSet ( CustomModelViewSet ) : <EOL> queryset = MessageCenter . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MessageCenterSerializer <EOL> create_serializer_class = MessageCenterCreateSerializer <EOL> extra_filter_backends = [ ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> return MessageCenter . objects . filter ( creator = self . request . user . id ) . all ( ) <EOL> return MessageCenter . objects . all ( ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> pk = kwargs . get ( '<STR_LIT>' ) <EOL> user_id = self . request . user . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( users__id = user_id , messagecenter__id = pk ) . first ( ) <EOL> if queryset : <EOL> queryset . is_read = True <EOL> queryset . save ( ) <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance ) <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user_id , is_read = False ) . count ( ) <EOL> websocket_push ( user_id , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_self_receive ( self , request ) : <EOL> self_user_id = self . request . user . id <EOL> queryset = MessageCenter . objects . filter ( target_user__id = self_user_id ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = MessageCenterTargetUserListSerializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = MessageCenterTargetUserListSerializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> ", "gt": "@ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] )"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> ", "gt": "serializer = self . get_serializer ( data = request . data , request = request )"}
{"input": "from rest_framework . response import Response <EOL> class SuccessResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , page = <NUM_LIT> , limit = <NUM_LIT> , total = <NUM_LIT> ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : page , <EOL> \"<STR_LIT>\" : limit , <EOL> \"<STR_LIT>\" : total , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class DetailResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class ErrorResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , code = <NUM_LIT> , status = None , template_name = None , headers = None , <EOL> exception = False , content_type = None ) : <EOL> std_data = { <EOL> ", "gt": "\"<STR_LIT>\" : code ,"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> ", "gt": "}"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> class FieldPermissionMixin : <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def field_permission ( self , request ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is self . serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded : <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> user = request . user <EOL> if user . is_superuser == <NUM_LIT> : <EOL> data = MenuField . objects . filter ( model = model [ '<STR_LIT>' ] ) . values ( '<STR_LIT>' ) <EOL> for item in data : <EOL> item [ '<STR_LIT>' ] = True <EOL> item [ '<STR_LIT>' ] = True <EOL> item [ '<STR_LIT>' ] = True <EOL> else : <EOL> ", "gt": "roles = request . user . role . values_list ( '<STR_LIT>' , flat = True )"}
{"input": "import hashlib <EOL> import random <EOL> CHAR_SET = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def random_str ( number = <NUM_LIT> ) : <EOL> result = \"<STR_LIT>\" <EOL> for i in range ( <NUM_LIT> , number ) : <EOL> ", "gt": "inx = random . randint ( <NUM_LIT> , len ( CHAR_SET ) - <NUM_LIT> )"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> ", "gt": "res = [ ]"}
{"input": "import logging <EOL> import traceback <EOL> from django . db . models import ProtectedError <EOL> from django . http import Http404 <EOL> from rest_framework . exceptions import APIException as DRFAPIException , AuthenticationFailed , NotAuthenticated <EOL> from rest_framework . status import HTTP_401_UNAUTHORIZED <EOL> from rest_framework . views import set_rollback , exception_handler <EOL> from dvadmin . utils . json_response import ErrorResponse <EOL> logger = logging . getLogger ( __name__ ) <EOL> class CustomAuthenticationFailed ( NotAuthenticated ) : <EOL> status_code = <NUM_LIT> <EOL> def CustomExceptionHandler ( ex , context ) : <EOL> msg = '<STR_LIT>' <EOL> code = <NUM_LIT> <EOL> response = exception_handler ( ex , context ) <EOL> if isinstance ( ex , AuthenticationFailed ) : <EOL> if response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> return ErrorResponse ( status = HTTP_401_UNAUTHORIZED ) <EOL> else : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif isinstance ( ex , Http404 ) : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> elif isinstance ( ex , DRFAPIException ) : <EOL> ", "gt": "set_rollback ( )"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> fields = ALL_FIELDS <EOL> if fields == ALL_FIELDS : <EOL> fields = cls . get_all_model_fields ( model ) <EOL> exclude = exclude or [ ] <EOL> if not isinstance ( fields , dict ) : <EOL> fields = [ ( f , [ settings . DEFAULT_LOOKUP_EXPR ] ) for f in fields if f not in exclude ] <EOL> else : <EOL> fields = [ ( f , lookups ) for f , lookups in fields . items ( ) if f not in exclude ] <EOL> return OrderedDict ( fields ) <EOL> @ classmethod <EOL> def get_filters ( cls ) : <EOL> if not cls . _meta . model : <EOL> return cls . declared_filters . copy ( ) <EOL> filters = OrderedDict ( ) <EOL> fields = cls . get_fields ( ) <EOL> undefined = [ ] <EOL> for field_name , lookups in fields . items ( ) : <EOL> field = get_model_field ( cls . _meta . model , field_name ) <EOL> from django . db import models <EOL> from timezone_field import TimeZoneField <EOL> if isinstance ( field , ( models . JSONField , TimeZoneField ) ) : <EOL> continue <EOL> if field is None : <EOL> undefined . append ( field_name ) <EOL> if ( <EOL> isinstance ( field , ( models . CharField ) ) <EOL> and filterset_fields == \"<STR_LIT>\" <EOL> and lookups == [ \"<STR_LIT>\" ] <EOL> ) : <EOL> lookups = [ \"<STR_LIT>\" ] <EOL> for lookup_expr in lookups : <EOL> filter_name = cls . get_filter_name ( field_name , lookup_expr ) <EOL> if filter_name in cls . declared_filters : <EOL> filters [ filter_name ] = cls . declared_filters [ filter_name ] <EOL> continue <EOL> if field is not None : <EOL> filters [ filter_name ] = cls . filter_for_field ( field , field_name , lookup_expr ) <EOL> if isinstance ( cls . _meta . fields , ( list , tuple ) ) : <EOL> undefined = [ f for f in undefined if f not in cls . declared_filters ] <EOL> if undefined : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" % \"<STR_LIT>\" . join ( undefined ) <EOL> ) <EOL> filters . update ( cls . declared_filters ) <EOL> return filters <EOL> class Meta ( MetaBase ) : <EOL> model = queryset . model <EOL> fields = filterset_fields <EOL> return AutoFilterSet <EOL> return None <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> filterset = self . get_filterset ( request , queryset , view ) <EOL> if filterset is None : <EOL> return queryset <EOL> if filterset . __class__ . __name__ == \"<STR_LIT>\" : <EOL> queryset = filterset . queryset <EOL> filter_fields = filterset . filters if self . filter_fields == \"<STR_LIT>\" else self . filter_fields <EOL> orm_lookup_dict = dict ( <EOL> zip ( <EOL> [ field for field in filter_fields ] , <EOL> [ filterset . filters [ lookup ] . lookup_expr for lookup in filterset . filters . keys ( ) ] , <EOL> ) <EOL> ) <EOL> orm_lookups = [ <EOL> self . construct_search ( lookup , lookup_expr ) for lookup , lookup_expr in orm_lookup_dict . items ( ) <EOL> ] <EOL> conditions = [ ] <EOL> queries = [ ] <EOL> for search_term_key in filterset . data . keys ( ) : <EOL> orm_lookup = self . find_filter_lookups ( orm_lookups , search_term_key ) <EOL> if not orm_lookup or filterset . data . get ( search_term_key ) == '<STR_LIT>' : <EOL> continue <EOL> filterset_data_len = len ( filterset . data . getlist ( search_term_key ) ) <EOL> if filterset_data_len == <NUM_LIT> : <EOL> query = Q ( ** { orm_lookup : filterset . data [ search_term_key ] } ) <EOL> queries . append ( query ) <EOL> elif filterset_data_len == <NUM_LIT> : <EOL> orm_lookup += '<STR_LIT>' <EOL> ", "gt": "query = Q ( ** { orm_lookup : filterset . data . getlist ( search_term_key ) } )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> ", "gt": "if self . modifier_field_id in self . fields . fields :"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) <EOL> else : <EOL> nested_dict [ target_key ] = new_value <EOL> return nested_dict <EOL> def __handle_crud ( self ) : <EOL> result = self . __get_field_attribute ( ) <EOL> columns = dict ( ) <EOL> ", "gt": "for item in result :"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = self . get_serializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def update ( self , request , * args , ** kwargs ) : <EOL> partial = kwargs . pop ( '<STR_LIT>' , False ) <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance , data = request . data , request = request , partial = partial ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_update ( serializer ) <EOL> if getattr ( instance , '<STR_LIT>' , None ) : <EOL> instance . _prefetched_objects_cache = { } <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def destroy ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> instance . delete ( ) <EOL> return DetailResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> keys = openapi . Schema ( description = '<STR_LIT>' , type = openapi . TYPE_ARRAY , items = openapi . TYPE_STRING ) <EOL> @ swagger_auto_schema ( request_body = openapi . Schema ( <EOL> type = openapi . TYPE_OBJECT , <EOL> required = [ '<STR_LIT>' ] , <EOL> properties = { '<STR_LIT>' : keys } <EOL> ) , operation_summary = '<STR_LIT>' ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def multiple_delete ( self , request , * args , ** kwargs ) : <EOL> request_data = request . data <EOL> ", "gt": "keys = request_data . get ( '<STR_LIT>' , None )"}
{"input": "import os <EOL> from application . settings import BASE_DIR <EOL> DATABASE_ENGINE = \"<STR_LIT>\" <EOL> DATABASE_NAME = '<STR_LIT>' <EOL> DATABASE_HOST = '<STR_LIT>' <EOL> DATABASE_PORT = <NUM_LIT> <EOL> DATABASE_USER = \"<STR_LIT>\" <EOL> DATABASE_PASSWORD = \"<STR_LIT>\" <EOL> TABLE_PREFIX = \"<STR_LIT>\" <EOL> REDIS_PASSWORD = '<STR_LIT>' <EOL> REDIS_HOST = '<STR_LIT>' <EOL> REDIS_URL = f'<STR_LIT>' <EOL> ", "gt": "DEBUG = True"}
{"input": "from drf_yasg . generators import OpenAPISchemaGenerator <EOL> from drf_yasg . inspectors import SwaggerAutoSchema <EOL> from application . settings import SWAGGER_SETTINGS <EOL> def get_summary ( string ) : <EOL> if string is not None : <EOL> result = string . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) <EOL> return result [ <NUM_LIT> ] <EOL> class CustomSwaggerAutoSchema ( SwaggerAutoSchema ) : <EOL> def get_tags ( self , operation_keys = None ) : <EOL> tags = super ( ) . get_tags ( operation_keys ) <EOL> if \"<STR_LIT>\" in tags and operation_keys : <EOL> tags [ <NUM_LIT> ] = operation_keys [ SWAGGER_SETTINGS . get ( '<STR_LIT>' , <NUM_LIT> ) ] <EOL> return tags <EOL> def get_summary_and_description ( self ) : <EOL> summary_and_description = super ( ) . get_summary_and_description ( ) <EOL> summary = get_summary ( self . __dict__ . get ( '<STR_LIT>' ) . __doc__ ) <EOL> description = summary_and_description [ <NUM_LIT> ] <EOL> return summary , description <EOL> ", "gt": "class CustomOpenAPISchemaGenerator ( OpenAPISchemaGenerator ) :"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterViewSet ( CustomModelViewSet ) : <EOL> queryset = MessageCenter . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MessageCenterSerializer <EOL> create_serializer_class = MessageCenterCreateSerializer <EOL> extra_filter_backends = [ ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> return MessageCenter . objects . filter ( creator = self . request . user . id ) . all ( ) <EOL> return MessageCenter . objects . all ( ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> pk = kwargs . get ( '<STR_LIT>' ) <EOL> user_id = self . request . user . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( users__id = user_id , messagecenter__id = pk ) . first ( ) <EOL> if queryset : <EOL> ", "gt": "queryset . is_read = True"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> ", "gt": "model = MessageCenter"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_name ( self ) : <EOL> ", "gt": "if getattr ( self . request , \"<STR_LIT>\" , None ) :"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> ", "gt": "else :"}
{"input": "from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class OperationLogSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = OperationLog <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class OperationLogCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> ", "gt": "model = OperationLog"}
{"input": "from django . db import DataError <EOL> from rest_framework . exceptions import APIException <EOL> from rest_framework . validators import UniqueValidator <EOL> class CustomValidationError ( APIException ) : <EOL> def __init__ ( self , detail ) : <EOL> self . detail = detail <EOL> def qs_exists ( queryset ) : <EOL> try : <EOL> return queryset . exists ( ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return False <EOL> def qs_filter ( queryset , ** kwargs ) : <EOL> try : <EOL> return queryset . filter ( ** kwargs ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return queryset . none ( ) <EOL> class CustomUniqueValidator ( UniqueValidator ) : <EOL> ", "gt": "def filter_queryset ( self , value , queryset , field_name ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> ", "gt": "params = self . request . query_params"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MenuButtonPermissionSerializer ( CustomModelSerializer ) : <EOL> isCheck = serializers . SerializerMethodField ( ) <EOL> def get_isCheck ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> return True <EOL> else : <EOL> return MenuButton . objects . filter ( <EOL> menu__id = instance . id , <EOL> role__id__in = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) , <EOL> ) . exists ( ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = '<STR_LIT>' <EOL> class RoleViewSet ( CustomModelViewSet , FastCrudMixin , FieldPermissionMixin ) : <EOL> queryset = Role . objects . all ( ) <EOL> ", "gt": "serializer_class = RoleSerializer"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> ", "gt": "targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request )"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import RoleMenuPermission , Menu , MenuButton <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleMenuPermissionSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionInitSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionViewSet ( CustomModelViewSet ) : <EOL> queryset = RoleMenuPermission . objects . all ( ) <EOL> serializer_class = RoleMenuPermissionSerializer <EOL> create_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> update_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def save_auth ( self , request ) : <EOL> body = request . data <EOL> role_id = body . get ( '<STR_LIT>' , None ) <EOL> if role_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> menu_list = body . get ( '<STR_LIT>' , None ) <EOL> if menu_list is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> ", "gt": "obj_list = RoleMenuPermission . objects . filter ( role__id = role_id ) . values_list ( '<STR_LIT>' , flat = True )"}
{"input": "import logging <EOL> import traceback <EOL> from django . db . models import ProtectedError <EOL> from django . http import Http404 <EOL> from rest_framework . exceptions import APIException as DRFAPIException , AuthenticationFailed , NotAuthenticated <EOL> from rest_framework . status import HTTP_401_UNAUTHORIZED <EOL> from rest_framework . views import set_rollback , exception_handler <EOL> from dvadmin . utils . json_response import ErrorResponse <EOL> logger = logging . getLogger ( __name__ ) <EOL> class CustomAuthenticationFailed ( NotAuthenticated ) : <EOL> status_code = <NUM_LIT> <EOL> def CustomExceptionHandler ( ex , context ) : <EOL> msg = '<STR_LIT>' <EOL> code = <NUM_LIT> <EOL> response = exception_handler ( ex , context ) <EOL> if isinstance ( ex , AuthenticationFailed ) : <EOL> if response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> return ErrorResponse ( status = HTTP_401_UNAUTHORIZED ) <EOL> else : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif isinstance ( ex , Http404 ) : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> elif isinstance ( ex , DRFAPIException ) : <EOL> set_rollback ( ) <EOL> msg = ex . detail <EOL> if isinstance ( msg , dict ) : <EOL> for k , v in msg . items ( ) : <EOL> for i in v : <EOL> msg = \"<STR_LIT>\" % ( k , i ) <EOL> elif isinstance ( ex , ProtectedError ) : <EOL> ", "gt": "set_rollback ( )"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> ", "gt": "return"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> ", "gt": "target_role = None , message : dict = None , request = Request ) :"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = self . get_serializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> ", "gt": "serializer = self . get_serializer ( instance )"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> pass <EOL> ", "gt": "return model if model else \"<STR_LIT>\""}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> ", "gt": "} )"}
{"input": "from drf_yasg . generators import OpenAPISchemaGenerator <EOL> from drf_yasg . inspectors import SwaggerAutoSchema <EOL> from application . settings import SWAGGER_SETTINGS <EOL> def get_summary ( string ) : <EOL> if string is not None : <EOL> result = string . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) <EOL> return result [ <NUM_LIT> ] <EOL> class CustomSwaggerAutoSchema ( SwaggerAutoSchema ) : <EOL> def get_tags ( self , operation_keys = None ) : <EOL> tags = super ( ) . get_tags ( operation_keys ) <EOL> if \"<STR_LIT>\" in tags and operation_keys : <EOL> tags [ <NUM_LIT> ] = operation_keys [ SWAGGER_SETTINGS . get ( '<STR_LIT>' , <NUM_LIT> ) ] <EOL> return tags <EOL> def get_summary_and_description ( self ) : <EOL> summary_and_description = super ( ) . get_summary_and_description ( ) <EOL> summary = get_summary ( self . __dict__ . get ( '<STR_LIT>' ) . __doc__ ) <EOL> description = summary_and_description [ <NUM_LIT> ] <EOL> return summary , description <EOL> class CustomOpenAPISchemaGenerator ( OpenAPISchemaGenerator ) : <EOL> def get_schema ( self , request = None , public = False ) : <EOL> swagger = super ( ) . get_schema ( request , public ) <EOL> swagger . tags = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> ] <EOL> ", "gt": "return swagger"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> ", "gt": "raise ValueError ( \"<STR_LIT>\" )"}
{"input": "import os <EOL> exclude = [ \"<STR_LIT>\" ] <EOL> for root , dirs , files in os . walk ( '<STR_LIT>' ) : <EOL> dirs [ : ] = list ( set ( dirs ) - set ( exclude ) ) <EOL> if '<STR_LIT>' in dirs : <EOL> dir = dirs [ dirs . index ( '<STR_LIT>' ) ] <EOL> ", "gt": "for root_j , dirs_j , files_j in os . walk ( os . path . join ( root , dir ) ) :"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> ", "gt": "return DetailResponse ( res )"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> fields = ALL_FIELDS <EOL> if fields == ALL_FIELDS : <EOL> fields = cls . get_all_model_fields ( model ) <EOL> exclude = exclude or [ ] <EOL> if not isinstance ( fields , dict ) : <EOL> fields = [ ( f , [ settings . DEFAULT_LOOKUP_EXPR ] ) for f in fields if f not in exclude ] <EOL> else : <EOL> fields = [ ( f , lookups ) for f , lookups in fields . items ( ) if f not in exclude ] <EOL> return OrderedDict ( fields ) <EOL> @ classmethod <EOL> def get_filters ( cls ) : <EOL> if not cls . _meta . model : <EOL> return cls . declared_filters . copy ( ) <EOL> filters = OrderedDict ( ) <EOL> fields = cls . get_fields ( ) <EOL> undefined = [ ] <EOL> for field_name , lookups in fields . items ( ) : <EOL> field = get_model_field ( cls . _meta . model , field_name ) <EOL> from django . db import models <EOL> from timezone_field import TimeZoneField <EOL> if isinstance ( field , ( models . JSONField , TimeZoneField ) ) : <EOL> continue <EOL> if field is None : <EOL> undefined . append ( field_name ) <EOL> if ( <EOL> isinstance ( field , ( models . CharField ) ) <EOL> and filterset_fields == \"<STR_LIT>\" <EOL> and lookups == [ \"<STR_LIT>\" ] <EOL> ) : <EOL> lookups = [ \"<STR_LIT>\" ] <EOL> for lookup_expr in lookups : <EOL> filter_name = cls . get_filter_name ( field_name , lookup_expr ) <EOL> if filter_name in cls . declared_filters : <EOL> filters [ filter_name ] = cls . declared_filters [ filter_name ] <EOL> continue <EOL> if field is not None : <EOL> filters [ filter_name ] = cls . filter_for_field ( field , field_name , lookup_expr ) <EOL> if isinstance ( cls . _meta . fields , ( list , tuple ) ) : <EOL> undefined = [ f for f in undefined if f not in cls . declared_filters ] <EOL> if undefined : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" % \"<STR_LIT>\" . join ( undefined ) <EOL> ) <EOL> filters . update ( cls . declared_filters ) <EOL> return filters <EOL> class Meta ( MetaBase ) : <EOL> model = queryset . model <EOL> fields = filterset_fields <EOL> return AutoFilterSet <EOL> return None <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> filterset = self . get_filterset ( request , queryset , view ) <EOL> if filterset is None : <EOL> return queryset <EOL> if filterset . __class__ . __name__ == \"<STR_LIT>\" : <EOL> queryset = filterset . queryset <EOL> filter_fields = filterset . filters if self . filter_fields == \"<STR_LIT>\" else self . filter_fields <EOL> orm_lookup_dict = dict ( <EOL> zip ( <EOL> [ field for field in filter_fields ] , <EOL> [ filterset . filters [ lookup ] . lookup_expr for lookup in filterset . filters . keys ( ) ] , <EOL> ) <EOL> ) <EOL> orm_lookups = [ <EOL> self . construct_search ( lookup , lookup_expr ) for lookup , lookup_expr in orm_lookup_dict . items ( ) <EOL> ] <EOL> conditions = [ ] <EOL> queries = [ ] <EOL> for search_term_key in filterset . data . keys ( ) : <EOL> orm_lookup = self . find_filter_lookups ( orm_lookups , search_term_key ) <EOL> if not orm_lookup or filterset . data . get ( search_term_key ) == '<STR_LIT>' : <EOL> continue <EOL> filterset_data_len = len ( filterset . data . getlist ( search_term_key ) ) <EOL> if filterset_data_len == <NUM_LIT> : <EOL> query = Q ( ** { orm_lookup : filterset . data [ search_term_key ] } ) <EOL> queries . append ( query ) <EOL> elif filterset_data_len == <NUM_LIT> : <EOL> orm_lookup += '<STR_LIT>' <EOL> query = Q ( ** { orm_lookup : filterset . data . getlist ( search_term_key ) } ) <EOL> queries . append ( query ) <EOL> if len ( queries ) > <NUM_LIT> : <EOL> conditions . append ( reduce ( operator . and_ , queries ) ) <EOL> queryset = queryset . filter ( reduce ( operator . and_ , conditions ) ) <EOL> ", "gt": "return queryset"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> fields = ALL_FIELDS <EOL> if fields == ALL_FIELDS : <EOL> fields = cls . get_all_model_fields ( model ) <EOL> exclude = exclude or [ ] <EOL> if not isinstance ( fields , dict ) : <EOL> fields = [ ( f , [ settings . DEFAULT_LOOKUP_EXPR ] ) for f in fields if f not in exclude ] <EOL> else : <EOL> fields = [ ( f , lookups ) for f , lookups in fields . items ( ) if f not in exclude ] <EOL> return OrderedDict ( fields ) <EOL> @ classmethod <EOL> def get_filters ( cls ) : <EOL> if not cls . _meta . model : <EOL> return cls . declared_filters . copy ( ) <EOL> filters = OrderedDict ( ) <EOL> fields = cls . get_fields ( ) <EOL> undefined = [ ] <EOL> for field_name , lookups in fields . items ( ) : <EOL> field = get_model_field ( cls . _meta . model , field_name ) <EOL> from django . db import models <EOL> from timezone_field import TimeZoneField <EOL> if isinstance ( field , ( models . JSONField , TimeZoneField ) ) : <EOL> continue <EOL> if field is None : <EOL> undefined . append ( field_name ) <EOL> if ( <EOL> isinstance ( field , ( models . CharField ) ) <EOL> and filterset_fields == \"<STR_LIT>\" <EOL> and lookups == [ \"<STR_LIT>\" ] <EOL> ) : <EOL> lookups = [ \"<STR_LIT>\" ] <EOL> for lookup_expr in lookups : <EOL> filter_name = cls . get_filter_name ( field_name , lookup_expr ) <EOL> if filter_name in cls . declared_filters : <EOL> filters [ filter_name ] = cls . declared_filters [ filter_name ] <EOL> continue <EOL> if field is not None : <EOL> filters [ filter_name ] = cls . filter_for_field ( field , field_name , lookup_expr ) <EOL> if isinstance ( cls . _meta . fields , ( list , tuple ) ) : <EOL> undefined = [ f for f in undefined if f not in cls . declared_filters ] <EOL> if undefined : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" % \"<STR_LIT>\" . join ( undefined ) <EOL> ) <EOL> filters . update ( cls . declared_filters ) <EOL> return filters <EOL> class Meta ( MetaBase ) : <EOL> model = queryset . model <EOL> fields = filterset_fields <EOL> return AutoFilterSet <EOL> return None <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> filterset = self . get_filterset ( request , queryset , view ) <EOL> if filterset is None : <EOL> return queryset <EOL> if filterset . __class__ . __name__ == \"<STR_LIT>\" : <EOL> queryset = filterset . queryset <EOL> filter_fields = filterset . filters if self . filter_fields == \"<STR_LIT>\" else self . filter_fields <EOL> orm_lookup_dict = dict ( <EOL> zip ( <EOL> [ field for field in filter_fields ] , <EOL> [ filterset . filters [ lookup ] . lookup_expr for lookup in filterset . filters . keys ( ) ] , <EOL> ) <EOL> ) <EOL> orm_lookups = [ <EOL> self . construct_search ( lookup , lookup_expr ) for lookup , lookup_expr in orm_lookup_dict . items ( ) <EOL> ] <EOL> conditions = [ ] <EOL> queries = [ ] <EOL> for search_term_key in filterset . data . keys ( ) : <EOL> orm_lookup = self . find_filter_lookups ( orm_lookups , search_term_key ) <EOL> if not orm_lookup or filterset . data . get ( search_term_key ) == '<STR_LIT>' : <EOL> continue <EOL> filterset_data_len = len ( filterset . data . getlist ( search_term_key ) ) <EOL> if filterset_data_len == <NUM_LIT> : <EOL> query = Q ( ** { orm_lookup : filterset . data [ search_term_key ] } ) <EOL> queries . append ( query ) <EOL> elif filterset_data_len == <NUM_LIT> : <EOL> orm_lookup += '<STR_LIT>' <EOL> query = Q ( ** { orm_lookup : filterset . data . getlist ( search_term_key ) } ) <EOL> queries . append ( query ) <EOL> if len ( queries ) > <NUM_LIT> : <EOL> conditions . append ( reduce ( operator . and_ , queries ) ) <EOL> queryset = queryset . filter ( reduce ( operator . and_ , conditions ) ) <EOL> return queryset <EOL> else : <EOL> return queryset <EOL> if not filterset . is_valid ( ) and self . raise_exception : <EOL> raise utils . translate_validation ( filterset . errors ) <EOL> ", "gt": "return filterset . qs"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> ", "gt": "queryset = self . filter_queryset ( self . get_queryset ( ) )"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = self . get_serializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def update ( self , request , * args , ** kwargs ) : <EOL> partial = kwargs . pop ( '<STR_LIT>' , False ) <EOL> instance = self . get_object ( ) <EOL> ", "gt": "serializer = self . get_serializer ( instance , data = request . data , request = request , partial = partial )"}
{"input": "from django . db . models import Q <EOL> from rest_framework import serializers <EOL> from dvadmin . system . models import Area <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class AreaSerializer ( CustomModelSerializer ) : <EOL> pcode_count = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_pcode_count ( self , instance : Area ) : <EOL> return Area . objects . filter ( pcode = instance ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Area . objects . filter ( pcode = instance . code ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Area <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class AreaCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> ", "gt": "class Meta :"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> ", "gt": "data [ \"<STR_LIT>\" ] = self . user . avatar"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ", "gt": ") ,"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> api_white_list = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return False <EOL> ", "gt": "role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True )"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> ", "gt": "\"<STR_LIT>\" : field . verbose_name ,"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> ", "gt": "if self . methods == '<STR_LIT>' or request . method in self . methods :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> return queryset <EOL> else : <EOL> return self . queryset <EOL> class InitDictionaryViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> queryset = Dictionary . objects . all ( ) <EOL> def get ( self , request ) : <EOL> dictionary_key = self . request . query_params . get ( '<STR_LIT>' ) <EOL> if dictionary_key : <EOL> if dictionary_key == '<STR_LIT>' : <EOL> data = [ ele for ele in dispatch . get_dictionary_config ( ) . values ( ) ] <EOL> if not data : <EOL> dispatch . refresh_dictionary ( ) <EOL> data = [ ele for ele in dispatch . get_dictionary_config ( ) . values ( ) ] <EOL> else : <EOL> ", "gt": "data = self . queryset . filter ( parent__value = dictionary_key , status = True ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ,"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> class FieldPermissionMixin : <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def field_permission ( self , request ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is self . serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded : <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> user = request . user <EOL> if user . is_superuser == <NUM_LIT> : <EOL> data = MenuField . objects . filter ( model = model [ '<STR_LIT>' ] ) . values ( '<STR_LIT>' ) <EOL> for item in data : <EOL> item [ '<STR_LIT>' ] = True <EOL> item [ '<STR_LIT>' ] = True <EOL> item [ '<STR_LIT>' ] = True <EOL> else : <EOL> roles = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data = FieldPermission . objects . filter ( <EOL> field__model = model [ '<STR_LIT>' ] , role__in = roles <EOL> ", "gt": ") . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , field_name = F ( '<STR_LIT>' ) )"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> ", "gt": "continue"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MenuButtonPermissionSerializer ( CustomModelSerializer ) : <EOL> isCheck = serializers . SerializerMethodField ( ) <EOL> def get_isCheck ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> return True <EOL> else : <EOL> ", "gt": "return MenuButton . objects . filter ("}
{"input": "from dvadmin . system . models import ApiWhiteList <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class ApiWhiteListSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = ApiWhiteList <EOL> ", "gt": "fields = \"<STR_LIT>\""}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . method == \"<STR_LIT>\" : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return self . readiness ( request ) <EOL> elif request . path == \"<STR_LIT>\" : <EOL> return self . healthz ( request ) <EOL> return self . get_response ( request ) <EOL> def healthz ( self , request ) : <EOL> return HttpResponse ( \"<STR_LIT>\" ) <EOL> def readiness ( self , request ) : <EOL> try : <EOL> from django . db import connections <EOL> for name in connections : <EOL> cursor = connections [ name ] . cursor ( ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> row = cursor . fetchone ( ) <EOL> if row is None : <EOL> return HttpResponseServerError ( \"<STR_LIT>\" ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return HttpResponseServerError ( \"<STR_LIT>\" ) <EOL> try : <EOL> from django . core . cache import caches <EOL> from django . core . cache . backends . memcached import BaseMemcachedCache <EOL> for cache in caches . all ( ) : <EOL> ", "gt": "if isinstance ( cache , BaseMemcachedCache ) :"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> target_role = None , message : dict = None , request = Request ) : <EOL> if message is None : <EOL> ", "gt": "message = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None }"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import RoleMenuPermission , Menu , MenuButton <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleMenuPermissionSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionInitSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionViewSet ( CustomModelViewSet ) : <EOL> queryset = RoleMenuPermission . objects . all ( ) <EOL> serializer_class = RoleMenuPermissionSerializer <EOL> create_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> update_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def save_auth ( self , request ) : <EOL> body = request . data <EOL> role_id = body . get ( '<STR_LIT>' , None ) <EOL> if role_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> menu_list = body . get ( '<STR_LIT>' , None ) <EOL> if menu_list is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> obj_list = RoleMenuPermission . objects . filter ( role__id = role_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> old_set = set ( obj_list ) <EOL> new_set = set ( menu_list ) <EOL> need_del = old_set . difference ( new_set ) <EOL> need_add = new_set . difference ( old_set ) <EOL> RoleMenuPermission . objects . filter ( role__id = role_id , menu__in = list ( need_del ) ) . delete ( ) <EOL> ", "gt": "data = [ { \"<STR_LIT>\" : role_id , \"<STR_LIT>\" : item } for item in list ( need_add ) ]"}
{"input": "from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class OperationLogSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = OperationLog <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class OperationLogCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = OperationLog <EOL> ", "gt": "fields = '<STR_LIT>'"}
{"input": "from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class OperationLogSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = OperationLog <EOL> fields = \"<STR_LIT>\" <EOL> ", "gt": "read_only_fields = [ \"<STR_LIT>\" ]"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> ", "gt": "def auto_match_fields ( self , request ) :"}
{"input": "import os <EOL> import django <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . utils . core_initialize import CoreInitialize <EOL> from dvadmin . system . fixtures . initSerializer import ( <EOL> UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , <EOL> MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , <EOL> SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> ) <EOL> class Initialize ( CoreInitialize ) : <EOL> def init_dept ( self ) : <EOL> self . init_base ( DeptInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role ( self ) : <EOL> self . init_base ( RoleInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_users ( self ) : <EOL> self . init_base ( UsersInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_menu ( self ) : <EOL> self . init_base ( MenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu ( self ) : <EOL> self . init_base ( RoleMenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu_button ( self ) : <EOL> self . init_base ( RoleMenuButtonInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_api_white_list ( self ) : <EOL> self . init_base ( ApiWhiteListInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> ", "gt": "def init_dictionary ( self ) :"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> return settings . ALL_MODELS_OBJECTS [ model_name ] or { } <EOL> return settings . ALL_MODELS_OBJECTS or { } <EOL> def get_model_from_app ( app_name ) : <EOL> model_module = import_module ( app_name + '<STR_LIT>' ) <EOL> filter_model = [ <EOL> getattr ( model_module , item ) for item in dir ( model_module ) <EOL> if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) <EOL> ] <EOL> model_list = [ ] <EOL> for model in filter_model : <EOL> if model . __name__ == '<STR_LIT>' : <EOL> continue <EOL> fields = [ <EOL> { '<STR_LIT>' : field . verbose_name , '<STR_LIT>' : field . name , '<STR_LIT>' : field } <EOL> for field in model . _meta . fields <EOL> ", "gt": "]"}
{"input": "from dvadmin . system . models import ApiWhiteList <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class ApiWhiteListSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = ApiWhiteList <EOL> fields = \"<STR_LIT>\" <EOL> ", "gt": "read_only_fields = [ \"<STR_LIT>\" ]"}
{"input": "from drf_yasg . generators import OpenAPISchemaGenerator <EOL> from drf_yasg . inspectors import SwaggerAutoSchema <EOL> from application . settings import SWAGGER_SETTINGS <EOL> def get_summary ( string ) : <EOL> if string is not None : <EOL> result = string . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) <EOL> return result [ <NUM_LIT> ] <EOL> class CustomSwaggerAutoSchema ( SwaggerAutoSchema ) : <EOL> def get_tags ( self , operation_keys = None ) : <EOL> tags = super ( ) . get_tags ( operation_keys ) <EOL> if \"<STR_LIT>\" in tags and operation_keys : <EOL> tags [ <NUM_LIT> ] = operation_keys [ SWAGGER_SETTINGS . get ( '<STR_LIT>' , <NUM_LIT> ) ] <EOL> return tags <EOL> def get_summary_and_description ( self ) : <EOL> summary_and_description = super ( ) . get_summary_and_description ( ) <EOL> summary = get_summary ( self . __dict__ . get ( '<STR_LIT>' ) . __doc__ ) <EOL> description = summary_and_description [ <NUM_LIT> ] <EOL> return summary , description <EOL> class CustomOpenAPISchemaGenerator ( OpenAPISchemaGenerator ) : <EOL> def get_schema ( self , request = None , public = False ) : <EOL> ", "gt": "swagger = super ( ) . get_schema ( request , public )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> return queryset <EOL> else : <EOL> return self . queryset <EOL> class InitDictionaryViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> queryset = Dictionary . objects . all ( ) <EOL> def get ( self , request ) : <EOL> dictionary_key = self . request . query_params . get ( '<STR_LIT>' ) <EOL> ", "gt": "if dictionary_key :"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> fields = ALL_FIELDS <EOL> if fields == ALL_FIELDS : <EOL> fields = cls . get_all_model_fields ( model ) <EOL> exclude = exclude or [ ] <EOL> if not isinstance ( fields , dict ) : <EOL> fields = [ ( f , [ settings . DEFAULT_LOOKUP_EXPR ] ) for f in fields if f not in exclude ] <EOL> else : <EOL> fields = [ ( f , lookups ) for f , lookups in fields . items ( ) if f not in exclude ] <EOL> return OrderedDict ( fields ) <EOL> @ classmethod <EOL> def get_filters ( cls ) : <EOL> if not cls . _meta . model : <EOL> return cls . declared_filters . copy ( ) <EOL> filters = OrderedDict ( ) <EOL> fields = cls . get_fields ( ) <EOL> undefined = [ ] <EOL> for field_name , lookups in fields . items ( ) : <EOL> field = get_model_field ( cls . _meta . model , field_name ) <EOL> from django . db import models <EOL> from timezone_field import TimeZoneField <EOL> if isinstance ( field , ( models . JSONField , TimeZoneField ) ) : <EOL> continue <EOL> if field is None : <EOL> undefined . append ( field_name ) <EOL> if ( <EOL> isinstance ( field , ( models . CharField ) ) <EOL> and filterset_fields == \"<STR_LIT>\" <EOL> and lookups == [ \"<STR_LIT>\" ] <EOL> ) : <EOL> lookups = [ \"<STR_LIT>\" ] <EOL> for lookup_expr in lookups : <EOL> filter_name = cls . get_filter_name ( field_name , lookup_expr ) <EOL> if filter_name in cls . declared_filters : <EOL> filters [ filter_name ] = cls . declared_filters [ filter_name ] <EOL> continue <EOL> if field is not None : <EOL> filters [ filter_name ] = cls . filter_for_field ( field , field_name , lookup_expr ) <EOL> if isinstance ( cls . _meta . fields , ( list , tuple ) ) : <EOL> undefined = [ f for f in undefined if f not in cls . declared_filters ] <EOL> if undefined : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" % \"<STR_LIT>\" . join ( undefined ) <EOL> ) <EOL> filters . update ( cls . declared_filters ) <EOL> return filters <EOL> class Meta ( MetaBase ) : <EOL> model = queryset . model <EOL> fields = filterset_fields <EOL> return AutoFilterSet <EOL> return None <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> filterset = self . get_filterset ( request , queryset , view ) <EOL> if filterset is None : <EOL> return queryset <EOL> if filterset . __class__ . __name__ == \"<STR_LIT>\" : <EOL> queryset = filterset . queryset <EOL> filter_fields = filterset . filters if self . filter_fields == \"<STR_LIT>\" else self . filter_fields <EOL> orm_lookup_dict = dict ( <EOL> zip ( <EOL> ", "gt": "[ field for field in filter_fields ] ,"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = self . get_serializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def update ( self , request , * args , ** kwargs ) : <EOL> partial = kwargs . pop ( '<STR_LIT>' , False ) <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance , data = request . data , request = request , partial = partial ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_update ( serializer ) <EOL> if getattr ( instance , '<STR_LIT>' , None ) : <EOL> instance . _prefetched_objects_cache = { } <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def destroy ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> instance . delete ( ) <EOL> return DetailResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> keys = openapi . Schema ( description = '<STR_LIT>' , type = openapi . TYPE_ARRAY , items = openapi . TYPE_STRING ) <EOL> @ swagger_auto_schema ( request_body = openapi . Schema ( <EOL> type = openapi . TYPE_OBJECT , <EOL> required = [ '<STR_LIT>' ] , <EOL> properties = { '<STR_LIT>' : keys } <EOL> ) , operation_summary = '<STR_LIT>' ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def multiple_delete ( self , request , * args , ** kwargs ) : <EOL> request_data = request . data <EOL> keys = request_data . get ( '<STR_LIT>' , None ) <EOL> if keys : <EOL> ", "gt": "self . get_queryset ( ) . filter ( id__in = keys ) . delete ( )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MenuButtonPermissionSerializer ( CustomModelSerializer ) : <EOL> isCheck = serializers . SerializerMethodField ( ) <EOL> def get_isCheck ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> return True <EOL> else : <EOL> return MenuButton . objects . filter ( <EOL> menu__id = instance . id , <EOL> ", "gt": "role__id__in = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) ,"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> return queryset <EOL> else : <EOL> return self . queryset <EOL> ", "gt": "class InitDictionaryViewSet ( APIView ) :"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> try : <EOL> request_user = self . request . user <EOL> validated_data [ '<STR_LIT>' ] = request_user . dept . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> except : <EOL> pass <EOL> return super ( ) . create ( validated_data ) <EOL> class FileViewSet ( CustomModelViewSet ) : <EOL> ", "gt": "queryset = FileList . objects . all ( )"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> var_name = body . get ( '<STR_LIT>' , None ) <EOL> table = body . get ( '<STR_LIT>' , None ) <EOL> instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> relation_id = body . get ( '<STR_LIT>' , None ) <EOL> relationIds = [ ] <EOL> if relation_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = [ relation_id ] <EOL> elif instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = relation_id . split ( '<STR_LIT>' ) <EOL> queryset = SystemConfig . objects . filter ( value__in = relationIds ) . first ( ) <EOL> if queryset is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> serializer = SystemConfigChinldernSerializer ( queryset . parent ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = serializer . data ) <EOL> class InitSettingsViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def filter_system_config_values ( self , data : dict ) : <EOL> ", "gt": "if not self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) :"}
{"input": "from rest_framework . views import APIView <EOL> from django . shortcuts import render <EOL> class PrivacyView ( APIView ) : <EOL> permission_classes = [ ] <EOL> def get ( self , request , * args , ** kwargs ) : <EOL> return render ( request , '<STR_LIT>' ) <EOL> class TermsServiceView ( APIView ) : <EOL> permission_classes = [ ] <EOL> ", "gt": "def get ( self , request , * args , ** kwargs ) :"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> obj . objects . all ( ) . delete ( ) <EOL> ", "gt": "settings . INITIALIZE_RESET_LIST . append ( obj )"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> if not getattr ( settings , \"<STR_LIT>\" , False ) : <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginTokenView ( TokenObtainPairView ) : <EOL> serializer_class = LoginTokenSerializer <EOL> permission_classes = [ ] <EOL> class LogoutView ( APIView ) : <EOL> def post ( self , request ) : <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> class ApiLoginSerializer ( CustomModelSerializer ) : <EOL> username = serializers . CharField ( ) <EOL> password = serializers . CharField ( ) <EOL> class Meta : <EOL> model = Users <EOL> fields = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class ApiLogin ( APIView ) : <EOL> serializer_class = ApiLoginSerializer <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def post ( self , request ) : <EOL> ", "gt": "username = request . data . get ( \"<STR_LIT>\" )"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> ", "gt": "methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ]"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> ", "gt": "api_white_list = ["}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> ", "gt": "or not isinstance ( f , models . AutoField )"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> ", "gt": "raise CustomValidationError ( '<STR_LIT>' )"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> pass <EOL> return model if model else \"<STR_LIT>\" <EOL> def get_ip_analysis ( ip ) : <EOL> data = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> if ip != '<STR_LIT>' and ip : <EOL> if getattr ( settings , '<STR_LIT>' , True ) : <EOL> try : <EOL> res = requests . get ( url = '<STR_LIT>' , params = { \"<STR_LIT>\" : ip } , timeout = <NUM_LIT> ) <EOL> if res . status_code == <NUM_LIT> : <EOL> res_data = res . json ( ) <EOL> if res_data . get ( '<STR_LIT>' ) == <NUM_LIT> : <EOL> data = res_data . get ( '<STR_LIT>' ) <EOL> return data <EOL> except Exception as e : <EOL> print ( e ) <EOL> return data <EOL> def save_login_log ( request ) : <EOL> ip = get_request_ip ( request = request ) <EOL> analysis_data = get_ip_analysis ( ip ) <EOL> analysis_data [ '<STR_LIT>' ] = request . user . username <EOL> analysis_data [ '<STR_LIT>' ] = ip <EOL> analysis_data [ '<STR_LIT>' ] = str ( parse ( request . META [ '<STR_LIT>' ] ) ) <EOL> analysis_data [ '<STR_LIT>' ] = get_browser ( request ) <EOL> analysis_data [ '<STR_LIT>' ] = get_os ( request ) <EOL> ", "gt": "analysis_data [ '<STR_LIT>' ] = request . user . id"}
{"input": "from rest_framework . response import Response <EOL> class SuccessResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , page = <NUM_LIT> , limit = <NUM_LIT> , total = <NUM_LIT> ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : page , <EOL> \"<STR_LIT>\" : limit , <EOL> \"<STR_LIT>\" : total , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class DetailResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class ErrorResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , code = <NUM_LIT> , status = None , template_name = None , headers = None , <EOL> exception = False , content_type = None ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : code , <EOL> \"<STR_LIT>\" : data , <EOL> ", "gt": "\"<STR_LIT>\" : msg"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> ", "gt": "raise CustomValidationError ( \"<STR_LIT>\" )"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> ", "gt": "if exclude is not None and fields is None :"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> ", "gt": "schema_view . without_ui ( cache_timeout = <NUM_LIT> ) ,"}
{"input": "from django . db . models import Q <EOL> from rest_framework import serializers <EOL> from dvadmin . system . models import Area <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class AreaSerializer ( CustomModelSerializer ) : <EOL> pcode_count = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_pcode_count ( self , instance : Area ) : <EOL> return Area . objects . filter ( pcode = instance ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Area . objects . filter ( pcode = instance . code ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Area <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class AreaCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Area <EOL> fields = '<STR_LIT>' <EOL> class AreaViewSet ( CustomModelViewSet ) : <EOL> queryset = Area . objects . all ( ) <EOL> serializer_class = AreaSerializer <EOL> ", "gt": "extra_filter_class = [ ]"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> ", "gt": "self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ", "gt": "class MenuButtonPermissionSerializer ( CustomModelSerializer ) :"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> elif value_type == '<STR_LIT>' : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) <EOL> else : <EOL> if type ( cell_value ) is float and str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] == \"<STR_LIT>\" : <EOL> cell_value = int ( str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ) <EOL> elif type ( cell_value ) is str : <EOL> ", "gt": "cell_value = cell_value . strip ( \"<STR_LIT>\" )"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import MenuButton , RoleMenuButtonPermission <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuButtonSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuButton . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuButtonSerializer <EOL> create_serializer_class = MenuButtonCreateUpdateSerializer <EOL> update_serializer_class = MenuButtonCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) . order_by ( '<STR_LIT>' ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( serializer . data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def menu_button_all_permission ( self , request ) : <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> ", "gt": "else :"}
{"input": "from rest_framework . response import Response <EOL> class SuccessResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , page = <NUM_LIT> , limit = <NUM_LIT> , total = <NUM_LIT> ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : page , <EOL> \"<STR_LIT>\" : limit , <EOL> \"<STR_LIT>\" : total , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class DetailResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class ErrorResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , code = <NUM_LIT> , status = None , template_name = None , headers = None , <EOL> exception = False , content_type = None ) : <EOL> ", "gt": "std_data = {"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> obj . objects . all ( ) . delete ( ) <EOL> settings . INITIALIZE_RESET_LIST . append ( obj ) <EOL> except Exception : <EOL> pass <EOL> for ele in data : <EOL> m2m_dict = { } <EOL> new_data = { } <EOL> for key , value in ele . items ( ) : <EOL> if isinstance ( value , list ) and value and isinstance ( value [ <NUM_LIT> ] , int ) : <EOL> m2m_dict [ key ] = value <EOL> else : <EOL> new_data [ key ] = value <EOL> object , _ = obj . objects . get_or_create ( id = ele . get ( \"<STR_LIT>\" ) , defaults = new_data ) <EOL> for key , m2m in m2m_dict . items ( ) : <EOL> m2m = list ( set ( m2m ) ) <EOL> if m2m and len ( m2m ) > <NUM_LIT> and m2m [ <NUM_LIT> ] : <EOL> exec ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def run ( self ) : <EOL> ", "gt": "raise NotImplementedError ( '<STR_LIT>' )"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterViewSet ( CustomModelViewSet ) : <EOL> queryset = MessageCenter . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MessageCenterSerializer <EOL> create_serializer_class = MessageCenterCreateSerializer <EOL> extra_filter_backends = [ ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> return MessageCenter . objects . filter ( creator = self . request . user . id ) . all ( ) <EOL> return MessageCenter . objects . all ( ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> pk = kwargs . get ( '<STR_LIT>' ) <EOL> user_id = self . request . user . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( users__id = user_id , messagecenter__id = pk ) . first ( ) <EOL> if queryset : <EOL> queryset . is_read = True <EOL> queryset . save ( ) <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance ) <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user_id , is_read = False ) . count ( ) <EOL> websocket_push ( user_id , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_self_receive ( self , request ) : <EOL> self_user_id = self . request . user . id <EOL> queryset = MessageCenter . objects . filter ( target_user__id = self_user_id ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = MessageCenterTargetUserListSerializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = MessageCenterTargetUserListSerializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_newest_msg ( self , request ) : <EOL> self_user_id = self . request . user . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( users__id = self_user_id ) . order_by ( '<STR_LIT>' ) . last ( ) <EOL> ", "gt": "data = None"}
{"input": "from django . db import DataError <EOL> from rest_framework . exceptions import APIException <EOL> from rest_framework . validators import UniqueValidator <EOL> class CustomValidationError ( APIException ) : <EOL> def __init__ ( self , detail ) : <EOL> self . detail = detail <EOL> def qs_exists ( queryset ) : <EOL> try : <EOL> return queryset . exists ( ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return False <EOL> def qs_filter ( queryset , ** kwargs ) : <EOL> try : <EOL> return queryset . filter ( ** kwargs ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return queryset . none ( ) <EOL> class CustomUniqueValidator ( UniqueValidator ) : <EOL> def filter_queryset ( self , value , queryset , field_name ) : <EOL> filter_kwargs = { '<STR_LIT>' % ( field_name , self . lookup ) : value } <EOL> return qs_filter ( queryset , ** filter_kwargs ) <EOL> def exclude_current_instance ( self , queryset , instance ) : <EOL> if instance is not None : <EOL> return queryset . exclude ( pk = instance . pk ) <EOL> return queryset <EOL> def __call__ ( self , value , serializer_field ) : <EOL> field_name = serializer_field . source_attrs [ - <NUM_LIT> ] <EOL> instance = getattr ( serializer_field . parent , '<STR_LIT>' , None ) <EOL> queryset = self . queryset <EOL> ", "gt": "queryset = self . filter_queryset ( value , queryset , field_name )"}
{"input": "import logging <EOL> from django . core . management . base import BaseCommand <EOL> from application import settings <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> nargs = \"<STR_LIT>\" , <EOL> type = str , <EOL> ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> def handle ( self , * args , ** options ) : <EOL> ", "gt": "reset = False"}
{"input": "import functools <EOL> import os <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from django . conf import settings <EOL> from celery import platforms <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from tenant_schemas_celery . app import CeleryApp as TenantAwareCeleryApp <EOL> app = TenantAwareCeleryApp ( ) <EOL> else : <EOL> from celery import Celery <EOL> app = Celery ( f\"<STR_LIT>\" ) <EOL> app . config_from_object ( '<STR_LIT>' ) <EOL> app . autodiscover_tasks ( lambda : settings . INSTALLED_APPS ) <EOL> platforms . C_FORCE_ROOT = True <EOL> ", "gt": "def retry_base_task_error ( ) :"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> elif value_type == '<STR_LIT>' : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) <EOL> else : <EOL> if type ( cell_value ) is float and str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] == \"<STR_LIT>\" : <EOL> cell_value = int ( str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ) <EOL> elif type ( cell_value ) is str : <EOL> cell_value = cell_value . strip ( \"<STR_LIT>\" ) <EOL> if key in validation_data_dict : <EOL> array [ key ] = validation_data_dict . get ( key , { } ) . get ( cell_value , None ) <EOL> if key in m2m_fields : <EOL> array [ key ] = list ( <EOL> filter ( <EOL> lambda x : x , <EOL> [ <EOL> validation_data_dict . get ( key , { } ) . get ( value , None ) <EOL> for value in re . split ( r\"<STR_LIT>\" , cell_value ) <EOL> ] , <EOL> ) <EOL> ) <EOL> else : <EOL> array [ key ] = cell_value <EOL> ", "gt": "tables . append ( array )"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> ", "gt": "return MenuField . objects . filter ( model = model [ '<STR_LIT>' ]"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> ", "gt": "r\"<STR_LIT>\" ,"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> return settings . ALL_MODELS_OBJECTS [ model_name ] or { } <EOL> return settings . ALL_MODELS_OBJECTS or { } <EOL> def get_model_from_app ( app_name ) : <EOL> model_module = import_module ( app_name + '<STR_LIT>' ) <EOL> filter_model = [ <EOL> getattr ( model_module , item ) for item in dir ( model_module ) <EOL> if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) <EOL> ] <EOL> model_list = [ ] <EOL> for model in filter_model : <EOL> if model . __name__ == '<STR_LIT>' : <EOL> continue <EOL> fields = [ <EOL> { '<STR_LIT>' : field . verbose_name , '<STR_LIT>' : field . name , '<STR_LIT>' : field } <EOL> for field in model . _meta . fields <EOL> ] <EOL> model_list . append ( { <EOL> '<STR_LIT>' : app_name , <EOL> '<STR_LIT>' : model . _meta . verbose_name , <EOL> '<STR_LIT>' : model . __name__ , <EOL> '<STR_LIT>' : model , <EOL> '<STR_LIT>' : fields <EOL> } ) <EOL> return model_list <EOL> def get_custom_app_models ( app_name = None ) : <EOL> if app_name : <EOL> return get_model_from_app ( app_name ) <EOL> all_apps = apps . get_app_configs ( ) <EOL> res = [ ] <EOL> for app in all_apps : <EOL> if app . name . startswith ( '<STR_LIT>' ) : <EOL> continue <EOL> if app . name in settings . COLUMN_EXCLUDE_APPS : <EOL> continue <EOL> try : <EOL> all_models = get_model_from_app ( app . name ) <EOL> if all_models : <EOL> for model in all_models : <EOL> res . append ( model ) <EOL> except Exception as e : <EOL> pass <EOL> ", "gt": "return res"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> target_role = None , message : dict = None , request = Request ) : <EOL> if message is None : <EOL> message = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> if target_role is None : <EOL> target_role = [ ] <EOL> if target_dept is None : <EOL> target_dept = [ ] <EOL> data = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : content , <EOL> \"<STR_LIT>\" : target_type , <EOL> \"<STR_LIT>\" : target_user , <EOL> \"<STR_LIT>\" : target_dept , <EOL> \"<STR_LIT>\" : target_role <EOL> } <EOL> message_center_instance = MessageCreateSerializer ( data = data , request = request ) <EOL> message_center_instance . is_valid ( raise_exception = True ) <EOL> message_center_instance . save ( ) <EOL> users = target_user or [ ] <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : message_center_instance . instance . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> username = \"<STR_LIT>\" + str ( user ) <EOL> unread_count = async_to_sync ( _get_message_unread ) ( user ) <EOL> channel_layer = get_channel_layer ( ) <EOL> ", "gt": "async_to_sync ( channel_layer . group_send ) ("}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> ", "gt": "log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) )"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> ", "gt": "table = {"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> try : <EOL> request_user = self . request . user <EOL> validated_data [ '<STR_LIT>' ] = request_user . dept . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> except : <EOL> ", "gt": "pass"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> fields = ALL_FIELDS <EOL> if fields == ALL_FIELDS : <EOL> fields = cls . get_all_model_fields ( model ) <EOL> exclude = exclude or [ ] <EOL> if not isinstance ( fields , dict ) : <EOL> fields = [ ( f , [ settings . DEFAULT_LOOKUP_EXPR ] ) for f in fields if f not in exclude ] <EOL> else : <EOL> fields = [ ( f , lookups ) for f , lookups in fields . items ( ) if f not in exclude ] <EOL> return OrderedDict ( fields ) <EOL> @ classmethod <EOL> def get_filters ( cls ) : <EOL> if not cls . _meta . model : <EOL> return cls . declared_filters . copy ( ) <EOL> filters = OrderedDict ( ) <EOL> fields = cls . get_fields ( ) <EOL> undefined = [ ] <EOL> for field_name , lookups in fields . items ( ) : <EOL> field = get_model_field ( cls . _meta . model , field_name ) <EOL> from django . db import models <EOL> from timezone_field import TimeZoneField <EOL> if isinstance ( field , ( models . JSONField , TimeZoneField ) ) : <EOL> continue <EOL> if field is None : <EOL> undefined . append ( field_name ) <EOL> if ( <EOL> isinstance ( field , ( models . CharField ) ) <EOL> and filterset_fields == \"<STR_LIT>\" <EOL> and lookups == [ \"<STR_LIT>\" ] <EOL> ) : <EOL> lookups = [ \"<STR_LIT>\" ] <EOL> for lookup_expr in lookups : <EOL> filter_name = cls . get_filter_name ( field_name , lookup_expr ) <EOL> if filter_name in cls . declared_filters : <EOL> filters [ filter_name ] = cls . declared_filters [ filter_name ] <EOL> continue <EOL> if field is not None : <EOL> filters [ filter_name ] = cls . filter_for_field ( field , field_name , lookup_expr ) <EOL> if isinstance ( cls . _meta . fields , ( list , tuple ) ) : <EOL> undefined = [ f for f in undefined if f not in cls . declared_filters ] <EOL> if undefined : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" % \"<STR_LIT>\" . join ( undefined ) <EOL> ) <EOL> filters . update ( cls . declared_filters ) <EOL> return filters <EOL> class Meta ( MetaBase ) : <EOL> model = queryset . model <EOL> fields = filterset_fields <EOL> return AutoFilterSet <EOL> return None <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> filterset = self . get_filterset ( request , queryset , view ) <EOL> if filterset is None : <EOL> return queryset <EOL> if filterset . __class__ . __name__ == \"<STR_LIT>\" : <EOL> queryset = filterset . queryset <EOL> filter_fields = filterset . filters if self . filter_fields == \"<STR_LIT>\" else self . filter_fields <EOL> orm_lookup_dict = dict ( <EOL> zip ( <EOL> [ field for field in filter_fields ] , <EOL> [ filterset . filters [ lookup ] . lookup_expr for lookup in filterset . filters . keys ( ) ] , <EOL> ) <EOL> ) <EOL> orm_lookups = [ <EOL> self . construct_search ( lookup , lookup_expr ) for lookup , lookup_expr in orm_lookup_dict . items ( ) <EOL> ] <EOL> conditions = [ ] <EOL> queries = [ ] <EOL> for search_term_key in filterset . data . keys ( ) : <EOL> orm_lookup = self . find_filter_lookups ( orm_lookups , search_term_key ) <EOL> if not orm_lookup or filterset . data . get ( search_term_key ) == '<STR_LIT>' : <EOL> continue <EOL> filterset_data_len = len ( filterset . data . getlist ( search_term_key ) ) <EOL> if filterset_data_len == <NUM_LIT> : <EOL> query = Q ( ** { orm_lookup : filterset . data [ search_term_key ] } ) <EOL> queries . append ( query ) <EOL> ", "gt": "elif filterset_data_len == <NUM_LIT> :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> ", "gt": "else :"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> var_name = body . get ( '<STR_LIT>' , None ) <EOL> table = body . get ( '<STR_LIT>' , None ) <EOL> instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> relation_id = body . get ( '<STR_LIT>' , None ) <EOL> relationIds = [ ] <EOL> if relation_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = [ relation_id ] <EOL> elif instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = relation_id . split ( '<STR_LIT>' ) <EOL> queryset = SystemConfig . objects . filter ( value__in = relationIds ) . first ( ) <EOL> if queryset is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> serializer = SystemConfigChinldernSerializer ( queryset . parent ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = serializer . data ) <EOL> class InitSettingsViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def filter_system_config_values ( self , data : dict ) : <EOL> if not self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> return data <EOL> new_data = { } <EOL> for key in self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) . split ( '<STR_LIT>' ) : <EOL> if key : <EOL> new_data . update ( ** dict ( filter ( lambda x : x [ <NUM_LIT> ] . startswith ( key ) , data . items ( ) ) ) ) <EOL> ", "gt": "return new_data"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> api_white_list = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return False <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> ", "gt": "userApiList = RoleMenuButtonPermission . objects . filter ( role__in = role_id_list ) . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) )"}
{"input": "from django . urls import path <EOL> from rest_framework import routers <EOL> from dvadmin . system . views . api_white_list import ApiWhiteListViewSet <EOL> from dvadmin . system . views . area import AreaViewSet <EOL> from dvadmin . system . views . clause import PrivacyView , TermsServiceView <EOL> from dvadmin . system . views . dept import DeptViewSet <EOL> from dvadmin . system . views . dictionary import DictionaryViewSet <EOL> from dvadmin . system . views . file_list import FileViewSet <EOL> from dvadmin . system . views . login_log import LoginLogViewSet <EOL> from dvadmin . system . views . menu import MenuViewSet <EOL> from dvadmin . system . views . menu_button import MenuButtonViewSet <EOL> from dvadmin . system . views . message_center import MessageCenterViewSet <EOL> from dvadmin . system . views . operation_log import OperationLogViewSet <EOL> from dvadmin . system . views . role import RoleViewSet <EOL> from dvadmin . system . views . role_menu import RoleMenuPermissionViewSet <EOL> from dvadmin . system . views . role_menu_button_permission import RoleMenuButtonPermissionViewSet <EOL> from dvadmin . system . views . system_config import SystemConfigViewSet <EOL> from dvadmin . system . views . user import UserViewSet <EOL> from dvadmin . system . views . menu_field import MenuFieldViewSet <EOL> system_url = routers . SimpleRouter ( ) <EOL> system_url . register ( r'<STR_LIT>' , MenuViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuButtonViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DeptViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , UserViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , OperationLogViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DictionaryViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , AreaViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , FileViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , ApiWhiteListViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , SystemConfigViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MessageCenterViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuButtonPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuFieldViewSet ) <EOL> urlpatterns = [ <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , } ) ) , <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , LoginLogViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , LoginLogViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , DeptViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , PrivacyView . as_view ( ) ) , <EOL> path ( '<STR_LIT>' , TermsServiceView . as_view ( ) ) , <EOL> ", "gt": "]"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> ", "gt": "urlpatterns = ("}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterViewSet ( CustomModelViewSet ) : <EOL> queryset = MessageCenter . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MessageCenterSerializer <EOL> create_serializer_class = MessageCenterCreateSerializer <EOL> extra_filter_backends = [ ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> return MessageCenter . objects . filter ( creator = self . request . user . id ) . all ( ) <EOL> return MessageCenter . objects . all ( ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> ", "gt": "pk = kwargs . get ( '<STR_LIT>' )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> ", "gt": "return ErrorResponse ( msg = \"<STR_LIT>\" )"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> ", "gt": "def __call__ ( self , request ) :"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> target_role = None , message : dict = None , request = Request ) : <EOL> if message is None : <EOL> message = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> if target_role is None : <EOL> target_role = [ ] <EOL> if target_dept is None : <EOL> target_dept = [ ] <EOL> data = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : content , <EOL> \"<STR_LIT>\" : target_type , <EOL> \"<STR_LIT>\" : target_user , <EOL> \"<STR_LIT>\" : target_dept , <EOL> \"<STR_LIT>\" : target_role <EOL> } <EOL> message_center_instance = MessageCreateSerializer ( data = data , request = request ) <EOL> message_center_instance . is_valid ( raise_exception = True ) <EOL> message_center_instance . save ( ) <EOL> users = target_user or [ ] <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : message_center_instance . instance . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> username = \"<STR_LIT>\" + str ( user ) <EOL> unread_count = async_to_sync ( _get_message_unread ) ( user ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { ** message , '<STR_LIT>' : unread_count } <EOL> ", "gt": "}"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> model_name = request . data . get ( '<STR_LIT>' ) <EOL> if not menu_id or not model_name : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] != model_name : <EOL> continue <EOL> for field in model [ '<STR_LIT>' ] : <EOL> if MenuField . objects . filter ( <EOL> menu_id = menu_id , model = model_name , field_name = field [ '<STR_LIT>' ] <EOL> ) . exists ( ) : <EOL> continue <EOL> data = { <EOL> '<STR_LIT>' : menu_id , <EOL> '<STR_LIT>' : model_name , <EOL> '<STR_LIT>' : field [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : str ( field [ '<STR_LIT>' ] ) , <EOL> } <EOL> serializer = self . get_serializer ( data = data , request = request ) <EOL> ", "gt": "serializer . is_valid ( raise_exception = True )"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> ", "gt": "'<STR_LIT>' : model [ '<STR_LIT>' ] ,"}
{"input": "import logging <EOL> from django . core . management . base import BaseCommand <EOL> from application import settings <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> nargs = \"<STR_LIT>\" , <EOL> type = str , <EOL> ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> def handle ( self , * args , ** options ) : <EOL> reset = False <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = True <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = False <EOL> for app in settings . INSTALLED_APPS : <EOL> try : <EOL> exec ( <EOL> ) <EOL> ", "gt": "except ModuleNotFoundError :"}
{"input": "import os <EOL> exclude = [ \"<STR_LIT>\" ] <EOL> for root , dirs , files in os . walk ( '<STR_LIT>' ) : <EOL> dirs [ : ] = list ( set ( dirs ) - set ( exclude ) ) <EOL> if '<STR_LIT>' in dirs : <EOL> dir = dirs [ dirs . index ( '<STR_LIT>' ) ] <EOL> for root_j , dirs_j , files_j in os . walk ( os . path . join ( root , dir ) ) : <EOL> for file_k in files_j : <EOL> ", "gt": "if file_k != '<STR_LIT>' :"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import MenuButton , RoleMenuButtonPermission <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuButtonSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuButton . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuButtonSerializer <EOL> create_serializer_class = MenuButtonCreateUpdateSerializer <EOL> update_serializer_class = MenuButtonCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) . order_by ( '<STR_LIT>' ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( serializer . data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def menu_button_all_permission ( self , request ) : <EOL> ", "gt": "is_superuser = request . user . is_superuser"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> var_name = body . get ( '<STR_LIT>' , None ) <EOL> table = body . get ( '<STR_LIT>' , None ) <EOL> instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> relation_id = body . get ( '<STR_LIT>' , None ) <EOL> relationIds = [ ] <EOL> if relation_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = [ relation_id ] <EOL> elif instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = relation_id . split ( '<STR_LIT>' ) <EOL> queryset = SystemConfig . objects . filter ( value__in = relationIds ) . first ( ) <EOL> if queryset is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> serializer = SystemConfigChinldernSerializer ( queryset . parent ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = serializer . data ) <EOL> class InitSettingsViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def filter_system_config_values ( self , data : dict ) : <EOL> if not self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> return data <EOL> ", "gt": "new_data = { }"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> pass <EOL> return model if model else \"<STR_LIT>\" <EOL> def get_ip_analysis ( ip ) : <EOL> data = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> queryset = self . queryset . filter ( status = <NUM_LIT> ) <EOL> else : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def get_all_menu ( self , request ) : <EOL> user = request . user <EOL> queryset = self . queryset . all ( ) <EOL> if not user . is_superuser : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> ", "gt": "serializer = WebRouterSerializer ( queryset , many = True , request = request )"}
{"input": "import functools <EOL> import os <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from django . conf import settings <EOL> from celery import platforms <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from tenant_schemas_celery . app import CeleryApp as TenantAwareCeleryApp <EOL> app = TenantAwareCeleryApp ( ) <EOL> else : <EOL> from celery import Celery <EOL> app = Celery ( f\"<STR_LIT>\" ) <EOL> app . config_from_object ( '<STR_LIT>' ) <EOL> app . autodiscover_tasks ( lambda : settings . INSTALLED_APPS ) <EOL> platforms . C_FORCE_ROOT = True <EOL> def retry_base_task_error ( ) : <EOL> def wraps ( func ) : <EOL> @ app . task ( bind = True , retry_delay = <NUM_LIT> , max_retries = <NUM_LIT> ) <EOL> @ functools . wraps ( func ) <EOL> def wrapper ( self , * args , ** kwargs ) : <EOL> try : <EOL> ", "gt": "return func ( * args , ** kwargs )"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> ", "gt": "from dvadmin_cloud_storage . views . aliyun import ali_oss_upload"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> class FieldPermissionMixin : <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def field_permission ( self , request ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is self . serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded : <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> user = request . user <EOL> if user . is_superuser == <NUM_LIT> : <EOL> ", "gt": "data = MenuField . objects . filter ( model = model [ '<STR_LIT>' ] ) . values ( '<STR_LIT>' )"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( \"<STR_LIT>\" , include ( \"<STR_LIT>\" ) ) , <EOL> path ( \"<STR_LIT>\" , LoginView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , LogoutView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , TokenRefreshView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> re_path ( <EOL> r\"<STR_LIT>\" , include ( \"<STR_LIT>\" , namespace = \"<STR_LIT>\" ) <EOL> ) , <EOL> path ( \"<STR_LIT>\" , CaptchaView . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitDictionaryViewSet . as_view ( ) ) , <EOL> ", "gt": "path ( \"<STR_LIT>\" , InitSettingsViewSet . as_view ( ) ) ,"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) <EOL> else : <EOL> nested_dict [ target_key ] = new_value <EOL> return nested_dict <EOL> def __handle_crud ( self ) : <EOL> result = self . __get_field_attribute ( ) <EOL> columns = dict ( ) <EOL> for item in result : <EOL> key = item . get ( '<STR_LIT>' ) <EOL> title = item . get ( '<STR_LIT>' ) <EOL> type = item . get ( '<STR_LIT>' ) <EOL> ", "gt": "columns [ key ] = {"}
{"input": "import hashlib <EOL> import logging <EOL> from django . contrib . auth import get_user_model <EOL> from django . contrib . auth . backends import ModelBackend <EOL> from django . contrib . auth . hashers import check_password <EOL> from django . utils import timezone <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> logger = logging . getLogger ( __name__ ) <EOL> UserModel = get_user_model ( ) <EOL> class CustomBackend ( ModelBackend ) : <EOL> def authenticate ( self , request , username = None , password = None , ** kwargs ) : <EOL> msg = '<STR_LIT>' % username <EOL> logger . info ( msg ) <EOL> if username is None : <EOL> username = kwargs . get ( UserModel . USERNAME_FIELD ) <EOL> try : <EOL> ", "gt": "user = UserModel . _default_manager . get_by_natural_key ( username )"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> ", "gt": "fields = {"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> fields = ALL_FIELDS <EOL> if fields == ALL_FIELDS : <EOL> fields = cls . get_all_model_fields ( model ) <EOL> exclude = exclude or [ ] <EOL> if not isinstance ( fields , dict ) : <EOL> fields = [ ( f , [ settings . DEFAULT_LOOKUP_EXPR ] ) for f in fields if f not in exclude ] <EOL> else : <EOL> fields = [ ( f , lookups ) for f , lookups in fields . items ( ) if f not in exclude ] <EOL> return OrderedDict ( fields ) <EOL> @ classmethod <EOL> def get_filters ( cls ) : <EOL> if not cls . _meta . model : <EOL> return cls . declared_filters . copy ( ) <EOL> filters = OrderedDict ( ) <EOL> fields = cls . get_fields ( ) <EOL> undefined = [ ] <EOL> for field_name , lookups in fields . items ( ) : <EOL> field = get_model_field ( cls . _meta . model , field_name ) <EOL> from django . db import models <EOL> ", "gt": "from timezone_field import TimeZoneField"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> ", "gt": "'<STR_LIT>' : model [ '<STR_LIT>' ]"}
{"input": "from functools import wraps <EOL> from django . db . models import Func , F , OuterRef , Exists <EOL> from django . test import TestCase <EOL> import django <EOL> import os <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . system . models import Menu , RoleMenuPermission , RoleMenuButtonPermission , MenuButton <EOL> import time <EOL> def timing_decorator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = func ( * args , ** kwargs ) <EOL> end_time = time . time ( ) <EOL> run_time = end_time - start_time <EOL> print ( f\"<STR_LIT>\" ) <EOL> return result <EOL> return wrapper <EOL> @ timing_decorator <EOL> def getMenu ( ) : <EOL> data = [ ] <EOL> queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> for item in queryset : <EOL> parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) <EOL> ", "gt": "names = [ d [ \"<STR_LIT>\" ] for d in parent_list ]"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> ", "gt": "setattr ("}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MenuButtonPermissionSerializer ( CustomModelSerializer ) : <EOL> isCheck = serializers . SerializerMethodField ( ) <EOL> def get_isCheck ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> return True <EOL> else : <EOL> return MenuButton . objects . filter ( <EOL> menu__id = instance . id , <EOL> role__id__in = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) , <EOL> ) . exists ( ) <EOL> ", "gt": "class Meta :"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> model_name = request . data . get ( '<STR_LIT>' ) <EOL> if not menu_id or not model_name : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] != model_name : <EOL> ", "gt": "continue"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> model_name = request . data . get ( '<STR_LIT>' ) <EOL> if not menu_id or not model_name : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] != model_name : <EOL> continue <EOL> for field in model [ '<STR_LIT>' ] : <EOL> if MenuField . objects . filter ( <EOL> menu_id = menu_id , model = model_name , field_name = field [ '<STR_LIT>' ] <EOL> ) . exists ( ) : <EOL> continue <EOL> data = { <EOL> '<STR_LIT>' : menu_id , <EOL> '<STR_LIT>' : model_name , <EOL> ", "gt": "'<STR_LIT>' : field [ '<STR_LIT>' ] ,"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> ", "gt": "def get_request_name ( self ) :"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> var_name = body . get ( '<STR_LIT>' , None ) <EOL> table = body . get ( '<STR_LIT>' , None ) <EOL> instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> relation_id = body . get ( '<STR_LIT>' , None ) <EOL> relationIds = [ ] <EOL> if relation_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = [ relation_id ] <EOL> elif instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = relation_id . split ( '<STR_LIT>' ) <EOL> queryset = SystemConfig . objects . filter ( value__in = relationIds ) . first ( ) <EOL> if queryset is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> serializer = SystemConfigChinldernSerializer ( queryset . parent ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = serializer . data ) <EOL> class InitSettingsViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> ", "gt": "permission_classes = [ ]"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> queryset = self . queryset . filter ( status = <NUM_LIT> ) <EOL> else : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def get_all_menu ( self , request ) : <EOL> user = request . user <EOL> queryset = self . queryset . all ( ) <EOL> if not user . is_superuser : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def move_up ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> menu = Menu . objects . get ( id = menu_id ) <EOL> except Menu . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Menu . objects . filter ( sort__lt = menu . sort , parent = menu . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , menu . sort = menu . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> menu . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def move_down ( self , request ) : <EOL> menu_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> menu = Menu . objects . get ( id = menu_id ) <EOL> except Menu . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> ", "gt": "next_menu = Menu . objects . filter ( sort__gt = menu . sort , parent = menu . parent ) . order_by ( '<STR_LIT>' ) . first ( )"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ", "gt": "ua_string = request . META [ '<STR_LIT>' ]"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> class FieldPermissionMixin : <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def field_permission ( self , request ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is self . serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded : <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> user = request . user <EOL> if user . is_superuser == <NUM_LIT> : <EOL> data = MenuField . objects . filter ( model = model [ '<STR_LIT>' ] ) . values ( '<STR_LIT>' ) <EOL> ", "gt": "for item in data :"}
{"input": "from rest_framework . response import Response <EOL> class SuccessResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , page = <NUM_LIT> , limit = <NUM_LIT> , total = <NUM_LIT> ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : page , <EOL> \"<STR_LIT>\" : limit , <EOL> \"<STR_LIT>\" : total , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class DetailResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , ) : <EOL> std_data = { <EOL> ", "gt": "\"<STR_LIT>\" : <NUM_LIT> ,"}
{"input": "from drf_yasg . generators import OpenAPISchemaGenerator <EOL> from drf_yasg . inspectors import SwaggerAutoSchema <EOL> from application . settings import SWAGGER_SETTINGS <EOL> def get_summary ( string ) : <EOL> if string is not None : <EOL> result = string . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) <EOL> return result [ <NUM_LIT> ] <EOL> class CustomSwaggerAutoSchema ( SwaggerAutoSchema ) : <EOL> def get_tags ( self , operation_keys = None ) : <EOL> tags = super ( ) . get_tags ( operation_keys ) <EOL> if \"<STR_LIT>\" in tags and operation_keys : <EOL> tags [ <NUM_LIT> ] = operation_keys [ SWAGGER_SETTINGS . get ( '<STR_LIT>' , <NUM_LIT> ) ] <EOL> return tags <EOL> def get_summary_and_description ( self ) : <EOL> summary_and_description = super ( ) . get_summary_and_description ( ) <EOL> summary = get_summary ( self . __dict__ . get ( '<STR_LIT>' ) . __doc__ ) <EOL> description = summary_and_description [ <NUM_LIT> ] <EOL> ", "gt": "return summary , description"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> ", "gt": "values = items [ <NUM_LIT> ]"}
{"input": "import multiprocessing <EOL> workers = multiprocessing . cpu_count ( ) * <NUM_LIT> + <NUM_LIT> <EOL> threads = <NUM_LIT> <EOL> bind = '<STR_LIT>' <EOL> daemon = '<STR_LIT>' <EOL> worker_class = '<STR_LIT>' <EOL> worker_connections = <NUM_LIT> <EOL> max_requests = <NUM_LIT> <EOL> max_requests_jitter = <NUM_LIT> <EOL> pidfile = '<STR_LIT>' <EOL> loglevel = '<STR_LIT>' <EOL> access_log_format = '<STR_LIT>' <EOL> ", "gt": "backlog = <NUM_LIT>"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> ", "gt": "async def push_message ( self , event ) :"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> elif value_type == '<STR_LIT>' : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) <EOL> else : <EOL> if type ( cell_value ) is float and str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] == \"<STR_LIT>\" : <EOL> cell_value = int ( str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ) <EOL> elif type ( cell_value ) is str : <EOL> cell_value = cell_value . strip ( \"<STR_LIT>\" ) <EOL> if key in validation_data_dict : <EOL> array [ key ] = validation_data_dict . get ( key , { } ) . get ( cell_value , None ) <EOL> if key in m2m_fields : <EOL> array [ key ] = list ( <EOL> filter ( <EOL> lambda x : x , <EOL> [ <EOL> validation_data_dict . get ( key , { } ) . get ( value , None ) <EOL> for value in re . split ( r\"<STR_LIT>\" , cell_value ) <EOL> ] , <EOL> ) <EOL> ) <EOL> ", "gt": "else :"}
{"input": "from django . urls import path <EOL> from rest_framework import routers <EOL> from dvadmin . system . views . api_white_list import ApiWhiteListViewSet <EOL> from dvadmin . system . views . area import AreaViewSet <EOL> from dvadmin . system . views . clause import PrivacyView , TermsServiceView <EOL> from dvadmin . system . views . dept import DeptViewSet <EOL> from dvadmin . system . views . dictionary import DictionaryViewSet <EOL> from dvadmin . system . views . file_list import FileViewSet <EOL> from dvadmin . system . views . login_log import LoginLogViewSet <EOL> from dvadmin . system . views . menu import MenuViewSet <EOL> from dvadmin . system . views . menu_button import MenuButtonViewSet <EOL> from dvadmin . system . views . message_center import MessageCenterViewSet <EOL> from dvadmin . system . views . operation_log import OperationLogViewSet <EOL> from dvadmin . system . views . role import RoleViewSet <EOL> from dvadmin . system . views . role_menu import RoleMenuPermissionViewSet <EOL> from dvadmin . system . views . role_menu_button_permission import RoleMenuButtonPermissionViewSet <EOL> from dvadmin . system . views . system_config import SystemConfigViewSet <EOL> from dvadmin . system . views . user import UserViewSet <EOL> from dvadmin . system . views . menu_field import MenuFieldViewSet <EOL> system_url = routers . SimpleRouter ( ) <EOL> system_url . register ( r'<STR_LIT>' , MenuViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuButtonViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DeptViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , UserViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , OperationLogViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DictionaryViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , AreaViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , FileViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , ApiWhiteListViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , SystemConfigViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MessageCenterViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuButtonPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuFieldViewSet ) <EOL> urlpatterns = [ <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , } ) ) , <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> ", "gt": "path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) ,"}
{"input": "from functools import wraps <EOL> from django . db . models import Func , F , OuterRef , Exists <EOL> from django . test import TestCase <EOL> import django <EOL> import os <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . system . models import Menu , RoleMenuPermission , RoleMenuButtonPermission , MenuButton <EOL> import time <EOL> def timing_decorator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = func ( * args , ** kwargs ) <EOL> end_time = time . time ( ) <EOL> run_time = end_time - start_time <EOL> print ( f\"<STR_LIT>\" ) <EOL> return result <EOL> return wrapper <EOL> @ timing_decorator <EOL> def getMenu ( ) : <EOL> data = [ ] <EOL> queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> for item in queryset : <EOL> parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) <EOL> names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] <EOL> completeName = \"<STR_LIT>\" . join ( names ) <EOL> isCheck = RoleMenuPermission . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> role__id = <NUM_LIT> , <EOL> ) . exists ( ) <EOL> mbCheck = RoleMenuButtonPermission . objects . filter ( <EOL> menu_button = OuterRef ( \"<STR_LIT>\" ) , <EOL> role__id = <NUM_LIT> , <EOL> ) <EOL> ", "gt": "btns = MenuButton . objects . filter ("}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> elif value_type == '<STR_LIT>' : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) <EOL> else : <EOL> if type ( cell_value ) is float and str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] == \"<STR_LIT>\" : <EOL> cell_value = int ( str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ) <EOL> elif type ( cell_value ) is str : <EOL> cell_value = cell_value . strip ( \"<STR_LIT>\" ) <EOL> if key in validation_data_dict : <EOL> array [ key ] = validation_data_dict . get ( key , { } ) . get ( cell_value , None ) <EOL> if key in m2m_fields : <EOL> array [ key ] = list ( <EOL> filter ( <EOL> lambda x : x , <EOL> [ <EOL> validation_data_dict . get ( key , { } ) . get ( value , None ) <EOL> ", "gt": "for value in re . split ( r\"<STR_LIT>\" , cell_value )"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) <EOL> else : <EOL> nested_dict [ target_key ] = new_value <EOL> return nested_dict <EOL> def __handle_crud ( self ) : <EOL> result = self . __get_field_attribute ( ) <EOL> columns = dict ( ) <EOL> for item in result : <EOL> key = item . get ( '<STR_LIT>' ) <EOL> title = item . get ( '<STR_LIT>' ) <EOL> type = item . get ( '<STR_LIT>' ) <EOL> columns [ key ] = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : key , <EOL> \"<STR_LIT>\" : type <EOL> } <EOL> if self . custom_crud_json and isinstance ( self . custom_crud_json , dict ) : <EOL> columns = columns | self . custom_crud_json <EOL> if self . crud_update_key_value and isinstance ( self . crud_update_key_value , dict ) : <EOL> for key , value in self . crud_update_key_value . items ( ) : <EOL> columns = self . __update_nested_dict ( columns , key , value ) <EOL> return columns <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ AllowAny ] ) <EOL> def init_crud ( self , request ) : <EOL> self . permission_classes = [ AllowAny ] <EOL> columns = self . __handle_crud ( ) <EOL> expose = \"<STR_LIT>\" <EOL> ", "gt": "ret = \"<STR_LIT>\""}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( \"<STR_LIT>\" , include ( \"<STR_LIT>\" ) ) , <EOL> path ( \"<STR_LIT>\" , LoginView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , LogoutView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , TokenRefreshView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> re_path ( <EOL> r\"<STR_LIT>\" , include ( \"<STR_LIT>\" , namespace = \"<STR_LIT>\" ) <EOL> ) , <EOL> path ( \"<STR_LIT>\" , CaptchaView . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitDictionaryViewSet . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitSettingsViewSet . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , ApiLogin . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , LoginTokenView . as_view ( ) ) , <EOL> ] <EOL> + static ( settings . MEDIA_URL , document_root = settings . MEDIA_ROOT ) <EOL> ", "gt": "+ static ( settings . STATIC_URL , document_root = settings . STATIC_URL )"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> if not getattr ( settings , \"<STR_LIT>\" , False ) : <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginTokenView ( TokenObtainPairView ) : <EOL> serializer_class = LoginTokenSerializer <EOL> permission_classes = [ ] <EOL> class LogoutView ( APIView ) : <EOL> def post ( self , request ) : <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> class ApiLoginSerializer ( CustomModelSerializer ) : <EOL> username = serializers . CharField ( ) <EOL> password = serializers . CharField ( ) <EOL> class Meta : <EOL> model = Users <EOL> fields = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class ApiLogin ( APIView ) : <EOL> serializer_class = ApiLoginSerializer <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def post ( self , request ) : <EOL> username = request . data . get ( \"<STR_LIT>\" ) <EOL> password = request . data . get ( \"<STR_LIT>\" ) <EOL> user_obj = auth . authenticate ( <EOL> request , <EOL> username = username , <EOL> password = hashlib . md5 ( password . encode ( encoding = \"<STR_LIT>\" ) ) . hexdigest ( ) , <EOL> ) <EOL> if user_obj : <EOL> login ( request , user_obj ) <EOL> ", "gt": "return redirect ( \"<STR_LIT>\" )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> ", "gt": "serializer = MenuButtonSerializer ( queryset , many = True , read_only = True )"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> ", "gt": "elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) :"}
{"input": "import functools <EOL> import os <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from django . conf import settings <EOL> from celery import platforms <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from tenant_schemas_celery . app import CeleryApp as TenantAwareCeleryApp <EOL> app = TenantAwareCeleryApp ( ) <EOL> else : <EOL> from celery import Celery <EOL> app = Celery ( f\"<STR_LIT>\" ) <EOL> app . config_from_object ( '<STR_LIT>' ) <EOL> app . autodiscover_tasks ( lambda : settings . INSTALLED_APPS ) <EOL> platforms . C_FORCE_ROOT = True <EOL> def retry_base_task_error ( ) : <EOL> def wraps ( func ) : <EOL> ", "gt": "@ app . task ( bind = True , retry_delay = <NUM_LIT> , max_retries = <NUM_LIT> )"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> ", "gt": "def get_table_data ( self , request , pk ) :"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> ", "gt": "def save ( self , obj , data : list , name = None , no_reset = False ) :"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import MenuButton , RoleMenuButtonPermission <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuButtonSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuButton . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuButtonSerializer <EOL> create_serializer_class = MenuButtonCreateUpdateSerializer <EOL> update_serializer_class = MenuButtonCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) . order_by ( '<STR_LIT>' ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( serializer . data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def menu_button_all_permission ( self , request ) : <EOL> is_superuser = request . user . is_superuser <EOL> ", "gt": "if is_superuser :"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> model_name = request . data . get ( '<STR_LIT>' ) <EOL> if not menu_id or not model_name : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] != model_name : <EOL> continue <EOL> for field in model [ '<STR_LIT>' ] : <EOL> if MenuField . objects . filter ( <EOL> menu_id = menu_id , model = model_name , field_name = field [ '<STR_LIT>' ] <EOL> ) . exists ( ) : <EOL> continue <EOL> data = { <EOL> '<STR_LIT>' : menu_id , <EOL> '<STR_LIT>' : model_name , <EOL> '<STR_LIT>' : field [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : str ( field [ '<STR_LIT>' ] ) , <EOL> } <EOL> ", "gt": "serializer = self . get_serializer ( data = data , request = request )"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> ", "gt": "if file_engine == '<STR_LIT>' :"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> ", "gt": "read_only_fields = [ \"<STR_LIT>\" ]"}
{"input": "from functools import wraps <EOL> from django . db . models import Func , F , OuterRef , Exists <EOL> from django . test import TestCase <EOL> import django <EOL> import os <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . system . models import Menu , RoleMenuPermission , RoleMenuButtonPermission , MenuButton <EOL> import time <EOL> def timing_decorator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = func ( * args , ** kwargs ) <EOL> end_time = time . time ( ) <EOL> run_time = end_time - start_time <EOL> print ( f\"<STR_LIT>\" ) <EOL> return result <EOL> return wrapper <EOL> @ timing_decorator <EOL> def getMenu ( ) : <EOL> data = [ ] <EOL> queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> for item in queryset : <EOL> parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) <EOL> names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] <EOL> completeName = \"<STR_LIT>\" . join ( names ) <EOL> isCheck = RoleMenuPermission . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> role__id = <NUM_LIT> , <EOL> ) . exists ( ) <EOL> mbCheck = RoleMenuButtonPermission . objects . filter ( <EOL> menu_button = OuterRef ( \"<STR_LIT>\" ) , <EOL> role__id = <NUM_LIT> , <EOL> ) <EOL> btns = MenuButton . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> ) . annotate ( isCheck = Exists ( mbCheck ) ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , data_range = F ( '<STR_LIT>' ) ) <EOL> dicts = { <EOL> '<STR_LIT>' : completeName , <EOL> '<STR_LIT>' : item [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : isCheck , <EOL> '<STR_LIT>' : btns <EOL> } <EOL> print ( dicts ) <EOL> ", "gt": "data . append ( dicts )"}
{"input": "import hashlib <EOL> import random <EOL> CHAR_SET = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def random_str ( number = <NUM_LIT> ) : <EOL> result = \"<STR_LIT>\" <EOL> for i in range ( <NUM_LIT> , number ) : <EOL> inx = random . randint ( <NUM_LIT> , len ( CHAR_SET ) - <NUM_LIT> ) <EOL> result += CHAR_SET [ inx ] <EOL> return result <EOL> def has_md5 ( str , salt = '<STR_LIT>' ) : <EOL> str = str + salt <EOL> md = hashlib . md5 ( ) <EOL> md . update ( str . encode ( ) ) <EOL> res = md . hexdigest ( ) <EOL> ", "gt": "return res"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> ", "gt": "if dept :"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> ", "gt": "for send_user in user_list :"}
{"input": "import os <EOL> from channels . auth import AuthMiddlewareStack <EOL> from channels . security . websocket import AllowedHostsOriginValidator <EOL> from channels . routing import ProtocolTypeRouter , URLRouter <EOL> from django . core . asgi import get_asgi_application <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> http_application = get_asgi_application ( ) <EOL> from application . routing import websocket_urlpatterns <EOL> application = ProtocolTypeRouter ( { <EOL> \"<STR_LIT>\" : http_application , <EOL> ", "gt": "'<STR_LIT>' : AllowedHostsOriginValidator ("}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> ", "gt": "table = setting . get ( '<STR_LIT>' )"}
{"input": "from drf_yasg . generators import OpenAPISchemaGenerator <EOL> from drf_yasg . inspectors import SwaggerAutoSchema <EOL> from application . settings import SWAGGER_SETTINGS <EOL> def get_summary ( string ) : <EOL> if string is not None : <EOL> result = string . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) <EOL> return result [ <NUM_LIT> ] <EOL> class CustomSwaggerAutoSchema ( SwaggerAutoSchema ) : <EOL> def get_tags ( self , operation_keys = None ) : <EOL> tags = super ( ) . get_tags ( operation_keys ) <EOL> if \"<STR_LIT>\" in tags and operation_keys : <EOL> tags [ <NUM_LIT> ] = operation_keys [ SWAGGER_SETTINGS . get ( '<STR_LIT>' , <NUM_LIT> ) ] <EOL> return tags <EOL> def get_summary_and_description ( self ) : <EOL> summary_and_description = super ( ) . get_summary_and_description ( ) <EOL> summary = get_summary ( self . __dict__ . get ( '<STR_LIT>' ) . __doc__ ) <EOL> description = summary_and_description [ <NUM_LIT> ] <EOL> return summary , description <EOL> class CustomOpenAPISchemaGenerator ( OpenAPISchemaGenerator ) : <EOL> def get_schema ( self , request = None , public = False ) : <EOL> swagger = super ( ) . get_schema ( request , public ) <EOL> swagger . tags = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> ", "gt": "]"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> ", "gt": "try :"}
{"input": "from rest_framework . response import Response <EOL> class SuccessResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , page = <NUM_LIT> , limit = <NUM_LIT> , total = <NUM_LIT> ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : page , <EOL> \"<STR_LIT>\" : limit , <EOL> \"<STR_LIT>\" : total , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class DetailResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class ErrorResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , code = <NUM_LIT> , status = None , template_name = None , headers = None , <EOL> exception = False , content_type = None ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : code , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> ", "gt": "}"}
{"input": "from functools import wraps <EOL> from django . db . models import Func , F , OuterRef , Exists <EOL> from django . test import TestCase <EOL> import django <EOL> import os <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . system . models import Menu , RoleMenuPermission , RoleMenuButtonPermission , MenuButton <EOL> import time <EOL> def timing_decorator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = func ( * args , ** kwargs ) <EOL> end_time = time . time ( ) <EOL> run_time = end_time - start_time <EOL> print ( f\"<STR_LIT>\" ) <EOL> return result <EOL> return wrapper <EOL> @ timing_decorator <EOL> def getMenu ( ) : <EOL> data = [ ] <EOL> queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> for item in queryset : <EOL> parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) <EOL> names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] <EOL> completeName = \"<STR_LIT>\" . join ( names ) <EOL> isCheck = RoleMenuPermission . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> role__id = <NUM_LIT> , <EOL> ) . exists ( ) <EOL> mbCheck = RoleMenuButtonPermission . objects . filter ( <EOL> menu_button = OuterRef ( \"<STR_LIT>\" ) , <EOL> role__id = <NUM_LIT> , <EOL> ) <EOL> btns = MenuButton . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> ) . annotate ( isCheck = Exists ( mbCheck ) ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , data_range = F ( '<STR_LIT>' ) ) <EOL> dicts = { <EOL> '<STR_LIT>' : completeName , <EOL> '<STR_LIT>' : item [ '<STR_LIT>' ] , <EOL> ", "gt": "'<STR_LIT>' : isCheck ,"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> target_role = None , message : dict = None , request = Request ) : <EOL> if message is None : <EOL> message = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> if target_role is None : <EOL> target_role = [ ] <EOL> if target_dept is None : <EOL> target_dept = [ ] <EOL> data = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : content , <EOL> \"<STR_LIT>\" : target_type , <EOL> ", "gt": "\"<STR_LIT>\" : target_user ,"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import RoleMenuPermission , Menu , MenuButton <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleMenuPermissionSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionInitSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionViewSet ( CustomModelViewSet ) : <EOL> queryset = RoleMenuPermission . objects . all ( ) <EOL> serializer_class = RoleMenuPermissionSerializer <EOL> create_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> update_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def save_auth ( self , request ) : <EOL> body = request . data <EOL> ", "gt": "role_id = body . get ( '<STR_LIT>' , None )"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> class FieldPermissionMixin : <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def field_permission ( self , request ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is self . serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded : <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> ", "gt": "user = request . user"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> try : <EOL> request_user = self . request . user <EOL> validated_data [ '<STR_LIT>' ] = request_user . dept . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> except : <EOL> pass <EOL> return super ( ) . create ( validated_data ) <EOL> class FileViewSet ( CustomModelViewSet ) : <EOL> queryset = FileList . objects . all ( ) <EOL> serializer_class = FileSerializer <EOL> ", "gt": "filter_fields = [ '<STR_LIT>' , ]"}
{"input": "import os <EOL> import django <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . utils . core_initialize import CoreInitialize <EOL> from dvadmin . system . fixtures . initSerializer import ( <EOL> UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , <EOL> MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , <EOL> SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> ) <EOL> class Initialize ( CoreInitialize ) : <EOL> def init_dept ( self ) : <EOL> self . init_base ( DeptInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role ( self ) : <EOL> self . init_base ( RoleInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_users ( self ) : <EOL> self . init_base ( UsersInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_menu ( self ) : <EOL> self . init_base ( MenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu ( self ) : <EOL> self . init_base ( RoleMenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu_button ( self ) : <EOL> self . init_base ( RoleMenuButtonInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_api_white_list ( self ) : <EOL> self . init_base ( ApiWhiteListInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def init_dictionary ( self ) : <EOL> self . init_base ( DictionaryInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def init_system_config ( self ) : <EOL> self . init_base ( SystemConfigInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def run ( self ) : <EOL> self . init_dept ( ) <EOL> self . init_role ( ) <EOL> self . init_users ( ) <EOL> self . init_menu ( ) <EOL> self . init_role_menu ( ) <EOL> self . init_role_menu_button ( ) <EOL> self . init_api_white_list ( ) <EOL> ", "gt": "self . init_dictionary ( )"}
{"input": "from django . urls import path <EOL> from rest_framework import routers <EOL> from dvadmin . system . views . api_white_list import ApiWhiteListViewSet <EOL> from dvadmin . system . views . area import AreaViewSet <EOL> from dvadmin . system . views . clause import PrivacyView , TermsServiceView <EOL> from dvadmin . system . views . dept import DeptViewSet <EOL> from dvadmin . system . views . dictionary import DictionaryViewSet <EOL> from dvadmin . system . views . file_list import FileViewSet <EOL> from dvadmin . system . views . login_log import LoginLogViewSet <EOL> from dvadmin . system . views . menu import MenuViewSet <EOL> from dvadmin . system . views . menu_button import MenuButtonViewSet <EOL> from dvadmin . system . views . message_center import MessageCenterViewSet <EOL> from dvadmin . system . views . operation_log import OperationLogViewSet <EOL> from dvadmin . system . views . role import RoleViewSet <EOL> from dvadmin . system . views . role_menu import RoleMenuPermissionViewSet <EOL> from dvadmin . system . views . role_menu_button_permission import RoleMenuButtonPermissionViewSet <EOL> from dvadmin . system . views . system_config import SystemConfigViewSet <EOL> from dvadmin . system . views . user import UserViewSet <EOL> from dvadmin . system . views . menu_field import MenuFieldViewSet <EOL> system_url = routers . SimpleRouter ( ) <EOL> system_url . register ( r'<STR_LIT>' , MenuViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuButtonViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DeptViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , UserViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , OperationLogViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DictionaryViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , AreaViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , FileViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , ApiWhiteListViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , SystemConfigViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MessageCenterViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuButtonPermissionViewSet ) <EOL> ", "gt": "system_url . register ( r'<STR_LIT>' , RoleMenuPermissionViewSet )"}
{"input": "from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class OperationLogSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = OperationLog <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> ", "gt": "class OperationLogCreateUpdateSerializer ( CustomModelSerializer ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> queryset = self . queryset . filter ( status = <NUM_LIT> ) <EOL> else : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def get_all_menu ( self , request ) : <EOL> user = request . user <EOL> queryset = self . queryset . all ( ) <EOL> if not user . is_superuser : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def move_up ( self , request ) : <EOL> ", "gt": "menu_id = request . data . get ( '<STR_LIT>' )"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> ", "gt": "if isinstance ( self . filter_fields , ( list , tuple ) ) :"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> target_role = None , message : dict = None , request = Request ) : <EOL> if message is None : <EOL> message = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> if target_role is None : <EOL> ", "gt": "target_role = [ ]"}
{"input": "from drf_yasg . generators import OpenAPISchemaGenerator <EOL> from drf_yasg . inspectors import SwaggerAutoSchema <EOL> from application . settings import SWAGGER_SETTINGS <EOL> def get_summary ( string ) : <EOL> if string is not None : <EOL> result = string . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) <EOL> return result [ <NUM_LIT> ] <EOL> class CustomSwaggerAutoSchema ( SwaggerAutoSchema ) : <EOL> def get_tags ( self , operation_keys = None ) : <EOL> tags = super ( ) . get_tags ( operation_keys ) <EOL> if \"<STR_LIT>\" in tags and operation_keys : <EOL> tags [ <NUM_LIT> ] = operation_keys [ SWAGGER_SETTINGS . get ( '<STR_LIT>' , <NUM_LIT> ) ] <EOL> return tags <EOL> def get_summary_and_description ( self ) : <EOL> summary_and_description = super ( ) . get_summary_and_description ( ) <EOL> summary = get_summary ( self . __dict__ . get ( '<STR_LIT>' ) . __doc__ ) <EOL> description = summary_and_description [ <NUM_LIT> ] <EOL> return summary , description <EOL> class CustomOpenAPISchemaGenerator ( OpenAPISchemaGenerator ) : <EOL> def get_schema ( self , request = None , public = False ) : <EOL> swagger = super ( ) . get_schema ( request , public ) <EOL> swagger . tags = [ <EOL> ", "gt": "{"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> obj . objects . all ( ) . delete ( ) <EOL> settings . INITIALIZE_RESET_LIST . append ( obj ) <EOL> except Exception : <EOL> pass <EOL> ", "gt": "for ele in data :"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ", "gt": ")"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> ", "gt": "class MessageCenterViewSet ( CustomModelViewSet ) :"}
{"input": "import os <EOL> import sys <EOL> def main ( ) : <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> from django . core . management import execute_from_command_line <EOL> except ImportError as exc : <EOL> raise ImportError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ", "gt": ") from exc"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> ", "gt": "cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( )"}
{"input": "import hashlib <EOL> import logging <EOL> from django . contrib . auth import get_user_model <EOL> from django . contrib . auth . backends import ModelBackend <EOL> from django . contrib . auth . hashers import check_password <EOL> from django . utils import timezone <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> logger = logging . getLogger ( __name__ ) <EOL> UserModel = get_user_model ( ) <EOL> class CustomBackend ( ModelBackend ) : <EOL> def authenticate ( self , request , username = None , password = None , ** kwargs ) : <EOL> msg = '<STR_LIT>' % username <EOL> logger . info ( msg ) <EOL> if username is None : <EOL> username = kwargs . get ( UserModel . USERNAME_FIELD ) <EOL> try : <EOL> user = UserModel . _default_manager . get_by_natural_key ( username ) <EOL> except UserModel . DoesNotExist : <EOL> UserModel ( ) . set_password ( password ) <EOL> ", "gt": "else :"}
{"input": "import os <EOL> from channels . auth import AuthMiddlewareStack <EOL> from channels . security . websocket import AllowedHostsOriginValidator <EOL> from channels . routing import ProtocolTypeRouter , URLRouter <EOL> from django . core . asgi import get_asgi_application <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> http_application = get_asgi_application ( ) <EOL> from application . routing import websocket_urlpatterns <EOL> application = ProtocolTypeRouter ( { <EOL> \"<STR_LIT>\" : http_application , <EOL> '<STR_LIT>' : AllowedHostsOriginValidator ( <EOL> AuthMiddlewareStack ( <EOL> ", "gt": "URLRouter ("}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) <EOL> else : <EOL> nested_dict [ target_key ] = new_value <EOL> return nested_dict <EOL> def __handle_crud ( self ) : <EOL> result = self . __get_field_attribute ( ) <EOL> columns = dict ( ) <EOL> for item in result : <EOL> key = item . get ( '<STR_LIT>' ) <EOL> title = item . get ( '<STR_LIT>' ) <EOL> type = item . get ( '<STR_LIT>' ) <EOL> columns [ key ] = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : key , <EOL> \"<STR_LIT>\" : type <EOL> } <EOL> if self . custom_crud_json and isinstance ( self . custom_crud_json , dict ) : <EOL> columns = columns | self . custom_crud_json <EOL> if self . crud_update_key_value and isinstance ( self . crud_update_key_value , dict ) : <EOL> for key , value in self . crud_update_key_value . items ( ) : <EOL> columns = self . __update_nested_dict ( columns , key , value ) <EOL> return columns <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ AllowAny ] ) <EOL> def init_crud ( self , request ) : <EOL> self . permission_classes = [ AllowAny ] <EOL> columns = self . __handle_crud ( ) <EOL> ", "gt": "expose = \"<STR_LIT>\""}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> ", "gt": "obj . objects . all ( ) . delete ( )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> next_menu = Dept . objects . filter ( sort__gt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if next_menu : <EOL> next_menu . sort , dept . sort = dept . sort , next_menu . sort <EOL> next_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def dept_info ( self , request ) : <EOL> def inner ( did , li ) : <EOL> sub = Dept . objects . filter ( parent_id = did ) <EOL> if not sub . exists ( ) : <EOL> return li <EOL> for i in sub : <EOL> li . append ( i . pk ) <EOL> inner ( i , li ) <EOL> return li <EOL> dept_id = request . query_params . get ( '<STR_LIT>' ) <EOL> show_all = request . query_params . get ( '<STR_LIT>' ) <EOL> if dept_id is None : <EOL> ", "gt": "return ErrorResponse ( msg = \"<STR_LIT>\" )"}
{"input": "from django . urls import path <EOL> from rest_framework import routers <EOL> from dvadmin . system . views . api_white_list import ApiWhiteListViewSet <EOL> from dvadmin . system . views . area import AreaViewSet <EOL> from dvadmin . system . views . clause import PrivacyView , TermsServiceView <EOL> from dvadmin . system . views . dept import DeptViewSet <EOL> from dvadmin . system . views . dictionary import DictionaryViewSet <EOL> from dvadmin . system . views . file_list import FileViewSet <EOL> from dvadmin . system . views . login_log import LoginLogViewSet <EOL> from dvadmin . system . views . menu import MenuViewSet <EOL> from dvadmin . system . views . menu_button import MenuButtonViewSet <EOL> from dvadmin . system . views . message_center import MessageCenterViewSet <EOL> from dvadmin . system . views . operation_log import OperationLogViewSet <EOL> from dvadmin . system . views . role import RoleViewSet <EOL> from dvadmin . system . views . role_menu import RoleMenuPermissionViewSet <EOL> from dvadmin . system . views . role_menu_button_permission import RoleMenuButtonPermissionViewSet <EOL> from dvadmin . system . views . system_config import SystemConfigViewSet <EOL> from dvadmin . system . views . user import UserViewSet <EOL> from dvadmin . system . views . menu_field import MenuFieldViewSet <EOL> system_url = routers . SimpleRouter ( ) <EOL> system_url . register ( r'<STR_LIT>' , MenuViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuButtonViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DeptViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , UserViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , OperationLogViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DictionaryViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , AreaViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , FileViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , ApiWhiteListViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , SystemConfigViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MessageCenterViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuButtonPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuFieldViewSet ) <EOL> urlpatterns = [ <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , } ) ) , <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> ", "gt": "path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) ,"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> fields = ALL_FIELDS <EOL> if fields == ALL_FIELDS : <EOL> fields = cls . get_all_model_fields ( model ) <EOL> ", "gt": "exclude = exclude or [ ]"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> if not getattr ( settings , \"<STR_LIT>\" , False ) : <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> data = super ( ) . validate ( attrs ) <EOL> ", "gt": "data [ \"<STR_LIT>\" ] = self . user . name"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> api_white_list = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return False <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> userApiList = RoleMenuButtonPermission . objects . filter ( role__in = role_id_list ) . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> ", "gt": "ApiList = ["}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> ", "gt": "fields = ALL_FIELDS"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> api_white_list = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return False <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> userApiList = RoleMenuButtonPermission . objects . filter ( role__in = role_id_list ) . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> ApiList = [ <EOL> ", "gt": "str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ("}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( \"<STR_LIT>\" , include ( \"<STR_LIT>\" ) ) , <EOL> path ( \"<STR_LIT>\" , LoginView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , LogoutView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , TokenRefreshView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> re_path ( <EOL> r\"<STR_LIT>\" , include ( \"<STR_LIT>\" , namespace = \"<STR_LIT>\" ) <EOL> ) , <EOL> path ( \"<STR_LIT>\" , CaptchaView . as_view ( ) ) , <EOL> ", "gt": "path ( \"<STR_LIT>\" , InitDictionaryViewSet . as_view ( ) ) ,"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import RoleMenuPermission , Menu , MenuButton <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleMenuPermissionSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionInitSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionViewSet ( CustomModelViewSet ) : <EOL> queryset = RoleMenuPermission . objects . all ( ) <EOL> serializer_class = RoleMenuPermissionSerializer <EOL> create_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> update_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def save_auth ( self , request ) : <EOL> body = request . data <EOL> role_id = body . get ( '<STR_LIT>' , None ) <EOL> if role_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> menu_list = body . get ( '<STR_LIT>' , None ) <EOL> if menu_list is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> obj_list = RoleMenuPermission . objects . filter ( role__id = role_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> old_set = set ( obj_list ) <EOL> new_set = set ( menu_list ) <EOL> need_del = old_set . difference ( new_set ) <EOL> need_add = new_set . difference ( old_set ) <EOL> RoleMenuPermission . objects . filter ( role__id = role_id , menu__in = list ( need_del ) ) . delete ( ) <EOL> data = [ { \"<STR_LIT>\" : role_id , \"<STR_LIT>\" : item } for item in list ( need_add ) ] <EOL> serializer = RoleMenuPermissionSerializer ( data = data , many = True , request = request ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> ", "gt": "serializer . save ( )"}
{"input": "from rest_framework . response import Response <EOL> class SuccessResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , page = <NUM_LIT> , limit = <NUM_LIT> , total = <NUM_LIT> ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : page , <EOL> \"<STR_LIT>\" : limit , <EOL> \"<STR_LIT>\" : total , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class DetailResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> ", "gt": "class ErrorResponse ( Response ) :"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> ", "gt": "return DetailResponse ( msg = \"<STR_LIT>\" )"}
{"input": "from drf_yasg . generators import OpenAPISchemaGenerator <EOL> from drf_yasg . inspectors import SwaggerAutoSchema <EOL> from application . settings import SWAGGER_SETTINGS <EOL> def get_summary ( string ) : <EOL> if string is not None : <EOL> result = string . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) <EOL> return result [ <NUM_LIT> ] <EOL> class CustomSwaggerAutoSchema ( SwaggerAutoSchema ) : <EOL> def get_tags ( self , operation_keys = None ) : <EOL> tags = super ( ) . get_tags ( operation_keys ) <EOL> if \"<STR_LIT>\" in tags and operation_keys : <EOL> tags [ <NUM_LIT> ] = operation_keys [ SWAGGER_SETTINGS . get ( '<STR_LIT>' , <NUM_LIT> ) ] <EOL> return tags <EOL> def get_summary_and_description ( self ) : <EOL> summary_and_description = super ( ) . get_summary_and_description ( ) <EOL> summary = get_summary ( self . __dict__ . get ( '<STR_LIT>' ) . __doc__ ) <EOL> description = summary_and_description [ <NUM_LIT> ] <EOL> return summary , description <EOL> class CustomOpenAPISchemaGenerator ( OpenAPISchemaGenerator ) : <EOL> def get_schema ( self , request = None , public = False ) : <EOL> swagger = super ( ) . get_schema ( request , public ) <EOL> swagger . tags = [ <EOL> { <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "import os <EOL> import django <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . utils . core_initialize import CoreInitialize <EOL> from dvadmin . system . fixtures . initSerializer import ( <EOL> UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , <EOL> MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , <EOL> SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> ) <EOL> class Initialize ( CoreInitialize ) : <EOL> def init_dept ( self ) : <EOL> self . init_base ( DeptInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role ( self ) : <EOL> self . init_base ( RoleInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_users ( self ) : <EOL> self . init_base ( UsersInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_menu ( self ) : <EOL> self . init_base ( MenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu ( self ) : <EOL> self . init_base ( RoleMenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu_button ( self ) : <EOL> self . init_base ( RoleMenuButtonInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_api_white_list ( self ) : <EOL> self . init_base ( ApiWhiteListInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def init_dictionary ( self ) : <EOL> self . init_base ( DictionaryInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def init_system_config ( self ) : <EOL> self . init_base ( SystemConfigInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def run ( self ) : <EOL> self . init_dept ( ) <EOL> ", "gt": "self . init_role ( )"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> ", "gt": "menu_id = request . data . get ( '<STR_LIT>' )"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import MenuButton , RoleMenuButtonPermission <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuButtonSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuButton . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuButtonSerializer <EOL> create_serializer_class = MenuButtonCreateUpdateSerializer <EOL> update_serializer_class = MenuButtonCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) . order_by ( '<STR_LIT>' ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( serializer . data , msg = \"<STR_LIT>\" ) <EOL> ", "gt": "@ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] )"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import MenuButton , RoleMenuButtonPermission <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuButtonSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuButton . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuButtonSerializer <EOL> create_serializer_class = MenuButtonCreateUpdateSerializer <EOL> update_serializer_class = MenuButtonCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) . order_by ( '<STR_LIT>' ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> ", "gt": "return SuccessResponse ( serializer . data , msg = \"<STR_LIT>\" )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MenuButtonPermissionSerializer ( CustomModelSerializer ) : <EOL> isCheck = serializers . SerializerMethodField ( ) <EOL> ", "gt": "def get_isCheck ( self , instance ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> queryset = self . queryset . filter ( status = <NUM_LIT> ) <EOL> else : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def get_all_menu ( self , request ) : <EOL> user = request . user <EOL> queryset = self . queryset . all ( ) <EOL> if not user . is_superuser : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def move_up ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> menu = Menu . objects . get ( id = menu_id ) <EOL> except Menu . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Menu . objects . filter ( sort__lt = menu . sort , parent = menu . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , menu . sort = menu . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> ", "gt": "menu . save ( )"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> ", "gt": "serializer = self . get_serializer ( page , many = True , request = request )"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> return settings . ALL_MODELS_OBJECTS [ model_name ] or { } <EOL> return settings . ALL_MODELS_OBJECTS or { } <EOL> def get_model_from_app ( app_name ) : <EOL> model_module = import_module ( app_name + '<STR_LIT>' ) <EOL> filter_model = [ <EOL> getattr ( model_module , item ) for item in dir ( model_module ) <EOL> if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) <EOL> ] <EOL> model_list = [ ] <EOL> for model in filter_model : <EOL> if model . __name__ == '<STR_LIT>' : <EOL> continue <EOL> fields = [ <EOL> { '<STR_LIT>' : field . verbose_name , '<STR_LIT>' : field . name , '<STR_LIT>' : field } <EOL> for field in model . _meta . fields <EOL> ] <EOL> model_list . append ( { <EOL> '<STR_LIT>' : app_name , <EOL> '<STR_LIT>' : model . _meta . verbose_name , <EOL> '<STR_LIT>' : model . __name__ , <EOL> '<STR_LIT>' : model , <EOL> '<STR_LIT>' : fields <EOL> } ) <EOL> return model_list <EOL> def get_custom_app_models ( app_name = None ) : <EOL> if app_name : <EOL> ", "gt": "return get_model_from_app ( app_name )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> ", "gt": "if parent :"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) <EOL> else : <EOL> nested_dict [ target_key ] = new_value <EOL> return nested_dict <EOL> def __handle_crud ( self ) : <EOL> result = self . __get_field_attribute ( ) <EOL> columns = dict ( ) <EOL> for item in result : <EOL> key = item . get ( '<STR_LIT>' ) <EOL> title = item . get ( '<STR_LIT>' ) <EOL> type = item . get ( '<STR_LIT>' ) <EOL> columns [ key ] = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : key , <EOL> \"<STR_LIT>\" : type <EOL> } <EOL> if self . custom_crud_json and isinstance ( self . custom_crud_json , dict ) : <EOL> ", "gt": "columns = columns | self . custom_crud_json"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> ", "gt": "if instance is None :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_name ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_user_id ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> ", "gt": "return getattr ( self . request . user , \"<STR_LIT>\" , None )"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> ", "gt": "page = self . paginate_queryset ( queryset )"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> ", "gt": "new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> var_name = body . get ( '<STR_LIT>' , None ) <EOL> table = body . get ( '<STR_LIT>' , None ) <EOL> instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> relation_id = body . get ( '<STR_LIT>' , None ) <EOL> relationIds = [ ] <EOL> if relation_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = [ relation_id ] <EOL> elif instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = relation_id . split ( '<STR_LIT>' ) <EOL> queryset = SystemConfig . objects . filter ( value__in = relationIds ) . first ( ) <EOL> if queryset is None : <EOL> ", "gt": "return ErrorResponse ( msg = \"<STR_LIT>\" )"}
{"input": "import logging <EOL> from django . core . management . base import BaseCommand <EOL> from application import settings <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> nargs = \"<STR_LIT>\" , <EOL> type = str , <EOL> ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> def handle ( self , * args , ** options ) : <EOL> reset = False <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = True <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = False <EOL> ", "gt": "for app in settings . INSTALLED_APPS :"}
{"input": "import functools <EOL> import os <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from django . conf import settings <EOL> from celery import platforms <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from tenant_schemas_celery . app import CeleryApp as TenantAwareCeleryApp <EOL> app = TenantAwareCeleryApp ( ) <EOL> else : <EOL> from celery import Celery <EOL> app = Celery ( f\"<STR_LIT>\" ) <EOL> app . config_from_object ( '<STR_LIT>' ) <EOL> app . autodiscover_tasks ( lambda : settings . INSTALLED_APPS ) <EOL> platforms . C_FORCE_ROOT = True <EOL> def retry_base_task_error ( ) : <EOL> def wraps ( func ) : <EOL> @ app . task ( bind = True , retry_delay = <NUM_LIT> , max_retries = <NUM_LIT> ) <EOL> @ functools . wraps ( func ) <EOL> def wrapper ( self , * args , ** kwargs ) : <EOL> try : <EOL> return func ( * args , ** kwargs ) <EOL> ", "gt": "except Exception as exc :"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import MenuButton , RoleMenuButtonPermission <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuButtonSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuButton . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuButtonSerializer <EOL> create_serializer_class = MenuButtonCreateUpdateSerializer <EOL> update_serializer_class = MenuButtonCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) . order_by ( '<STR_LIT>' ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( serializer . data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> ", "gt": "def menu_button_all_permission ( self , request ) :"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> ", "gt": "\"<STR_LIT>\" : item . _meta . verbose_name ,"}
{"input": "from rest_framework . response import Response <EOL> class SuccessResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , page = <NUM_LIT> , limit = <NUM_LIT> , total = <NUM_LIT> ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : page , <EOL> \"<STR_LIT>\" : limit , <EOL> \"<STR_LIT>\" : total , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class DetailResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class ErrorResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , code = <NUM_LIT> , status = None , template_name = None , headers = None , <EOL> ", "gt": "exception = False , content_type = None ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MenuButtonPermissionSerializer ( CustomModelSerializer ) : <EOL> isCheck = serializers . SerializerMethodField ( ) <EOL> def get_isCheck ( self , instance ) : <EOL> ", "gt": "is_superuser = self . request . user . is_superuser"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> ", "gt": "if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> ", "gt": "return queryset"}
{"input": "import os <EOL> import sys <EOL> def main ( ) : <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> from django . core . management import execute_from_command_line <EOL> except ImportError as exc : <EOL> raise ImportError ( <EOL> \"<STR_LIT>\" <EOL> ", "gt": "\"<STR_LIT>\""}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> ", "gt": "queryset = self . queryset . filter ( status = <NUM_LIT> )"}
{"input": "from django . urls import path <EOL> from rest_framework import routers <EOL> from dvadmin . system . views . api_white_list import ApiWhiteListViewSet <EOL> from dvadmin . system . views . area import AreaViewSet <EOL> from dvadmin . system . views . clause import PrivacyView , TermsServiceView <EOL> from dvadmin . system . views . dept import DeptViewSet <EOL> from dvadmin . system . views . dictionary import DictionaryViewSet <EOL> from dvadmin . system . views . file_list import FileViewSet <EOL> from dvadmin . system . views . login_log import LoginLogViewSet <EOL> from dvadmin . system . views . menu import MenuViewSet <EOL> from dvadmin . system . views . menu_button import MenuButtonViewSet <EOL> from dvadmin . system . views . message_center import MessageCenterViewSet <EOL> from dvadmin . system . views . operation_log import OperationLogViewSet <EOL> from dvadmin . system . views . role import RoleViewSet <EOL> from dvadmin . system . views . role_menu import RoleMenuPermissionViewSet <EOL> from dvadmin . system . views . role_menu_button_permission import RoleMenuButtonPermissionViewSet <EOL> from dvadmin . system . views . system_config import SystemConfigViewSet <EOL> from dvadmin . system . views . user import UserViewSet <EOL> from dvadmin . system . views . menu_field import MenuFieldViewSet <EOL> system_url = routers . SimpleRouter ( ) <EOL> system_url . register ( r'<STR_LIT>' , MenuViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuButtonViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DeptViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , UserViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , OperationLogViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DictionaryViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , AreaViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , FileViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , ApiWhiteListViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , SystemConfigViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MessageCenterViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuButtonPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuFieldViewSet ) <EOL> urlpatterns = [ <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , } ) ) , <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , LoginLogViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , LoginLogViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , DeptViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> ", "gt": "path ( '<STR_LIT>' , PrivacyView . as_view ( ) ) ,"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> ", "gt": "if self . enable :"}
{"input": "from functools import wraps <EOL> from django . db . models import Func , F , OuterRef , Exists <EOL> from django . test import TestCase <EOL> import django <EOL> import os <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . system . models import Menu , RoleMenuPermission , RoleMenuButtonPermission , MenuButton <EOL> import time <EOL> def timing_decorator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = func ( * args , ** kwargs ) <EOL> end_time = time . time ( ) <EOL> run_time = end_time - start_time <EOL> print ( f\"<STR_LIT>\" ) <EOL> return result <EOL> return wrapper <EOL> @ timing_decorator <EOL> def getMenu ( ) : <EOL> data = [ ] <EOL> queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> for item in queryset : <EOL> parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) <EOL> names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] <EOL> completeName = \"<STR_LIT>\" . join ( names ) <EOL> isCheck = RoleMenuPermission . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> role__id = <NUM_LIT> , <EOL> ) . exists ( ) <EOL> mbCheck = RoleMenuButtonPermission . objects . filter ( <EOL> menu_button = OuterRef ( \"<STR_LIT>\" ) , <EOL> role__id = <NUM_LIT> , <EOL> ) <EOL> btns = MenuButton . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> ) . annotate ( isCheck = Exists ( mbCheck ) ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , data_range = F ( '<STR_LIT>' ) ) <EOL> dicts = { <EOL> '<STR_LIT>' : completeName , <EOL> '<STR_LIT>' : item [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : isCheck , <EOL> ", "gt": "'<STR_LIT>' : btns"}
{"input": "import logging <EOL> from django . core . management . base import BaseCommand <EOL> from application import settings <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> nargs = \"<STR_LIT>\" , <EOL> type = str , <EOL> ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> def handle ( self , * args , ** options ) : <EOL> reset = False <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = True <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = False <EOL> for app in settings . INSTALLED_APPS : <EOL> ", "gt": "try :"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> ", "gt": "if target_type in [ <NUM_LIT> ] :"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> ", "gt": "if self . methods == '<STR_LIT>' or request . method in self . methods :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> next_menu = Dept . objects . filter ( sort__gt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if next_menu : <EOL> next_menu . sort , dept . sort = dept . sort , next_menu . sort <EOL> next_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def dept_info ( self , request ) : <EOL> def inner ( did , li ) : <EOL> sub = Dept . objects . filter ( parent_id = did ) <EOL> if not sub . exists ( ) : <EOL> return li <EOL> ", "gt": "for i in sub :"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = self . get_serializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def update ( self , request , * args , ** kwargs ) : <EOL> partial = kwargs . pop ( '<STR_LIT>' , False ) <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance , data = request . data , request = request , partial = partial ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_update ( serializer ) <EOL> if getattr ( instance , '<STR_LIT>' , None ) : <EOL> instance . _prefetched_objects_cache = { } <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def destroy ( self , request , * args , ** kwargs ) : <EOL> ", "gt": "instance = self . get_object ( )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_name ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_user_id ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> @ property <EOL> ", "gt": "def errors ( self ) :"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> ", "gt": "serializer_class = LoginSerializer"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> ", "gt": "}"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> if not getattr ( settings , \"<STR_LIT>\" , False ) : <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginTokenView ( TokenObtainPairView ) : <EOL> serializer_class = LoginTokenSerializer <EOL> permission_classes = [ ] <EOL> class LogoutView ( APIView ) : <EOL> def post ( self , request ) : <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> class ApiLoginSerializer ( CustomModelSerializer ) : <EOL> username = serializers . CharField ( ) <EOL> password = serializers . CharField ( ) <EOL> class Meta : <EOL> model = Users <EOL> fields = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class ApiLogin ( APIView ) : <EOL> serializer_class = ApiLoginSerializer <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def post ( self , request ) : <EOL> username = request . data . get ( \"<STR_LIT>\" ) <EOL> password = request . data . get ( \"<STR_LIT>\" ) <EOL> user_obj = auth . authenticate ( <EOL> request , <EOL> ", "gt": "username = username ,"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> ", "gt": "def update ( self , instance , validated_data ) :"}
{"input": "from dvadmin . system . models import ApiWhiteList <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class ApiWhiteListSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = ApiWhiteList <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class ApiWhiteListViewSet ( CustomModelViewSet ) : <EOL> queryset = ApiWhiteList . objects . all ( ) <EOL> ", "gt": "serializer_class = ApiWhiteListSerializer"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> ", "gt": "if not user . is_active :"}
{"input": "import os <EOL> import django <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . utils . core_initialize import CoreInitialize <EOL> from dvadmin . system . fixtures . initSerializer import ( <EOL> UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , <EOL> MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , <EOL> SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> ) <EOL> class Initialize ( CoreInitialize ) : <EOL> def init_dept ( self ) : <EOL> self . init_base ( DeptInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role ( self ) : <EOL> self . init_base ( RoleInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_users ( self ) : <EOL> self . init_base ( UsersInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_menu ( self ) : <EOL> self . init_base ( MenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu ( self ) : <EOL> self . init_base ( RoleMenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu_button ( self ) : <EOL> self . init_base ( RoleMenuButtonInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_api_white_list ( self ) : <EOL> self . init_base ( ApiWhiteListInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def init_dictionary ( self ) : <EOL> self . init_base ( DictionaryInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> ", "gt": "def init_system_config ( self ) :"}
{"input": "import logging <EOL> from django . core . management . base import BaseCommand <EOL> from application import settings <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> nargs = \"<STR_LIT>\" , <EOL> type = str , <EOL> ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> def handle ( self , * args , ** options ) : <EOL> reset = False <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = True <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = False <EOL> for app in settings . INSTALLED_APPS : <EOL> try : <EOL> exec ( <EOL> ) <EOL> except ModuleNotFoundError : <EOL> try : <EOL> exec ( <EOL> ) <EOL> ", "gt": "except ModuleNotFoundError :"}
{"input": "import os <EOL> import django <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . utils . core_initialize import CoreInitialize <EOL> from dvadmin . system . fixtures . initSerializer import ( <EOL> UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , <EOL> MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , <EOL> SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> ) <EOL> class Initialize ( CoreInitialize ) : <EOL> def init_dept ( self ) : <EOL> self . init_base ( DeptInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role ( self ) : <EOL> self . init_base ( RoleInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_users ( self ) : <EOL> self . init_base ( UsersInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_menu ( self ) : <EOL> self . init_base ( MenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu ( self ) : <EOL> self . init_base ( RoleMenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu_button ( self ) : <EOL> self . init_base ( RoleMenuButtonInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_api_white_list ( self ) : <EOL> self . init_base ( ApiWhiteListInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def init_dictionary ( self ) : <EOL> self . init_base ( DictionaryInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def init_system_config ( self ) : <EOL> self . init_base ( SystemConfigInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def run ( self ) : <EOL> self . init_dept ( ) <EOL> self . init_role ( ) <EOL> self . init_users ( ) <EOL> self . init_menu ( ) <EOL> self . init_role_menu ( ) <EOL> self . init_role_menu_button ( ) <EOL> ", "gt": "self . init_api_white_list ( )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> ", "gt": "model = Menu"}
{"input": "import multiprocessing <EOL> workers = multiprocessing . cpu_count ( ) * <NUM_LIT> + <NUM_LIT> <EOL> threads = <NUM_LIT> <EOL> bind = '<STR_LIT>' <EOL> daemon = '<STR_LIT>' <EOL> worker_class = '<STR_LIT>' <EOL> worker_connections = <NUM_LIT> <EOL> max_requests = <NUM_LIT> <EOL> max_requests_jitter = <NUM_LIT> <EOL> pidfile = '<STR_LIT>' <EOL> loglevel = '<STR_LIT>' <EOL> access_log_format = '<STR_LIT>' <EOL> backlog = <NUM_LIT> <EOL> proc_name = '<STR_LIT>' <EOL> timeout = <NUM_LIT> <EOL> graceful_timeout = <NUM_LIT> <EOL> ", "gt": "keepalive = <NUM_LIT>"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> ", "gt": "\"<STR_LIT>\" : user"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> ", "gt": "continue"}
{"input": "import os <EOL> from application . settings import BASE_DIR <EOL> DATABASE_ENGINE = \"<STR_LIT>\" <EOL> DATABASE_NAME = '<STR_LIT>' <EOL> DATABASE_HOST = '<STR_LIT>' <EOL> DATABASE_PORT = <NUM_LIT> <EOL> DATABASE_USER = \"<STR_LIT>\" <EOL> DATABASE_PASSWORD = \"<STR_LIT>\" <EOL> TABLE_PREFIX = \"<STR_LIT>\" <EOL> REDIS_PASSWORD = '<STR_LIT>' <EOL> REDIS_HOST = '<STR_LIT>' <EOL> ", "gt": "REDIS_URL = f'<STR_LIT>'"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> ", "gt": "if getattr ( self . request , \"<STR_LIT>\" , None ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> return queryset <EOL> else : <EOL> return self . queryset <EOL> class InitDictionaryViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> queryset = Dictionary . objects . all ( ) <EOL> def get ( self , request ) : <EOL> dictionary_key = self . request . query_params . get ( '<STR_LIT>' ) <EOL> if dictionary_key : <EOL> if dictionary_key == '<STR_LIT>' : <EOL> data = [ ele for ele in dispatch . get_dictionary_config ( ) . values ( ) ] <EOL> if not data : <EOL> dispatch . refresh_dictionary ( ) <EOL> data = [ ele for ele in dispatch . get_dictionary_config ( ) . values ( ) ] <EOL> else : <EOL> data = self . queryset . filter ( parent__value = dictionary_key , status = True ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> return SuccessResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> ", "gt": "return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" )"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( \"<STR_LIT>\" , include ( \"<STR_LIT>\" ) ) , <EOL> path ( \"<STR_LIT>\" , LoginView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , LogoutView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , TokenRefreshView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> re_path ( <EOL> r\"<STR_LIT>\" , include ( \"<STR_LIT>\" , namespace = \"<STR_LIT>\" ) <EOL> ) , <EOL> path ( \"<STR_LIT>\" , CaptchaView . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitDictionaryViewSet . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitSettingsViewSet . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , ApiLogin . as_view ( ) ) , <EOL> ", "gt": "path ( \"<STR_LIT>\" , LoginTokenView . as_view ( ) ) ,"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> ", "gt": "and validated_data . get ( self . dept_belong_id_field_name , None ) is None"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> pass <EOL> return model if model else \"<STR_LIT>\" <EOL> def get_ip_analysis ( ip ) : <EOL> data = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) <EOL> else : <EOL> nested_dict [ target_key ] = new_value <EOL> return nested_dict <EOL> def __handle_crud ( self ) : <EOL> result = self . __get_field_attribute ( ) <EOL> columns = dict ( ) <EOL> for item in result : <EOL> key = item . get ( '<STR_LIT>' ) <EOL> title = item . get ( '<STR_LIT>' ) <EOL> type = item . get ( '<STR_LIT>' ) <EOL> columns [ key ] = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : key , <EOL> \"<STR_LIT>\" : type <EOL> } <EOL> if self . custom_crud_json and isinstance ( self . custom_crud_json , dict ) : <EOL> columns = columns | self . custom_crud_json <EOL> if self . crud_update_key_value and isinstance ( self . crud_update_key_value , dict ) : <EOL> for key , value in self . crud_update_key_value . items ( ) : <EOL> columns = self . __update_nested_dict ( columns , key , value ) <EOL> return columns <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ AllowAny ] ) <EOL> ", "gt": "def init_crud ( self , request ) :"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . method == \"<STR_LIT>\" : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return self . readiness ( request ) <EOL> elif request . path == \"<STR_LIT>\" : <EOL> return self . healthz ( request ) <EOL> return self . get_response ( request ) <EOL> def healthz ( self , request ) : <EOL> return HttpResponse ( \"<STR_LIT>\" ) <EOL> def readiness ( self , request ) : <EOL> try : <EOL> from django . db import connections <EOL> for name in connections : <EOL> cursor = connections [ name ] . cursor ( ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> row = cursor . fetchone ( ) <EOL> if row is None : <EOL> return HttpResponseServerError ( \"<STR_LIT>\" ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return HttpResponseServerError ( \"<STR_LIT>\" ) <EOL> try : <EOL> from django . core . cache import caches <EOL> ", "gt": "from django . core . cache . backends . memcached import BaseMemcachedCache"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> pass <EOL> return model if model else \"<STR_LIT>\" <EOL> def get_ip_analysis ( ip ) : <EOL> data = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "import os <EOL> import django <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . utils . core_initialize import CoreInitialize <EOL> from dvadmin . system . fixtures . initSerializer import ( <EOL> UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , <EOL> MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , <EOL> SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> ) <EOL> class Initialize ( CoreInitialize ) : <EOL> def init_dept ( self ) : <EOL> self . init_base ( DeptInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role ( self ) : <EOL> self . init_base ( RoleInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_users ( self ) : <EOL> self . init_base ( UsersInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_menu ( self ) : <EOL> self . init_base ( MenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu ( self ) : <EOL> self . init_base ( RoleMenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu_button ( self ) : <EOL> ", "gt": "self . init_base ( RoleMenuButtonInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] )"}
{"input": "import hashlib <EOL> import random <EOL> CHAR_SET = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def random_str ( number = <NUM_LIT> ) : <EOL> result = \"<STR_LIT>\" <EOL> for i in range ( <NUM_LIT> , number ) : <EOL> inx = random . randint ( <NUM_LIT> , len ( CHAR_SET ) - <NUM_LIT> ) <EOL> result += CHAR_SET [ inx ] <EOL> return result <EOL> def has_md5 ( str , salt = '<STR_LIT>' ) : <EOL> str = str + salt <EOL> ", "gt": "md = hashlib . md5 ( )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> ", "gt": "fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ]"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> ", "gt": "users = Users . objects . values_list ( '<STR_LIT>' , flat = True )"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> pass <EOL> return model if model else \"<STR_LIT>\" <EOL> def get_ip_analysis ( ip ) : <EOL> ", "gt": "data = {"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> ", "gt": "if finded is False :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> ", "gt": "return DetailResponse ( data = data , msg = \"<STR_LIT>\" )"}
{"input": "from django . db import DataError <EOL> from rest_framework . exceptions import APIException <EOL> from rest_framework . validators import UniqueValidator <EOL> class CustomValidationError ( APIException ) : <EOL> def __init__ ( self , detail ) : <EOL> self . detail = detail <EOL> def qs_exists ( queryset ) : <EOL> try : <EOL> return queryset . exists ( ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return False <EOL> def qs_filter ( queryset , ** kwargs ) : <EOL> try : <EOL> return queryset . filter ( ** kwargs ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return queryset . none ( ) <EOL> class CustomUniqueValidator ( UniqueValidator ) : <EOL> def filter_queryset ( self , value , queryset , field_name ) : <EOL> filter_kwargs = { '<STR_LIT>' % ( field_name , self . lookup ) : value } <EOL> return qs_filter ( queryset , ** filter_kwargs ) <EOL> def exclude_current_instance ( self , queryset , instance ) : <EOL> if instance is not None : <EOL> ", "gt": "return queryset . exclude ( pk = instance . pk )"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterViewSet ( CustomModelViewSet ) : <EOL> queryset = MessageCenter . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MessageCenterSerializer <EOL> create_serializer_class = MessageCenterCreateSerializer <EOL> extra_filter_backends = [ ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> return MessageCenter . objects . filter ( creator = self . request . user . id ) . all ( ) <EOL> return MessageCenter . objects . all ( ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> pk = kwargs . get ( '<STR_LIT>' ) <EOL> user_id = self . request . user . id <EOL> ", "gt": "queryset = MessageCenterTargetUser . objects . filter ( users__id = user_id , messagecenter__id = pk ) . first ( )"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> elif value_type == '<STR_LIT>' : <EOL> ", "gt": "cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' )"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> ", "gt": "validated_data [ '<STR_LIT>' ] = file"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> if not getattr ( settings , \"<STR_LIT>\" , False ) : <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> ", "gt": "data = super ( ) . validate ( attrs )"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> ", "gt": "index : int = - <NUM_LIT> ) -> tuple :"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> elif value_type == '<STR_LIT>' : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) <EOL> else : <EOL> if type ( cell_value ) is float and str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] == \"<STR_LIT>\" : <EOL> cell_value = int ( str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ) <EOL> elif type ( cell_value ) is str : <EOL> cell_value = cell_value . strip ( \"<STR_LIT>\" ) <EOL> ", "gt": "if key in validation_data_dict :"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> ", "gt": "def __init__ ( self , get_response ) :"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . method == \"<STR_LIT>\" : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return self . readiness ( request ) <EOL> elif request . path == \"<STR_LIT>\" : <EOL> return self . healthz ( request ) <EOL> return self . get_response ( request ) <EOL> def healthz ( self , request ) : <EOL> return HttpResponse ( \"<STR_LIT>\" ) <EOL> def readiness ( self , request ) : <EOL> try : <EOL> from django . db import connections <EOL> for name in connections : <EOL> cursor = connections [ name ] . cursor ( ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> row = cursor . fetchone ( ) <EOL> if row is None : <EOL> return HttpResponseServerError ( \"<STR_LIT>\" ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> ", "gt": "return HttpResponseServerError ( \"<STR_LIT>\" )"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> ", "gt": "path ("}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> ", "gt": "else :"}
{"input": "import hashlib <EOL> import logging <EOL> from django . contrib . auth import get_user_model <EOL> from django . contrib . auth . backends import ModelBackend <EOL> from django . contrib . auth . hashers import check_password <EOL> from django . utils import timezone <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> logger = logging . getLogger ( __name__ ) <EOL> UserModel = get_user_model ( ) <EOL> class CustomBackend ( ModelBackend ) : <EOL> def authenticate ( self , request , username = None , password = None , ** kwargs ) : <EOL> msg = '<STR_LIT>' % username <EOL> logger . info ( msg ) <EOL> if username is None : <EOL> username = kwargs . get ( UserModel . USERNAME_FIELD ) <EOL> try : <EOL> user = UserModel . _default_manager . get_by_natural_key ( username ) <EOL> except UserModel . DoesNotExist : <EOL> UserModel ( ) . set_password ( password ) <EOL> else : <EOL> verify_password = check_password ( password , user . password ) <EOL> if not verify_password : <EOL> password = hashlib . md5 ( password . encode ( encoding = '<STR_LIT>' ) ) . hexdigest ( ) <EOL> verify_password = check_password ( password , user . password ) <EOL> if verify_password : <EOL> ", "gt": "if self . user_can_authenticate ( user ) :"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> class FieldPermissionMixin : <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def field_permission ( self , request ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is self . serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded : <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> user = request . user <EOL> if user . is_superuser == <NUM_LIT> : <EOL> data = MenuField . objects . filter ( model = model [ '<STR_LIT>' ] ) . values ( '<STR_LIT>' ) <EOL> for item in data : <EOL> item [ '<STR_LIT>' ] = True <EOL> item [ '<STR_LIT>' ] = True <EOL> item [ '<STR_LIT>' ] = True <EOL> else : <EOL> roles = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data = FieldPermission . objects . filter ( <EOL> ", "gt": "field__model = model [ '<STR_LIT>' ] , role__in = roles"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> ", "gt": "self . instance , self . modifier_field_id , self . get_request_user_id ( )"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> target_role = None , message : dict = None , request = Request ) : <EOL> if message is None : <EOL> message = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> if target_role is None : <EOL> target_role = [ ] <EOL> if target_dept is None : <EOL> target_dept = [ ] <EOL> data = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : content , <EOL> \"<STR_LIT>\" : target_type , <EOL> \"<STR_LIT>\" : target_user , <EOL> \"<STR_LIT>\" : target_dept , <EOL> \"<STR_LIT>\" : target_role <EOL> } <EOL> message_center_instance = MessageCreateSerializer ( data = data , request = request ) <EOL> message_center_instance . is_valid ( raise_exception = True ) <EOL> message_center_instance . save ( ) <EOL> users = target_user or [ ] <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : message_center_instance . instance . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> ", "gt": "for user in users :"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> ", "gt": "name = \"<STR_LIT>\" ,"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_name ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_user_id ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> @ property <EOL> def errors ( self ) : <EOL> ", "gt": "errors = super ( ) . errors"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) <EOL> else : <EOL> nested_dict [ target_key ] = new_value <EOL> return nested_dict <EOL> def __handle_crud ( self ) : <EOL> result = self . __get_field_attribute ( ) <EOL> columns = dict ( ) <EOL> for item in result : <EOL> key = item . get ( '<STR_LIT>' ) <EOL> title = item . get ( '<STR_LIT>' ) <EOL> type = item . get ( '<STR_LIT>' ) <EOL> columns [ key ] = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : key , <EOL> \"<STR_LIT>\" : type <EOL> } <EOL> if self . custom_crud_json and isinstance ( self . custom_crud_json , dict ) : <EOL> columns = columns | self . custom_crud_json <EOL> if self . crud_update_key_value and isinstance ( self . crud_update_key_value , dict ) : <EOL> for key , value in self . crud_update_key_value . items ( ) : <EOL> columns = self . __update_nested_dict ( columns , key , value ) <EOL> return columns <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ AllowAny ] ) <EOL> def init_crud ( self , request ) : <EOL> self . permission_classes = [ AllowAny ] <EOL> ", "gt": "columns = self . __handle_crud ( )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> ", "gt": "dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True )"}
{"input": "from django . db import DataError <EOL> from rest_framework . exceptions import APIException <EOL> from rest_framework . validators import UniqueValidator <EOL> class CustomValidationError ( APIException ) : <EOL> def __init__ ( self , detail ) : <EOL> self . detail = detail <EOL> def qs_exists ( queryset ) : <EOL> try : <EOL> return queryset . exists ( ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return False <EOL> def qs_filter ( queryset , ** kwargs ) : <EOL> try : <EOL> return queryset . filter ( ** kwargs ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return queryset . none ( ) <EOL> class CustomUniqueValidator ( UniqueValidator ) : <EOL> def filter_queryset ( self , value , queryset , field_name ) : <EOL> filter_kwargs = { '<STR_LIT>' % ( field_name , self . lookup ) : value } <EOL> return qs_filter ( queryset , ** filter_kwargs ) <EOL> def exclude_current_instance ( self , queryset , instance ) : <EOL> if instance is not None : <EOL> return queryset . exclude ( pk = instance . pk ) <EOL> return queryset <EOL> def __call__ ( self , value , serializer_field ) : <EOL> field_name = serializer_field . source_attrs [ - <NUM_LIT> ] <EOL> instance = getattr ( serializer_field . parent , '<STR_LIT>' , None ) <EOL> queryset = self . queryset <EOL> queryset = self . filter_queryset ( value , queryset , field_name ) <EOL> queryset = self . exclude_current_instance ( queryset , instance ) <EOL> if qs_exists ( queryset ) : <EOL> raise CustomValidationError ( self . message ) <EOL> def __repr__ ( self ) : <EOL> ", "gt": "return super ( ) . __repr__ ( )"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> ", "gt": "self . image_code and self . image_code . delete ( )"}
{"input": "from drf_yasg . generators import OpenAPISchemaGenerator <EOL> from drf_yasg . inspectors import SwaggerAutoSchema <EOL> from application . settings import SWAGGER_SETTINGS <EOL> def get_summary ( string ) : <EOL> if string is not None : <EOL> result = string . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) <EOL> return result [ <NUM_LIT> ] <EOL> class CustomSwaggerAutoSchema ( SwaggerAutoSchema ) : <EOL> def get_tags ( self , operation_keys = None ) : <EOL> tags = super ( ) . get_tags ( operation_keys ) <EOL> if \"<STR_LIT>\" in tags and operation_keys : <EOL> tags [ <NUM_LIT> ] = operation_keys [ SWAGGER_SETTINGS . get ( '<STR_LIT>' , <NUM_LIT> ) ] <EOL> return tags <EOL> def get_summary_and_description ( self ) : <EOL> summary_and_description = super ( ) . get_summary_and_description ( ) <EOL> summary = get_summary ( self . __dict__ . get ( '<STR_LIT>' ) . __doc__ ) <EOL> ", "gt": "description = summary_and_description [ <NUM_LIT> ]"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> ", "gt": "user = request . user"}
{"input": "import logging <EOL> from django . core . management . base import BaseCommand <EOL> from application import settings <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> nargs = \"<STR_LIT>\" , <EOL> type = str , <EOL> ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> def handle ( self , * args , ** options ) : <EOL> reset = False <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = True <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = False <EOL> for app in settings . INSTALLED_APPS : <EOL> try : <EOL> exec ( <EOL> ) <EOL> except ModuleNotFoundError : <EOL> try : <EOL> ", "gt": "exec ("}
{"input": "import functools <EOL> import os <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from django . conf import settings <EOL> from celery import platforms <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from tenant_schemas_celery . app import CeleryApp as TenantAwareCeleryApp <EOL> app = TenantAwareCeleryApp ( ) <EOL> else : <EOL> from celery import Celery <EOL> app = Celery ( f\"<STR_LIT>\" ) <EOL> app . config_from_object ( '<STR_LIT>' ) <EOL> app . autodiscover_tasks ( lambda : settings . INSTALLED_APPS ) <EOL> platforms . C_FORCE_ROOT = True <EOL> def retry_base_task_error ( ) : <EOL> def wraps ( func ) : <EOL> @ app . task ( bind = True , retry_delay = <NUM_LIT> , max_retries = <NUM_LIT> ) <EOL> @ functools . wraps ( func ) <EOL> def wrapper ( self , * args , ** kwargs ) : <EOL> try : <EOL> return func ( * args , ** kwargs ) <EOL> except Exception as exc : <EOL> raise self . retry ( exc = exc ) <EOL> ", "gt": "return wrapper"}
{"input": "import functools <EOL> import os <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from django . conf import settings <EOL> from celery import platforms <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from tenant_schemas_celery . app import CeleryApp as TenantAwareCeleryApp <EOL> app = TenantAwareCeleryApp ( ) <EOL> else : <EOL> from celery import Celery <EOL> app = Celery ( f\"<STR_LIT>\" ) <EOL> app . config_from_object ( '<STR_LIT>' ) <EOL> app . autodiscover_tasks ( lambda : settings . INSTALLED_APPS ) <EOL> platforms . C_FORCE_ROOT = True <EOL> def retry_base_task_error ( ) : <EOL> def wraps ( func ) : <EOL> @ app . task ( bind = True , retry_delay = <NUM_LIT> , max_retries = <NUM_LIT> ) <EOL> @ functools . wraps ( func ) <EOL> ", "gt": "def wrapper ( self , * args , ** kwargs ) :"}
{"input": "import os <EOL> import sys <EOL> def main ( ) : <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> from django . core . management import execute_from_command_line <EOL> except ImportError as exc : <EOL> raise ImportError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) from exc <EOL> execute_from_command_line ( sys . argv ) <EOL> ", "gt": "if __name__ == '<STR_LIT>' :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> ", "gt": "previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_name ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_user_id ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> @ property <EOL> def errors ( self ) : <EOL> errors = super ( ) . errors <EOL> verbose_errors = { } <EOL> fields = { field . name : field . verbose_name for field in <EOL> ", "gt": "self . Meta . model . _meta . get_fields ( ) if hasattr ( field , '<STR_LIT>' ) }"}
{"input": "from django . db . models import Q <EOL> from rest_framework import serializers <EOL> from dvadmin . system . models import Area <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class AreaSerializer ( CustomModelSerializer ) : <EOL> pcode_count = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_pcode_count ( self , instance : Area ) : <EOL> return Area . objects . filter ( pcode = instance ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Area . objects . filter ( pcode = instance . code ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Area <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class AreaCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Area <EOL> fields = '<STR_LIT>' <EOL> class AreaViewSet ( CustomModelViewSet ) : <EOL> queryset = Area . objects . all ( ) <EOL> serializer_class = AreaSerializer <EOL> extra_filter_class = [ ] <EOL> def get_queryset ( self ) : <EOL> self . request . query_params . _mutable = True <EOL> params = self . request . query_params <EOL> ", "gt": "pcode = params . get ( '<STR_LIT>' , None )"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ", "gt": ") ,"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . method == \"<STR_LIT>\" : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return self . readiness ( request ) <EOL> elif request . path == \"<STR_LIT>\" : <EOL> ", "gt": "return self . healthz ( request )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> ", "gt": "try :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> ", "gt": "@ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] )"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> ", "gt": "var_name = body . get ( '<STR_LIT>' , None )"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( \"<STR_LIT>\" , include ( \"<STR_LIT>\" ) ) , <EOL> path ( \"<STR_LIT>\" , LoginView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , LogoutView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , TokenRefreshView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> re_path ( <EOL> r\"<STR_LIT>\" , include ( \"<STR_LIT>\" , namespace = \"<STR_LIT>\" ) <EOL> ) , <EOL> path ( \"<STR_LIT>\" , CaptchaView . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitDictionaryViewSet . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitSettingsViewSet . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , ApiLogin . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , LoginTokenView . as_view ( ) ) , <EOL> ] <EOL> + static ( settings . MEDIA_URL , document_root = settings . MEDIA_ROOT ) <EOL> + static ( settings . STATIC_URL , document_root = settings . STATIC_URL ) <EOL> + [ re_path ( ele . get ( '<STR_LIT>' ) , include ( ele . get ( '<STR_LIT>' ) ) ) for ele in settings . PLUGINS_URL_PATTERNS ] <EOL> ", "gt": ")"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> ", "gt": "{ '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json }"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> model_name = request . data . get ( '<STR_LIT>' ) <EOL> if not menu_id or not model_name : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] != model_name : <EOL> continue <EOL> for field in model [ '<STR_LIT>' ] : <EOL> if MenuField . objects . filter ( <EOL> menu_id = menu_id , model = model_name , field_name = field [ '<STR_LIT>' ] <EOL> ) . exists ( ) : <EOL> continue <EOL> data = { <EOL> '<STR_LIT>' : menu_id , <EOL> '<STR_LIT>' : model_name , <EOL> '<STR_LIT>' : field [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : str ( field [ '<STR_LIT>' ] ) , <EOL> } <EOL> serializer = self . get_serializer ( data = data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> ", "gt": "return SuccessResponse ( msg = '<STR_LIT>' )"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> ", "gt": "def __update_nested_dict ( self , nested_dict : dict ,"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = self . get_serializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def update ( self , request , * args , ** kwargs ) : <EOL> partial = kwargs . pop ( '<STR_LIT>' , False ) <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance , data = request . data , request = request , partial = partial ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_update ( serializer ) <EOL> if getattr ( instance , '<STR_LIT>' , None ) : <EOL> instance . _prefetched_objects_cache = { } <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def destroy ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> instance . delete ( ) <EOL> return DetailResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> keys = openapi . Schema ( description = '<STR_LIT>' , type = openapi . TYPE_ARRAY , items = openapi . TYPE_STRING ) <EOL> @ swagger_auto_schema ( request_body = openapi . Schema ( <EOL> type = openapi . TYPE_OBJECT , <EOL> required = [ '<STR_LIT>' ] , <EOL> properties = { '<STR_LIT>' : keys } <EOL> ) , operation_summary = '<STR_LIT>' ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def multiple_delete ( self , request , * args , ** kwargs ) : <EOL> request_data = request . data <EOL> keys = request_data . get ( '<STR_LIT>' , None ) <EOL> if keys : <EOL> self . get_queryset ( ) . filter ( id__in = keys ) . delete ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> else : <EOL> ", "gt": "return ErrorResponse ( msg = \"<STR_LIT>\" )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> ", "gt": "else :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> ", "gt": "def move_up ( self , request ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> ", "gt": "class Meta :"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> ", "gt": "if isinstance ( dct_ , dict ) :"}
{"input": "import os <EOL> from channels . auth import AuthMiddlewareStack <EOL> from channels . security . websocket import AllowedHostsOriginValidator <EOL> from channels . routing import ProtocolTypeRouter , URLRouter <EOL> from django . core . asgi import get_asgi_application <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> http_application = get_asgi_application ( ) <EOL> from application . routing import websocket_urlpatterns <EOL> application = ProtocolTypeRouter ( { <EOL> \"<STR_LIT>\" : http_application , <EOL> '<STR_LIT>' : AllowedHostsOriginValidator ( <EOL> AuthMiddlewareStack ( <EOL> URLRouter ( <EOL> websocket_urlpatterns <EOL> ) <EOL> ) <EOL> ", "gt": ") ,"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> queryset = self . queryset . filter ( status = <NUM_LIT> ) <EOL> else : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def get_all_menu ( self , request ) : <EOL> user = request . user <EOL> queryset = self . queryset . all ( ) <EOL> if not user . is_superuser : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def move_up ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> ", "gt": "menu = Menu . objects . get ( id = menu_id )"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> try : <EOL> request_user = self . request . user <EOL> validated_data [ '<STR_LIT>' ] = request_user . dept . id <EOL> ", "gt": "validated_data [ '<STR_LIT>' ] = request_user . id"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> ", "gt": "def web_router ( self , request ) :"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = self . get_serializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def update ( self , request , * args , ** kwargs ) : <EOL> partial = kwargs . pop ( '<STR_LIT>' , False ) <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance , data = request . data , request = request , partial = partial ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_update ( serializer ) <EOL> if getattr ( instance , '<STR_LIT>' , None ) : <EOL> instance . _prefetched_objects_cache = { } <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def destroy ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> instance . delete ( ) <EOL> return DetailResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> keys = openapi . Schema ( description = '<STR_LIT>' , type = openapi . TYPE_ARRAY , items = openapi . TYPE_STRING ) <EOL> @ swagger_auto_schema ( request_body = openapi . Schema ( <EOL> ", "gt": "type = openapi . TYPE_OBJECT ,"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ", "gt": "method = methodList . index ( method )"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> ", "gt": "'<STR_LIT>' : model [ '<STR_LIT>' ] ,"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> target_role = None , message : dict = None , request = Request ) : <EOL> if message is None : <EOL> message = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> if target_role is None : <EOL> target_role = [ ] <EOL> if target_dept is None : <EOL> target_dept = [ ] <EOL> data = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : content , <EOL> \"<STR_LIT>\" : target_type , <EOL> \"<STR_LIT>\" : target_user , <EOL> \"<STR_LIT>\" : target_dept , <EOL> \"<STR_LIT>\" : target_role <EOL> } <EOL> message_center_instance = MessageCreateSerializer ( data = data , request = request ) <EOL> message_center_instance . is_valid ( raise_exception = True ) <EOL> message_center_instance . save ( ) <EOL> users = target_user or [ ] <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : message_center_instance . instance . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> username = \"<STR_LIT>\" + str ( user ) <EOL> unread_count = async_to_sync ( _get_message_unread ) ( user ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { ** message , '<STR_LIT>' : unread_count } <EOL> } <EOL> ", "gt": ")"}
{"input": "import hashlib <EOL> import logging <EOL> from django . contrib . auth import get_user_model <EOL> from django . contrib . auth . backends import ModelBackend <EOL> from django . contrib . auth . hashers import check_password <EOL> from django . utils import timezone <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> logger = logging . getLogger ( __name__ ) <EOL> UserModel = get_user_model ( ) <EOL> class CustomBackend ( ModelBackend ) : <EOL> def authenticate ( self , request , username = None , password = None , ** kwargs ) : <EOL> msg = '<STR_LIT>' % username <EOL> logger . info ( msg ) <EOL> if username is None : <EOL> username = kwargs . get ( UserModel . USERNAME_FIELD ) <EOL> ", "gt": "try :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> ", "gt": "serializer = MenuSerializer ( queryset , many = True , request = request )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> ", "gt": "data = serializer . data"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> ", "gt": "if cell_value is None or cell_value == '<STR_LIT>' :"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> pass <EOL> return model if model else \"<STR_LIT>\" <EOL> def get_ip_analysis ( ip ) : <EOL> data = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> if ip != '<STR_LIT>' and ip : <EOL> if getattr ( settings , '<STR_LIT>' , True ) : <EOL> try : <EOL> res = requests . get ( url = '<STR_LIT>' , params = { \"<STR_LIT>\" : ip } , timeout = <NUM_LIT> ) <EOL> if res . status_code == <NUM_LIT> : <EOL> res_data = res . json ( ) <EOL> if res_data . get ( '<STR_LIT>' ) == <NUM_LIT> : <EOL> data = res_data . get ( '<STR_LIT>' ) <EOL> ", "gt": "return data"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> ", "gt": "serializer = SystemConfigCreateSerializer ( instance_obj , data = data )"}
{"input": "import os <EOL> import sys <EOL> def main ( ) : <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> from django . core . management import execute_from_command_line <EOL> except ImportError as exc : <EOL> raise ImportError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) from exc <EOL> execute_from_command_line ( sys . argv ) <EOL> if __name__ == '<STR_LIT>' : <EOL> ", "gt": "main ( )"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> return settings . ALL_MODELS_OBJECTS [ model_name ] or { } <EOL> return settings . ALL_MODELS_OBJECTS or { } <EOL> def get_model_from_app ( app_name ) : <EOL> model_module = import_module ( app_name + '<STR_LIT>' ) <EOL> filter_model = [ <EOL> getattr ( model_module , item ) for item in dir ( model_module ) <EOL> if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) <EOL> ", "gt": "]"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> next_menu = Dept . objects . filter ( sort__gt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if next_menu : <EOL> next_menu . sort , dept . sort = dept . sort , next_menu . sort <EOL> next_menu . save ( ) <EOL> dept . save ( ) <EOL> ", "gt": "return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" )"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> ", "gt": "log . save ( )"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> if not getattr ( settings , \"<STR_LIT>\" , False ) : <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> ", "gt": "data [ \"<STR_LIT>\" ] = self . user . id"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ", "gt": ") ,"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MenuButtonPermissionSerializer ( CustomModelSerializer ) : <EOL> isCheck = serializers . SerializerMethodField ( ) <EOL> def get_isCheck ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> return True <EOL> else : <EOL> return MenuButton . objects . filter ( <EOL> menu__id = instance . id , <EOL> role__id__in = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) , <EOL> ) . exists ( ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = '<STR_LIT>' <EOL> ", "gt": "class RoleViewSet ( CustomModelViewSet , FastCrudMixin , FieldPermissionMixin ) :"}
{"input": "from django . db . models import Q <EOL> from rest_framework import serializers <EOL> from dvadmin . system . models import Area <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class AreaSerializer ( CustomModelSerializer ) : <EOL> pcode_count = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_pcode_count ( self , instance : Area ) : <EOL> return Area . objects . filter ( pcode = instance ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Area . objects . filter ( pcode = instance . code ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Area <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class AreaCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Area <EOL> fields = '<STR_LIT>' <EOL> class AreaViewSet ( CustomModelViewSet ) : <EOL> queryset = Area . objects . all ( ) <EOL> serializer_class = AreaSerializer <EOL> extra_filter_class = [ ] <EOL> def get_queryset ( self ) : <EOL> self . request . query_params . _mutable = True <EOL> params = self . request . query_params <EOL> pcode = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> ", "gt": "limit = params . get ( '<STR_LIT>' , None )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MenuButtonPermissionSerializer ( CustomModelSerializer ) : <EOL> isCheck = serializers . SerializerMethodField ( ) <EOL> def get_isCheck ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> return True <EOL> else : <EOL> return MenuButton . objects . filter ( <EOL> menu__id = instance . id , <EOL> role__id__in = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) , <EOL> ) . exists ( ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = '<STR_LIT>' <EOL> class RoleViewSet ( CustomModelViewSet , FastCrudMixin , FieldPermissionMixin ) : <EOL> ", "gt": "queryset = Role . objects . all ( )"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterViewSet ( CustomModelViewSet ) : <EOL> queryset = MessageCenter . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MessageCenterSerializer <EOL> create_serializer_class = MessageCenterCreateSerializer <EOL> extra_filter_backends = [ ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> return MessageCenter . objects . filter ( creator = self . request . user . id ) . all ( ) <EOL> return MessageCenter . objects . all ( ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> pk = kwargs . get ( '<STR_LIT>' ) <EOL> ", "gt": "user_id = self . request . user . id"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> try : <EOL> request_user = self . request . user <EOL> validated_data [ '<STR_LIT>' ] = request_user . dept . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> except : <EOL> pass <EOL> return super ( ) . create ( validated_data ) <EOL> class FileViewSet ( CustomModelViewSet ) : <EOL> queryset = FileList . objects . all ( ) <EOL> ", "gt": "serializer_class = FileSerializer"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> fields = ALL_FIELDS <EOL> if fields == ALL_FIELDS : <EOL> fields = cls . get_all_model_fields ( model ) <EOL> exclude = exclude or [ ] <EOL> if not isinstance ( fields , dict ) : <EOL> fields = [ ( f , [ settings . DEFAULT_LOOKUP_EXPR ] ) for f in fields if f not in exclude ] <EOL> else : <EOL> fields = [ ( f , lookups ) for f , lookups in fields . items ( ) if f not in exclude ] <EOL> return OrderedDict ( fields ) <EOL> ", "gt": "@ classmethod"}
{"input": "from django . db . models import Q <EOL> from rest_framework import serializers <EOL> from dvadmin . system . models import Area <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class AreaSerializer ( CustomModelSerializer ) : <EOL> pcode_count = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_pcode_count ( self , instance : Area ) : <EOL> return Area . objects . filter ( pcode = instance ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Area . objects . filter ( pcode = instance . code ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Area <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class AreaCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Area <EOL> fields = '<STR_LIT>' <EOL> class AreaViewSet ( CustomModelViewSet ) : <EOL> queryset = Area . objects . all ( ) <EOL> serializer_class = AreaSerializer <EOL> extra_filter_class = [ ] <EOL> def get_queryset ( self ) : <EOL> self . request . query_params . _mutable = True <EOL> params = self . request . query_params <EOL> pcode = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> ", "gt": "if params and pcode :"}
{"input": "import hashlib <EOL> import logging <EOL> from django . contrib . auth import get_user_model <EOL> from django . contrib . auth . backends import ModelBackend <EOL> from django . contrib . auth . hashers import check_password <EOL> from django . utils import timezone <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> logger = logging . getLogger ( __name__ ) <EOL> UserModel = get_user_model ( ) <EOL> class CustomBackend ( ModelBackend ) : <EOL> def authenticate ( self , request , username = None , password = None , ** kwargs ) : <EOL> msg = '<STR_LIT>' % username <EOL> logger . info ( msg ) <EOL> if username is None : <EOL> username = kwargs . get ( UserModel . USERNAME_FIELD ) <EOL> try : <EOL> user = UserModel . _default_manager . get_by_natural_key ( username ) <EOL> except UserModel . DoesNotExist : <EOL> UserModel ( ) . set_password ( password ) <EOL> else : <EOL> verify_password = check_password ( password , user . password ) <EOL> ", "gt": "if not verify_password :"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> api_white_list = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return False <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> userApiList = RoleMenuButtonPermission . objects . filter ( role__in = role_id_list ) . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> ApiList = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in userApiList if item . get ( '<STR_LIT>' ) ] <EOL> new_api_ist = api_white_list + ApiList <EOL> new_api = api + \"<STR_LIT>\" + str ( method ) <EOL> for item in new_api_ist : <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return True <EOL> ", "gt": "else :"}
{"input": "import hashlib <EOL> import logging <EOL> from django . contrib . auth import get_user_model <EOL> from django . contrib . auth . backends import ModelBackend <EOL> from django . contrib . auth . hashers import check_password <EOL> from django . utils import timezone <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> logger = logging . getLogger ( __name__ ) <EOL> UserModel = get_user_model ( ) <EOL> class CustomBackend ( ModelBackend ) : <EOL> def authenticate ( self , request , username = None , password = None , ** kwargs ) : <EOL> msg = '<STR_LIT>' % username <EOL> logger . info ( msg ) <EOL> if username is None : <EOL> username = kwargs . get ( UserModel . USERNAME_FIELD ) <EOL> try : <EOL> user = UserModel . _default_manager . get_by_natural_key ( username ) <EOL> except UserModel . DoesNotExist : <EOL> UserModel ( ) . set_password ( password ) <EOL> else : <EOL> verify_password = check_password ( password , user . password ) <EOL> if not verify_password : <EOL> password = hashlib . md5 ( password . encode ( encoding = '<STR_LIT>' ) ) . hexdigest ( ) <EOL> ", "gt": "verify_password = check_password ( password , user . password )"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import RoleMenuPermission , Menu , MenuButton <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleMenuPermissionSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionInitSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionViewSet ( CustomModelViewSet ) : <EOL> queryset = RoleMenuPermission . objects . all ( ) <EOL> serializer_class = RoleMenuPermissionSerializer <EOL> create_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> update_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def save_auth ( self , request ) : <EOL> body = request . data <EOL> role_id = body . get ( '<STR_LIT>' , None ) <EOL> if role_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> menu_list = body . get ( '<STR_LIT>' , None ) <EOL> if menu_list is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> obj_list = RoleMenuPermission . objects . filter ( role__id = role_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> old_set = set ( obj_list ) <EOL> new_set = set ( menu_list ) <EOL> need_del = old_set . difference ( new_set ) <EOL> need_add = new_set . difference ( old_set ) <EOL> RoleMenuPermission . objects . filter ( role__id = role_id , menu__in = list ( need_del ) ) . delete ( ) <EOL> data = [ { \"<STR_LIT>\" : role_id , \"<STR_LIT>\" : item } for item in list ( need_add ) ] <EOL> serializer = RoleMenuPermissionSerializer ( data = data , many = True , request = request ) <EOL> ", "gt": "if serializer . is_valid ( raise_exception = True ) :"}
{"input": "import multiprocessing <EOL> workers = multiprocessing . cpu_count ( ) * <NUM_LIT> + <NUM_LIT> <EOL> threads = <NUM_LIT> <EOL> bind = '<STR_LIT>' <EOL> daemon = '<STR_LIT>' <EOL> worker_class = '<STR_LIT>' <EOL> worker_connections = <NUM_LIT> <EOL> max_requests = <NUM_LIT> <EOL> max_requests_jitter = <NUM_LIT> <EOL> pidfile = '<STR_LIT>' <EOL> loglevel = '<STR_LIT>' <EOL> access_log_format = '<STR_LIT>' <EOL> backlog = <NUM_LIT> <EOL> proc_name = '<STR_LIT>' <EOL> timeout = <NUM_LIT> <EOL> graceful_timeout = <NUM_LIT> <EOL> keepalive = <NUM_LIT> <EOL> ", "gt": "limit_request_line = <NUM_LIT>"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> return queryset <EOL> else : <EOL> return self . queryset <EOL> class InitDictionaryViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> queryset = Dictionary . objects . all ( ) <EOL> def get ( self , request ) : <EOL> dictionary_key = self . request . query_params . get ( '<STR_LIT>' ) <EOL> if dictionary_key : <EOL> ", "gt": "if dictionary_key == '<STR_LIT>' :"}
{"input": "import logging <EOL> from django . core . management . base import BaseCommand <EOL> from application import settings <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> nargs = \"<STR_LIT>\" , <EOL> type = str , <EOL> ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> def handle ( self , * args , ** options ) : <EOL> reset = False <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = True <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = False <EOL> for app in settings . INSTALLED_APPS : <EOL> try : <EOL> exec ( <EOL> ) <EOL> except ModuleNotFoundError : <EOL> try : <EOL> exec ( <EOL> ", "gt": ")"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . method == \"<STR_LIT>\" : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return self . readiness ( request ) <EOL> elif request . path == \"<STR_LIT>\" : <EOL> return self . healthz ( request ) <EOL> return self . get_response ( request ) <EOL> def healthz ( self , request ) : <EOL> return HttpResponse ( \"<STR_LIT>\" ) <EOL> def readiness ( self , request ) : <EOL> try : <EOL> from django . db import connections <EOL> for name in connections : <EOL> cursor = connections [ name ] . cursor ( ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> row = cursor . fetchone ( ) <EOL> if row is None : <EOL> return HttpResponseServerError ( \"<STR_LIT>\" ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return HttpResponseServerError ( \"<STR_LIT>\" ) <EOL> ", "gt": "try :"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> elif value_type == '<STR_LIT>' : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) <EOL> else : <EOL> if type ( cell_value ) is float and str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] == \"<STR_LIT>\" : <EOL> cell_value = int ( str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ) <EOL> elif type ( cell_value ) is str : <EOL> cell_value = cell_value . strip ( \"<STR_LIT>\" ) <EOL> if key in validation_data_dict : <EOL> array [ key ] = validation_data_dict . get ( key , { } ) . get ( cell_value , None ) <EOL> ", "gt": "if key in m2m_fields :"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> ", "gt": "elif value_type == '<STR_LIT>' :"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> ", "gt": "from dvadmin_cloud_storage . views . tencent import tencent_cos_upload"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> obj . objects . all ( ) . delete ( ) <EOL> settings . INITIALIZE_RESET_LIST . append ( obj ) <EOL> except Exception : <EOL> pass <EOL> for ele in data : <EOL> m2m_dict = { } <EOL> new_data = { } <EOL> for key , value in ele . items ( ) : <EOL> ", "gt": "if isinstance ( value , list ) and value and isinstance ( value [ <NUM_LIT> ] , int ) :"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterViewSet ( CustomModelViewSet ) : <EOL> queryset = MessageCenter . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MessageCenterSerializer <EOL> create_serializer_class = MessageCenterCreateSerializer <EOL> extra_filter_backends = [ ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> return MessageCenter . objects . filter ( creator = self . request . user . id ) . all ( ) <EOL> return MessageCenter . objects . all ( ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> pk = kwargs . get ( '<STR_LIT>' ) <EOL> user_id = self . request . user . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( users__id = user_id , messagecenter__id = pk ) . first ( ) <EOL> if queryset : <EOL> queryset . is_read = True <EOL> queryset . save ( ) <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance ) <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user_id , is_read = False ) . count ( ) <EOL> websocket_push ( user_id , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_self_receive ( self , request ) : <EOL> self_user_id = self . request . user . id <EOL> queryset = MessageCenter . objects . filter ( target_user__id = self_user_id ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> ", "gt": "serializer = MessageCenterTargetUserListSerializer ( page , many = True , request = request )"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> ", "gt": "new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ]"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> ", "gt": "return super ( ) . update ( instance , validated_data )"}
{"input": "import logging <EOL> from django . core . management . base import BaseCommand <EOL> from application import settings <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> nargs = \"<STR_LIT>\" , <EOL> type = str , <EOL> ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) <EOL> def handle ( self , * args , ** options ) : <EOL> reset = False <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> reset = True <EOL> if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : <EOL> ", "gt": "reset = False"}
{"input": "import os <EOL> import django <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . utils . core_initialize import CoreInitialize <EOL> from dvadmin . system . fixtures . initSerializer import ( <EOL> UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , <EOL> MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , <EOL> SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> ) <EOL> class Initialize ( CoreInitialize ) : <EOL> def init_dept ( self ) : <EOL> self . init_base ( DeptInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role ( self ) : <EOL> self . init_base ( RoleInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_users ( self ) : <EOL> self . init_base ( UsersInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_menu ( self ) : <EOL> self . init_base ( MenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu ( self ) : <EOL> self . init_base ( RoleMenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu_button ( self ) : <EOL> self . init_base ( RoleMenuButtonInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_api_white_list ( self ) : <EOL> self . init_base ( ApiWhiteListInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def init_dictionary ( self ) : <EOL> ", "gt": "self . init_base ( DictionaryInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] )"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> ", "gt": "if result is not None :"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) <EOL> else : <EOL> nested_dict [ target_key ] = new_value <EOL> return nested_dict <EOL> def __handle_crud ( self ) : <EOL> result = self . __get_field_attribute ( ) <EOL> columns = dict ( ) <EOL> for item in result : <EOL> key = item . get ( '<STR_LIT>' ) <EOL> title = item . get ( '<STR_LIT>' ) <EOL> type = item . get ( '<STR_LIT>' ) <EOL> columns [ key ] = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : key , <EOL> \"<STR_LIT>\" : type <EOL> ", "gt": "}"}
{"input": "import functools <EOL> import os <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from django . conf import settings <EOL> from celery import platforms <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from tenant_schemas_celery . app import CeleryApp as TenantAwareCeleryApp <EOL> app = TenantAwareCeleryApp ( ) <EOL> else : <EOL> from celery import Celery <EOL> app = Celery ( f\"<STR_LIT>\" ) <EOL> app . config_from_object ( '<STR_LIT>' ) <EOL> app . autodiscover_tasks ( lambda : settings . INSTALLED_APPS ) <EOL> ", "gt": "platforms . C_FORCE_ROOT = True"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> queryset = self . queryset . filter ( status = <NUM_LIT> ) <EOL> else : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def get_all_menu ( self , request ) : <EOL> user = request . user <EOL> queryset = self . queryset . all ( ) <EOL> if not user . is_superuser : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def move_up ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> menu = Menu . objects . get ( id = menu_id ) <EOL> except Menu . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Menu . objects . filter ( sort__lt = menu . sort , parent = menu . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , menu . sort = menu . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> menu . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> ", "gt": "def move_down ( self , request ) :"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> model_name = request . data . get ( '<STR_LIT>' ) <EOL> if not menu_id or not model_name : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> for model in get_custom_app_models ( ) : <EOL> ", "gt": "if model [ '<STR_LIT>' ] != model_name :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> queryset = self . queryset . filter ( status = <NUM_LIT> ) <EOL> else : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def get_all_menu ( self , request ) : <EOL> user = request . user <EOL> queryset = self . queryset . all ( ) <EOL> if not user . is_superuser : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def move_up ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> menu = Menu . objects . get ( id = menu_id ) <EOL> except Menu . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Menu . objects . filter ( sort__lt = menu . sort , parent = menu . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , menu . sort = menu . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> menu . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def move_down ( self , request ) : <EOL> menu_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> menu = Menu . objects . get ( id = menu_id ) <EOL> except Menu . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> next_menu = Menu . objects . filter ( sort__gt = menu . sort , parent = menu . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if next_menu : <EOL> next_menu . sort , menu . sort = menu . sort , next_menu . sort <EOL> next_menu . save ( ) <EOL> ", "gt": "menu . save ( )"}
{"input": "from rest_framework . response import Response <EOL> class SuccessResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , page = <NUM_LIT> , limit = <NUM_LIT> , total = <NUM_LIT> ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : page , <EOL> \"<STR_LIT>\" : limit , <EOL> \"<STR_LIT>\" : total , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class DetailResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class ErrorResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , code = <NUM_LIT> , status = None , template_name = None , headers = None , <EOL> exception = False , content_type = None ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : code , <EOL> ", "gt": "\"<STR_LIT>\" : data ,"}
{"input": "from dvadmin . system . models import ApiWhiteList <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class ApiWhiteListSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> ", "gt": "model = ApiWhiteList"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> ", "gt": "self . dept_belong_id_field_name in self . fields . fields"}
{"input": "from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class OperationLogSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = OperationLog <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class OperationLogCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = OperationLog <EOL> fields = '<STR_LIT>' <EOL> ", "gt": "class OperationLogViewSet ( CustomModelViewSet ) :"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> ", "gt": "def list ( self , request , * args , ** kwargs ) :"}
{"input": "import os <EOL> from application . settings import BASE_DIR <EOL> DATABASE_ENGINE = \"<STR_LIT>\" <EOL> DATABASE_NAME = '<STR_LIT>' <EOL> DATABASE_HOST = '<STR_LIT>' <EOL> DATABASE_PORT = <NUM_LIT> <EOL> DATABASE_USER = \"<STR_LIT>\" <EOL> DATABASE_PASSWORD = \"<STR_LIT>\" <EOL> TABLE_PREFIX = \"<STR_LIT>\" <EOL> REDIS_PASSWORD = '<STR_LIT>' <EOL> REDIS_HOST = '<STR_LIT>' <EOL> REDIS_URL = f'<STR_LIT>' <EOL> DEBUG = True <EOL> ENABLE_LOGIN_ANALYSIS_LOG = True <EOL> ", "gt": "LOGIN_NO_CAPTCHA_AUTH = True"}
{"input": "from drf_yasg . generators import OpenAPISchemaGenerator <EOL> from drf_yasg . inspectors import SwaggerAutoSchema <EOL> from application . settings import SWAGGER_SETTINGS <EOL> def get_summary ( string ) : <EOL> if string is not None : <EOL> result = string . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) <EOL> return result [ <NUM_LIT> ] <EOL> class CustomSwaggerAutoSchema ( SwaggerAutoSchema ) : <EOL> def get_tags ( self , operation_keys = None ) : <EOL> tags = super ( ) . get_tags ( operation_keys ) <EOL> if \"<STR_LIT>\" in tags and operation_keys : <EOL> tags [ <NUM_LIT> ] = operation_keys [ SWAGGER_SETTINGS . get ( '<STR_LIT>' , <NUM_LIT> ) ] <EOL> return tags <EOL> def get_summary_and_description ( self ) : <EOL> ", "gt": "summary_and_description = super ( ) . get_summary_and_description ( )"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> ", "gt": "read_only_fields = [ \"<STR_LIT>\" ]"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> api_white_list = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return False <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> userApiList = RoleMenuButtonPermission . objects . filter ( role__in = role_id_list ) . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> ApiList = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in userApiList if item . get ( '<STR_LIT>' ) ] <EOL> new_api_ist = api_white_list + ApiList <EOL> new_api = api + \"<STR_LIT>\" + str ( method ) <EOL> for item in new_api_ist : <EOL> ", "gt": "matchObj = re . match ( item , new_api , re . M | re . I )"}
{"input": "import os <EOL> from channels . auth import AuthMiddlewareStack <EOL> from channels . security . websocket import AllowedHostsOriginValidator <EOL> from channels . routing import ProtocolTypeRouter , URLRouter <EOL> from django . core . asgi import get_asgi_application <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> http_application = get_asgi_application ( ) <EOL> from application . routing import websocket_urlpatterns <EOL> application = ProtocolTypeRouter ( { <EOL> \"<STR_LIT>\" : http_application , <EOL> '<STR_LIT>' : AllowedHostsOriginValidator ( <EOL> AuthMiddlewareStack ( <EOL> URLRouter ( <EOL> websocket_urlpatterns <EOL> ) <EOL> ) <EOL> ) , <EOL> ", "gt": "} )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> ", "gt": "elif item == <NUM_LIT> :"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> try : <EOL> request_user = self . request . user <EOL> validated_data [ '<STR_LIT>' ] = request_user . dept . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> except : <EOL> pass <EOL> ", "gt": "return super ( ) . create ( validated_data )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> next_menu = Dept . objects . filter ( sort__gt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if next_menu : <EOL> next_menu . sort , dept . sort = dept . sort , next_menu . sort <EOL> next_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def dept_info ( self , request ) : <EOL> def inner ( did , li ) : <EOL> sub = Dept . objects . filter ( parent_id = did ) <EOL> if not sub . exists ( ) : <EOL> return li <EOL> for i in sub : <EOL> li . append ( i . pk ) <EOL> inner ( i , li ) <EOL> return li <EOL> dept_id = request . query_params . get ( '<STR_LIT>' ) <EOL> show_all = request . query_params . get ( '<STR_LIT>' ) <EOL> if dept_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if not show_all : <EOL> show_all = <NUM_LIT> <EOL> if int ( show_all ) : <EOL> all_did = [ dept_id ] <EOL> inner ( dept_id , all_did ) <EOL> users = Users . objects . filter ( dept_id__in = all_did ) <EOL> else : <EOL> if dept_id != '<STR_LIT>' : <EOL> users = Users . objects . filter ( dept_id = dept_id ) <EOL> else : <EOL> users = Users . objects . none ( ) <EOL> dept_obj = Dept . objects . get ( id = dept_id ) if dept_id != '<STR_LIT>' else None <EOL> sub_dept = Dept . objects . filter ( parent_id = dept_obj . pk ) if dept_id != '<STR_LIT>' else [ ] <EOL> ", "gt": "data = {"}
{"input": "import multiprocessing <EOL> workers = multiprocessing . cpu_count ( ) * <NUM_LIT> + <NUM_LIT> <EOL> threads = <NUM_LIT> <EOL> bind = '<STR_LIT>' <EOL> daemon = '<STR_LIT>' <EOL> worker_class = '<STR_LIT>' <EOL> worker_connections = <NUM_LIT> <EOL> max_requests = <NUM_LIT> <EOL> max_requests_jitter = <NUM_LIT> <EOL> pidfile = '<STR_LIT>' <EOL> loglevel = '<STR_LIT>' <EOL> access_log_format = '<STR_LIT>' <EOL> backlog = <NUM_LIT> <EOL> proc_name = '<STR_LIT>' <EOL> ", "gt": "timeout = <NUM_LIT>"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> return settings . ALL_MODELS_OBJECTS [ model_name ] or { } <EOL> return settings . ALL_MODELS_OBJECTS or { } <EOL> def get_model_from_app ( app_name ) : <EOL> model_module = import_module ( app_name + '<STR_LIT>' ) <EOL> filter_model = [ <EOL> getattr ( model_module , item ) for item in dir ( model_module ) <EOL> if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) <EOL> ] <EOL> model_list = [ ] <EOL> for model in filter_model : <EOL> if model . __name__ == '<STR_LIT>' : <EOL> continue <EOL> ", "gt": "fields = ["}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> ", "gt": "model = Users"}
{"input": "from rest_framework . views import APIView <EOL> from django . shortcuts import render <EOL> class PrivacyView ( APIView ) : <EOL> permission_classes = [ ] <EOL> def get ( self , request , * args , ** kwargs ) : <EOL> return render ( request , '<STR_LIT>' ) <EOL> class TermsServiceView ( APIView ) : <EOL> ", "gt": "permission_classes = [ ]"}
{"input": "from django . db . models import Q <EOL> from rest_framework import serializers <EOL> from dvadmin . system . models import Area <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class AreaSerializer ( CustomModelSerializer ) : <EOL> pcode_count = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_pcode_count ( self , instance : Area ) : <EOL> return Area . objects . filter ( pcode = instance ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Area . objects . filter ( pcode = instance . code ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Area <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class AreaCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Area <EOL> fields = '<STR_LIT>' <EOL> class AreaViewSet ( CustomModelViewSet ) : <EOL> queryset = Area . objects . all ( ) <EOL> serializer_class = AreaSerializer <EOL> extra_filter_class = [ ] <EOL> def get_queryset ( self ) : <EOL> self . request . query_params . _mutable = True <EOL> params = self . request . query_params <EOL> pcode = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and pcode : <EOL> queryset = self . queryset . filter ( enable = True , pcode = pcode ) <EOL> else : <EOL> ", "gt": "queryset = self . queryset . filter ( enable = True )"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> api_white_list = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return False <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> userApiList = RoleMenuButtonPermission . objects . filter ( role__in = role_id_list ) . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) <EOL> ApiList = [ <EOL> str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( <EOL> ", "gt": "item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in userApiList if item . get ( '<STR_LIT>' ) ]"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> return settings . ALL_MODELS_OBJECTS [ model_name ] or { } <EOL> return settings . ALL_MODELS_OBJECTS or { } <EOL> def get_model_from_app ( app_name ) : <EOL> model_module = import_module ( app_name + '<STR_LIT>' ) <EOL> filter_model = [ <EOL> getattr ( model_module , item ) for item in dir ( model_module ) <EOL> if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) <EOL> ] <EOL> model_list = [ ] <EOL> for model in filter_model : <EOL> if model . __name__ == '<STR_LIT>' : <EOL> continue <EOL> fields = [ <EOL> { '<STR_LIT>' : field . verbose_name , '<STR_LIT>' : field . name , '<STR_LIT>' : field } <EOL> for field in model . _meta . fields <EOL> ] <EOL> model_list . append ( { <EOL> '<STR_LIT>' : app_name , <EOL> '<STR_LIT>' : model . _meta . verbose_name , <EOL> '<STR_LIT>' : model . __name__ , <EOL> '<STR_LIT>' : model , <EOL> '<STR_LIT>' : fields <EOL> } ) <EOL> return model_list <EOL> def get_custom_app_models ( app_name = None ) : <EOL> ", "gt": "if app_name :"}
{"input": "import logging <EOL> import traceback <EOL> from django . db . models import ProtectedError <EOL> from django . http import Http404 <EOL> from rest_framework . exceptions import APIException as DRFAPIException , AuthenticationFailed , NotAuthenticated <EOL> from rest_framework . status import HTTP_401_UNAUTHORIZED <EOL> from rest_framework . views import set_rollback , exception_handler <EOL> from dvadmin . utils . json_response import ErrorResponse <EOL> logger = logging . getLogger ( __name__ ) <EOL> class CustomAuthenticationFailed ( NotAuthenticated ) : <EOL> status_code = <NUM_LIT> <EOL> def CustomExceptionHandler ( ex , context ) : <EOL> msg = '<STR_LIT>' <EOL> code = <NUM_LIT> <EOL> response = exception_handler ( ex , context ) <EOL> if isinstance ( ex , AuthenticationFailed ) : <EOL> if response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> return ErrorResponse ( status = HTTP_401_UNAUTHORIZED ) <EOL> else : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> ", "gt": "elif isinstance ( ex , Http404 ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_name ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_user_id ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> ", "gt": "@ property"}
{"input": "from django . urls import path <EOL> from rest_framework import routers <EOL> from dvadmin . system . views . api_white_list import ApiWhiteListViewSet <EOL> from dvadmin . system . views . area import AreaViewSet <EOL> from dvadmin . system . views . clause import PrivacyView , TermsServiceView <EOL> from dvadmin . system . views . dept import DeptViewSet <EOL> from dvadmin . system . views . dictionary import DictionaryViewSet <EOL> from dvadmin . system . views . file_list import FileViewSet <EOL> from dvadmin . system . views . login_log import LoginLogViewSet <EOL> from dvadmin . system . views . menu import MenuViewSet <EOL> from dvadmin . system . views . menu_button import MenuButtonViewSet <EOL> from dvadmin . system . views . message_center import MessageCenterViewSet <EOL> from dvadmin . system . views . operation_log import OperationLogViewSet <EOL> from dvadmin . system . views . role import RoleViewSet <EOL> from dvadmin . system . views . role_menu import RoleMenuPermissionViewSet <EOL> from dvadmin . system . views . role_menu_button_permission import RoleMenuButtonPermissionViewSet <EOL> from dvadmin . system . views . system_config import SystemConfigViewSet <EOL> from dvadmin . system . views . user import UserViewSet <EOL> from dvadmin . system . views . menu_field import MenuFieldViewSet <EOL> system_url = routers . SimpleRouter ( ) <EOL> system_url . register ( r'<STR_LIT>' , MenuViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuButtonViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DeptViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , UserViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , OperationLogViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DictionaryViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , AreaViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , FileViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , ApiWhiteListViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , SystemConfigViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MessageCenterViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuButtonPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleMenuPermissionViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuFieldViewSet ) <EOL> urlpatterns = [ <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , } ) ) , <EOL> path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> path ( '<STR_LIT>' , LoginLogViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , <EOL> ", "gt": "path ( '<STR_LIT>' , LoginLogViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) ,"}
{"input": "import logging <EOL> import traceback <EOL> from django . db . models import ProtectedError <EOL> from django . http import Http404 <EOL> from rest_framework . exceptions import APIException as DRFAPIException , AuthenticationFailed , NotAuthenticated <EOL> from rest_framework . status import HTTP_401_UNAUTHORIZED <EOL> from rest_framework . views import set_rollback , exception_handler <EOL> from dvadmin . utils . json_response import ErrorResponse <EOL> logger = logging . getLogger ( __name__ ) <EOL> class CustomAuthenticationFailed ( NotAuthenticated ) : <EOL> status_code = <NUM_LIT> <EOL> def CustomExceptionHandler ( ex , context ) : <EOL> msg = '<STR_LIT>' <EOL> code = <NUM_LIT> <EOL> response = exception_handler ( ex , context ) <EOL> if isinstance ( ex , AuthenticationFailed ) : <EOL> if response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> return ErrorResponse ( status = HTTP_401_UNAUTHORIZED ) <EOL> else : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif isinstance ( ex , Http404 ) : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> elif isinstance ( ex , DRFAPIException ) : <EOL> set_rollback ( ) <EOL> msg = ex . detail <EOL> if isinstance ( msg , dict ) : <EOL> for k , v in msg . items ( ) : <EOL> for i in v : <EOL> msg = \"<STR_LIT>\" % ( k , i ) <EOL> elif isinstance ( ex , ProtectedError ) : <EOL> set_rollback ( ) <EOL> msg = \"<STR_LIT>\" <EOL> elif isinstance ( ex , Exception ) : <EOL> logger . exception ( traceback . format_exc ( ) ) <EOL> msg = str ( ex ) <EOL> ", "gt": "return ErrorResponse ( msg = msg , code = code )"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> ", "gt": "for lookup in orm_lookups :"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> ", "gt": "value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' )"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> var_name = body . get ( '<STR_LIT>' , None ) <EOL> table = body . get ( '<STR_LIT>' , None ) <EOL> instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> relation_id = body . get ( '<STR_LIT>' , None ) <EOL> relationIds = [ ] <EOL> if relation_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = [ relation_id ] <EOL> elif instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = relation_id . split ( '<STR_LIT>' ) <EOL> queryset = SystemConfig . objects . filter ( value__in = relationIds ) . first ( ) <EOL> if queryset is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> serializer = SystemConfigChinldernSerializer ( queryset . parent ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = serializer . data ) <EOL> class InitSettingsViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def filter_system_config_values ( self , data : dict ) : <EOL> if not self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> return data <EOL> new_data = { } <EOL> for key in self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) . split ( '<STR_LIT>' ) : <EOL> if key : <EOL> new_data . update ( ** dict ( filter ( lambda x : x [ <NUM_LIT> ] . startswith ( key ) , data . items ( ) ) ) ) <EOL> return new_data <EOL> def get ( self , request ) : <EOL> data = dispatch . get_system_config ( ) <EOL> ", "gt": "if not data :"}
{"input": "from django . db import DataError <EOL> from rest_framework . exceptions import APIException <EOL> from rest_framework . validators import UniqueValidator <EOL> class CustomValidationError ( APIException ) : <EOL> def __init__ ( self , detail ) : <EOL> self . detail = detail <EOL> def qs_exists ( queryset ) : <EOL> try : <EOL> return queryset . exists ( ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return False <EOL> def qs_filter ( queryset , ** kwargs ) : <EOL> try : <EOL> return queryset . filter ( ** kwargs ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return queryset . none ( ) <EOL> class CustomUniqueValidator ( UniqueValidator ) : <EOL> def filter_queryset ( self , value , queryset , field_name ) : <EOL> filter_kwargs = { '<STR_LIT>' % ( field_name , self . lookup ) : value } <EOL> ", "gt": "return qs_filter ( queryset , ** filter_kwargs )"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> try : <EOL> request_user = self . request . user <EOL> validated_data [ '<STR_LIT>' ] = request_user . dept . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> ", "gt": "except :"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> var_name = body . get ( '<STR_LIT>' , None ) <EOL> table = body . get ( '<STR_LIT>' , None ) <EOL> instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> relation_id = body . get ( '<STR_LIT>' , None ) <EOL> relationIds = [ ] <EOL> if relation_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = [ relation_id ] <EOL> elif instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = relation_id . split ( '<STR_LIT>' ) <EOL> queryset = SystemConfig . objects . filter ( value__in = relationIds ) . first ( ) <EOL> if queryset is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> serializer = SystemConfigChinldernSerializer ( queryset . parent ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = serializer . data ) <EOL> class InitSettingsViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def filter_system_config_values ( self , data : dict ) : <EOL> if not self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> return data <EOL> new_data = { } <EOL> for key in self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) . split ( '<STR_LIT>' ) : <EOL> if key : <EOL> new_data . update ( ** dict ( filter ( lambda x : x [ <NUM_LIT> ] . startswith ( key ) , data . items ( ) ) ) ) <EOL> return new_data <EOL> def get ( self , request ) : <EOL> data = dispatch . get_system_config ( ) <EOL> if not data : <EOL> dispatch . refresh_system_config ( ) <EOL> data = dispatch . get_system_config ( ) <EOL> backend_config = [ f\"<STR_LIT>\" for ele in <EOL> ", "gt": "SystemConfig . objects . filter ( status = False , parent_id__isnull = False ) . values ( '<STR_LIT>' ,"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import RoleMenuPermission , Menu , MenuButton <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleMenuPermissionSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionInitSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionViewSet ( CustomModelViewSet ) : <EOL> queryset = RoleMenuPermission . objects . all ( ) <EOL> serializer_class = RoleMenuPermissionSerializer <EOL> create_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> update_serializer_class = RoleMenuPermissionCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def save_auth ( self , request ) : <EOL> body = request . data <EOL> role_id = body . get ( '<STR_LIT>' , None ) <EOL> if role_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> menu_list = body . get ( '<STR_LIT>' , None ) <EOL> if menu_list is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> obj_list = RoleMenuPermission . objects . filter ( role__id = role_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> ", "gt": "old_set = set ( obj_list )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> ", "gt": "queryset = MenuButton . objects . filter ( menu__id = instance . id )"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> fields = cls . _meta . fields <EOL> exclude = cls . _meta . exclude <EOL> assert not ( fields is None and exclude is None ) , ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % cls . __name__ <EOL> ) <EOL> if exclude is not None and fields is None : <EOL> fields = ALL_FIELDS <EOL> if fields == ALL_FIELDS : <EOL> fields = cls . get_all_model_fields ( model ) <EOL> exclude = exclude or [ ] <EOL> if not isinstance ( fields , dict ) : <EOL> fields = [ ( f , [ settings . DEFAULT_LOOKUP_EXPR ] ) for f in fields if f not in exclude ] <EOL> else : <EOL> fields = [ ( f , lookups ) for f , lookups in fields . items ( ) if f not in exclude ] <EOL> return OrderedDict ( fields ) <EOL> @ classmethod <EOL> def get_filters ( cls ) : <EOL> if not cls . _meta . model : <EOL> return cls . declared_filters . copy ( ) <EOL> filters = OrderedDict ( ) <EOL> fields = cls . get_fields ( ) <EOL> undefined = [ ] <EOL> for field_name , lookups in fields . items ( ) : <EOL> field = get_model_field ( cls . _meta . model , field_name ) <EOL> from django . db import models <EOL> from timezone_field import TimeZoneField <EOL> if isinstance ( field , ( models . JSONField , TimeZoneField ) ) : <EOL> continue <EOL> if field is None : <EOL> undefined . append ( field_name ) <EOL> if ( <EOL> isinstance ( field , ( models . CharField ) ) <EOL> and filterset_fields == \"<STR_LIT>\" <EOL> and lookups == [ \"<STR_LIT>\" ] <EOL> ) : <EOL> lookups = [ \"<STR_LIT>\" ] <EOL> for lookup_expr in lookups : <EOL> filter_name = cls . get_filter_name ( field_name , lookup_expr ) <EOL> if filter_name in cls . declared_filters : <EOL> filters [ filter_name ] = cls . declared_filters [ filter_name ] <EOL> continue <EOL> if field is not None : <EOL> ", "gt": "filters [ filter_name ] = cls . filter_for_field ( field , field_name , lookup_expr )"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> serializer = self . get_serializer ( data = request . data , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_create ( serializer ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> serializer = self . get_serializer ( page , many = True , request = request ) <EOL> return self . get_paginated_response ( serializer . data ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance ) <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def update ( self , request , * args , ** kwargs ) : <EOL> partial = kwargs . pop ( '<STR_LIT>' , False ) <EOL> instance = self . get_object ( ) <EOL> serializer = self . get_serializer ( instance , data = request . data , request = request , partial = partial ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> self . perform_update ( serializer ) <EOL> if getattr ( instance , '<STR_LIT>' , None ) : <EOL> instance . _prefetched_objects_cache = { } <EOL> return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def destroy ( self , request , * args , ** kwargs ) : <EOL> instance = self . get_object ( ) <EOL> instance . delete ( ) <EOL> return DetailResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> keys = openapi . Schema ( description = '<STR_LIT>' , type = openapi . TYPE_ARRAY , items = openapi . TYPE_STRING ) <EOL> @ swagger_auto_schema ( request_body = openapi . Schema ( <EOL> type = openapi . TYPE_OBJECT , <EOL> required = [ '<STR_LIT>' ] , <EOL> properties = { '<STR_LIT>' : keys } <EOL> ) , operation_summary = '<STR_LIT>' ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> ", "gt": "def multiple_delete ( self , request , * args , ** kwargs ) :"}
{"input": "import os <EOL> from channels . auth import AuthMiddlewareStack <EOL> from channels . security . websocket import AllowedHostsOriginValidator <EOL> from channels . routing import ProtocolTypeRouter , URLRouter <EOL> from django . core . asgi import get_asgi_application <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> http_application = get_asgi_application ( ) <EOL> from application . routing import websocket_urlpatterns <EOL> application = ProtocolTypeRouter ( { <EOL> \"<STR_LIT>\" : http_application , <EOL> '<STR_LIT>' : AllowedHostsOriginValidator ( <EOL> AuthMiddlewareStack ( <EOL> URLRouter ( <EOL> ", "gt": "websocket_urlpatterns"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> ", "gt": "model = view . get_serializer ( ) . Meta . model"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> ", "gt": "targetuser_instance . save ( )"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> ", "gt": "pass"}
{"input": "from django . urls import path <EOL> from rest_framework import routers <EOL> from dvadmin . system . views . api_white_list import ApiWhiteListViewSet <EOL> from dvadmin . system . views . area import AreaViewSet <EOL> from dvadmin . system . views . clause import PrivacyView , TermsServiceView <EOL> from dvadmin . system . views . dept import DeptViewSet <EOL> from dvadmin . system . views . dictionary import DictionaryViewSet <EOL> from dvadmin . system . views . file_list import FileViewSet <EOL> from dvadmin . system . views . login_log import LoginLogViewSet <EOL> from dvadmin . system . views . menu import MenuViewSet <EOL> from dvadmin . system . views . menu_button import MenuButtonViewSet <EOL> from dvadmin . system . views . message_center import MessageCenterViewSet <EOL> from dvadmin . system . views . operation_log import OperationLogViewSet <EOL> from dvadmin . system . views . role import RoleViewSet <EOL> from dvadmin . system . views . role_menu import RoleMenuPermissionViewSet <EOL> from dvadmin . system . views . role_menu_button_permission import RoleMenuButtonPermissionViewSet <EOL> from dvadmin . system . views . system_config import SystemConfigViewSet <EOL> from dvadmin . system . views . user import UserViewSet <EOL> from dvadmin . system . views . menu_field import MenuFieldViewSet <EOL> system_url = routers . SimpleRouter ( ) <EOL> system_url . register ( r'<STR_LIT>' , MenuViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuButtonViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DeptViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , UserViewSet ) <EOL> ", "gt": "system_url . register ( r'<STR_LIT>' , OperationLogViewSet )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> next_menu = Dept . objects . filter ( sort__gt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if next_menu : <EOL> next_menu . sort , dept . sort = dept . sort , next_menu . sort <EOL> next_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def dept_info ( self , request ) : <EOL> def inner ( did , li ) : <EOL> sub = Dept . objects . filter ( parent_id = did ) <EOL> if not sub . exists ( ) : <EOL> return li <EOL> for i in sub : <EOL> li . append ( i . pk ) <EOL> inner ( i , li ) <EOL> return li <EOL> dept_id = request . query_params . get ( '<STR_LIT>' ) <EOL> show_all = request . query_params . get ( '<STR_LIT>' ) <EOL> if dept_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if not show_all : <EOL> show_all = <NUM_LIT> <EOL> if int ( show_all ) : <EOL> all_did = [ dept_id ] <EOL> inner ( dept_id , all_did ) <EOL> users = Users . objects . filter ( dept_id__in = all_did ) <EOL> else : <EOL> if dept_id != '<STR_LIT>' : <EOL> users = Users . objects . filter ( dept_id = dept_id ) <EOL> else : <EOL> users = Users . objects . none ( ) <EOL> dept_obj = Dept . objects . get ( id = dept_id ) if dept_id != '<STR_LIT>' else None <EOL> sub_dept = Dept . objects . filter ( parent_id = dept_obj . pk ) if dept_id != '<STR_LIT>' else [ ] <EOL> data = { <EOL> '<STR_LIT>' : dept_obj and dept_obj . name , <EOL> '<STR_LIT>' : users . count ( ) , <EOL> ", "gt": "'<STR_LIT>' : dept_obj and dept_obj . owner ,"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> target_role = None , message : dict = None , request = Request ) : <EOL> if message is None : <EOL> message = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> if target_role is None : <EOL> target_role = [ ] <EOL> if target_dept is None : <EOL> target_dept = [ ] <EOL> data = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : content , <EOL> \"<STR_LIT>\" : target_type , <EOL> \"<STR_LIT>\" : target_user , <EOL> \"<STR_LIT>\" : target_dept , <EOL> ", "gt": "\"<STR_LIT>\" : target_role"}
{"input": "import logging <EOL> import traceback <EOL> from django . db . models import ProtectedError <EOL> from django . http import Http404 <EOL> from rest_framework . exceptions import APIException as DRFAPIException , AuthenticationFailed , NotAuthenticated <EOL> from rest_framework . status import HTTP_401_UNAUTHORIZED <EOL> from rest_framework . views import set_rollback , exception_handler <EOL> from dvadmin . utils . json_response import ErrorResponse <EOL> logger = logging . getLogger ( __name__ ) <EOL> class CustomAuthenticationFailed ( NotAuthenticated ) : <EOL> status_code = <NUM_LIT> <EOL> def CustomExceptionHandler ( ex , context ) : <EOL> msg = '<STR_LIT>' <EOL> code = <NUM_LIT> <EOL> response = exception_handler ( ex , context ) <EOL> if isinstance ( ex , AuthenticationFailed ) : <EOL> if response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> return ErrorResponse ( status = HTTP_401_UNAUTHORIZED ) <EOL> else : <EOL> code = <NUM_LIT> <EOL> ", "gt": "msg = ex . detail"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> ", "gt": "elif file_engine == '<STR_LIT>' :"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import RoleMenuPermission , Menu , MenuButton <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleMenuPermissionSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionInitSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = RoleMenuPermission <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleMenuPermissionViewSet ( CustomModelViewSet ) : <EOL> queryset = RoleMenuPermission . objects . all ( ) <EOL> ", "gt": "serializer_class = RoleMenuPermissionSerializer"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> try : <EOL> request_user = self . request . user <EOL> validated_data [ '<STR_LIT>' ] = request_user . dept . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> except : <EOL> pass <EOL> return super ( ) . create ( validated_data ) <EOL> ", "gt": "class FileViewSet ( CustomModelViewSet ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> next_menu = Dept . objects . filter ( sort__gt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if next_menu : <EOL> next_menu . sort , dept . sort = dept . sort , next_menu . sort <EOL> next_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def dept_info ( self , request ) : <EOL> def inner ( did , li ) : <EOL> sub = Dept . objects . filter ( parent_id = did ) <EOL> if not sub . exists ( ) : <EOL> return li <EOL> for i in sub : <EOL> li . append ( i . pk ) <EOL> inner ( i , li ) <EOL> return li <EOL> dept_id = request . query_params . get ( '<STR_LIT>' ) <EOL> show_all = request . query_params . get ( '<STR_LIT>' ) <EOL> if dept_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if not show_all : <EOL> show_all = <NUM_LIT> <EOL> if int ( show_all ) : <EOL> all_did = [ dept_id ] <EOL> inner ( dept_id , all_did ) <EOL> users = Users . objects . filter ( dept_id__in = all_did ) <EOL> else : <EOL> if dept_id != '<STR_LIT>' : <EOL> users = Users . objects . filter ( dept_id = dept_id ) <EOL> else : <EOL> users = Users . objects . none ( ) <EOL> dept_obj = Dept . objects . get ( id = dept_id ) if dept_id != '<STR_LIT>' else None <EOL> sub_dept = Dept . objects . filter ( parent_id = dept_obj . pk ) if dept_id != '<STR_LIT>' else [ ] <EOL> data = { <EOL> '<STR_LIT>' : dept_obj and dept_obj . name , <EOL> '<STR_LIT>' : users . count ( ) , <EOL> '<STR_LIT>' : dept_obj and dept_obj . owner , <EOL> '<STR_LIT>' : dept_obj and dept_obj . description , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : users . filter ( gender = <NUM_LIT> ) . count ( ) , <EOL> '<STR_LIT>' : users . filter ( gender = <NUM_LIT> ) . count ( ) , <EOL> '<STR_LIT>' : users . filter ( gender = <NUM_LIT> ) . count ( ) , <EOL> } , <EOL> '<STR_LIT>' : [ ] <EOL> } <EOL> for dept in sub_dept : <EOL> all_did = [ dept . pk ] <EOL> inner ( dept . pk , all_did ) <EOL> sub_data = { <EOL> '<STR_LIT>' : dept . name , <EOL> ", "gt": "'<STR_LIT>' : Users . objects . filter ( dept_id__in = all_did ) . count ( )"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> ", "gt": "return lookup"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> ", "gt": "self . operation_log_id = log . id"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> ", "gt": "key = items [ <NUM_LIT> ]"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = Menu <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MenuButtonPermissionSerializer ( CustomModelSerializer ) : <EOL> isCheck = serializers . SerializerMethodField ( ) <EOL> def get_isCheck ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> return True <EOL> else : <EOL> return MenuButton . objects . filter ( <EOL> menu__id = instance . id , <EOL> role__id__in = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) , <EOL> ) . exists ( ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = '<STR_LIT>' <EOL> class RoleViewSet ( CustomModelViewSet , FastCrudMixin , FieldPermissionMixin ) : <EOL> queryset = Role . objects . all ( ) <EOL> serializer_class = RoleSerializer <EOL> create_serializer_class = RoleCreateUpdateSerializer <EOL> ", "gt": "update_serializer_class = RoleCreateUpdateSerializer"}
{"input": "import hashlib <EOL> import logging <EOL> from django . contrib . auth import get_user_model <EOL> from django . contrib . auth . backends import ModelBackend <EOL> from django . contrib . auth . hashers import check_password <EOL> from django . utils import timezone <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> logger = logging . getLogger ( __name__ ) <EOL> UserModel = get_user_model ( ) <EOL> class CustomBackend ( ModelBackend ) : <EOL> def authenticate ( self , request , username = None , password = None , ** kwargs ) : <EOL> msg = '<STR_LIT>' % username <EOL> logger . info ( msg ) <EOL> if username is None : <EOL> username = kwargs . get ( UserModel . USERNAME_FIELD ) <EOL> try : <EOL> user = UserModel . _default_manager . get_by_natural_key ( username ) <EOL> except UserModel . DoesNotExist : <EOL> UserModel ( ) . set_password ( password ) <EOL> else : <EOL> verify_password = check_password ( password , user . password ) <EOL> if not verify_password : <EOL> password = hashlib . md5 ( password . encode ( encoding = '<STR_LIT>' ) ) . hexdigest ( ) <EOL> verify_password = check_password ( password , user . password ) <EOL> ", "gt": "if verify_password :"}
{"input": "import os <EOL> from application . settings import BASE_DIR <EOL> DATABASE_ENGINE = \"<STR_LIT>\" <EOL> DATABASE_NAME = '<STR_LIT>' <EOL> DATABASE_HOST = '<STR_LIT>' <EOL> DATABASE_PORT = <NUM_LIT> <EOL> DATABASE_USER = \"<STR_LIT>\" <EOL> DATABASE_PASSWORD = \"<STR_LIT>\" <EOL> TABLE_PREFIX = \"<STR_LIT>\" <EOL> REDIS_PASSWORD = '<STR_LIT>' <EOL> REDIS_HOST = '<STR_LIT>' <EOL> REDIS_URL = f'<STR_LIT>' <EOL> DEBUG = True <EOL> ENABLE_LOGIN_ANALYSIS_LOG = True <EOL> LOGIN_NO_CAPTCHA_AUTH = True <EOL> ", "gt": "ALLOWED_HOSTS = [ \"<STR_LIT>\" ]"}
{"input": "from django . db import transaction <EOL> from django_filters import DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import FilterSet <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework . decorators import action <EOL> from rest_framework . viewsets import ModelViewSet <EOL> from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend <EOL> from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse <EOL> from dvadmin . utils . permission import CustomPermission <EOL> from dvadmin . utils . models import get_custom_app_models , CoreModel <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from django_restql . mixins import QueryArgumentsMixin <EOL> class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : <EOL> values_queryset = None <EOL> ordering_fields = '<STR_LIT>' <EOL> create_serializer_class = None <EOL> update_serializer_class = None <EOL> filter_fields = '<STR_LIT>' <EOL> search_fields = ( ) <EOL> extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] <EOL> permission_classes = [ CustomPermission ] <EOL> import_field_dict = { } <EOL> export_field_label = { } <EOL> def filter_queryset ( self , queryset ) : <EOL> for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : <EOL> queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) <EOL> return queryset <EOL> def get_queryset ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . values_queryset <EOL> return super ( ) . get_queryset ( ) <EOL> def get_serializer_class ( self ) : <EOL> action_serializer_name = f\"<STR_LIT>\" <EOL> action_serializer_class = getattr ( self , action_serializer_name , None ) <EOL> if action_serializer_class : <EOL> return action_serializer_class <EOL> return super ( ) . get_serializer_class ( ) <EOL> def get_serializer ( self , * args , ** kwargs ) : <EOL> serializer_class = self . get_serializer_class ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) <EOL> can_see = self . get_menu_field ( serializer_class ) <EOL> self . request . permission_fields = can_see <EOL> if isinstance ( self . request . data , list ) : <EOL> with transaction . atomic ( ) : <EOL> return serializer_class ( many = True , * args , ** kwargs ) <EOL> else : <EOL> return serializer_class ( * args , ** kwargs ) <EOL> def get_menu_field ( self , serializer_class ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is serializer_class . Meta . model : <EOL> finded = True <EOL> ", "gt": "break"}
{"input": "import hashlib <EOL> import random <EOL> CHAR_SET = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def random_str ( number = <NUM_LIT> ) : <EOL> result = \"<STR_LIT>\" <EOL> for i in range ( <NUM_LIT> , number ) : <EOL> inx = random . randint ( <NUM_LIT> , len ( CHAR_SET ) - <NUM_LIT> ) <EOL> ", "gt": "result += CHAR_SET [ inx ]"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> obj . objects . all ( ) . delete ( ) <EOL> settings . INITIALIZE_RESET_LIST . append ( obj ) <EOL> except Exception : <EOL> pass <EOL> for ele in data : <EOL> m2m_dict = { } <EOL> new_data = { } <EOL> for key , value in ele . items ( ) : <EOL> if isinstance ( value , list ) and value and isinstance ( value [ <NUM_LIT> ] , int ) : <EOL> m2m_dict [ key ] = value <EOL> else : <EOL> new_data [ key ] = value <EOL> object , _ = obj . objects . get_or_create ( id = ele . get ( \"<STR_LIT>\" ) , defaults = new_data ) <EOL> for key , m2m in m2m_dict . items ( ) : <EOL> ", "gt": "m2m = list ( set ( m2m ) )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> queryset = self . queryset . filter ( status = <NUM_LIT> ) <EOL> else : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def get_all_menu ( self , request ) : <EOL> user = request . user <EOL> queryset = self . queryset . all ( ) <EOL> if not user . is_superuser : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' ) <EOL> ", "gt": "queryset = Menu . objects . filter ( id__in = menu_list )"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> ", "gt": "re_path ("}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> ", "gt": "model = view . get_queryset ( ) . model"}
{"input": "import hashlib <EOL> import logging <EOL> from django . contrib . auth import get_user_model <EOL> from django . contrib . auth . backends import ModelBackend <EOL> from django . contrib . auth . hashers import check_password <EOL> from django . utils import timezone <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> logger = logging . getLogger ( __name__ ) <EOL> UserModel = get_user_model ( ) <EOL> class CustomBackend ( ModelBackend ) : <EOL> def authenticate ( self , request , username = None , password = None , ** kwargs ) : <EOL> msg = '<STR_LIT>' % username <EOL> logger . info ( msg ) <EOL> if username is None : <EOL> username = kwargs . get ( UserModel . USERNAME_FIELD ) <EOL> try : <EOL> user = UserModel . _default_manager . get_by_natural_key ( username ) <EOL> except UserModel . DoesNotExist : <EOL> UserModel ( ) . set_password ( password ) <EOL> else : <EOL> ", "gt": "verify_password = check_password ( password , user . password )"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> if not getattr ( settings , \"<STR_LIT>\" , False ) : <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginTokenView ( TokenObtainPairView ) : <EOL> serializer_class = LoginTokenSerializer <EOL> permission_classes = [ ] <EOL> class LogoutView ( APIView ) : <EOL> def post ( self , request ) : <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> class ApiLoginSerializer ( CustomModelSerializer ) : <EOL> username = serializers . CharField ( ) <EOL> password = serializers . CharField ( ) <EOL> class Meta : <EOL> model = Users <EOL> fields = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class ApiLogin ( APIView ) : <EOL> serializer_class = ApiLoginSerializer <EOL> ", "gt": "authentication_classes = [ ]"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> if not getattr ( settings , \"<STR_LIT>\" , False ) : <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginTokenView ( TokenObtainPairView ) : <EOL> serializer_class = LoginTokenSerializer <EOL> permission_classes = [ ] <EOL> class LogoutView ( APIView ) : <EOL> def post ( self , request ) : <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> class ApiLoginSerializer ( CustomModelSerializer ) : <EOL> username = serializers . CharField ( ) <EOL> password = serializers . CharField ( ) <EOL> class Meta : <EOL> model = Users <EOL> fields = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class ApiLogin ( APIView ) : <EOL> serializer_class = ApiLoginSerializer <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def post ( self , request ) : <EOL> username = request . data . get ( \"<STR_LIT>\" ) <EOL> password = request . data . get ( \"<STR_LIT>\" ) <EOL> user_obj = auth . authenticate ( <EOL> request , <EOL> username = username , <EOL> password = hashlib . md5 ( password . encode ( encoding = \"<STR_LIT>\" ) ) . hexdigest ( ) , <EOL> ) <EOL> if user_obj : <EOL> ", "gt": "login ( request , user_obj )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> next_menu = Dept . objects . filter ( sort__gt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if next_menu : <EOL> next_menu . sort , dept . sort = dept . sort , next_menu . sort <EOL> next_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def dept_info ( self , request ) : <EOL> def inner ( did , li ) : <EOL> sub = Dept . objects . filter ( parent_id = did ) <EOL> if not sub . exists ( ) : <EOL> return li <EOL> for i in sub : <EOL> li . append ( i . pk ) <EOL> inner ( i , li ) <EOL> return li <EOL> dept_id = request . query_params . get ( '<STR_LIT>' ) <EOL> show_all = request . query_params . get ( '<STR_LIT>' ) <EOL> if dept_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if not show_all : <EOL> show_all = <NUM_LIT> <EOL> if int ( show_all ) : <EOL> all_did = [ dept_id ] <EOL> inner ( dept_id , all_did ) <EOL> users = Users . objects . filter ( dept_id__in = all_did ) <EOL> else : <EOL> ", "gt": "if dept_id != '<STR_LIT>' :"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> ", "gt": "return False"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> next_menu = Dept . objects . filter ( sort__gt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if next_menu : <EOL> next_menu . sort , dept . sort = dept . sort , next_menu . sort <EOL> next_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def dept_info ( self , request ) : <EOL> def inner ( did , li ) : <EOL> sub = Dept . objects . filter ( parent_id = did ) <EOL> if not sub . exists ( ) : <EOL> return li <EOL> for i in sub : <EOL> li . append ( i . pk ) <EOL> inner ( i , li ) <EOL> return li <EOL> dept_id = request . query_params . get ( '<STR_LIT>' ) <EOL> show_all = request . query_params . get ( '<STR_LIT>' ) <EOL> if dept_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if not show_all : <EOL> show_all = <NUM_LIT> <EOL> if int ( show_all ) : <EOL> all_did = [ dept_id ] <EOL> inner ( dept_id , all_did ) <EOL> ", "gt": "users = Users . objects . filter ( dept_id__in = all_did )"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( \"<STR_LIT>\" , include ( \"<STR_LIT>\" ) ) , <EOL> path ( \"<STR_LIT>\" , LoginView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> ", "gt": "path ( \"<STR_LIT>\" , LogoutView . as_view ( ) , name = \"<STR_LIT>\" ) ,"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> ", "gt": "dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True )"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterViewSet ( CustomModelViewSet ) : <EOL> queryset = MessageCenter . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MessageCenterSerializer <EOL> create_serializer_class = MessageCenterCreateSerializer <EOL> extra_filter_backends = [ ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> return MessageCenter . objects . filter ( creator = self . request . user . id ) . all ( ) <EOL> return MessageCenter . objects . all ( ) <EOL> def retrieve ( self , request , * args , ** kwargs ) : <EOL> pk = kwargs . get ( '<STR_LIT>' ) <EOL> user_id = self . request . user . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( users__id = user_id , messagecenter__id = pk ) . first ( ) <EOL> if queryset : <EOL> queryset . is_read = True <EOL> queryset . save ( ) <EOL> instance = self . get_object ( ) <EOL> ", "gt": "serializer = self . get_serializer ( instance )"}
{"input": "import logging <EOL> import traceback <EOL> from django . db . models import ProtectedError <EOL> from django . http import Http404 <EOL> from rest_framework . exceptions import APIException as DRFAPIException , AuthenticationFailed , NotAuthenticated <EOL> from rest_framework . status import HTTP_401_UNAUTHORIZED <EOL> from rest_framework . views import set_rollback , exception_handler <EOL> from dvadmin . utils . json_response import ErrorResponse <EOL> logger = logging . getLogger ( __name__ ) <EOL> class CustomAuthenticationFailed ( NotAuthenticated ) : <EOL> status_code = <NUM_LIT> <EOL> def CustomExceptionHandler ( ex , context ) : <EOL> msg = '<STR_LIT>' <EOL> code = <NUM_LIT> <EOL> response = exception_handler ( ex , context ) <EOL> if isinstance ( ex , AuthenticationFailed ) : <EOL> if response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> return ErrorResponse ( status = HTTP_401_UNAUTHORIZED ) <EOL> else : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif isinstance ( ex , Http404 ) : <EOL> code = <NUM_LIT> <EOL> ", "gt": "msg = \"<STR_LIT>\""}
{"input": "from functools import wraps <EOL> from django . db . models import Func , F , OuterRef , Exists <EOL> from django . test import TestCase <EOL> import django <EOL> import os <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . system . models import Menu , RoleMenuPermission , RoleMenuButtonPermission , MenuButton <EOL> import time <EOL> def timing_decorator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = func ( * args , ** kwargs ) <EOL> end_time = time . time ( ) <EOL> run_time = end_time - start_time <EOL> print ( f\"<STR_LIT>\" ) <EOL> return result <EOL> return wrapper <EOL> @ timing_decorator <EOL> def getMenu ( ) : <EOL> data = [ ] <EOL> queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> for item in queryset : <EOL> parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) <EOL> names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] <EOL> completeName = \"<STR_LIT>\" . join ( names ) <EOL> isCheck = RoleMenuPermission . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> role__id = <NUM_LIT> , <EOL> ) . exists ( ) <EOL> mbCheck = RoleMenuButtonPermission . objects . filter ( <EOL> menu_button = OuterRef ( \"<STR_LIT>\" ) , <EOL> ", "gt": "role__id = <NUM_LIT> ,"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> elif value_type == '<STR_LIT>' : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) <EOL> else : <EOL> if type ( cell_value ) is float and str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] == \"<STR_LIT>\" : <EOL> cell_value = int ( str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ) <EOL> elif type ( cell_value ) is str : <EOL> cell_value = cell_value . strip ( \"<STR_LIT>\" ) <EOL> if key in validation_data_dict : <EOL> array [ key ] = validation_data_dict . get ( key , { } ) . get ( cell_value , None ) <EOL> if key in m2m_fields : <EOL> array [ key ] = list ( <EOL> ", "gt": "filter ("}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> class AutoFilterSet ( self . filterset_base ) : <EOL> @ classmethod <EOL> def get_all_model_fields ( cls , model ) : <EOL> opts = model . _meta <EOL> return [ <EOL> f . name <EOL> for f in sorted ( opts . fields + opts . many_to_many ) <EOL> if ( f . name == \"<STR_LIT>\" ) <EOL> or not isinstance ( f , models . AutoField ) <EOL> and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) <EOL> ] <EOL> @ classmethod <EOL> def get_fields ( cls ) : <EOL> model = cls . _meta . model <EOL> ", "gt": "fields = cls . _meta . fields"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) <EOL> else : <EOL> nested_dict [ target_key ] = new_value <EOL> return nested_dict <EOL> def __handle_crud ( self ) : <EOL> result = self . __get_field_attribute ( ) <EOL> columns = dict ( ) <EOL> for item in result : <EOL> key = item . get ( '<STR_LIT>' ) <EOL> title = item . get ( '<STR_LIT>' ) <EOL> type = item . get ( '<STR_LIT>' ) <EOL> columns [ key ] = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : key , <EOL> \"<STR_LIT>\" : type <EOL> } <EOL> ", "gt": "if self . custom_crud_json and isinstance ( self . custom_crud_json , dict ) :"}
{"input": "from django . db import DataError <EOL> from rest_framework . exceptions import APIException <EOL> from rest_framework . validators import UniqueValidator <EOL> class CustomValidationError ( APIException ) : <EOL> def __init__ ( self , detail ) : <EOL> self . detail = detail <EOL> def qs_exists ( queryset ) : <EOL> try : <EOL> return queryset . exists ( ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return False <EOL> def qs_filter ( queryset , ** kwargs ) : <EOL> try : <EOL> return queryset . filter ( ** kwargs ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return queryset . none ( ) <EOL> class CustomUniqueValidator ( UniqueValidator ) : <EOL> def filter_queryset ( self , value , queryset , field_name ) : <EOL> filter_kwargs = { '<STR_LIT>' % ( field_name , self . lookup ) : value } <EOL> return qs_filter ( queryset , ** filter_kwargs ) <EOL> ", "gt": "def exclude_current_instance ( self , queryset , instance ) :"}
{"input": "from rest_framework . views import APIView <EOL> from django . shortcuts import render <EOL> class PrivacyView ( APIView ) : <EOL> permission_classes = [ ] <EOL> def get ( self , request , * args , ** kwargs ) : <EOL> return render ( request , '<STR_LIT>' ) <EOL> ", "gt": "class TermsServiceView ( APIView ) :"}
{"input": "import os <EOL> exclude = [ \"<STR_LIT>\" ] <EOL> for root , dirs , files in os . walk ( '<STR_LIT>' ) : <EOL> dirs [ : ] = list ( set ( dirs ) - set ( exclude ) ) <EOL> if '<STR_LIT>' in dirs : <EOL> dir = dirs [ dirs . index ( '<STR_LIT>' ) ] <EOL> for root_j , dirs_j , files_j in os . walk ( os . path . join ( root , dir ) ) : <EOL> for file_k in files_j : <EOL> if file_k != '<STR_LIT>' : <EOL> dst_file = os . path . join ( root_j , file_k ) <EOL> ", "gt": "print ( '<STR_LIT>' , dst_file )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DeptSerializer ( CustomModelSerializer ) : <EOL> parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) <EOL> status_label = serializers . SerializerMethodField ( ) <EOL> has_children = serializers . SerializerMethodField ( ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> dept_user_count = serializers . SerializerMethodField ( ) <EOL> def get_dept_user_count ( self , obj : Dept ) : <EOL> return Users . objects . filter ( dept = obj ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Dept . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> def get_status_label ( self , obj : Dept ) : <EOL> if obj . status : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_has_children ( self , obj : Dept ) : <EOL> return Dept . objects . filter ( parent_id = obj . id ) . count ( ) <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptImportSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DeptCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> def create ( self , validated_data ) : <EOL> value = validated_data . get ( '<STR_LIT>' , None ) <EOL> if value is None : <EOL> validated_data [ '<STR_LIT>' ] = self . request . user . dept <EOL> dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = dept_obj . sort if dept_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> instance = super ( ) . create ( validated_data ) <EOL> instance . dept_belong_id = instance . id <EOL> instance . save ( ) <EOL> return instance <EOL> class Meta : <EOL> model = Dept <EOL> fields = '<STR_LIT>' <EOL> class DeptViewSet ( CustomModelViewSet ) : <EOL> queryset = Dept . objects . all ( ) <EOL> serializer_class = DeptSerializer <EOL> create_serializer_class = DeptCreateUpdateSerializer <EOL> update_serializer_class = DeptCreateUpdateSerializer <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> search_fields = [ ] <EOL> import_serializer_class = DeptImportSerializer <EOL> import_field_dict = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and parent : <EOL> queryset = self . queryset . filter ( status = True , parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( status = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = DeptSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def dept_lazy_tree ( self , request , * args , ** kwargs ) : <EOL> parent = self . request . query_params . get ( '<STR_LIT>' ) <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> user_dept_id = request . user . dept . id <EOL> dept_list = [ user_dept_id ] <EOL> data_range_list = list ( set ( data_range ) ) <EOL> for item in data_range_list : <EOL> if item in [ <NUM_LIT> , <NUM_LIT> ] : <EOL> dept_list = [ user_dept_id ] <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> elif item == <NUM_LIT> : <EOL> dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> dept_list = [ ] <EOL> queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) <EOL> def all_dept ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_up ( self , request ) : <EOL> dept_id = request . data . get ( '<STR_LIT>' ) <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if previous_menu : <EOL> previous_menu . sort , dept . sort = dept . sort , previous_menu . sort <EOL> previous_menu . save ( ) <EOL> dept . save ( ) <EOL> return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def move_down ( self , request ) : <EOL> dept_id = request . data [ '<STR_LIT>' ] <EOL> try : <EOL> dept = Dept . objects . get ( id = dept_id ) <EOL> except Dept . DoesNotExist : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> next_menu = Dept . objects . filter ( sort__gt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> if next_menu : <EOL> next_menu . sort , dept . sort = dept . sort , next_menu . sort <EOL> ", "gt": "next_menu . save ( )"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_role = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : data . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) <EOL> websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) <EOL> return data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterViewSet ( CustomModelViewSet ) : <EOL> queryset = MessageCenter . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MessageCenterSerializer <EOL> create_serializer_class = MessageCenterCreateSerializer <EOL> extra_filter_backends = [ ] <EOL> def get_queryset ( self ) : <EOL> ", "gt": "if self . action == '<STR_LIT>' :"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import MenuButton , RoleMenuButtonPermission <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuButtonSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuButton . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuButtonSerializer <EOL> create_serializer_class = MenuButtonCreateUpdateSerializer <EOL> update_serializer_class = MenuButtonCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> ", "gt": "def list ( self , request , * args , ** kwargs ) :"}
{"input": "import operator <EOL> import re <EOL> from collections import OrderedDict <EOL> from functools import reduce <EOL> import six <EOL> from django . db import models <EOL> from django . db . models import Q , F <EOL> from django . db . models . constants import LOOKUP_SEP <EOL> from django_filters import utils , FilterSet <EOL> from django_filters . constants import ALL_FIELDS <EOL> from django_filters . filters import CharFilter , DateTimeFromToRangeFilter <EOL> from django_filters . rest_framework import DjangoFilterBackend <EOL> from django_filters . utils import get_model_field <EOL> from rest_framework . filters import BaseFilterBackend <EOL> from django_filters . conf import settings <EOL> from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission <EOL> from dvadmin . utils . models import CoreModel <EOL> class CoreModelFilterBankend ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) <EOL> update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) <EOL> if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : <EOL> create_filter = Q ( ) <EOL> if create_datetime_after and create_datetime_before : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) <EOL> elif create_datetime_after : <EOL> create_filter &= Q ( create_datetime__gte = create_datetime_after ) <EOL> elif create_datetime_before : <EOL> create_filter &= Q ( create_datetime__lte = create_datetime_before ) <EOL> update_filter = Q ( ) <EOL> if update_datetime_after and update_datetime_before : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) <EOL> elif update_datetime_after : <EOL> update_filter &= Q ( update_datetime__gte = update_datetime_after ) <EOL> elif update_datetime_before : <EOL> update_filter &= Q ( update_datetime__lte = update_datetime_before ) <EOL> queryset = queryset . filter ( create_filter & update_filter ) <EOL> return queryset <EOL> return queryset <EOL> def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : <EOL> if not dept_all_list : <EOL> dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if dept_list is None : <EOL> dept_list = [ dept_id ] <EOL> for ele in dept_all_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == dept_id : <EOL> dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) <EOL> return list ( set ( dept_list ) ) <EOL> class DataLevelPermissionsFilter ( BaseFilterBackend ) : <EOL> def filter_queryset ( self , request , queryset , view ) : <EOL> api = request . path <EOL> method = request . method <EOL> methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> method = methodList . index ( method ) <EOL> api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( <EOL> permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) <EOL> ) <EOL> api_white_list = [ <EOL> str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> + \"<STR_LIT>\" <EOL> + str ( item . get ( \"<STR_LIT>\" ) ) <EOL> for item in api_white_list <EOL> if item . get ( \"<STR_LIT>\" ) <EOL> ] <EOL> for item in api_white_list : <EOL> new_api = f\"<STR_LIT>\" <EOL> matchObj = re . match ( item , new_api , re . M | re . I ) <EOL> if matchObj is None : <EOL> continue <EOL> else : <EOL> return queryset <EOL> if request . user . is_superuser == <NUM_LIT> : <EOL> return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) <EOL> else : <EOL> return queryset <EOL> def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : <EOL> user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) <EOL> if not user_dept_id : <EOL> return queryset . none ( ) <EOL> if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : <EOL> return queryset <EOL> if not hasattr ( request . user , \"<STR_LIT>\" ) : <EOL> return queryset . filter ( dept_belong_id = user_dept_id ) <EOL> re_api = api <EOL> _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) <EOL> if _pk : <EOL> re_api = re . sub ( _pk , '<STR_LIT>' , api ) <EOL> role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> role_permission_list = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> menu_button__api = re_api , <EOL> menu_button__method = method ) . values ( <EOL> '<STR_LIT>' <EOL> ) <EOL> dataScope_list = [ ] <EOL> for ele in role_permission_list : <EOL> if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> return queryset <EOL> dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> dataScope_list = list ( set ( dataScope_list ) ) <EOL> if <NUM_LIT> in dataScope_list : <EOL> return queryset . filter ( <EOL> creator = request . user , dept_belong_id = user_dept_id <EOL> ) <EOL> dept_list = [ ] <EOL> for ele in dataScope_list : <EOL> if ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> dept_list . extend ( <EOL> get_dept ( <EOL> user_dept_id , <EOL> ) <EOL> ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_list . append ( user_dept_id ) <EOL> elif ele == <NUM_LIT> : <EOL> dept_ids = RoleMenuButtonPermission . objects . filter ( <EOL> role__in = role_id_list , <EOL> role__status = <NUM_LIT> , <EOL> data_range = <NUM_LIT> ) . values_list ( <EOL> '<STR_LIT>' , flat = True <EOL> ) <EOL> dept_list . extend ( <EOL> dept_ids <EOL> ) <EOL> if queryset . model . _meta . model_name == '<STR_LIT>' : <EOL> return queryset . filter ( id__in = list ( set ( dept_list ) ) ) <EOL> return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) <EOL> class CustomDjangoFilterBackend ( DjangoFilterBackend ) : <EOL> lookup_prefixes = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> filter_fields = \"<STR_LIT>\" <EOL> def construct_search ( self , field_name , lookup_expr = None ) : <EOL> lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) <EOL> if lookup : <EOL> field_name = field_name [ <NUM_LIT> : ] <EOL> else : <EOL> lookup = lookup_expr <EOL> if lookup : <EOL> if field_name . endswith ( lookup ) : <EOL> return field_name <EOL> return LOOKUP_SEP . join ( [ field_name , lookup ] ) <EOL> return field_name <EOL> def find_filter_lookups ( self , orm_lookups , search_term_key ) : <EOL> for lookup in orm_lookups : <EOL> new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup <EOL> if new_lookup == search_term_key : <EOL> return lookup <EOL> return None <EOL> def get_filterset_class ( self , view , queryset = None ) : <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> filterset_class = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : <EOL> utils . deprecate ( <EOL> \"<STR_LIT>\" % view . __class__ . __name__ <EOL> ) <EOL> self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) <EOL> if isinstance ( self . filter_fields , ( list , tuple ) ) : <EOL> filterset_fields = [ <EOL> field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields <EOL> ] <EOL> else : <EOL> filterset_fields = self . filter_fields <EOL> if filterset_class : <EOL> filterset_model = filterset_class . _meta . model <EOL> if filterset_model and queryset is not None : <EOL> assert issubclass ( <EOL> queryset . model , filterset_model <EOL> ) , \"<STR_LIT>\" % ( <EOL> filterset_model , <EOL> queryset . model , <EOL> ) <EOL> return filterset_class <EOL> if filterset_fields and queryset is not None : <EOL> MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) <EOL> ", "gt": "class AutoFilterSet ( self . filterset_base ) :"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> var_name = body . get ( '<STR_LIT>' , None ) <EOL> table = body . get ( '<STR_LIT>' , None ) <EOL> instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> relation_id = body . get ( '<STR_LIT>' , None ) <EOL> relationIds = [ ] <EOL> if relation_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if instance . form_item_type in [ <NUM_LIT> ] : <EOL> ", "gt": "relationIds = [ relation_id ]"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) <EOL> queryset = model . objects . values ( ) <EOL> body = request . query_params <EOL> search_value = body . get ( '<STR_LIT>' , None ) <EOL> if search_value : <EOL> search_fields = setting . get ( '<STR_LIT>' ) <EOL> filters = Q ( ) <EOL> filters . connector = '<STR_LIT>' <EOL> for item in search_fields : <EOL> filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) <EOL> filters . children . append ( ( filed , search_value ) ) <EOL> queryset = model . objects . filter ( filters ) . values ( ) <EOL> page = self . paginate_queryset ( queryset ) <EOL> if page is not None : <EOL> return self . get_paginated_response ( queryset ) <EOL> return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) <EOL> def get_relation_info ( self , request ) : <EOL> body = request . query_params <EOL> var_name = body . get ( '<STR_LIT>' , None ) <EOL> table = body . get ( '<STR_LIT>' , None ) <EOL> instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> relation_id = body . get ( '<STR_LIT>' , None ) <EOL> relationIds = [ ] <EOL> if relation_id is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> if instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = [ relation_id ] <EOL> elif instance . form_item_type in [ <NUM_LIT> ] : <EOL> relationIds = relation_id . split ( '<STR_LIT>' ) <EOL> queryset = SystemConfig . objects . filter ( value__in = relationIds ) . first ( ) <EOL> if queryset is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> serializer = SystemConfigChinldernSerializer ( queryset . parent ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = serializer . data ) <EOL> class InitSettingsViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> def filter_system_config_values ( self , data : dict ) : <EOL> if not self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> ", "gt": "return data"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> return queryset <EOL> else : <EOL> return self . queryset <EOL> class InitDictionaryViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> queryset = Dictionary . objects . all ( ) <EOL> def get ( self , request ) : <EOL> ", "gt": "dictionary_key = self . request . query_params . get ( '<STR_LIT>' )"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> obj . objects . all ( ) . delete ( ) <EOL> settings . INITIALIZE_RESET_LIST . append ( obj ) <EOL> except Exception : <EOL> pass <EOL> for ele in data : <EOL> m2m_dict = { } <EOL> new_data = { } <EOL> ", "gt": "for key , value in ele . items ( ) :"}
{"input": "from django . urls import path <EOL> from rest_framework import routers <EOL> from dvadmin . system . views . api_white_list import ApiWhiteListViewSet <EOL> from dvadmin . system . views . area import AreaViewSet <EOL> from dvadmin . system . views . clause import PrivacyView , TermsServiceView <EOL> from dvadmin . system . views . dept import DeptViewSet <EOL> from dvadmin . system . views . dictionary import DictionaryViewSet <EOL> from dvadmin . system . views . file_list import FileViewSet <EOL> from dvadmin . system . views . login_log import LoginLogViewSet <EOL> from dvadmin . system . views . menu import MenuViewSet <EOL> from dvadmin . system . views . menu_button import MenuButtonViewSet <EOL> from dvadmin . system . views . message_center import MessageCenterViewSet <EOL> from dvadmin . system . views . operation_log import OperationLogViewSet <EOL> from dvadmin . system . views . role import RoleViewSet <EOL> from dvadmin . system . views . role_menu import RoleMenuPermissionViewSet <EOL> from dvadmin . system . views . role_menu_button_permission import RoleMenuButtonPermissionViewSet <EOL> from dvadmin . system . views . system_config import SystemConfigViewSet <EOL> from dvadmin . system . views . user import UserViewSet <EOL> from dvadmin . system . views . menu_field import MenuFieldViewSet <EOL> system_url = routers . SimpleRouter ( ) <EOL> system_url . register ( r'<STR_LIT>' , MenuViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , MenuButtonViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , RoleViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DeptViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , UserViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , OperationLogViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , DictionaryViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , AreaViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , FileViewSet ) <EOL> system_url . register ( r'<STR_LIT>' , ApiWhiteListViewSet ) <EOL> ", "gt": "system_url . register ( r'<STR_LIT>' , SystemConfigViewSet )"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> return settings . ALL_MODELS_OBJECTS [ model_name ] or { } <EOL> return settings . ALL_MODELS_OBJECTS or { } <EOL> def get_model_from_app ( app_name ) : <EOL> model_module = import_module ( app_name + '<STR_LIT>' ) <EOL> filter_model = [ <EOL> getattr ( model_module , item ) for item in dir ( model_module ) <EOL> if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) <EOL> ] <EOL> model_list = [ ] <EOL> for model in filter_model : <EOL> if model . __name__ == '<STR_LIT>' : <EOL> continue <EOL> fields = [ <EOL> { '<STR_LIT>' : field . verbose_name , '<STR_LIT>' : field . name , '<STR_LIT>' : field } <EOL> for field in model . _meta . fields <EOL> ] <EOL> model_list . append ( { <EOL> '<STR_LIT>' : app_name , <EOL> '<STR_LIT>' : model . _meta . verbose_name , <EOL> '<STR_LIT>' : model . __name__ , <EOL> '<STR_LIT>' : model , <EOL> '<STR_LIT>' : fields <EOL> } ) <EOL> return model_list <EOL> def get_custom_app_models ( app_name = None ) : <EOL> if app_name : <EOL> return get_model_from_app ( app_name ) <EOL> all_apps = apps . get_app_configs ( ) <EOL> res = [ ] <EOL> for app in all_apps : <EOL> if app . name . startswith ( '<STR_LIT>' ) : <EOL> continue <EOL> if app . name in settings . COLUMN_EXCLUDE_APPS : <EOL> continue <EOL> try : <EOL> ", "gt": "all_models = get_model_from_app ( app . name )"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import MenuButton , RoleMenuButtonPermission <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuButtonSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuButton <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuButtonViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuButton . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuButtonSerializer <EOL> create_serializer_class = MenuButtonCreateUpdateSerializer <EOL> update_serializer_class = MenuButtonCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) . order_by ( '<STR_LIT>' ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( serializer . data , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def menu_button_all_permission ( self , request ) : <EOL> is_superuser = request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> else : <EOL> role_id = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> ", "gt": "queryset = RoleMenuButtonPermission . objects . filter ( role__in = role_id ) . values_list ( '<STR_LIT>' , flat = True ) . distinct ( )"}
{"input": "import hashlib <EOL> import random <EOL> CHAR_SET = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def random_str ( number = <NUM_LIT> ) : <EOL> result = \"<STR_LIT>\" <EOL> for i in range ( <NUM_LIT> , number ) : <EOL> inx = random . randint ( <NUM_LIT> , len ( CHAR_SET ) - <NUM_LIT> ) <EOL> result += CHAR_SET [ inx ] <EOL> return result <EOL> def has_md5 ( str , salt = '<STR_LIT>' ) : <EOL> str = str + salt <EOL> md = hashlib . md5 ( ) <EOL> md . update ( str . encode ( ) ) <EOL> ", "gt": "res = md . hexdigest ( )"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> class FieldPermissionMixin : <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def field_permission ( self , request ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is self . serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded : <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> user = request . user <EOL> if user . is_superuser == <NUM_LIT> : <EOL> data = MenuField . objects . filter ( model = model [ '<STR_LIT>' ] ) . values ( '<STR_LIT>' ) <EOL> for item in data : <EOL> item [ '<STR_LIT>' ] = True <EOL> item [ '<STR_LIT>' ] = True <EOL> ", "gt": "item [ '<STR_LIT>' ] = True"}
{"input": "import logging <EOL> import traceback <EOL> from django . db . models import ProtectedError <EOL> from django . http import Http404 <EOL> from rest_framework . exceptions import APIException as DRFAPIException , AuthenticationFailed , NotAuthenticated <EOL> from rest_framework . status import HTTP_401_UNAUTHORIZED <EOL> from rest_framework . views import set_rollback , exception_handler <EOL> from dvadmin . utils . json_response import ErrorResponse <EOL> logger = logging . getLogger ( __name__ ) <EOL> class CustomAuthenticationFailed ( NotAuthenticated ) : <EOL> status_code = <NUM_LIT> <EOL> def CustomExceptionHandler ( ex , context ) : <EOL> msg = '<STR_LIT>' <EOL> code = <NUM_LIT> <EOL> response = exception_handler ( ex , context ) <EOL> if isinstance ( ex , AuthenticationFailed ) : <EOL> if response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> ", "gt": "return ErrorResponse ( status = HTTP_401_UNAUTHORIZED )"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> class FieldPermissionMixin : <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def field_permission ( self , request ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is self . serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded : <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> user = request . user <EOL> if user . is_superuser == <NUM_LIT> : <EOL> data = MenuField . objects . filter ( model = model [ '<STR_LIT>' ] ) . values ( '<STR_LIT>' ) <EOL> for item in data : <EOL> item [ '<STR_LIT>' ] = True <EOL> item [ '<STR_LIT>' ] = True <EOL> item [ '<STR_LIT>' ] = True <EOL> ", "gt": "else :"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> elif value_type == '<STR_LIT>' : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) <EOL> else : <EOL> if type ( cell_value ) is float and str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] == \"<STR_LIT>\" : <EOL> cell_value = int ( str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ) <EOL> elif type ( cell_value ) is str : <EOL> cell_value = cell_value . strip ( \"<STR_LIT>\" ) <EOL> if key in validation_data_dict : <EOL> array [ key ] = validation_data_dict . get ( key , { } ) . get ( cell_value , None ) <EOL> if key in m2m_fields : <EOL> array [ key ] = list ( <EOL> filter ( <EOL> lambda x : x , <EOL> [ <EOL> validation_data_dict . get ( key , { } ) . get ( value , None ) <EOL> for value in re . split ( r\"<STR_LIT>\" , cell_value ) <EOL> ] , <EOL> ) <EOL> ", "gt": ")"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> obj . objects . all ( ) . delete ( ) <EOL> settings . INITIALIZE_RESET_LIST . append ( obj ) <EOL> except Exception : <EOL> pass <EOL> for ele in data : <EOL> m2m_dict = { } <EOL> new_data = { } <EOL> for key , value in ele . items ( ) : <EOL> if isinstance ( value , list ) and value and isinstance ( value [ <NUM_LIT> ] , int ) : <EOL> m2m_dict [ key ] = value <EOL> else : <EOL> new_data [ key ] = value <EOL> ", "gt": "object , _ = obj . objects . get_or_create ( id = ele . get ( \"<STR_LIT>\" ) , defaults = new_data )"}
{"input": "from dvadmin . system . models import ApiWhiteList <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class ApiWhiteListSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = ApiWhiteList <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> ", "gt": "class ApiWhiteListViewSet ( CustomModelViewSet ) :"}
{"input": "import logging <EOL> import traceback <EOL> from django . db . models import ProtectedError <EOL> from django . http import Http404 <EOL> from rest_framework . exceptions import APIException as DRFAPIException , AuthenticationFailed , NotAuthenticated <EOL> from rest_framework . status import HTTP_401_UNAUTHORIZED <EOL> from rest_framework . views import set_rollback , exception_handler <EOL> from dvadmin . utils . json_response import ErrorResponse <EOL> logger = logging . getLogger ( __name__ ) <EOL> class CustomAuthenticationFailed ( NotAuthenticated ) : <EOL> status_code = <NUM_LIT> <EOL> def CustomExceptionHandler ( ex , context ) : <EOL> msg = '<STR_LIT>' <EOL> code = <NUM_LIT> <EOL> response = exception_handler ( ex , context ) <EOL> if isinstance ( ex , AuthenticationFailed ) : <EOL> if response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> return ErrorResponse ( status = HTTP_401_UNAUTHORIZED ) <EOL> else : <EOL> code = <NUM_LIT> <EOL> msg = ex . detail <EOL> elif isinstance ( ex , Http404 ) : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> elif isinstance ( ex , DRFAPIException ) : <EOL> set_rollback ( ) <EOL> msg = ex . detail <EOL> if isinstance ( msg , dict ) : <EOL> for k , v in msg . items ( ) : <EOL> for i in v : <EOL> msg = \"<STR_LIT>\" % ( k , i ) <EOL> elif isinstance ( ex , ProtectedError ) : <EOL> set_rollback ( ) <EOL> msg = \"<STR_LIT>\" <EOL> ", "gt": "elif isinstance ( ex , Exception ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> return queryset <EOL> else : <EOL> ", "gt": "return self . queryset"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> ", "gt": "if model :"}
{"input": "import os <EOL> import re <EOL> from datetime import datetime <EOL> import openpyxl <EOL> from django . conf import settings <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> def import_to_data ( file_url , field_data , m2m_fields = None ) : <EOL> file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) <EOL> workbook = openpyxl . load_workbook ( file_path_dir ) <EOL> table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] <EOL> theader = tuple ( table . values ) [ <NUM_LIT> ] <EOL> is_update = '<STR_LIT>' in theader <EOL> if is_update is False : <EOL> field_data . pop ( '<STR_LIT>' ) <EOL> validation_data_dict = { } <EOL> for key , value in field_data . items ( ) : <EOL> if isinstance ( value , dict ) : <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> data_dict = { } <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : <EOL> data_dict [ k ] = v <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> for ele in data_list : <EOL> data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) <EOL> else : <EOL> continue <EOL> validation_data_dict [ key ] = data_dict <EOL> tables = [ ] <EOL> for i , row in enumerate ( range ( table . max_row ) ) : <EOL> if i == <NUM_LIT> : <EOL> continue <EOL> array = { } <EOL> for index , item in enumerate ( field_data . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> values = items [ <NUM_LIT> ] <EOL> value_type = '<STR_LIT>' <EOL> if isinstance ( values , dict ) : <EOL> value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value <EOL> if cell_value is None or cell_value == '<STR_LIT>' : <EOL> continue <EOL> elif value_type == '<STR_LIT>' : <EOL> print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) <EOL> try : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) <EOL> except : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> elif value_type == '<STR_LIT>' : <EOL> cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) <EOL> else : <EOL> if type ( cell_value ) is float and str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] == \"<STR_LIT>\" : <EOL> cell_value = int ( str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ) <EOL> ", "gt": "elif type ( cell_value ) is str :"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . method == \"<STR_LIT>\" : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return self . readiness ( request ) <EOL> elif request . path == \"<STR_LIT>\" : <EOL> return self . healthz ( request ) <EOL> return self . get_response ( request ) <EOL> def healthz ( self , request ) : <EOL> return HttpResponse ( \"<STR_LIT>\" ) <EOL> def readiness ( self , request ) : <EOL> try : <EOL> from django . db import connections <EOL> for name in connections : <EOL> cursor = connections [ name ] . cursor ( ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> row = cursor . fetchone ( ) <EOL> if row is None : <EOL> return HttpResponseServerError ( \"<STR_LIT>\" ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return HttpResponseServerError ( \"<STR_LIT>\" ) <EOL> try : <EOL> from django . core . cache import caches <EOL> from django . core . cache . backends . memcached import BaseMemcachedCache <EOL> for cache in caches . all ( ) : <EOL> if isinstance ( cache , BaseMemcachedCache ) : <EOL> ", "gt": "stats = cache . _cache . get_stats ( )"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> pass <EOL> return model if model else \"<STR_LIT>\" <EOL> ", "gt": "def get_ip_analysis ( ip ) :"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> ", "gt": "serializer . is_valid ( raise_exception = True )"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> try : <EOL> request_user = self . request . user <EOL> ", "gt": "validated_data [ '<STR_LIT>' ] = request_user . dept . id"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> return settings . ALL_MODELS_OBJECTS [ model_name ] or { } <EOL> return settings . ALL_MODELS_OBJECTS or { } <EOL> def get_model_from_app ( app_name ) : <EOL> model_module = import_module ( app_name + '<STR_LIT>' ) <EOL> filter_model = [ <EOL> getattr ( model_module , item ) for item in dir ( model_module ) <EOL> if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) <EOL> ] <EOL> model_list = [ ] <EOL> ", "gt": "for model in filter_model :"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> ", "gt": "message = event [ '<STR_LIT>' ]"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> return queryset <EOL> else : <EOL> return self . queryset <EOL> class InitDictionaryViewSet ( APIView ) : <EOL> ", "gt": "authentication_classes = [ ]"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" : message"}
{"input": "from functools import wraps <EOL> from django . db . models import Func , F , OuterRef , Exists <EOL> from django . test import TestCase <EOL> import django <EOL> import os <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . system . models import Menu , RoleMenuPermission , RoleMenuButtonPermission , MenuButton <EOL> import time <EOL> def timing_decorator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = func ( * args , ** kwargs ) <EOL> end_time = time . time ( ) <EOL> run_time = end_time - start_time <EOL> print ( f\"<STR_LIT>\" ) <EOL> return result <EOL> return wrapper <EOL> @ timing_decorator <EOL> def getMenu ( ) : <EOL> data = [ ] <EOL> queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> for item in queryset : <EOL> parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) <EOL> names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] <EOL> completeName = \"<STR_LIT>\" . join ( names ) <EOL> isCheck = RoleMenuPermission . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> role__id = <NUM_LIT> , <EOL> ) . exists ( ) <EOL> mbCheck = RoleMenuButtonPermission . objects . filter ( <EOL> menu_button = OuterRef ( \"<STR_LIT>\" ) , <EOL> role__id = <NUM_LIT> , <EOL> ) <EOL> btns = MenuButton . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> ) . annotate ( isCheck = Exists ( mbCheck ) ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , data_range = F ( '<STR_LIT>' ) ) <EOL> dicts = { <EOL> '<STR_LIT>' : completeName , <EOL> '<STR_LIT>' : item [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : isCheck , <EOL> '<STR_LIT>' : btns <EOL> } <EOL> ", "gt": "print ( dicts )"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> obj . objects . all ( ) . delete ( ) <EOL> settings . INITIALIZE_RESET_LIST . append ( obj ) <EOL> except Exception : <EOL> pass <EOL> for ele in data : <EOL> m2m_dict = { } <EOL> new_data = { } <EOL> for key , value in ele . items ( ) : <EOL> if isinstance ( value , list ) and value and isinstance ( value [ <NUM_LIT> ] , int ) : <EOL> m2m_dict [ key ] = value <EOL> else : <EOL> new_data [ key ] = value <EOL> object , _ = obj . objects . get_or_create ( id = ele . get ( \"<STR_LIT>\" ) , defaults = new_data ) <EOL> for key , m2m in m2m_dict . items ( ) : <EOL> m2m = list ( set ( m2m ) ) <EOL> ", "gt": "if m2m and len ( m2m ) > <NUM_LIT> and m2m [ <NUM_LIT> ] :"}
{"input": "from django . db . models import F <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import FieldPermission , MenuField <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> class FieldPermissionMixin : <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def field_permission ( self , request ) : <EOL> finded = False <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] is self . serializer_class . Meta . model : <EOL> finded = True <EOL> break <EOL> if finded : <EOL> break <EOL> if finded is False : <EOL> return [ ] <EOL> user = request . user <EOL> if user . is_superuser == <NUM_LIT> : <EOL> data = MenuField . objects . filter ( model = model [ '<STR_LIT>' ] ) . values ( '<STR_LIT>' ) <EOL> for item in data : <EOL> item [ '<STR_LIT>' ] = True <EOL> item [ '<STR_LIT>' ] = True <EOL> item [ '<STR_LIT>' ] = True <EOL> else : <EOL> roles = request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> data = FieldPermission . objects . filter ( <EOL> field__model = model [ '<STR_LIT>' ] , role__in = roles <EOL> ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , field_name = F ( '<STR_LIT>' ) ) <EOL> ", "gt": "return DetailResponse ( data = data )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> ", "gt": "queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id )"}
{"input": "import os <EOL> import django <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . utils . core_initialize import CoreInitialize <EOL> from dvadmin . system . fixtures . initSerializer import ( <EOL> UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , <EOL> MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , <EOL> SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> ) <EOL> class Initialize ( CoreInitialize ) : <EOL> def init_dept ( self ) : <EOL> self . init_base ( DeptInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role ( self ) : <EOL> self . init_base ( RoleInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_users ( self ) : <EOL> self . init_base ( UsersInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_menu ( self ) : <EOL> self . init_base ( MenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu ( self ) : <EOL> self . init_base ( RoleMenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu_button ( self ) : <EOL> self . init_base ( RoleMenuButtonInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_api_white_list ( self ) : <EOL> self . init_base ( ApiWhiteListInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def init_dictionary ( self ) : <EOL> self . init_base ( DictionaryInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) <EOL> def init_system_config ( self ) : <EOL> ", "gt": "self . init_base ( SystemConfigInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] )"}
{"input": "import urllib <EOL> from asgiref . sync import sync_to_async , async_to_sync <EOL> from channels . db import database_sync_to_async <EOL> from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer <EOL> import json <EOL> from channels . layers import get_channel_layer <EOL> from jwt import InvalidSignatureError <EOL> from rest_framework . request import Request <EOL> from application import settings <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> send_dict = { } <EOL> def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : <EOL> text = { <EOL> '<STR_LIT>' : sender , <EOL> '<STR_LIT>' : msg_type , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : unread <EOL> } <EOL> return text <EOL> @ database_sync_to_async <EOL> def _get_message_center_instance ( message_id ) : <EOL> from dvadmin . system . models import MessageCenter <EOL> _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if _MessageCenter : <EOL> return _MessageCenter <EOL> else : <EOL> return [ ] <EOL> @ database_sync_to_async <EOL> def _get_message_unread ( user_id ) : <EOL> from dvadmin . system . models import MessageCenterTargetUser <EOL> count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) <EOL> return count or <NUM_LIT> <EOL> def request_data ( scope ) : <EOL> query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) <EOL> qs = urllib . parse . parse_qs ( query_string ) <EOL> return qs <EOL> class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : <EOL> async def connect ( self ) : <EOL> try : <EOL> import jwt <EOL> self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) <EOL> if decoded_result : <EOL> self . user_id = decoded_result . get ( '<STR_LIT>' ) <EOL> self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) <EOL> await self . channel_layer . group_add ( <EOL> self . chat_group_name , <EOL> self . channel_name <EOL> ) <EOL> await self . accept ( ) <EOL> unread_count = await _get_message_unread ( self . user_id ) <EOL> if unread_count == <NUM_LIT> : <EOL> await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> else : <EOL> await self . send_json ( <EOL> set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , <EOL> unread = unread_count ) ) <EOL> except InvalidSignatureError : <EOL> await self . disconnect ( None ) <EOL> async def disconnect ( self , close_code ) : <EOL> await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) <EOL> print ( \"<STR_LIT>\" ) <EOL> try : <EOL> await self . close ( close_code ) <EOL> except Exception : <EOL> pass <EOL> class MegCenter ( DvadminWebSocket ) : <EOL> async def receive ( self , text_data ) : <EOL> text_data_json = json . loads ( text_data ) <EOL> message_id = text_data_json . get ( '<STR_LIT>' , None ) <EOL> user_list = await _get_message_center_instance ( message_id ) <EOL> for send_user in user_list : <EOL> await self . channel_layer . group_send ( <EOL> \"<STR_LIT>\" + str ( send_user ) , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } <EOL> ) <EOL> async def push_message ( self , event ) : <EOL> message = event [ '<STR_LIT>' ] <EOL> await self . send ( text_data = json . dumps ( message ) ) <EOL> class MessageCreateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , <EOL> target_role = None , message : dict = None , request = Request ) : <EOL> if message is None : <EOL> message = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } <EOL> if target_role is None : <EOL> target_role = [ ] <EOL> if target_dept is None : <EOL> target_dept = [ ] <EOL> data = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : content , <EOL> \"<STR_LIT>\" : target_type , <EOL> \"<STR_LIT>\" : target_user , <EOL> \"<STR_LIT>\" : target_dept , <EOL> \"<STR_LIT>\" : target_role <EOL> } <EOL> message_center_instance = MessageCreateSerializer ( data = data , request = request ) <EOL> message_center_instance . is_valid ( raise_exception = True ) <EOL> message_center_instance . save ( ) <EOL> users = target_user or [ ] <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) <EOL> targetuser_data = [ ] <EOL> for user in users : <EOL> targetuser_data . append ( { <EOL> \"<STR_LIT>\" : message_center_instance . instance . id , <EOL> \"<STR_LIT>\" : user <EOL> } ) <EOL> targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = request ) <EOL> targetuser_instance . is_valid ( raise_exception = True ) <EOL> targetuser_instance . save ( ) <EOL> for user in users : <EOL> username = \"<STR_LIT>\" + str ( user ) <EOL> unread_count = async_to_sync ( _get_message_unread ) ( user ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> ", "gt": "{"}
{"input": "import os <EOL> import django <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . utils . core_initialize import CoreInitialize <EOL> from dvadmin . system . fixtures . initSerializer import ( <EOL> UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , <EOL> MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , <EOL> SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> ) <EOL> class Initialize ( CoreInitialize ) : <EOL> def init_dept ( self ) : <EOL> self . init_base ( DeptInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role ( self ) : <EOL> self . init_base ( RoleInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_users ( self ) : <EOL> self . init_base ( UsersInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_menu ( self ) : <EOL> self . init_base ( MenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu ( self ) : <EOL> ", "gt": "self . init_base ( RoleMenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] )"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> table [ '<STR_LIT>' ] . append ( fields ) <EOL> settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) <EOL> if model_name : <EOL> return settings . ALL_MODELS_OBJECTS [ model_name ] or { } <EOL> return settings . ALL_MODELS_OBJECTS or { } <EOL> def get_model_from_app ( app_name ) : <EOL> model_module = import_module ( app_name + '<STR_LIT>' ) <EOL> filter_model = [ <EOL> getattr ( model_module , item ) for item in dir ( model_module ) <EOL> if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) <EOL> ] <EOL> model_list = [ ] <EOL> for model in filter_model : <EOL> if model . __name__ == '<STR_LIT>' : <EOL> continue <EOL> fields = [ <EOL> { '<STR_LIT>' : field . verbose_name , '<STR_LIT>' : field . name , '<STR_LIT>' : field } <EOL> for field in model . _meta . fields <EOL> ] <EOL> model_list . append ( { <EOL> '<STR_LIT>' : app_name , <EOL> '<STR_LIT>' : model . _meta . verbose_name , <EOL> '<STR_LIT>' : model . __name__ , <EOL> '<STR_LIT>' : model , <EOL> '<STR_LIT>' : fields <EOL> } ) <EOL> return model_list <EOL> def get_custom_app_models ( app_name = None ) : <EOL> if app_name : <EOL> return get_model_from_app ( app_name ) <EOL> all_apps = apps . get_app_configs ( ) <EOL> res = [ ] <EOL> for app in all_apps : <EOL> if app . name . startswith ( '<STR_LIT>' ) : <EOL> continue <EOL> ", "gt": "if app . name in settings . COLUMN_EXCLUDE_APPS :"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( \"<STR_LIT>\" , include ( \"<STR_LIT>\" ) ) , <EOL> path ( \"<STR_LIT>\" , LoginView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , LogoutView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , TokenRefreshView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> re_path ( <EOL> r\"<STR_LIT>\" , include ( \"<STR_LIT>\" , namespace = \"<STR_LIT>\" ) <EOL> ) , <EOL> path ( \"<STR_LIT>\" , CaptchaView . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitDictionaryViewSet . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitSettingsViewSet . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , ApiLogin . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , LoginTokenView . as_view ( ) ) , <EOL> ", "gt": "]"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( \"<STR_LIT>\" , include ( \"<STR_LIT>\" ) ) , <EOL> path ( \"<STR_LIT>\" , LoginView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , LogoutView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , TokenRefreshView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> re_path ( <EOL> r\"<STR_LIT>\" , include ( \"<STR_LIT>\" , namespace = \"<STR_LIT>\" ) <EOL> ) , <EOL> path ( \"<STR_LIT>\" , CaptchaView . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitDictionaryViewSet . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitSettingsViewSet . as_view ( ) ) , <EOL> ", "gt": "path ( \"<STR_LIT>\" , ApiLogin . as_view ( ) ) ,"}
{"input": "from django . db . models import Q <EOL> from rest_framework import serializers <EOL> from dvadmin . system . models import Area <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class AreaSerializer ( CustomModelSerializer ) : <EOL> pcode_count = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_pcode_count ( self , instance : Area ) : <EOL> return Area . objects . filter ( pcode = instance ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Area . objects . filter ( pcode = instance . code ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Area <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class AreaCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Area <EOL> fields = '<STR_LIT>' <EOL> class AreaViewSet ( CustomModelViewSet ) : <EOL> queryset = Area . objects . all ( ) <EOL> serializer_class = AreaSerializer <EOL> extra_filter_class = [ ] <EOL> def get_queryset ( self ) : <EOL> self . request . query_params . _mutable = True <EOL> params = self . request . query_params <EOL> pcode = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params and pcode : <EOL> ", "gt": "queryset = self . queryset . filter ( enable = True , pcode = pcode )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> ", "gt": "def get_queryset ( self ) :"}
{"input": "import multiprocessing <EOL> workers = multiprocessing . cpu_count ( ) * <NUM_LIT> + <NUM_LIT> <EOL> threads = <NUM_LIT> <EOL> bind = '<STR_LIT>' <EOL> daemon = '<STR_LIT>' <EOL> worker_class = '<STR_LIT>' <EOL> worker_connections = <NUM_LIT> <EOL> max_requests = <NUM_LIT> <EOL> max_requests_jitter = <NUM_LIT> <EOL> pidfile = '<STR_LIT>' <EOL> loglevel = '<STR_LIT>' <EOL> access_log_format = '<STR_LIT>' <EOL> backlog = <NUM_LIT> <EOL> proc_name = '<STR_LIT>' <EOL> timeout = <NUM_LIT> <EOL> ", "gt": "graceful_timeout = <NUM_LIT>"}
{"input": "import functools <EOL> import os <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from django . conf import settings <EOL> from celery import platforms <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from tenant_schemas_celery . app import CeleryApp as TenantAwareCeleryApp <EOL> app = TenantAwareCeleryApp ( ) <EOL> else : <EOL> from celery import Celery <EOL> app = Celery ( f\"<STR_LIT>\" ) <EOL> app . config_from_object ( '<STR_LIT>' ) <EOL> app . autodiscover_tasks ( lambda : settings . INSTALLED_APPS ) <EOL> platforms . C_FORCE_ROOT = True <EOL> def retry_base_task_error ( ) : <EOL> def wraps ( func ) : <EOL> @ app . task ( bind = True , retry_delay = <NUM_LIT> , max_retries = <NUM_LIT> ) <EOL> ", "gt": "@ functools . wraps ( func )"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ", "gt": "for key , value in resolver_match . kwargs . items ( ) :"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> ", "gt": "new_value ) -> dict :"}
{"input": "from functools import wraps <EOL> from django . db . models import Func , F , OuterRef , Exists <EOL> from django . test import TestCase <EOL> import django <EOL> import os <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . system . models import Menu , RoleMenuPermission , RoleMenuButtonPermission , MenuButton <EOL> import time <EOL> def timing_decorator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = func ( * args , ** kwargs ) <EOL> end_time = time . time ( ) <EOL> run_time = end_time - start_time <EOL> print ( f\"<STR_LIT>\" ) <EOL> return result <EOL> return wrapper <EOL> @ timing_decorator <EOL> def getMenu ( ) : <EOL> data = [ ] <EOL> queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> for item in queryset : <EOL> parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) <EOL> names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] <EOL> completeName = \"<STR_LIT>\" . join ( names ) <EOL> isCheck = RoleMenuPermission . objects . filter ( <EOL> menu__id = item [ '<STR_LIT>' ] , <EOL> role__id = <NUM_LIT> , <EOL> ) . exists ( ) <EOL> ", "gt": "mbCheck = RoleMenuButtonPermission . objects . filter ("}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> data [ \"<STR_LIT>\" ] = self . user . name <EOL> data [ \"<STR_LIT>\" ] = self . user . id <EOL> data [ \"<STR_LIT>\" ] = self . user . avatar <EOL> data [ '<STR_LIT>' ] = self . user . user_type <EOL> dept = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if dept : <EOL> data [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : dept . id , <EOL> '<STR_LIT>' : dept . name , <EOL> } <EOL> role = getattr ( self . user , '<STR_LIT>' , None ) <EOL> if role : <EOL> data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> request = self . context . get ( \"<STR_LIT>\" ) <EOL> request . user = self . user <EOL> save_login_log ( request = request ) <EOL> return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } <EOL> class LoginView ( TokenObtainPairView ) : <EOL> serializer_class = LoginSerializer <EOL> permission_classes = [ ] <EOL> class LoginTokenSerializer ( TokenObtainPairSerializer ) : <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> ", "gt": "read_only_fields = [ \"<STR_LIT>\" ]"}
{"input": "import os <EOL> import django <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> django . setup ( ) <EOL> from dvadmin . utils . core_initialize import CoreInitialize <EOL> from dvadmin . system . fixtures . initSerializer import ( <EOL> UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , <EOL> MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , <EOL> SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> ) <EOL> class Initialize ( CoreInitialize ) : <EOL> def init_dept ( self ) : <EOL> self . init_base ( DeptInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role ( self ) : <EOL> self . init_base ( RoleInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_users ( self ) : <EOL> self . init_base ( UsersInitSerializer , unique_fields = [ '<STR_LIT>' ] ) <EOL> def init_menu ( self ) : <EOL> self . init_base ( MenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu ( self ) : <EOL> self . init_base ( RoleMenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def init_role_menu_button ( self ) : <EOL> self . init_base ( RoleMenuButtonInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> ", "gt": "def init_api_white_list ( self ) :"}
{"input": "import re <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . db . models import F <EOL> from rest_framework . permissions import BasePermission <EOL> from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission <EOL> def ValidationApi ( reqApi , validApi ) : <EOL> if validApi is not None : <EOL> valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> matchObj = re . match ( valid_api , reqApi , re . M | re . I ) <EOL> if matchObj : <EOL> return True <EOL> else : <EOL> return False <EOL> else : <EOL> return False <EOL> class AnonymousUserPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> return True <EOL> def ReUUID ( api ) : <EOL> pattern = re . compile ( r'<STR_LIT>' ) <EOL> m = pattern . search ( api ) <EOL> if m : <EOL> res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) <EOL> return res <EOL> else : <EOL> return None <EOL> class CustomPermission ( BasePermission ) : <EOL> def has_permission ( self , request , view ) : <EOL> if isinstance ( request . user , AnonymousUser ) : <EOL> return False <EOL> if request . user . is_superuser : <EOL> return True <EOL> else : <EOL> ", "gt": "api = request . path"}
{"input": "import multiprocessing <EOL> workers = multiprocessing . cpu_count ( ) * <NUM_LIT> + <NUM_LIT> <EOL> threads = <NUM_LIT> <EOL> bind = '<STR_LIT>' <EOL> daemon = '<STR_LIT>' <EOL> worker_class = '<STR_LIT>' <EOL> worker_connections = <NUM_LIT> <EOL> max_requests = <NUM_LIT> <EOL> max_requests_jitter = <NUM_LIT> <EOL> pidfile = '<STR_LIT>' <EOL> loglevel = '<STR_LIT>' <EOL> access_log_format = '<STR_LIT>' <EOL> backlog = <NUM_LIT> <EOL> proc_name = '<STR_LIT>' <EOL> timeout = <NUM_LIT> <EOL> graceful_timeout = <NUM_LIT> <EOL> keepalive = <NUM_LIT> <EOL> limit_request_line = <NUM_LIT> <EOL> limit_request_fields = <NUM_LIT> <EOL> ", "gt": "limit_request_field_size = <NUM_LIT>"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> try : <EOL> request_user = self . request . user <EOL> validated_data [ '<STR_LIT>' ] = request_user . dept . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> validated_data [ '<STR_LIT>' ] = request_user . id <EOL> except : <EOL> pass <EOL> return super ( ) . create ( validated_data ) <EOL> class FileViewSet ( CustomModelViewSet ) : <EOL> queryset = FileList . objects . all ( ) <EOL> serializer_class = FileSerializer <EOL> filter_fields = [ '<STR_LIT>' , ] <EOL> ", "gt": "permission_classes = [ ]"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> ", "gt": "if user . is_superuser :"}
{"input": "from drf_yasg . generators import OpenAPISchemaGenerator <EOL> from drf_yasg . inspectors import SwaggerAutoSchema <EOL> from application . settings import SWAGGER_SETTINGS <EOL> def get_summary ( string ) : <EOL> if string is not None : <EOL> result = string . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) <EOL> return result [ <NUM_LIT> ] <EOL> class CustomSwaggerAutoSchema ( SwaggerAutoSchema ) : <EOL> def get_tags ( self , operation_keys = None ) : <EOL> tags = super ( ) . get_tags ( operation_keys ) <EOL> if \"<STR_LIT>\" in tags and operation_keys : <EOL> tags [ <NUM_LIT> ] = operation_keys [ SWAGGER_SETTINGS . get ( '<STR_LIT>' , <NUM_LIT> ) ] <EOL> return tags <EOL> def get_summary_and_description ( self ) : <EOL> summary_and_description = super ( ) . get_summary_and_description ( ) <EOL> ", "gt": "summary = get_summary ( self . __dict__ . get ( '<STR_LIT>' ) . __doc__ )"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> \"<STR_LIT>\" : [ ] <EOL> } <EOL> for field in item . _meta . fields : <EOL> fields = { <EOL> \"<STR_LIT>\" : field . verbose_name , <EOL> \"<STR_LIT>\" : field . name <EOL> } <EOL> ", "gt": "table [ '<STR_LIT>' ] . append ( fields )"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) <EOL> else : <EOL> nested_dict [ target_key ] = new_value <EOL> return nested_dict <EOL> def __handle_crud ( self ) : <EOL> result = self . __get_field_attribute ( ) <EOL> columns = dict ( ) <EOL> for item in result : <EOL> key = item . get ( '<STR_LIT>' ) <EOL> title = item . get ( '<STR_LIT>' ) <EOL> type = item . get ( '<STR_LIT>' ) <EOL> columns [ key ] = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : key , <EOL> \"<STR_LIT>\" : type <EOL> } <EOL> if self . custom_crud_json and isinstance ( self . custom_crud_json , dict ) : <EOL> columns = columns | self . custom_crud_json <EOL> if self . crud_update_key_value and isinstance ( self . crud_update_key_value , dict ) : <EOL> for key , value in self . crud_update_key_value . items ( ) : <EOL> columns = self . __update_nested_dict ( columns , key , value ) <EOL> return columns <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ AllowAny ] ) <EOL> def init_crud ( self , request ) : <EOL> self . permission_classes = [ AllowAny ] <EOL> columns = self . __handle_crud ( ) <EOL> expose = \"<STR_LIT>\" <EOL> ret = \"<STR_LIT>\" <EOL> res = \"<STR_LIT>\" <EOL> ", "gt": "data ="}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> obj . objects . all ( ) . delete ( ) <EOL> settings . INITIALIZE_RESET_LIST . append ( obj ) <EOL> except Exception : <EOL> pass <EOL> for ele in data : <EOL> ", "gt": "m2m_dict = { }"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> if is_superuser : <EOL> queryset = MenuButton . objects . filter ( menu__id = instance . id ) <EOL> else : <EOL> menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) <EOL> serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) <EOL> ", "gt": "return serializer . data"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , Menu , MenuButton , Dept <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> from dvadmin . system . views . menu import MenuSerializer <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . crud_mixin import FastCrudMixin <EOL> from dvadmin . utils . field_permission import FieldPermissionMixin <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomUniqueValidator <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class RoleSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Role <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class RoleCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> menu = MenuSerializer ( many = True , read_only = True ) <EOL> dept = DeptSerializer ( many = True , read_only = True ) <EOL> permission = MenuButtonSerializer ( many = True , read_only = True ) <EOL> key = serializers . CharField ( max_length = <NUM_LIT> , <EOL> validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) <EOL> name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) <EOL> def validate ( self , attrs : dict ) : <EOL> return super ( ) . validate ( attrs ) <EOL> class Meta : <EOL> model = Role <EOL> fields = '<STR_LIT>' <EOL> class MenuPermissionSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> is_superuser = self . request . user . is_superuser <EOL> ", "gt": "if is_superuser :"}
{"input": "from django . db import DataError <EOL> from rest_framework . exceptions import APIException <EOL> from rest_framework . validators import UniqueValidator <EOL> class CustomValidationError ( APIException ) : <EOL> def __init__ ( self , detail ) : <EOL> self . detail = detail <EOL> def qs_exists ( queryset ) : <EOL> try : <EOL> return queryset . exists ( ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return False <EOL> def qs_filter ( queryset , ** kwargs ) : <EOL> try : <EOL> return queryset . filter ( ** kwargs ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return queryset . none ( ) <EOL> class CustomUniqueValidator ( UniqueValidator ) : <EOL> def filter_queryset ( self , value , queryset , field_name ) : <EOL> filter_kwargs = { '<STR_LIT>' % ( field_name , self . lookup ) : value } <EOL> return qs_filter ( queryset , ** filter_kwargs ) <EOL> def exclude_current_instance ( self , queryset , instance ) : <EOL> if instance is not None : <EOL> return queryset . exclude ( pk = instance . pk ) <EOL> ", "gt": "return queryset"}
{"input": "import hashlib <EOL> import mimetypes <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from application import dispatch <EOL> from dvadmin . system . models import FileList <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class FileSerializer ( CustomModelSerializer ) : <EOL> url = serializers . SerializerMethodField ( read_only = True ) <EOL> def get_url ( self , instance ) : <EOL> return instance . file_url or ( f'<STR_LIT>' ) <EOL> class Meta : <EOL> model = FileList <EOL> fields = \"<STR_LIT>\" <EOL> def create ( self , validated_data ) : <EOL> file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' <EOL> file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) <EOL> file = self . initial_data . get ( '<STR_LIT>' ) <EOL> file_size = file . size <EOL> validated_data [ '<STR_LIT>' ] = str ( file ) <EOL> validated_data [ '<STR_LIT>' ] = file_size <EOL> md5 = hashlib . md5 ( ) <EOL> for chunk in file . chunks ( ) : <EOL> md5 . update ( chunk ) <EOL> validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) <EOL> validated_data [ '<STR_LIT>' ] = file_engine <EOL> validated_data [ '<STR_LIT>' ] = file . content_type <EOL> if file_backup : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> if file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . aliyun import ali_oss_upload <EOL> file_path = ali_oss_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif file_engine == '<STR_LIT>' : <EOL> from dvadmin_cloud_storage . views . tencent import tencent_cos_upload <EOL> file_path = tencent_cos_upload ( file ) <EOL> if file_path : <EOL> validated_data [ '<STR_LIT>' ] = file_path <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> validated_data [ '<STR_LIT>' ] = file <EOL> ", "gt": "try :"}
{"input": "from django . db import DataError <EOL> from rest_framework . exceptions import APIException <EOL> from rest_framework . validators import UniqueValidator <EOL> class CustomValidationError ( APIException ) : <EOL> def __init__ ( self , detail ) : <EOL> self . detail = detail <EOL> def qs_exists ( queryset ) : <EOL> try : <EOL> return queryset . exists ( ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return False <EOL> def qs_filter ( queryset , ** kwargs ) : <EOL> try : <EOL> return queryset . filter ( ** kwargs ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return queryset . none ( ) <EOL> class CustomUniqueValidator ( UniqueValidator ) : <EOL> def filter_queryset ( self , value , queryset , field_name ) : <EOL> filter_kwargs = { '<STR_LIT>' % ( field_name , self . lookup ) : value } <EOL> return qs_filter ( queryset , ** filter_kwargs ) <EOL> def exclude_current_instance ( self , queryset , instance ) : <EOL> if instance is not None : <EOL> return queryset . exclude ( pk = instance . pk ) <EOL> return queryset <EOL> def __call__ ( self , value , serializer_field ) : <EOL> ", "gt": "field_name = serializer_field . source_attrs [ - <NUM_LIT> ]"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> ", "gt": "queryset = self . queryset . filter ( parent__isnull = True )"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class HealthCheckMiddleware ( object ) : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . method == \"<STR_LIT>\" : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return self . readiness ( request ) <EOL> elif request . path == \"<STR_LIT>\" : <EOL> return self . healthz ( request ) <EOL> return self . get_response ( request ) <EOL> def healthz ( self , request ) : <EOL> ", "gt": "return HttpResponse ( \"<STR_LIT>\" )"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> pass <EOL> return model if model else \"<STR_LIT>\" <EOL> def get_ip_analysis ( ip ) : <EOL> data = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "from rest_framework . response import Response <EOL> class SuccessResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , page = <NUM_LIT> , limit = <NUM_LIT> , total = <NUM_LIT> ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : page , <EOL> \"<STR_LIT>\" : limit , <EOL> \"<STR_LIT>\" : total , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class DetailResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , ) : <EOL> ", "gt": "std_data = {"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( \"<STR_LIT>\" , include ( \"<STR_LIT>\" ) ) , <EOL> path ( \"<STR_LIT>\" , LoginView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , LogoutView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , TokenRefreshView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> re_path ( <EOL> r\"<STR_LIT>\" , include ( \"<STR_LIT>\" , namespace = \"<STR_LIT>\" ) <EOL> ) , <EOL> path ( \"<STR_LIT>\" , CaptchaView . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitDictionaryViewSet . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , InitSettingsViewSet . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , ApiLogin . as_view ( ) ) , <EOL> path ( \"<STR_LIT>\" , LoginTokenView . as_view ( ) ) , <EOL> ] <EOL> ", "gt": "+ static ( settings . MEDIA_URL , document_root = settings . MEDIA_ROOT )"}
{"input": "import json <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . http import HttpResponse , HttpResponseServerError <EOL> from django . utils . deprecation import MiddlewareMixin <EOL> from dvadmin . system . models import OperationLog <EOL> from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name <EOL> class ApiLoggingMiddleware ( MiddlewareMixin ) : <EOL> def __init__ ( self , get_response = None ) : <EOL> super ( ) . __init__ ( get_response ) <EOL> self . enable = getattr ( settings , '<STR_LIT>' , None ) or False <EOL> self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) <EOL> self . operation_log_id = None <EOL> @ classmethod <EOL> def __handle_request ( cls , request ) : <EOL> request . request_ip = get_request_ip ( request ) <EOL> request . request_data = get_request_data ( request ) <EOL> request . request_path = get_request_path ( request ) <EOL> def __handle_response ( self , request , response ) : <EOL> body = getattr ( request , '<STR_LIT>' , { } ) <EOL> if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) <EOL> if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : <EOL> response . data = { } <EOL> try : <EOL> if not response . data and response . content : <EOL> content = json . loads ( response . content . decode ( ) ) <EOL> response . data = content if isinstance ( content , dict ) else { } <EOL> except Exception : <EOL> return <EOL> user = get_request_user ( request ) <EOL> info = { <EOL> '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , <EOL> '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : request . method , <EOL> '<STR_LIT>' : request . request_path , <EOL> '<STR_LIT>' : body , <EOL> '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : get_os ( request ) , <EOL> '<STR_LIT>' : get_browser ( request ) , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , <EOL> '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , <EOL> } <EOL> operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) <EOL> if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : <EOL> operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] <EOL> operation_log . save ( ) <EOL> def process_view ( self , request , view_func , view_args , view_kwargs ) : <EOL> if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) <EOL> log . save ( ) <EOL> self . operation_log_id = log . id <EOL> return <EOL> def process_request ( self , request ) : <EOL> self . __handle_request ( request ) <EOL> def process_response ( self , request , response ) : <EOL> if self . enable : <EOL> if self . methods == '<STR_LIT>' or request . method in self . methods : <EOL> self . __handle_response ( request , response ) <EOL> return response <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> ", "gt": "class HealthCheckMiddleware ( object ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> ", "gt": "parent = params . get ( '<STR_LIT>' , None )"}
{"input": "from rest_framework . response import Response <EOL> class SuccessResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , page = <NUM_LIT> , limit = <NUM_LIT> , total = <NUM_LIT> ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : page , <EOL> \"<STR_LIT>\" : limit , <EOL> \"<STR_LIT>\" : total , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> } <EOL> super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) <EOL> class DetailResponse ( Response ) : <EOL> def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , <EOL> content_type = None , ) : <EOL> std_data = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : data , <EOL> \"<STR_LIT>\" : msg <EOL> ", "gt": "}"}
{"input": "import os <EOL> from application . settings import BASE_DIR <EOL> DATABASE_ENGINE = \"<STR_LIT>\" <EOL> DATABASE_NAME = '<STR_LIT>' <EOL> DATABASE_HOST = '<STR_LIT>' <EOL> DATABASE_PORT = <NUM_LIT> <EOL> DATABASE_USER = \"<STR_LIT>\" <EOL> DATABASE_PASSWORD = \"<STR_LIT>\" <EOL> TABLE_PREFIX = \"<STR_LIT>\" <EOL> ", "gt": "REDIS_PASSWORD = '<STR_LIT>'"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> ", "gt": "name = name or obj . _meta . verbose_name"}
{"input": "from importlib import import_module <EOL> from django . apps import apps <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from application import settings <EOL> table_prefix = settings . TABLE_PREFIX <EOL> class SoftDeleteQuerySet ( models . QuerySet ) : <EOL> pass <EOL> class SoftDeleteManager ( models . Manager ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . __add_is_del_filter = False <EOL> super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) <EOL> def filter ( self , * args , ** kwargs ) : <EOL> if not kwargs . get ( '<STR_LIT>' ) is None : <EOL> self . __add_is_del_filter = True <EOL> return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if self . __add_is_del_filter : <EOL> return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) <EOL> return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) <EOL> def get_by_natural_key ( self , name ) : <EOL> return SoftDeleteQuerySet ( self . model ) . get ( username = name ) <EOL> class SoftDeleteModel ( models . Model ) : <EOL> is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) <EOL> objects = SoftDeleteManager ( ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : <EOL> self . is_deleted = True <EOL> self . save ( using = using ) <EOL> class CoreModel ( models . Model ) : <EOL> id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) <EOL> creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , <EOL> verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , <EOL> db_constraint = False ) <EOL> modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) <EOL> dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = '<STR_LIT>' <EOL> verbose_name_plural = verbose_name <EOL> def get_all_models_objects ( model_name = None ) : <EOL> settings . ALL_MODELS_OBJECTS = { } <EOL> if not settings . ALL_MODELS_OBJECTS : <EOL> all_models = apps . get_models ( ) <EOL> for item in list ( all_models ) : <EOL> table = { <EOL> \"<STR_LIT>\" : item . _meta . verbose_name , <EOL> \"<STR_LIT>\" : item . __name__ , <EOL> ", "gt": "\"<STR_LIT>\" : [ ]"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> ", "gt": "user_agent = parse ( ua_string )"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> ", "gt": "return None"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import Dictionary <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class DictionarySerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> value = serializers . CharField ( max_length = <NUM_LIT> ) <EOL> def validate_value ( self , value ) : <EOL> initial_data = self . initial_data <EOL> parent = initial_data . get ( '<STR_LIT>' , None ) <EOL> if parent is None : <EOL> unique = Dictionary . objects . filter ( value = value ) . exists ( ) <EOL> if unique : <EOL> raise serializers . ValidationError ( \"<STR_LIT>\" ) <EOL> return value <EOL> class Meta : <EOL> model = Dictionary <EOL> fields = '<STR_LIT>' <EOL> class DictionaryViewSet ( CustomModelViewSet ) : <EOL> queryset = Dictionary . objects . all ( ) <EOL> serializer_class = DictionarySerializer <EOL> create_serializer_class = DictionaryCreateUpdateSerializer <EOL> extra_filter_class = [ ] <EOL> search_fields = [ '<STR_LIT>' ] <EOL> def get_queryset ( self ) : <EOL> if self . action == '<STR_LIT>' : <EOL> params = self . request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> return queryset <EOL> else : <EOL> return self . queryset <EOL> class InitDictionaryViewSet ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> queryset = Dictionary . objects . all ( ) <EOL> def get ( self , request ) : <EOL> dictionary_key = self . request . query_params . get ( '<STR_LIT>' ) <EOL> if dictionary_key : <EOL> if dictionary_key == '<STR_LIT>' : <EOL> data = [ ele for ele in dispatch . get_dictionary_config ( ) . values ( ) ] <EOL> if not data : <EOL> dispatch . refresh_dictionary ( ) <EOL> data = [ ele for ele in dispatch . get_dictionary_config ( ) . values ( ) ] <EOL> ", "gt": "else :"}
{"input": "import base64 <EOL> import hashlib <EOL> from datetime import datetime , timedelta <EOL> from captcha . views import CaptchaStore , captcha_image <EOL> from django . contrib import auth <EOL> from django . contrib . auth import login <EOL> from django . shortcuts import redirect <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from drf_yasg import openapi <EOL> from drf_yasg . utils import swagger_auto_schema <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from rest_framework_simplejwt . serializers import TokenObtainPairSerializer <EOL> from rest_framework_simplejwt . views import TokenObtainPairView <EOL> from django . conf import settings <EOL> from application import dispatch <EOL> from dvadmin . system . models import Users <EOL> from dvadmin . utils . json_response import ErrorResponse , DetailResponse <EOL> from dvadmin . utils . request_util import save_login_log <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> class CaptchaView ( APIView ) : <EOL> authentication_classes = [ ] <EOL> permission_classes = [ ] <EOL> @ swagger_auto_schema ( <EOL> responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , <EOL> security = [ ] , <EOL> operation_id = \"<STR_LIT>\" , <EOL> operation_description = \"<STR_LIT>\" , <EOL> ) <EOL> def get ( self , request ) : <EOL> data = { } <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> hashkey = CaptchaStore . generate_key ( ) <EOL> id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id <EOL> imgage = captcha_image ( request , hashkey ) <EOL> image_base = base64 . b64encode ( imgage . content ) <EOL> data = { <EOL> \"<STR_LIT>\" : id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , <EOL> } <EOL> return DetailResponse ( data = data ) <EOL> class LoginSerializer ( TokenObtainPairSerializer ) : <EOL> captcha = serializers . CharField ( <EOL> max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True <EOL> ) <EOL> class Meta : <EOL> model = Users <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } <EOL> def validate ( self , attrs ) : <EOL> captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) <EOL> if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : <EOL> if captcha is None : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> self . image_code = CaptchaStore . objects . filter ( <EOL> id = self . initial_data [ \"<STR_LIT>\" ] <EOL> ) . first ( ) <EOL> five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> if self . image_code and five_minute_ago > self . image_code . expiration : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> else : <EOL> if self . image_code and ( <EOL> self . image_code . response == captcha <EOL> or self . image_code . challenge == captcha <EOL> ) : <EOL> self . image_code and self . image_code . delete ( ) <EOL> else : <EOL> self . image_code and self . image_code . delete ( ) <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) <EOL> if not user . is_active : <EOL> raise CustomValidationError ( \"<STR_LIT>\" ) <EOL> data = super ( ) . validate ( attrs ) <EOL> ", "gt": "data [ \"<STR_LIT>\" ] = self . user . name"}
{"input": "from django . conf . urls . static import static <EOL> from django . urls import path , include , re_path <EOL> from drf_yasg import openapi <EOL> from drf_yasg . views import get_schema_view <EOL> from rest_framework import permissions <EOL> from rest_framework_simplejwt . views import ( <EOL> TokenRefreshView , <EOL> ) <EOL> from application import dispatch <EOL> from application import settings <EOL> from dvadmin . system . views . dictionary import InitDictionaryViewSet <EOL> from dvadmin . system . views . login import ( <EOL> LoginView , <EOL> CaptchaView , <EOL> ApiLogin , <EOL> LogoutView , <EOL> LoginTokenView <EOL> ) <EOL> from dvadmin . system . views . system_config import InitSettingsViewSet <EOL> from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator <EOL> dispatch . init_system_config ( ) <EOL> dispatch . init_dictionary ( ) <EOL> schema_view = get_schema_view ( <EOL> openapi . Info ( <EOL> title = \"<STR_LIT>\" , <EOL> default_version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> terms_of_service = \"<STR_LIT>\" , <EOL> contact = openapi . Contact ( email = \"<STR_LIT>\" ) , <EOL> license = openapi . License ( name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> public = True , <EOL> permission_classes = ( permissions . AllowAny , ) , <EOL> generator_class = CustomOpenAPISchemaGenerator , <EOL> ) <EOL> urlpatterns = ( <EOL> [ <EOL> re_path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> \"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( <EOL> r\"<STR_LIT>\" , <EOL> schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , <EOL> name = \"<STR_LIT>\" , <EOL> ) , <EOL> path ( \"<STR_LIT>\" , include ( \"<STR_LIT>\" ) ) , <EOL> path ( \"<STR_LIT>\" , LoginView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , LogoutView . as_view ( ) , name = \"<STR_LIT>\" ) , <EOL> ", "gt": "path ( \"<STR_LIT>\" , TokenRefreshView . as_view ( ) , name = \"<STR_LIT>\" ) ,"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> for model in get_custom_app_models ( ) : <EOL> res . append ( { <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : model [ '<STR_LIT>' ] <EOL> } ) <EOL> return DetailResponse ( res ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def auto_match_fields ( self , request ) : <EOL> menu_id = request . data . get ( '<STR_LIT>' ) <EOL> model_name = request . data . get ( '<STR_LIT>' ) <EOL> if not menu_id or not model_name : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> for model in get_custom_app_models ( ) : <EOL> if model [ '<STR_LIT>' ] != model_name : <EOL> continue <EOL> for field in model [ '<STR_LIT>' ] : <EOL> if MenuField . objects . filter ( <EOL> menu_id = menu_id , model = model_name , field_name = field [ '<STR_LIT>' ] <EOL> ", "gt": ") . exists ( ) :"}
{"input": "import os <EOL> import sys <EOL> def main ( ) : <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> from django . core . management import execute_from_command_line <EOL> except ImportError as exc : <EOL> raise ImportError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ", "gt": "\"<STR_LIT>\""}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> pass <EOL> return model if model else \"<STR_LIT>\" <EOL> def get_ip_analysis ( ip ) : <EOL> data = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> if ip != '<STR_LIT>' and ip : <EOL> if getattr ( settings , '<STR_LIT>' , True ) : <EOL> try : <EOL> res = requests . get ( url = '<STR_LIT>' , params = { \"<STR_LIT>\" : ip } , timeout = <NUM_LIT> ) <EOL> if res . status_code == <NUM_LIT> : <EOL> res_data = res . json ( ) <EOL> if res_data . get ( '<STR_LIT>' ) == <NUM_LIT> : <EOL> data = res_data . get ( '<STR_LIT>' ) <EOL> return data <EOL> except Exception as e : <EOL> print ( e ) <EOL> return data <EOL> def save_login_log ( request ) : <EOL> ip = get_request_ip ( request = request ) <EOL> ", "gt": "analysis_data = get_ip_analysis ( ip )"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_os ( ) <EOL> def get_verbose_name ( queryset = None , view = None , model = None ) : <EOL> try : <EOL> if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : <EOL> model = queryset . model <EOL> elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : <EOL> model = view . get_queryset ( ) . model <EOL> elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) : <EOL> model = view . get_serializer ( ) . Meta . model <EOL> if model : <EOL> return getattr ( model , '<STR_LIT>' ) . verbose_name <EOL> else : <EOL> model = queryset . model . _meta . verbose_name <EOL> except Exception as e : <EOL> pass <EOL> return model if model else \"<STR_LIT>\" <EOL> def get_ip_analysis ( ip ) : <EOL> data = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> if ip != '<STR_LIT>' and ip : <EOL> if getattr ( settings , '<STR_LIT>' , True ) : <EOL> try : <EOL> res = requests . get ( url = '<STR_LIT>' , params = { \"<STR_LIT>\" : ip } , timeout = <NUM_LIT> ) <EOL> if res . status_code == <NUM_LIT> : <EOL> res_data = res . json ( ) <EOL> if res_data . get ( '<STR_LIT>' ) == <NUM_LIT> : <EOL> data = res_data . get ( '<STR_LIT>' ) <EOL> return data <EOL> except Exception as e : <EOL> print ( e ) <EOL> return data <EOL> def save_login_log ( request ) : <EOL> ip = get_request_ip ( request = request ) <EOL> analysis_data = get_ip_analysis ( ip ) <EOL> ", "gt": "analysis_data [ '<STR_LIT>' ] = request . user . username"}
{"input": "from django . db import DataError <EOL> from rest_framework . exceptions import APIException <EOL> from rest_framework . validators import UniqueValidator <EOL> class CustomValidationError ( APIException ) : <EOL> def __init__ ( self , detail ) : <EOL> self . detail = detail <EOL> def qs_exists ( queryset ) : <EOL> try : <EOL> return queryset . exists ( ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return False <EOL> def qs_filter ( queryset , ** kwargs ) : <EOL> try : <EOL> return queryset . filter ( ** kwargs ) <EOL> except ( TypeError , ValueError , DataError ) : <EOL> return queryset . none ( ) <EOL> class CustomUniqueValidator ( UniqueValidator ) : <EOL> def filter_queryset ( self , value , queryset , field_name ) : <EOL> filter_kwargs = { '<STR_LIT>' % ( field_name , self . lookup ) : value } <EOL> return qs_filter ( queryset , ** filter_kwargs ) <EOL> def exclude_current_instance ( self , queryset , instance ) : <EOL> if instance is not None : <EOL> return queryset . exclude ( pk = instance . pk ) <EOL> return queryset <EOL> def __call__ ( self , value , serializer_field ) : <EOL> field_name = serializer_field . source_attrs [ - <NUM_LIT> ] <EOL> instance = getattr ( serializer_field . parent , '<STR_LIT>' , None ) <EOL> ", "gt": "queryset = self . queryset"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> return result <EOL> else : <EOL> continue <EOL> elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : <EOL> continue <EOL> def __update_nested_dict ( self , nested_dict : dict , <EOL> target_key : str , <EOL> new_value ) -> dict : <EOL> split_target_key = target_key . split ( '<STR_LIT>' ) <EOL> if len ( split_target_key ) > <NUM_LIT> : <EOL> new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] <EOL> for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : <EOL> new_dict = new_dict [ item ] <EOL> self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) <EOL> else : <EOL> nested_dict [ target_key ] = new_value <EOL> return nested_dict <EOL> def __handle_crud ( self ) : <EOL> result = self . __get_field_attribute ( ) <EOL> columns = dict ( ) <EOL> for item in result : <EOL> key = item . get ( '<STR_LIT>' ) <EOL> title = item . get ( '<STR_LIT>' ) <EOL> type = item . get ( '<STR_LIT>' ) <EOL> columns [ key ] = { <EOL> \"<STR_LIT>\" : title , <EOL> \"<STR_LIT>\" : key , <EOL> \"<STR_LIT>\" : type <EOL> } <EOL> if self . custom_crud_json and isinstance ( self . custom_crud_json , dict ) : <EOL> columns = columns | self . custom_crud_json <EOL> if self . crud_update_key_value and isinstance ( self . crud_update_key_value , dict ) : <EOL> for key , value in self . crud_update_key_value . items ( ) : <EOL> columns = self . __update_nested_dict ( columns , key , value ) <EOL> ", "gt": "return columns"}
{"input": "from rest_framework . decorators import action <EOL> from rest_framework . permissions import AllowAny <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> class FastCrudMixin : <EOL> crud_fields = None <EOL> exclude_fields = None <EOL> custom_crud_json = None <EOL> crud_update_key_value = None <EOL> def __handle_type ( self , type ) : <EOL> if type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> if type == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> def __get_field_attribute ( self ) : <EOL> result = [ ] <EOL> queryset = self . get_queryset ( ) <EOL> __name = \"<STR_LIT>\" <EOL> __verbose_name = \"<STR_LIT>\" <EOL> __type = \"<STR_LIT>\" <EOL> if self . crud_fields and type ( self . crud_fields == list ) : <EOL> for item in self . crud_fields : <EOL> try : <EOL> field = queryset . model . _meta . get_field ( item ) <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> except : <EOL> continue <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> else : <EOL> model_fields = queryset . model . _meta . get_fields ( ) <EOL> for field in model_fields : <EOL> field_type = field . get_internal_type ( ) <EOL> __name = field . name <EOL> if self . exclude_fields and type ( self . exclude_fields == list ) : <EOL> if __name in self . exclude_fields : <EOL> continue <EOL> if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> continue <EOL> else : <EOL> __verbose_name = field . verbose_name <EOL> __type = self . __handle_type ( field_type ) <EOL> result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) <EOL> return result <EOL> def __find_key ( self , dct : dict , <EOL> target_key : str , <EOL> level : int = - <NUM_LIT> , <EOL> index : int = - <NUM_LIT> ) -> tuple : <EOL> for k , v in dct . items ( ) : <EOL> level += <NUM_LIT> <EOL> index += <NUM_LIT> <EOL> if k == target_key : <EOL> return level , index <EOL> elif isinstance ( v , list ) : <EOL> for i , dct_ in enumerate ( v ) : <EOL> if isinstance ( dct_ , dict ) : <EOL> result = self . __find_key ( dct_ , target_key ) <EOL> if result is not None : <EOL> ", "gt": "return result"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . fields import empty <EOL> from rest_framework . request import Request <EOL> from rest_framework . serializers import ModelSerializer <EOL> from django . utils . functional import cached_property <EOL> from rest_framework . utils . serializer_helpers import BindingDict <EOL> from dvadmin . system . models import Users <EOL> from django_restql . mixins import DynamicFieldsMixin <EOL> class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : <EOL> modifier_field_id = \"<STR_LIT>\" <EOL> modifier_name = serializers . SerializerMethodField ( read_only = True ) <EOL> dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) <EOL> def get_modifier_name ( self , instance ) : <EOL> if not hasattr ( instance , \"<STR_LIT>\" ) : <EOL> return None <EOL> queryset = ( <EOL> Users . objects . filter ( id = instance . modifier ) <EOL> . values_list ( \"<STR_LIT>\" , flat = True ) <EOL> . first ( ) <EOL> ) <EOL> if queryset : <EOL> return queryset <EOL> return None <EOL> creator_field_id = \"<STR_LIT>\" <EOL> creator_name = serializers . SlugRelatedField ( <EOL> slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True <EOL> ) <EOL> dept_belong_id_field_name = \"<STR_LIT>\" <EOL> create_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False , read_only = True <EOL> ) <EOL> update_datetime = serializers . DateTimeField ( <EOL> format = \"<STR_LIT>\" , required = False <EOL> ) <EOL> def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : <EOL> super ( ) . __init__ ( instance , data , ** kwargs ) <EOL> self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) <EOL> def save ( self , ** kwargs ) : <EOL> return super ( ) . save ( ** kwargs ) <EOL> def create ( self , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if self . creator_field_id in self . fields . fields : <EOL> validated_data [ self . creator_field_id ] = self . request . user <EOL> if ( <EOL> self . dept_belong_id_field_name in self . fields . fields <EOL> and validated_data . get ( self . dept_belong_id_field_name , None ) is None <EOL> ) : <EOL> validated_data [ self . dept_belong_id_field_name ] = getattr ( <EOL> self . request . user , \"<STR_LIT>\" , None <EOL> ) <EOL> return super ( ) . create ( validated_data ) <EOL> def update ( self , instance , validated_data ) : <EOL> if self . request : <EOL> if str ( self . request . user ) != \"<STR_LIT>\" : <EOL> if self . modifier_field_id in self . fields . fields : <EOL> validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) <EOL> if hasattr ( self . instance , self . modifier_field_id ) : <EOL> setattr ( <EOL> self . instance , self . modifier_field_id , self . get_request_user_id ( ) <EOL> ) <EOL> return super ( ) . update ( instance , validated_data ) <EOL> def get_request_username ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_name ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> def get_request_user_id ( self ) : <EOL> if getattr ( self . request , \"<STR_LIT>\" , None ) : <EOL> return getattr ( self . request . user , \"<STR_LIT>\" , None ) <EOL> return None <EOL> @ property <EOL> def errors ( self ) : <EOL> errors = super ( ) . errors <EOL> verbose_errors = { } <EOL> fields = { field . name : field . verbose_name for field in <EOL> self . Meta . model . _meta . get_fields ( ) if hasattr ( field , '<STR_LIT>' ) } <EOL> for field_name , error in errors . items ( ) : <EOL> if field_name in fields : <EOL> verbose_errors [ str ( fields [ field_name ] ) ] = error <EOL> else : <EOL> verbose_errors [ field_name ] = error <EOL> ", "gt": "return verbose_errors"}
{"input": "import multiprocessing <EOL> workers = multiprocessing . cpu_count ( ) * <NUM_LIT> + <NUM_LIT> <EOL> threads = <NUM_LIT> <EOL> bind = '<STR_LIT>' <EOL> daemon = '<STR_LIT>' <EOL> worker_class = '<STR_LIT>' <EOL> worker_connections = <NUM_LIT> <EOL> max_requests = <NUM_LIT> <EOL> max_requests_jitter = <NUM_LIT> <EOL> pidfile = '<STR_LIT>' <EOL> loglevel = '<STR_LIT>' <EOL> access_log_format = '<STR_LIT>' <EOL> backlog = <NUM_LIT> <EOL> proc_name = '<STR_LIT>' <EOL> timeout = <NUM_LIT> <EOL> graceful_timeout = <NUM_LIT> <EOL> keepalive = <NUM_LIT> <EOL> limit_request_line = <NUM_LIT> <EOL> limit_request_fields = <NUM_LIT> <EOL> limit_request_field_size = <NUM_LIT> <EOL> ", "gt": "accesslog = '<STR_LIT>'"}
{"input": "import json <EOL> from asgiref . sync import async_to_sync <EOL> from channels . layers import get_channel_layer <EOL> from django_restql . fields import DynamicSerializerMethodField <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action , permission_classes <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser <EOL> from dvadmin . utils . json_response import SuccessResponse , DetailResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MessageCenterSerializer ( CustomModelSerializer ) : <EOL> role_info = DynamicSerializerMethodField ( ) <EOL> user_info = DynamicSerializerMethodField ( ) <EOL> dept_info = DynamicSerializerMethodField ( ) <EOL> is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) <EOL> def get_role_info ( self , instance , parsed_query ) : <EOL> roles = instance . target_role . all ( ) <EOL> from dvadmin . system . views . role import RoleSerializer <EOL> serializer = RoleSerializer ( <EOL> roles , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_user_info ( self , instance , parsed_query ) : <EOL> users = instance . target_user . all ( ) <EOL> from dvadmin . system . views . user import UserSerializer <EOL> serializer = UserSerializer ( <EOL> users , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> def get_dept_info ( self , instance , parsed_query ) : <EOL> dept = instance . target_dept . all ( ) <EOL> from dvadmin . system . views . dept import DeptSerializer <EOL> serializer = DeptSerializer ( <EOL> dept , <EOL> many = True , <EOL> parsed_query = parsed_query <EOL> ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MessageCenterTargetUser <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : <EOL> is_read = serializers . SerializerMethodField ( ) <EOL> def get_is_read ( self , instance ) : <EOL> user_id = self . request . user . id <EOL> message_center_id = instance . id <EOL> queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) <EOL> if queryset : <EOL> return queryset . is_read <EOL> return False <EOL> class Meta : <EOL> model = MessageCenter <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def websocket_push ( user_id , message ) : <EOL> username = \"<STR_LIT>\" + str ( user_id ) <EOL> channel_layer = get_channel_layer ( ) <EOL> async_to_sync ( channel_layer . group_send ) ( <EOL> username , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : message <EOL> } <EOL> ) <EOL> class MessageCenterCreateSerializer ( CustomModelSerializer ) : <EOL> def save ( self , ** kwargs ) : <EOL> data = super ( ) . save ( ** kwargs ) <EOL> initial_data = self . initial_data <EOL> target_type = initial_data . get ( '<STR_LIT>' ) <EOL> users = initial_data . get ( '<STR_LIT>' , [ ] ) <EOL> if target_type in [ <NUM_LIT> ] : <EOL> ", "gt": "target_role = initial_data . get ( '<STR_LIT>' , [ ] )"}
{"input": "from django . db . models import Q <EOL> from rest_framework import serializers <EOL> from dvadmin . system . models import Area <EOL> from dvadmin . utils . json_response import SuccessResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class AreaSerializer ( CustomModelSerializer ) : <EOL> pcode_count = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_pcode_count ( self , instance : Area ) : <EOL> return Area . objects . filter ( pcode = instance ) . count ( ) <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Area . objects . filter ( pcode = instance . code ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Area <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class AreaCreateUpdateSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = Area <EOL> fields = '<STR_LIT>' <EOL> class AreaViewSet ( CustomModelViewSet ) : <EOL> queryset = Area . objects . all ( ) <EOL> serializer_class = AreaSerializer <EOL> extra_filter_class = [ ] <EOL> def get_queryset ( self ) : <EOL> self . request . query_params . _mutable = True <EOL> params = self . request . query_params <EOL> pcode = params . get ( '<STR_LIT>' , None ) <EOL> ", "gt": "page = params . get ( '<STR_LIT>' , None )"}
{"input": "import os <EOL> exclude = [ \"<STR_LIT>\" ] <EOL> for root , dirs , files in os . walk ( '<STR_LIT>' ) : <EOL> dirs [ : ] = list ( set ( dirs ) - set ( exclude ) ) <EOL> if '<STR_LIT>' in dirs : <EOL> dir = dirs [ dirs . index ( '<STR_LIT>' ) ] <EOL> for root_j , dirs_j , files_j in os . walk ( os . path . join ( root , dir ) ) : <EOL> for file_k in files_j : <EOL> if file_k != '<STR_LIT>' : <EOL> dst_file = os . path . join ( root_j , file_k ) <EOL> print ( '<STR_LIT>' , dst_file ) <EOL> ", "gt": "os . remove ( dst_file )"}
{"input": "import json <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractBaseUser <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . urls . resolvers import ResolverMatch <EOL> from rest_framework_simplejwt . authentication import JWTAuthentication <EOL> from user_agents import parse <EOL> from dvadmin . system . models import LoginLog <EOL> def get_request_user ( request ) : <EOL> user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) <EOL> if user and user . is_authenticated : <EOL> return user <EOL> try : <EOL> user , tokrn = JWTAuthentication ( ) . authenticate ( request ) <EOL> except Exception as e : <EOL> pass <EOL> return user or AnonymousUser ( ) <EOL> def get_request_ip ( request ) : <EOL> x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if x_forwarded_for : <EOL> ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) <EOL> return ip <EOL> ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) <EOL> return ip or '<STR_LIT>' <EOL> def get_request_data ( request ) : <EOL> request_data = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_data : <EOL> return request_data <EOL> data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } <EOL> if not data : <EOL> try : <EOL> body = request . body <EOL> if body : <EOL> data = json . loads ( body ) <EOL> except Exception as e : <EOL> pass <EOL> if not isinstance ( data , dict ) : <EOL> data = { '<STR_LIT>' : data } <EOL> return data <EOL> def get_request_path ( request , * args , ** kwargs ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> values = [ ] <EOL> for arg in args : <EOL> if len ( arg ) == <NUM_LIT> : <EOL> continue <EOL> if isinstance ( arg , str ) : <EOL> values . append ( arg ) <EOL> elif isinstance ( arg , ( tuple , set , list ) ) : <EOL> values . extend ( arg ) <EOL> elif isinstance ( arg , dict ) : <EOL> values . extend ( arg . values ( ) ) <EOL> if len ( values ) == <NUM_LIT> : <EOL> return request . path <EOL> path : str = request . path <EOL> for value in values : <EOL> path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) <EOL> return path <EOL> def get_request_canonical_path ( request , ) : <EOL> request_path = getattr ( request , '<STR_LIT>' , None ) <EOL> if request_path : <EOL> return request_path <EOL> path : str = request . path <EOL> resolver_match : ResolverMatch = request . resolver_match <EOL> for value in resolver_match . args : <EOL> path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for key , value in resolver_match . kwargs . items ( ) : <EOL> if key == '<STR_LIT>' : <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> continue <EOL> path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) <EOL> return path <EOL> def get_browser ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> user_agent = parse ( ua_string ) <EOL> return user_agent . get_browser ( ) <EOL> def get_os ( request , ) : <EOL> ua_string = request . META [ '<STR_LIT>' ] <EOL> ", "gt": "user_agent = parse ( ua_string )"}
{"input": "import django_filters <EOL> from django . db . models import Q <EOL> from django_filters . rest_framework import BooleanFilter <EOL> from rest_framework import serializers <EOL> from rest_framework . views import APIView <EOL> from application import dispatch <EOL> from dvadmin . system . models import SystemConfig <EOL> from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . models import get_all_models_objects <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . validator import CustomValidationError <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class SystemConfigCreateSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> def validate_key ( self , value ) : <EOL> instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) <EOL> if instance : <EOL> raise CustomValidationError ( '<STR_LIT>' ) <EOL> return value <EOL> class SystemConfigSerializer ( CustomModelSerializer ) : <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigChinldernSerializer ( CustomModelSerializer ) : <EOL> children = serializers . SerializerMethodField ( ) <EOL> form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) <EOL> def get_children ( self , instance ) : <EOL> queryset = SystemConfig . objects . filter ( parent = instance ) <EOL> serializer = SystemConfigSerializer ( queryset , many = True ) <EOL> return serializer . data <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigListSerializer ( CustomModelSerializer ) : <EOL> def update ( self , instance , validated_data ) : <EOL> instance_mapping = { obj . id : obj for obj in instance } <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = instance_mapping . get ( obj_id , None ) <EOL> if instance_obj is None : <EOL> return SystemConfig . objects . create ( ** data ) <EOL> else : <EOL> return instance_obj . objects . update ( ** data ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class SystemConfigSaveSerializer ( serializers . Serializer ) : <EOL> class Meta : <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> list_serializer_class = SystemConfigListSerializer <EOL> class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : <EOL> parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = SystemConfig <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class SystemConfigViewSet ( CustomModelViewSet ) : <EOL> queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> serializer_class = SystemConfigChinldernSerializer <EOL> create_serializer_class = SystemConfigCreateSerializer <EOL> retrieve_serializer_class = SystemConfigChinldernSerializer <EOL> filter_class = SystemConfigFilter <EOL> def save_content ( self , request ) : <EOL> body = request . data <EOL> data_mapping = { item [ '<STR_LIT>' ] : item for item in body } <EOL> for obj_id , data in data_mapping . items ( ) : <EOL> instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) <EOL> if instance_obj is None : <EOL> serializer = SystemConfigCreateSerializer ( data = data ) <EOL> else : <EOL> serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) <EOL> if serializer . is_valid ( raise_exception = True ) : <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = \"<STR_LIT>\" ) <EOL> def get_association_table ( self , request ) : <EOL> res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] <EOL> return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) <EOL> def get_table_data ( self , request , pk ) : <EOL> instance = SystemConfig . objects . filter ( id = pk ) . first ( ) <EOL> if instance is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> setting = instance . setting <EOL> if setting is None : <EOL> return ErrorResponse ( msg = \"<STR_LIT>\" ) <EOL> table = setting . get ( '<STR_LIT>' ) <EOL> ", "gt": "model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } )"}
{"input": "import json <EOL> import os <EOL> from django . apps import apps <EOL> from rest_framework import request <EOL> from application import settings <EOL> from dvadmin . system . models import Users <EOL> class CoreInitialize : <EOL> creator_id = None <EOL> reset = False <EOL> request = request <EOL> file_path = None <EOL> def __init__ ( self , reset = False , creator_id = None , app = None ) : <EOL> self . reset = reset or self . reset <EOL> self . creator_id = creator_id or self . creator_id <EOL> self . app = app or '<STR_LIT>' <EOL> self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) <EOL> def init_base ( self , Serializer , unique_fields = None ) : <EOL> model = Serializer . Meta . model <EOL> path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , <EOL> f'<STR_LIT>' ) <EOL> if not os . path . isfile ( path_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> with open ( path_file , encoding = \"<STR_LIT>\" ) as f : <EOL> for data in json . load ( f ) : <EOL> filter_data = { } <EOL> if unique_fields : <EOL> for field in unique_fields : <EOL> if field in data : <EOL> filter_data [ field ] = data [ field ] <EOL> else : <EOL> for key , value in data . items ( ) : <EOL> if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : <EOL> continue <EOL> filter_data [ key ] = value <EOL> instance = model . objects . filter ( ** filter_data ) . first ( ) <EOL> data [ \"<STR_LIT>\" ] = self . reset <EOL> serializer = Serializer ( instance , data = data , request = self . request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> print ( f\"<STR_LIT>\" ) <EOL> def save ( self , obj , data : list , name = None , no_reset = False ) : <EOL> name = name or obj . _meta . verbose_name <EOL> print ( f\"<STR_LIT>\" ) <EOL> if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : <EOL> try : <EOL> obj . objects . all ( ) . delete ( ) <EOL> settings . INITIALIZE_RESET_LIST . append ( obj ) <EOL> except Exception : <EOL> pass <EOL> for ele in data : <EOL> m2m_dict = { } <EOL> new_data = { } <EOL> for key , value in ele . items ( ) : <EOL> if isinstance ( value , list ) and value and isinstance ( value [ <NUM_LIT> ] , int ) : <EOL> m2m_dict [ key ] = value <EOL> else : <EOL> new_data [ key ] = value <EOL> object , _ = obj . objects . get_or_create ( id = ele . get ( \"<STR_LIT>\" ) , defaults = new_data ) <EOL> for key , m2m in m2m_dict . items ( ) : <EOL> m2m = list ( set ( m2m ) ) <EOL> if m2m and len ( m2m ) > <NUM_LIT> and m2m [ <NUM_LIT> ] : <EOL> ", "gt": "exec ( )"}
{"input": "from django . apps import apps <EOL> from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from rest_framework . permissions import IsAuthenticated <EOL> from dvadmin . system . models import Role , MenuField <EOL> from dvadmin . utils . models import get_custom_app_models <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse <EOL> class MenuFieldSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = MenuField <EOL> fields = '<STR_LIT>' <EOL> read_only_fields = [ '<STR_LIT>' ] <EOL> class MenuFieldViewSet ( CustomModelViewSet ) : <EOL> queryset = MenuField . objects . order_by ( '<STR_LIT>' ) <EOL> serializer_class = MenuFieldSerializer <EOL> def list ( self , request , * args , ** kwargs ) : <EOL> menu = request . query_params . get ( '<STR_LIT>' ) <EOL> if not menu : <EOL> return SuccessResponse ( [ ] ) <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) <EOL> serializer = self . get_serializer ( queryset , many = True , request = request ) <EOL> return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) <EOL> def create ( self , request , * args , ** kwargs ) : <EOL> payload = request . data <EOL> for model in apps . get_models ( ) : <EOL> if payload . get ( '<STR_LIT>' ) == model . __name__ : <EOL> break <EOL> else : <EOL> return ErrorResponse ( msg = '<STR_LIT>' ) <EOL> if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : <EOL> return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) <EOL> return super ( ) . create ( request , * args , ** kwargs ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) <EOL> def get_models ( self , request ) : <EOL> res = [ ] <EOL> ", "gt": "for model in get_custom_app_models ( ) :"}
{"input": "from rest_framework import serializers <EOL> from rest_framework . decorators import action <EOL> from dvadmin . system . models import Menu , RoleMenuPermission <EOL> from dvadmin . system . views . menu_button import MenuButtonSerializer <EOL> from dvadmin . utils . json_response import SuccessResponse , ErrorResponse <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class MenuSerializer ( CustomModelSerializer ) : <EOL> menuPermission = serializers . SerializerMethodField ( read_only = True ) <EOL> hasChild = serializers . SerializerMethodField ( ) <EOL> def get_menuPermission ( self , instance ) : <EOL> queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if queryset : <EOL> return queryset <EOL> else : <EOL> return None <EOL> def get_hasChild ( self , instance ) : <EOL> hasChild = Menu . objects . filter ( parent = instance . id ) <EOL> if hasChild : <EOL> return True <EOL> return False <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuCreateSerializer ( CustomModelSerializer ) : <EOL> name = serializers . CharField ( required = False ) <EOL> def create ( self , validated_data ) : <EOL> menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) <EOL> last_sort = menu_obj . sort if menu_obj else <NUM_LIT> <EOL> validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> <EOL> return super ( ) . create ( validated_data ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class WebRouterSerializer ( CustomModelSerializer ) : <EOL> path = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> title = serializers . CharField ( source = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> model = Menu <EOL> fields = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class MenuViewSet ( CustomModelViewSet ) : <EOL> queryset = Menu . objects . all ( ) <EOL> serializer_class = MenuSerializer <EOL> create_serializer_class = MenuCreateSerializer <EOL> update_serializer_class = MenuCreateSerializer <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list ( self , request ) : <EOL> request . query_params . _mutable = True <EOL> params = request . query_params <EOL> parent = params . get ( '<STR_LIT>' , None ) <EOL> page = params . get ( '<STR_LIT>' , None ) <EOL> limit = params . get ( '<STR_LIT>' , None ) <EOL> if page : <EOL> del params [ '<STR_LIT>' ] <EOL> if limit : <EOL> del params [ '<STR_LIT>' ] <EOL> if params : <EOL> if parent : <EOL> queryset = self . queryset . filter ( parent = parent ) <EOL> else : <EOL> queryset = self . queryset . filter ( ) <EOL> else : <EOL> queryset = self . queryset . filter ( parent__isnull = True ) <EOL> queryset = self . filter_queryset ( queryset ) <EOL> serializer = MenuSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> def web_router ( self , request ) : <EOL> user = request . user <EOL> if user . is_superuser : <EOL> queryset = self . queryset . filter ( status = <NUM_LIT> ) <EOL> else : <EOL> role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) <EOL> menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> queryset = Menu . objects . filter ( id__in = menu_list ) <EOL> serializer = WebRouterSerializer ( queryset , many = True , request = request ) <EOL> data = serializer . data <EOL> return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) <EOL> ", "gt": "def get_all_menu ( self , request ) :"}
