{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> ", "gt": "results_list . append ( val )"}
{"input": "from dvadmin . system . models import LoginLog <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class LoginLogSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = LoginLog <EOL> fields = \"<STR_LIT>\" <EOL> ", "gt": "read_only_fields = [ \"<STR_LIT>\" ]"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> ", "gt": "msg = '<STR_LIT>'"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> ", "gt": "type = \"<STR_LIT>\" ,"}
{"input": "from dvadmin . system . models import LoginLog <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class LoginLogSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = LoginLog <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> ", "gt": "class LoginLogViewSet ( CustomModelViewSet ) :"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> ", "gt": "wb . save ( response )"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> is_previous = self . page . has_previous ( ) if self . page else False <EOL> if not data : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> data = [ ] <EOL> return Response ( OrderedDict ( [ <EOL> ( '<STR_LIT>' , code ) , <EOL> ( '<STR_LIT>' , msg ) , <EOL> ( '<STR_LIT>' , page ) , <EOL> ", "gt": "( '<STR_LIT>' , limit ) ,"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> is_previous = self . page . has_previous ( ) if self . page else False <EOL> ", "gt": "if not data :"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> ", "gt": "if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] :"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> class ExportSerializerMixin : <EOL> export_field_label = [ ] <EOL> export_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def export_data ( self , request : Request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . export_field_label , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . export_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . export_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> ", "gt": "response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\""}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> ", "gt": "def get_paginated_response ( self , data ) :"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ", "gt": "ws . add_table ( tab )"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> is_previous = self . page . has_previous ( ) if self . page else False <EOL> if not data : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> data = [ ] <EOL> return Response ( OrderedDict ( [ <EOL> ( '<STR_LIT>' , code ) , <EOL> ( '<STR_LIT>' , msg ) , <EOL> ( '<STR_LIT>' , page ) , <EOL> ( '<STR_LIT>' , limit ) , <EOL> ( '<STR_LIT>' , total ) , <EOL> ", "gt": "( '<STR_LIT>' , is_next ) ,"}
{"input": "from dvadmin . system . models import LoginLog <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class LoginLogSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = LoginLog <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class LoginLogViewSet ( CustomModelViewSet ) : <EOL> queryset = LoginLog . objects . all ( ) <EOL> ", "gt": "serializer_class = LoginLogSerializer"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> class ExportSerializerMixin : <EOL> export_field_label = [ ] <EOL> export_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> ", "gt": "def is_number ( self , num ) :"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> is_previous = self . page . has_previous ( ) if self . page else False <EOL> if not data : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> data = [ ] <EOL> return Response ( OrderedDict ( [ <EOL> ( '<STR_LIT>' , code ) , <EOL> ( '<STR_LIT>' , msg ) , <EOL> ", "gt": "( '<STR_LIT>' , page ) ,"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> is_previous = self . page . has_previous ( ) if self . page else False <EOL> if not data : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> data = [ ] <EOL> return Response ( OrderedDict ( [ <EOL> ", "gt": "( '<STR_LIT>' , code ) ,"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> is_previous = self . page . has_previous ( ) if self . page else False <EOL> if not data : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> data = [ ] <EOL> return Response ( OrderedDict ( [ <EOL> ( '<STR_LIT>' , code ) , <EOL> ( '<STR_LIT>' , msg ) , <EOL> ( '<STR_LIT>' , page ) , <EOL> ( '<STR_LIT>' , limit ) , <EOL> ( '<STR_LIT>' , total ) , <EOL> ( '<STR_LIT>' , is_next ) , <EOL> ", "gt": "( '<STR_LIT>' , is_previous ) ,"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> is_previous = self . page . has_previous ( ) if self . page else False <EOL> if not data : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> data = [ ] <EOL> ", "gt": "return Response ( OrderedDict ( ["}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> is_previous = self . page . has_previous ( ) if self . page else False <EOL> if not data : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> data = [ ] <EOL> return Response ( OrderedDict ( [ <EOL> ( '<STR_LIT>' , code ) , <EOL> ", "gt": "( '<STR_LIT>' , msg ) ,"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> class ExportSerializerMixin : <EOL> export_field_label = [ ] <EOL> export_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def export_data ( self , request : Request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . export_field_label , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . export_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . export_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws = wb . active <EOL> header_data = [ \"<STR_LIT>\" , * self . export_field_label . values ( ) ] <EOL> hidden_header = [ \"<STR_LIT>\" , * self . export_field_label . keys ( ) ] <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( self . export_field_label ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> ", "gt": "for h_index , h_item in enumerate ( hidden_header ) :"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> ", "gt": "limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT>"}
{"input": "from dvadmin . system . models import LoginLog <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class LoginLogSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = LoginLog <EOL> ", "gt": "fields = \"<STR_LIT>\""}
{"input": "from dvadmin . system . models import LoginLog <EOL> from dvadmin . utils . serializers import CustomModelSerializer <EOL> from dvadmin . utils . viewset import CustomModelViewSet <EOL> class LoginLogSerializer ( CustomModelSerializer ) : <EOL> class Meta : <EOL> model = LoginLog <EOL> fields = \"<STR_LIT>\" <EOL> read_only_fields = [ \"<STR_LIT>\" ] <EOL> class LoginLogViewSet ( CustomModelViewSet ) : <EOL> ", "gt": "queryset = LoginLog . objects . all ( )"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> ", "gt": "is_previous = self . page . has_previous ( ) if self . page else False"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> is_previous = self . page . has_previous ( ) if self . page else False <EOL> if not data : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> data = [ ] <EOL> return Response ( OrderedDict ( [ <EOL> ( '<STR_LIT>' , code ) , <EOL> ( '<STR_LIT>' , msg ) , <EOL> ( '<STR_LIT>' , page ) , <EOL> ( '<STR_LIT>' , limit ) , <EOL> ( '<STR_LIT>' , total ) , <EOL> ( '<STR_LIT>' , is_next ) , <EOL> ( '<STR_LIT>' , is_previous ) , <EOL> ", "gt": "( '<STR_LIT>' , data )"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> ", "gt": "data_list = [ ]"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> ", "gt": "hidden_header . append ( key )"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> class ExportSerializerMixin : <EOL> export_field_label = [ ] <EOL> export_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> ", "gt": "return True"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> ", "gt": "self . request = request"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> ", "gt": "return list ( self . page )"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> ", "gt": "self . page = [ ]"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> is_previous = self . page . has_previous ( ) if self . page else False <EOL> if not data : <EOL> ", "gt": "code = <NUM_LIT>"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> class ExportSerializerMixin : <EOL> export_field_label = [ ] <EOL> export_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> ", "gt": "length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT>"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> ", "gt": "total = self . page . paginator . count if self . page else <NUM_LIT>"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> ", "gt": "header_data . append ( value )"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> ", "gt": "page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT>"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> class ExportSerializerMixin : <EOL> export_field_label = [ ] <EOL> export_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def export_data ( self , request : Request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . export_field_label , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . export_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . export_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws = wb . active <EOL> header_data = [ \"<STR_LIT>\" , * self . export_field_label . values ( ) ] <EOL> hidden_header = [ \"<STR_LIT>\" , * self . export_field_label . keys ( ) ] <EOL> ", "gt": "df_len_max = [ self . get_string_len ( ele ) for ele in header_data ]"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> ", "gt": "for index , width in enumerate ( df_len_max ) :"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> ", "gt": "items = list ( item )"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> class ExportSerializerMixin : <EOL> export_field_label = [ ] <EOL> export_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def export_data ( self , request : Request , * args , ** kwargs ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . export_field_label , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> ", "gt": "assert self . export_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> class ExportSerializerMixin : <EOL> export_field_label = [ ] <EOL> export_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> ", "gt": "if self . is_number ( string ) :"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> ", "gt": "continue"}
{"input": "from urllib . parse import quote <EOL> from django . db import transaction <EOL> from django . http import HttpResponse <EOL> from openpyxl import Workbook <EOL> from openpyxl . worksheet . datavalidation import DataValidation <EOL> from openpyxl . utils import get_column_letter , quote_sheetname <EOL> from openpyxl . worksheet . table import Table , TableStyleInfo <EOL> from rest_framework . decorators import action <EOL> from rest_framework . request import Request <EOL> from dvadmin . utils . import_export import import_to_data <EOL> from dvadmin . utils . json_response import DetailResponse <EOL> from dvadmin . utils . request_util import get_verbose_name <EOL> class ImportSerializerMixin : <EOL> import_field_dict = { } <EOL> import_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width <EOL> @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) <EOL> @ transaction . atomic <EOL> def import_data ( self , request : Request , * args , ** kwargs ) : <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> if request . method == \"<STR_LIT>\" : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ <EOL> \"<STR_LIT>\" <EOL> ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> header_data = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> validation_data_dict = { } <EOL> for index , ele in enumerate ( self . import_field_dict . values ( ) ) : <EOL> if isinstance ( ele , dict ) : <EOL> header_data . append ( ele . get ( \"<STR_LIT>\" ) ) <EOL> choices = ele . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( ele ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> ws . append ( header_data ) <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> else : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> m2m_fields = [ <EOL> ele . name <EOL> for ele in queryset . model . _meta . get_fields ( ) <EOL> if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True <EOL> ] <EOL> import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } <EOL> data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) <EOL> for ele in data : <EOL> filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } <EOL> instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) <EOL> serializer = self . import_serializer_class ( instance , data = ele , request = request ) <EOL> serializer . is_valid ( raise_exception = True ) <EOL> serializer . save ( ) <EOL> return DetailResponse ( msg = f\"<STR_LIT>\" ) <EOL> @ action ( methods = [ '<STR_LIT>' ] , detail = False ) <EOL> def update_template ( self , request ) : <EOL> queryset = self . filter_queryset ( self . get_queryset ( ) ) <EOL> assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ <EOL> data = self . import_serializer_class ( queryset , many = True , request = request ) . data <EOL> response = HttpResponse ( content_type = \"<STR_LIT>\" ) <EOL> response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" <EOL> response [ \"<STR_LIT>\" ] = f'<STR_LIT>' <EOL> wb = Workbook ( ) <EOL> ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ws1 . sheet_state = \"<STR_LIT>\" <EOL> ws = wb . active <EOL> import_field_dict = { } <EOL> header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> validation_data_dict = { } <EOL> for index , item in enumerate ( self . import_field_dict . items ( ) ) : <EOL> items = list ( item ) <EOL> key = items [ <NUM_LIT> ] <EOL> value = items [ <NUM_LIT> ] <EOL> if isinstance ( value , dict ) : <EOL> header_data . append ( value . get ( \"<STR_LIT>\" ) ) <EOL> hidden_header . append ( value . get ( '<STR_LIT>' ) ) <EOL> choices = value . get ( \"<STR_LIT>\" , { } ) <EOL> if choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = [ ] <EOL> data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list <EOL> elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : <EOL> data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) <EOL> validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) <EOL> else : <EOL> continue <EOL> column_letter = get_column_letter ( len ( validation_data_dict ) ) <EOL> dv = DataValidation ( <EOL> type = \"<STR_LIT>\" , <EOL> formula1 = f\"<STR_LIT>\" , <EOL> allow_blank = True , <EOL> ) <EOL> ws . add_data_validation ( dv ) <EOL> dv . add ( f\"<STR_LIT>\" ) <EOL> else : <EOL> header_data . append ( value ) <EOL> hidden_header . append ( key ) <EOL> ws1 . append ( list ( validation_data_dict . keys ( ) ) ) <EOL> for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : <EOL> for inx , ele in enumerate ( validation_data ) : <EOL> ws1 [ f\"<STR_LIT>\" ] = ele <EOL> df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] <EOL> row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) <EOL> column = <NUM_LIT> <EOL> ws . append ( header_data ) <EOL> for index , results in enumerate ( data ) : <EOL> results_list = [ ] <EOL> for h_index , h_item in enumerate ( hidden_header ) : <EOL> for key , val in results . items ( ) : <EOL> if key == h_item : <EOL> if val is None or val == \"<STR_LIT>\" : <EOL> results_list . append ( \"<STR_LIT>\" ) <EOL> elif isinstance ( val , list ) : <EOL> results_list . append ( str ( val ) ) <EOL> else : <EOL> results_list . append ( val ) <EOL> if isinstance ( val , str ) : <EOL> result_column_width = self . get_string_len ( val ) <EOL> if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : <EOL> df_len_max [ h_index ] = result_column_width <EOL> ws . append ( [ index + <NUM_LIT> , * results_list ] ) <EOL> column += <NUM_LIT> <EOL> for index , width in enumerate ( df_len_max ) : <EOL> ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width <EOL> tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) <EOL> style = TableStyleInfo ( <EOL> name = \"<STR_LIT>\" , <EOL> showFirstColumn = True , <EOL> showLastColumn = True , <EOL> showRowStripes = True , <EOL> showColumnStripes = True , <EOL> ) <EOL> tab . tableStyleInfo = style <EOL> ws . add_table ( tab ) <EOL> wb . save ( response ) <EOL> return response <EOL> class ExportSerializerMixin : <EOL> export_field_label = [ ] <EOL> export_serializer_class = None <EOL> export_column_width = <NUM_LIT> <EOL> def is_number ( self , num ) : <EOL> try : <EOL> float ( num ) <EOL> return True <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> import unicodedata <EOL> unicodedata . numeric ( num ) <EOL> return True <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return False <EOL> def get_string_len ( self , string ) : <EOL> length = <NUM_LIT> <EOL> if string is None : <EOL> return length <EOL> if self . is_number ( string ) : <EOL> return length <EOL> for char in string : <EOL> length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> <EOL> ", "gt": "return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width"}
{"input": "from collections import OrderedDict <EOL> from django . core import paginator <EOL> from django . core . paginator import Paginator as DjangoPaginator , InvalidPage <EOL> from rest_framework . pagination import PageNumberPagination <EOL> from rest_framework . response import Response <EOL> class CustomPagination ( PageNumberPagination ) : <EOL> page_size = <NUM_LIT> <EOL> page_size_query_param = \"<STR_LIT>\" <EOL> max_page_size = <NUM_LIT> <EOL> django_paginator_class = DjangoPaginator <EOL> def paginate_queryset ( self , queryset , request , view = None ) : <EOL> empty = True <EOL> page_size = self . get_page_size ( request ) <EOL> if not page_size : <EOL> return None <EOL> paginator = self . django_paginator_class ( queryset , page_size ) <EOL> page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) <EOL> if page_number in self . last_page_strings : <EOL> page_number = paginator . num_pages <EOL> try : <EOL> self . page = paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> empty = False <EOL> if paginator . num_pages > <NUM_LIT> and self . template is not None : <EOL> self . display_page_controls = True <EOL> self . request = request <EOL> if not empty : <EOL> self . page = [ ] <EOL> return list ( self . page ) <EOL> def get_paginated_response ( self , data ) : <EOL> code = <NUM_LIT> <EOL> msg = '<STR_LIT>' <EOL> page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> <EOL> total = self . page . paginator . count if self . page else <NUM_LIT> <EOL> limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> <EOL> is_next = self . page . has_next ( ) if self . page else False <EOL> is_previous = self . page . has_previous ( ) if self . page else False <EOL> if not data : <EOL> code = <NUM_LIT> <EOL> msg = \"<STR_LIT>\" <EOL> data = [ ] <EOL> return Response ( OrderedDict ( [ <EOL> ( '<STR_LIT>' , code ) , <EOL> ( '<STR_LIT>' , msg ) , <EOL> ( '<STR_LIT>' , page ) , <EOL> ( '<STR_LIT>' , limit ) , <EOL> ( '<STR_LIT>' , total ) , <EOL> ( '<STR_LIT>' , is_next ) , <EOL> ( '<STR_LIT>' , is_previous ) , <EOL> ( '<STR_LIT>' , data ) <EOL> ", "gt": "] ) )"}
