{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> ", "gt": "f\"<STR_LIT>\""}
{"input": "import io <EOL> import os <EOL> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import tomlkit <EOL> from cappa . testing import CommandRunner <EOL> def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> assert env_file . exists ( ) <EOL> assert env_template_file . exists ( ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "env_file . write_text ( \"<STR_LIT>\" )"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : get_superuser_email ( project_name ) , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> } <EOL> def get_superuser_email ( project_name : str ) : <EOL> pyproject_file = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "if pyproject_file . exists ( ) :"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> ", "gt": "name = \"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> ", "gt": "} ,"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ", "gt": ")"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : get_superuser_email ( project_name ) , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> } <EOL> def get_superuser_email ( project_name : str ) : <EOL> pyproject_file = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_file . exists ( ) : <EOL> pyproject = tomlkit . parse ( pyproject_file . read_text ( ) ) <EOL> if authors := pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , [ ] ) : <EOL> return authors [ <NUM_LIT> ] [ \"<STR_LIT>\" ] <EOL> return f\"<STR_LIT>\" <EOL> def parse ( env_content : str ) -> dict : <EOL> result = { } <EOL> for line in env_content . split ( \"<STR_LIT>\" ) : <EOL> stripped_line = line . strip ( ) <EOL> if stripped_line . startswith ( \"<STR_LIT>\" ) or not stripped_line : <EOL> continue <EOL> try : <EOL> key , value = stripped_line . split ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> except ValueError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> result [ key ] = value <EOL> return result <EOL> def get_updated ( env_content : str , config : dict , * , keep_original = False , keep_whitespace = False ) -> str : <EOL> content_list = env_content . split ( \"<STR_LIT>\" ) <EOL> content_dict = { line . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] : line for line in content_list if \"<STR_LIT>\" in line } <EOL> new_content_list = content_list . copy ( ) <EOL> for key , value in config . items ( ) : <EOL> line = content_dict . get ( key ) <EOL> if line is not None : <EOL> index = new_content_list . index ( line ) <EOL> if not keep_original : <EOL> new_content_list [ index ] = f\"<STR_LIT>\" <EOL> else : <EOL> new_content_list . append ( f\"<STR_LIT>\" ) <EOL> if not keep_whitespace : <EOL> ", "gt": "new_content_list = [ line . strip ( ) for line in new_content_list if line . strip ( ) ]"}
{"input": "import subprocess <EOL> from contextlib import suppress <EOL> import cappa <EOL> def clean_git_repo ( * , ignore_dirty : bool = False ) -> None : <EOL> if ignore_dirty : <EOL> return <EOL> with suppress ( subprocess . CalledProcessError ) : <EOL> result = subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , capture_output = True , text = True , check = True ) <EOL> if result . stdout . strip ( ) == \"<STR_LIT>\" : <EOL> return <EOL> ", "gt": "raise cappa . Exit ("}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> repo = name_to_urls . get ( blueprint , blueprint ) <EOL> if repo . startswith ( \"<STR_LIT>\" ) and use_local : <EOL> if local_repo := find_local_cookiecutter ( repo ) : <EOL> repo = str ( local_repo . resolve ( ) ) <EOL> else : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , repo , \"<STR_LIT>\" ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> revision = result . stdout . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] . split ( ) [ <NUM_LIT> ] . strip ( ) <EOL> return repo , revision <EOL> def get_authors_info ( ) -> tuple [ str , str ] : <EOL> default_author_name = \"<STR_LIT>\" <EOL> default_author_email = \"<STR_LIT>\" <EOL> git_config_cmd = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> try : <EOL> user_name_cmd = subprocess . run ( [ * git_config_cmd , \"<STR_LIT>\" ] , capture_output = True , text = True , check = False ) <EOL> user_email_cmd = subprocess . run ( [ * git_config_cmd , \"<STR_LIT>\" ] , capture_output = True , text = True , check = False ) <EOL> except FileNotFoundError : <EOL> return default_author_name , default_author_email <EOL> if user_email_cmd . returncode != <NUM_LIT> : <EOL> return default_author_name , default_author_email <EOL> return ( <EOL> user_name_cmd . stdout . strip ( \"<STR_LIT>\" ) , <EOL> user_email_cmd . stdout . strip ( \"<STR_LIT>\" ) , <EOL> ) <EOL> @ contextmanager <EOL> ", "gt": "def change_directory ( new_directory : str | Path ) :"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , <EOL> ( \"<STR_LIT>\" , models . TextField ( ) ) , <EOL> ( \"<STR_LIT>\" , models . DecimalField ( decimal_places = <NUM_LIT> , max_digits = <NUM_LIT> ) ) , <EOL> ", "gt": "( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) ,"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> ", "gt": "verbose_name = \"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "pyproject_toml . touch ( )"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> ", "gt": "with TemporaryDirectory ( ) as temp :"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> partials_to_use = [ partials_to_use ] <EOL> rendered_partials = [ <EOL> render_to_string ( f\"<STR_LIT>\" , context = resp . context_data , request = request ) <EOL> for b in partials_to_use <EOL> ] <EOL> resp = HttpResponse ( <EOL> content = \"<STR_LIT>\" . join ( rendered_partials ) , <EOL> status = resp . status_code , <EOL> headers = resp . headers , <EOL> ) <EOL> return resp <EOL> return _view <EOL> return decorator <EOL> def _get_param_from_request ( request , param ) : <EOL> if param in request . GET : <EOL> ", "gt": "return request . GET . getlist ( param )"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> ", "gt": "filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) )"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> ", "gt": "\"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) ,"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> output_file . touch ( exist_ok = True ) <EOL> output_file . write_text ( <EOL> render_to_string ( imports_template , context ) <EOL> + render_to_string ( code_template , context ) <EOL> + output_file . read_text ( ) <EOL> ) <EOL> generated_files . append ( output_file ) <EOL> for file in generated_files : <EOL> run_python_formatters ( str ( file ) ) <EOL> return output_dir <EOL> ", "gt": "@ classmethod"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> ", "gt": "html_static_path = [ \"<STR_LIT>\" ]"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) <EOL> module = parso . parse ( settings_file . read_text ( ) ) <EOL> for node in module . children : <EOL> try : <EOL> if ( <EOL> node . children [ <NUM_LIT> ] . type == parso . python . tree . ExprStmt . type <EOL> and node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] . value in names <EOL> ", "gt": ") :"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> ", "gt": "assert ( output / \"<STR_LIT>\" ) . exists ( )"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> html_logo = \"<STR_LIT>\" <EOL> html_favicon = \"<STR_LIT>\" <EOL> html_css_files = [ <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "]"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> html_logo = \"<STR_LIT>\" <EOL> html_favicon = \"<STR_LIT>\" <EOL> html_css_files = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> html_js_files = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> ) , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ", "gt": "mermaid_version = \"<STR_LIT>\""}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> ", "gt": "with simple_progress ( \"<STR_LIT>\" ) :"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> def makemigaration ( ) : <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = False ) <EOL> def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert not first_migration . exists ( ) <EOL> def test_rm_migrations_fake_apps_dir ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ", "gt": "assert first_migration . exists ( )"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> ", "gt": "return original_run ( args , ** kwargs )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) <EOL> ", "gt": "module = parso . parse ( settings_file . read_text ( ) )"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> ", "gt": "dotenv_template_content = get_updated ("}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ", "gt": ") ,"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import pytest <EOL> from falco . commands . work import default_address <EOL> from falco . commands . work import default_server_cmd <EOL> from falco . commands . work import Work <EOL> from falco . config import write_falco_config <EOL> def test_env_resolution ( tmp_path ) : <EOL> assert Work ( ) . resolve_django_env ( ) <EOL> def test_env_resolution_with_env ( tmp_path ) : <EOL> ( tmp_path / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in Work ( ) . resolve_django_env ( ) <EOL> def test_without_pyproject_file ( ) : <EOL> assert Work ( ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) } <EOL> def test_with_pyproject_file ( pyproject_toml ) : <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> assert Work ( ) . get_commands ( ) == { <EOL> \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def test_override_server ( pyproject_toml ) : <EOL> work = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = work ) <EOL> assert Work ( ) . get_commands ( ) == work <EOL> @ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> def test_override_server_through_arg ( address ) : <EOL> assert Work ( address = address ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = address ) } <EOL> ", "gt": "@ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] )"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> html_logo = \"<STR_LIT>\" <EOL> html_favicon = \"<STR_LIT>\" <EOL> html_css_files = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> html_js_files = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "{ \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } ,"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> ", "gt": "StartProject ("}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> ", "gt": "url = HTMX_DOWNLOAD_URL . format ( version = version )"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> ", "gt": "@ classmethod"}
{"input": "import os <EOL> import sys <EOL> def main ( ) : <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> try : <EOL> from django . core . management import execute_from_command_line <EOL> except ImportError as exc : <EOL> raise ImportError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) from exc <EOL> ", "gt": "execute_from_command_line ( sys . argv )"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise ShellCodeError ( result . stderr ) <EOL> return ast . literal_eval ( result . stdout ) if eval_result else result . stdout . strip ( ) <EOL> def is_new_falco_cli_available ( ) -> bool : <EOL> try : <EOL> with network_request_with_progress ( <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> from typing import cast <EOL> from typing import TypedDict <EOL> import tomlkit <EOL> from typing_extensions import Unpack <EOL> class FalcoConfig ( TypedDict , total = False ) : <EOL> revision : str <EOL> blueprint : str <EOL> skip : list [ str ] <EOL> work : dict [ str , str ] <EOL> htmx : str <EOL> crud : \"<STR_LIT>\" <EOL> class CRUDConfig ( TypedDict ) : <EOL> blueprints : str <EOL> utils_path : str <EOL> login_required : bool <EOL> skip_git_check : bool <EOL> always_migrate : bool <EOL> def parse_crud_config_from_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def parse_crud_config_to_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def write_falco_config ( pyproject_path : Path , ** kwargs : Unpack [ TypedDict ] ) -> None : <EOL> new_falco_config = kwargs <EOL> new_crud_config = parse_crud_config_to_pyproject ( new_falco_config . pop ( \"<STR_LIT>\" , { } ) ) <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> existing_falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config = existing_falco_config . pop ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config . update ( new_crud_config ) <EOL> existing_falco_config . update ( { ** new_falco_config , \"<STR_LIT>\" : existing_crud_config } ) <EOL> tool = pyproject . get ( \"<STR_LIT>\" , { } ) <EOL> tool . update ( { \"<STR_LIT>\" : existing_falco_config } ) <EOL> pyproject [ \"<STR_LIT>\" ] = tool <EOL> ", "gt": "pyproject_path . write_text ( tomlkit . dumps ( pyproject ) )"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from honcho . manager import Manager <EOL> from . sync_dotenv import parse as parse_dotenv <EOL> default_server_cmd = \"<STR_LIT>\" <EOL> default_address = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Work : <EOL> address : Annotated [ str , cappa . Arg ( default = default_address , help = \"<STR_LIT>\" ) ] = default_address <EOL> def __call__ ( self ) -> None : <EOL> commands = self . get_commands ( ) <EOL> manager = Manager ( ) <EOL> django_env = self . resolve_django_env ( ) <EOL> for name , cmd in commands . items ( ) : <EOL> manager . add_process ( name , cmd , env = django_env ) <EOL> try : <EOL> manager . loop ( ) <EOL> finally : <EOL> ", "gt": "manager . terminate ( )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> def makemigaration ( ) : <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = False ) <EOL> def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert not first_migration . exists ( ) <EOL> ", "gt": "def test_rm_migrations_fake_apps_dir ( django_project , runner : CommandRunner , set_git_repo_to_clean ) :"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> def makemigaration ( ) : <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = False ) <EOL> def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> ", "gt": "runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from honcho . manager import Manager <EOL> from . sync_dotenv import parse as parse_dotenv <EOL> default_server_cmd = \"<STR_LIT>\" <EOL> default_address = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Work : <EOL> address : Annotated [ str , cappa . Arg ( default = default_address , help = \"<STR_LIT>\" ) ] = default_address <EOL> def __call__ ( self ) -> None : <EOL> commands = self . get_commands ( ) <EOL> manager = Manager ( ) <EOL> django_env = self . resolve_django_env ( ) <EOL> for name , cmd in commands . items ( ) : <EOL> manager . add_process ( name , cmd , env = django_env ) <EOL> try : <EOL> manager . loop ( ) <EOL> finally : <EOL> manager . terminate ( ) <EOL> sys . exit ( manager . returncode ) <EOL> def resolve_django_env ( self ) -> dict : <EOL> current_dir = Path ( ) . resolve ( ) <EOL> env_file = current_dir / \"<STR_LIT>\" <EOL> env_vars = parse_dotenv ( env_file . read_text ( ) ) if env_file . exists ( ) else { } <EOL> return { <EOL> ** os . environ , <EOL> \"<STR_LIT>\" : str ( current_dir ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ** env_vars , <EOL> } <EOL> def get_commands ( self ) -> dict : <EOL> ", "gt": "commands = { \"<STR_LIT>\" : default_server_cmd }"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> ", "gt": "renamed_project_dir . rmdir ( )"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> ", "gt": "related_query_name = \"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> root_dir = Path ( __file__ ) . parent . parent <EOL> readme = root_dir / \"<STR_LIT>\" <EOL> guides = root_dir / \"<STR_LIT>\" <EOL> guides_index = guides / \"<STR_LIT>\" <EOL> def get_rst_doc_title ( file : Path ) : <EOL> title = \"<STR_LIT>\" <EOL> for line in file . read_text ( ) . splitlines ( ) : <EOL> if line . startswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> title = line <EOL> return title <EOL> def guides_files ( ) : <EOL> index_content = guides_index . read_text ( ) <EOL> toc_tree_directive = \"<STR_LIT>\" <EOL> start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) <EOL> def valid_line ( line ) : <EOL> return bool ( line ) and not line . strip ( ) . startswith ( \"<STR_LIT>\" ) <EOL> lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( \"<STR_LIT>\" ) if valid_line ( line ) ] <EOL> return [ guides / f\"<STR_LIT>\" for line in lines ] <EOL> def get_guides_list ( ) : <EOL> guides_md = [ ] <EOL> for file in guides_files ( ) : <EOL> if file . name . startswith ( \"<STR_LIT>\" ) : <EOL> continue <EOL> link = f\"<STR_LIT>\" <EOL> title = get_rst_doc_title ( file ) <EOL> guides_md . append ( f\"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" + \"<STR_LIT>\" . join ( guides_md ) + \"<STR_LIT>\" <EOL> def update_readme ( start_comment , end_comment , new_content ) : <EOL> text = readme . read_text ( ) <EOL> start_index = text . find ( start_comment ) + len ( start_comment ) <EOL> end_index = text . find ( end_comment ) <EOL> new_content = text [ : start_index ] + new_content + text [ end_index : ] <EOL> readme . write_text ( new_content ) <EOL> def main ( ) : <EOL> ", "gt": "update_readme ("}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> content = response . content . decode ( \"<STR_LIT>\" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> filepath = self . resolve_filepath ( falco_config = falco_config ) <EOL> filepath . parent . mkdir ( parents = True , exist_ok = True ) <EOL> ", "gt": "filepath . write_text ( content )"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> skip_new_version_check = True , <EOL> ) ( ) <EOL> walk_directory ( temp_dir , tree ) <EOL> console = Console ( record = True ) <EOL> with console . capture ( ) : <EOL> console . print ( tree ) <EOL> console . save_svg ( <EOL> \"<STR_LIT>\" , <EOL> title = \"<STR_LIT>\" , <EOL> theme = DIMMED_MONOKAI , <EOL> ) <EOL> ", "gt": "if __name__ == \"<STR_LIT>\" :"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> ", "gt": "\"<STR_LIT>\" : self . blueprint ,"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> skip_new_version_check = True , <EOL> ) ( ) <EOL> walk_directory ( temp_dir , tree ) <EOL> console = Console ( record = True ) <EOL> with console . capture ( ) : <EOL> console . print ( tree ) <EOL> console . save_svg ( <EOL> \"<STR_LIT>\" , <EOL> title = \"<STR_LIT>\" , <EOL> theme = DIMMED_MONOKAI , <EOL> ", "gt": ")"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> ", "gt": "subtitle = subtitle ,"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> run_in_shell ( reset_migrations_table , eval_result = False ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> stderr = subprocess . DEVNULL , <EOL> ", "gt": ")"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> html_logo = \"<STR_LIT>\" <EOL> html_favicon = \"<STR_LIT>\" <EOL> html_css_files = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> html_js_files = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> ", "gt": ") ,"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> def makemigaration ( ) : <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = False ) <EOL> def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert not first_migration . exists ( ) <EOL> def test_rm_migrations_fake_apps_dir ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> ", "gt": "runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco import checks <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> def get_django_debug_value ( ) -> bool : <EOL> from django . conf import settings <EOL> return settings . DEBUG <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class RmMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) <EOL> django_debug_value = run_in_shell ( get_django_debug_value , eval_result = True ) <EOL> if not django_debug_value : <EOL> raise cappa . Exit ( <EOL> \"<STR_LIT>\" , <EOL> code = <NUM_LIT> , <EOL> ) <EOL> if not self . apps_dir : <EOL> self . apps_dir = Path ( ) / project_name <EOL> apps = set ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for folder in self . apps_dir . iterdir ( ) : <EOL> migration_dir = folder / \"<STR_LIT>\" <EOL> if not migration_dir . exists ( ) : <EOL> continue <EOL> apps . add ( folder . stem ) <EOL> for file in migration_dir . iterdir ( ) : <EOL> if file . suffix == \"<STR_LIT>\" and file . name not in [ \"<STR_LIT>\" ] : <EOL> file . unlink ( ) <EOL> ", "gt": "apps_ = \"<STR_LIT>\" . join ( apps )"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> ", "gt": "content = response . content . decode ( \"<STR_LIT>\" )"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ] , <EOL> options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } , <EOL> managers = [ <EOL> ( \"<STR_LIT>\" , django . contrib . auth . models . UserManager ( ) ) , <EOL> ", "gt": "] ,"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "from django . db import models <EOL> class Order ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT> ) <EOL> email = models . EmailField ( ) <EOL> address = models . CharField ( max_length = <NUM_LIT> ) <EOL> postal_code = models . CharField ( max_length = <NUM_LIT> ) <EOL> city = models . CharField ( max_length = <NUM_LIT> ) <EOL> products = models . ManyToManyField ( \"<STR_LIT>\" ) <EOL> created = models . DateTimeField ( auto_now_add = True ) <EOL> completed = models . BooleanField ( default = False ) <EOL> receipt = models . FileField ( null = True , blank = True ) <EOL> ", "gt": "image = models . ImageField ( null = True , blank = True )"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> ", "gt": "verbose_name = \"<STR_LIT>\" ,"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> ", "gt": "models_file . write_text ("}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> skip_new_version_check = True , <EOL> ) ( ) <EOL> walk_directory ( temp_dir , tree ) <EOL> console = Console ( record = True ) <EOL> with console . capture ( ) : <EOL> console . print ( tree ) <EOL> ", "gt": "console . save_svg ("}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> ", "gt": "Panel ("}
{"input": "import io <EOL> import os <EOL> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import tomlkit <EOL> from cappa . testing import CommandRunner <EOL> def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> assert env_file . exists ( ) <EOL> assert env_template_file . exists ( ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> def test_print_value ( runner : CommandRunner , pyproject_toml ) : <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> with patch ( \"<STR_LIT>\" , new = io . StringIO ( ) ) as fake_stdout : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> stdout = fake_stdout . getvalue ( ) <EOL> assert not Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert \"<STR_LIT>\" in stdout <EOL> def test_prod_config ( runner : CommandRunner , pyproject_toml ) : <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> pyproject = tomlkit . parse ( pyproject_toml . read_text ( ) ) <EOL> pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] = [ { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } ] <EOL> ", "gt": "pyproject_toml . write_text ( tomlkit . dumps ( pyproject ) )"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> repo = name_to_urls . get ( blueprint , blueprint ) <EOL> if repo . startswith ( \"<STR_LIT>\" ) and use_local : <EOL> if local_repo := find_local_cookiecutter ( repo ) : <EOL> repo = str ( local_repo . resolve ( ) ) <EOL> else : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ", "gt": "result = subprocess . run ("}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco import checks <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> def get_django_debug_value ( ) -> bool : <EOL> from django . conf import settings <EOL> return settings . DEBUG <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class RmMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) <EOL> django_debug_value = run_in_shell ( get_django_debug_value , eval_result = True ) <EOL> ", "gt": "if not django_debug_value :"}
{"input": "import io <EOL> import os <EOL> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import tomlkit <EOL> from cappa . testing import CommandRunner <EOL> def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> assert env_file . exists ( ) <EOL> assert env_template_file . exists ( ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> def test_print_value ( runner : CommandRunner , pyproject_toml ) : <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> with patch ( \"<STR_LIT>\" , new = io . StringIO ( ) ) as fake_stdout : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> stdout = fake_stdout . getvalue ( ) <EOL> assert not Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert \"<STR_LIT>\" in stdout <EOL> def test_prod_config ( runner : CommandRunner , pyproject_toml ) : <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> ", "gt": "pyproject = tomlkit . parse ( pyproject_toml . read_text ( ) )"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> skip_new_version_check = True , <EOL> ", "gt": ") ( )"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "pyproject_toml . touch ( )"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "import pytest <EOL> from falco . commands . work import default_address <EOL> from falco . commands . work import default_server_cmd <EOL> from falco . commands . work import Work <EOL> from falco . config import write_falco_config <EOL> def test_env_resolution ( tmp_path ) : <EOL> assert Work ( ) . resolve_django_env ( ) <EOL> def test_env_resolution_with_env ( tmp_path ) : <EOL> ( tmp_path / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in Work ( ) . resolve_django_env ( ) <EOL> def test_without_pyproject_file ( ) : <EOL> assert Work ( ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) } <EOL> def test_with_pyproject_file ( pyproject_toml ) : <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> assert Work ( ) . get_commands ( ) == { <EOL> \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def test_override_server ( pyproject_toml ) : <EOL> work = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = work ) <EOL> assert Work ( ) . get_commands ( ) == work <EOL> @ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> def test_override_server_through_arg ( address ) : <EOL> assert Work ( address = address ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = address ) } <EOL> @ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> def test_override_server_through_arg_by_pyproject ( pyproject_toml , address ) : <EOL> work = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = work ) <EOL> ", "gt": "assert Work ( address = address ) . get_commands ( ) == { \"<STR_LIT>\" : work [ \"<STR_LIT>\" ] . format ( address = address ) }"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . DateTimeField ( blank = True , null = True ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> ", "gt": "name = \"<STR_LIT>\" ,"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> ", "gt": "msg = f\"<STR_LIT>\""}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ", "gt": ")"}
{"input": "import io <EOL> import os <EOL> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import tomlkit <EOL> from cappa . testing import CommandRunner <EOL> def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> assert env_file . exists ( ) <EOL> assert env_template_file . exists ( ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> def test_print_value ( runner : CommandRunner , pyproject_toml ) : <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "env_template_file . write_text ( \"<STR_LIT>\" )"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> ", "gt": "filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config )"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> ", "gt": "class ShellCodeError ( Exception ) :"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . DateTimeField ( auto_now_add = True , default = django . utils . timezone . now ) , <EOL> ", "gt": "preserve_default = False ,"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> content = response . content . decode ( \"<STR_LIT>\" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> filepath = self . resolve_filepath ( falco_config = falco_config ) <EOL> filepath . parent . mkdir ( parents = True , exist_ok = True ) <EOL> filepath . write_text ( content ) <EOL> return filepath <EOL> def resolve_filepath ( self , falco_config : dict ) -> Path : <EOL> if self . output : <EOL> filepath = self . output if str ( self . output ) . endswith ( \"<STR_LIT>\" ) else self . output / \"<STR_LIT>\" <EOL> elif self . output is None and \"<STR_LIT>\" in falco_config : <EOL> htmx_config = self . read_from_config ( falco_config ) <EOL> filepath , _ = htmx_config <EOL> else : <EOL> filepath = Path ( \"<STR_LIT>\" ) <EOL> return filepath <EOL> @ classmethod <EOL> def read_from_config ( cls , falco_config : dict ) -> HtmxConfig : <EOL> htmx = falco_config . get ( \"<STR_LIT>\" ) <EOL> if not htmx : <EOL> return Path ( \"<STR_LIT>\" ) , None <EOL> try : <EOL> filepath , version = htmx . split ( \"<STR_LIT>\" ) <EOL> except ValueError : <EOL> return Path ( htmx ) , None <EOL> ", "gt": "return Path ( filepath ) , version"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> ", "gt": "dotenv_template_file . touch ( exist_ok = True )"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> ", "gt": "write_falco_config ( pyproject_path = pyproject_toml )"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> html_logo = \"<STR_LIT>\" <EOL> ", "gt": "html_favicon = \"<STR_LIT>\""}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> @ pytest . fixture <EOL> def git_user_infos ( ) : <EOL> name = \"<STR_LIT>\" <EOL> email = \"<STR_LIT>\" <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = name <EOL> return mock <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> ", "gt": "mock = MagicMock ( )"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> ", "gt": "}"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . EmailField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . ManyToManyField ( to = \"<STR_LIT>\" ) ) , <EOL> ] , <EOL> ) , <EOL> ", "gt": "]"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> ", "gt": "filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) )"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . BooleanField ( default = False ) , <EOL> ", "gt": ") ,"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_htmx_ext_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "pyproject_toml . touch ( )"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . DateTimeField ( blank = True , null = True ) , <EOL> ) , <EOL> ", "gt": "migrations . AddField ("}
{"input": "import pytest <EOL> from falco . commands . work import default_address <EOL> from falco . commands . work import default_server_cmd <EOL> from falco . commands . work import Work <EOL> from falco . config import write_falco_config <EOL> def test_env_resolution ( tmp_path ) : <EOL> assert Work ( ) . resolve_django_env ( ) <EOL> def test_env_resolution_with_env ( tmp_path ) : <EOL> ( tmp_path / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in Work ( ) . resolve_django_env ( ) <EOL> def test_without_pyproject_file ( ) : <EOL> assert Work ( ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) } <EOL> def test_with_pyproject_file ( pyproject_toml ) : <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> assert Work ( ) . get_commands ( ) == { <EOL> \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def test_override_server ( pyproject_toml ) : <EOL> work = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = work ) <EOL> assert Work ( ) . get_commands ( ) == work <EOL> @ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> def test_override_server_through_arg ( address ) : <EOL> assert Work ( address = address ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = address ) } <EOL> @ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> def test_override_server_through_arg_by_pyproject ( pyproject_toml , address ) : <EOL> ", "gt": "work = { \"<STR_LIT>\" : \"<STR_LIT>\" }"}
{"input": "import importlib <EOL> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> from falco . utils import simple_progress <EOL> from jinja2 import Template <EOL> IMPORT_START_COMMENT = \"<STR_LIT>\" <EOL> IMPORT_END_COMMENT = \"<STR_LIT>\" <EOL> CODE_START_COMMENT = \"<STR_LIT>\" <EOL> CODE_END_COMMENT = \"<STR_LIT>\" <EOL> def render_to_string ( template_content : str , context : dict ) : <EOL> return Template ( template_content ) . render ( ** context ) <EOL> def get_crud_blueprints_path ( ) -> Path : <EOL> package = importlib . util . find_spec ( \"<STR_LIT>\" ) <EOL> if package is None : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / \"<STR_LIT>\" <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_python_formatters ( filepath : str | Path ) : <EOL> autoflake = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> filepath , <EOL> ] <EOL> black = [ \"<STR_LIT>\" , filepath ] <EOL> isort = [ \"<STR_LIT>\" , filepath ] <EOL> subprocess . run ( autoflake , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( isort , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( black , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> ", "gt": "def run_html_formatters ( filepath : str | Path ) :"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> ", "gt": "if use_partial_from_params_val is not None :"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> partials_to_use = [ partials_to_use ] <EOL> rendered_partials = [ <EOL> render_to_string ( f\"<STR_LIT>\" , context = resp . context_data , request = request ) <EOL> for b in partials_to_use <EOL> ] <EOL> resp = HttpResponse ( <EOL> content = \"<STR_LIT>\" . join ( rendered_partials ) , <EOL> status = resp . status_code , <EOL> headers = resp . headers , <EOL> ) <EOL> return resp <EOL> return _view <EOL> ", "gt": "return decorator"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . DateTimeField ( blank = True , null = True ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . ImageField ( blank = True , null = True , upload_to = \"<STR_LIT>\" ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> ", "gt": "field = models . FileField ( blank = True , null = True , upload_to = \"<STR_LIT>\" ) ,"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> skip_new_version_check = True , <EOL> ) ( ) <EOL> walk_directory ( temp_dir , tree ) <EOL> console = Console ( record = True ) <EOL> with console . capture ( ) : <EOL> ", "gt": "console . print ( tree )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> ", "gt": "if result . returncode != <NUM_LIT> :"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . EmailField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ", "gt": "( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) ,"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> ", "gt": "help_text = \"<STR_LIT>\" ,"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise ShellCodeError ( result . stderr ) <EOL> return ast . literal_eval ( result . stdout ) if eval_result else result . stdout . strip ( ) <EOL> def is_new_falco_cli_available ( ) -> bool : <EOL> try : <EOL> with network_request_with_progress ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) as response : <EOL> latest_version = response . json ( ) [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> ", "gt": "current_version = falco_version"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> content = response . content . decode ( \"<STR_LIT>\" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> filepath = self . resolve_filepath ( falco_config = falco_config ) <EOL> filepath . parent . mkdir ( parents = True , exist_ok = True ) <EOL> filepath . write_text ( content ) <EOL> return filepath <EOL> def resolve_filepath ( self , falco_config : dict ) -> Path : <EOL> if self . output : <EOL> filepath = self . output if str ( self . output ) . endswith ( \"<STR_LIT>\" ) else self . output / \"<STR_LIT>\" <EOL> elif self . output is None and \"<STR_LIT>\" in falco_config : <EOL> ", "gt": "htmx_config = self . read_from_config ( falco_config )"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from honcho . manager import Manager <EOL> from . sync_dotenv import parse as parse_dotenv <EOL> default_server_cmd = \"<STR_LIT>\" <EOL> default_address = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Work : <EOL> address : Annotated [ str , cappa . Arg ( default = default_address , help = \"<STR_LIT>\" ) ] = default_address <EOL> def __call__ ( self ) -> None : <EOL> commands = self . get_commands ( ) <EOL> manager = Manager ( ) <EOL> django_env = self . resolve_django_env ( ) <EOL> for name , cmd in commands . items ( ) : <EOL> manager . add_process ( name , cmd , env = django_env ) <EOL> try : <EOL> manager . loop ( ) <EOL> finally : <EOL> manager . terminate ( ) <EOL> sys . exit ( manager . returncode ) <EOL> def resolve_django_env ( self ) -> dict : <EOL> current_dir = Path ( ) . resolve ( ) <EOL> env_file = current_dir / \"<STR_LIT>\" <EOL> env_vars = parse_dotenv ( env_file . read_text ( ) ) if env_file . exists ( ) else { } <EOL> return { <EOL> ** os . environ , <EOL> \"<STR_LIT>\" : str ( current_dir ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ** env_vars , <EOL> } <EOL> def get_commands ( self ) -> dict : <EOL> commands = { \"<STR_LIT>\" : default_server_cmd } <EOL> pyproject_file = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_file . exists ( ) : <EOL> user_commands = read_falco_config ( pyproject_path = pyproject_file ) . get ( \"<STR_LIT>\" , { } ) <EOL> else : <EOL> user_commands = { } <EOL> ", "gt": "commands |= user_commands"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> run_in_shell ( reset_migrations_table , eval_result = False ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = True , <EOL> ", "gt": "stdout = subprocess . DEVNULL ,"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ", "gt": "raise cappa . Exit ( msg , code = <NUM_LIT> )"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> ", "gt": "pyproject_toml = tmp_path / \"<STR_LIT>\""}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> ", "gt": "\"<STR_LIT>\" : revision ,"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> skip_new_version_check = True , <EOL> ) ( ) <EOL> walk_directory ( temp_dir , tree ) <EOL> console = Console ( record = True ) <EOL> with console . capture ( ) : <EOL> console . print ( tree ) <EOL> console . save_svg ( <EOL> \"<STR_LIT>\" , <EOL> title = \"<STR_LIT>\" , <EOL> theme = DIMMED_MONOKAI , <EOL> ) <EOL> if __name__ == \"<STR_LIT>\" : <EOL> ", "gt": "main ( )"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> output_file . touch ( exist_ok = True ) <EOL> ", "gt": "output_file . write_text ("}
{"input": "import pytest <EOL> from falco . commands . work import default_address <EOL> from falco . commands . work import default_server_cmd <EOL> from falco . commands . work import Work <EOL> from falco . config import write_falco_config <EOL> def test_env_resolution ( tmp_path ) : <EOL> assert Work ( ) . resolve_django_env ( ) <EOL> def test_env_resolution_with_env ( tmp_path ) : <EOL> ( tmp_path / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in Work ( ) . resolve_django_env ( ) <EOL> def test_without_pyproject_file ( ) : <EOL> assert Work ( ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) } <EOL> def test_with_pyproject_file ( pyproject_toml ) : <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> assert Work ( ) . get_commands ( ) == { <EOL> \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def test_override_server ( pyproject_toml ) : <EOL> work = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = work ) <EOL> assert Work ( ) . get_commands ( ) == work <EOL> @ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> def test_override_server_through_arg ( address ) : <EOL> assert Work ( address = address ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = address ) } <EOL> @ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> def test_override_server_through_arg_by_pyproject ( pyproject_toml , address ) : <EOL> work = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> ", "gt": "write_falco_config ( pyproject_path = pyproject_toml , work = work )"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> ", "gt": "def get_prod_config ( self , project_name : str ) -> dict :"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ", "gt": ")"}
{"input": "from django . db import models <EOL> class Order ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT> ) <EOL> email = models . EmailField ( ) <EOL> address = models . CharField ( max_length = <NUM_LIT> ) <EOL> postal_code = models . CharField ( max_length = <NUM_LIT> ) <EOL> city = models . CharField ( max_length = <NUM_LIT> ) <EOL> products = models . ManyToManyField ( \"<STR_LIT>\" ) <EOL> ", "gt": "created = models . DateTimeField ( auto_now_add = True )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_existing_config ( runner : CommandRunner , pyproject_toml ) : <EOL> ", "gt": "pyproject_toml = Path ( \"<STR_LIT>\" )"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = \"<STR_LIT>\" <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : BASE_DIR / \"<STR_LIT>\" , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> from typing import cast <EOL> from typing import TypedDict <EOL> import tomlkit <EOL> from typing_extensions import Unpack <EOL> class FalcoConfig ( TypedDict , total = False ) : <EOL> revision : str <EOL> blueprint : str <EOL> skip : list [ str ] <EOL> work : dict [ str , str ] <EOL> htmx : str <EOL> crud : \"<STR_LIT>\" <EOL> class CRUDConfig ( TypedDict ) : <EOL> blueprints : str <EOL> utils_path : str <EOL> login_required : bool <EOL> skip_git_check : bool <EOL> always_migrate : bool <EOL> def parse_crud_config_from_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def parse_crud_config_to_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def write_falco_config ( pyproject_path : Path , ** kwargs : Unpack [ TypedDict ] ) -> None : <EOL> new_falco_config = kwargs <EOL> new_crud_config = parse_crud_config_to_pyproject ( new_falco_config . pop ( \"<STR_LIT>\" , { } ) ) <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> existing_falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config = existing_falco_config . pop ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config . update ( new_crud_config ) <EOL> existing_falco_config . update ( { ** new_falco_config , \"<STR_LIT>\" : existing_crud_config } ) <EOL> tool = pyproject . get ( \"<STR_LIT>\" , { } ) <EOL> ", "gt": "tool . update ( { \"<STR_LIT>\" : existing_falco_config } )"}
{"input": "import io <EOL> import os <EOL> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import tomlkit <EOL> from cappa . testing import CommandRunner <EOL> def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> assert env_file . exists ( ) <EOL> assert env_template_file . exists ( ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "env_template_file = Path ( \"<STR_LIT>\" )"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> ", "gt": "output_file = output_dir / filename"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> repo = name_to_urls . get ( blueprint , blueprint ) <EOL> if repo . startswith ( \"<STR_LIT>\" ) and use_local : <EOL> if local_repo := find_local_cookiecutter ( repo ) : <EOL> repo = str ( local_repo . resolve ( ) ) <EOL> else : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , repo , \"<STR_LIT>\" ] , <EOL> capture_output = True , <EOL> text = True , <EOL> ", "gt": "check = False ,"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> ", "gt": "assert project_dir . exists ( )"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> ", "gt": "directory = temp_dir . resolve ( ) ,"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> ", "gt": "generated_files = [ ]"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ", "gt": ")"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ", "gt": "( \"<STR_LIT>\" , models . EmailField ( max_length = <NUM_LIT> ) ) ,"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . EmailField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ", "gt": "( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) ,"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> ", "gt": "verbose_name = \"<STR_LIT>\" ,"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> ", "gt": "operations = ["}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> ", "gt": "assert ( output / \"<STR_LIT>\" ) . exists ( )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> ", "gt": "settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> ", "gt": "def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) :"}
{"input": "from pathlib import Path <EOL> from typing import cast <EOL> from typing import TypedDict <EOL> import tomlkit <EOL> from typing_extensions import Unpack <EOL> class FalcoConfig ( TypedDict , total = False ) : <EOL> revision : str <EOL> blueprint : str <EOL> skip : list [ str ] <EOL> work : dict [ str , str ] <EOL> htmx : str <EOL> crud : \"<STR_LIT>\" <EOL> class CRUDConfig ( TypedDict ) : <EOL> blueprints : str <EOL> utils_path : str <EOL> login_required : bool <EOL> skip_git_check : bool <EOL> always_migrate : bool <EOL> def parse_crud_config_from_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def parse_crud_config_to_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def write_falco_config ( pyproject_path : Path , ** kwargs : Unpack [ TypedDict ] ) -> None : <EOL> new_falco_config = kwargs <EOL> new_crud_config = parse_crud_config_to_pyproject ( new_falco_config . pop ( \"<STR_LIT>\" , { } ) ) <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> existing_falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config = existing_falco_config . pop ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config . update ( new_crud_config ) <EOL> existing_falco_config . update ( { ** new_falco_config , \"<STR_LIT>\" : existing_crud_config } ) <EOL> tool = pyproject . get ( \"<STR_LIT>\" , { } ) <EOL> tool . update ( { \"<STR_LIT>\" : existing_falco_config } ) <EOL> pyproject [ \"<STR_LIT>\" ] = tool <EOL> pyproject_path . write_text ( tomlkit . dumps ( pyproject ) ) <EOL> def read_falco_config ( pyproject_path : Path ) -> FalcoConfig : <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) <EOL> crud_config = falco_config . pop ( \"<STR_LIT>\" , { } ) <EOL> ", "gt": "crud_config = parse_crud_config_from_pyproject ( crud_config )"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> ", "gt": "mock . stdout = \"<STR_LIT>\""}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> content = response . content . decode ( \"<STR_LIT>\" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> ", "gt": "msg = f\"<STR_LIT>\""}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . DateTimeField ( blank = True , null = True ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . ImageField ( blank = True , null = True , upload_to = \"<STR_LIT>\" ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . FileField ( blank = True , null = True , upload_to = \"<STR_LIT>\" ) , <EOL> ", "gt": ") ,"}
{"input": "import importlib <EOL> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> from falco . utils import simple_progress <EOL> from jinja2 import Template <EOL> IMPORT_START_COMMENT = \"<STR_LIT>\" <EOL> IMPORT_END_COMMENT = \"<STR_LIT>\" <EOL> CODE_START_COMMENT = \"<STR_LIT>\" <EOL> CODE_END_COMMENT = \"<STR_LIT>\" <EOL> def render_to_string ( template_content : str , context : dict ) : <EOL> return Template ( template_content ) . render ( ** context ) <EOL> def get_crud_blueprints_path ( ) -> Path : <EOL> package = importlib . util . find_spec ( \"<STR_LIT>\" ) <EOL> if package is None : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / \"<STR_LIT>\" <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_python_formatters ( filepath : str | Path ) : <EOL> autoflake = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> filepath , <EOL> ] <EOL> black = [ \"<STR_LIT>\" , filepath ] <EOL> isort = [ \"<STR_LIT>\" , filepath ] <EOL> subprocess . run ( autoflake , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( isort , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( black , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_html_formatters ( filepath : str | Path ) : <EOL> ", "gt": "djlint = [ \"<STR_LIT>\" , filepath , \"<STR_LIT>\" ]"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) :"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from honcho . manager import Manager <EOL> from . sync_dotenv import parse as parse_dotenv <EOL> default_server_cmd = \"<STR_LIT>\" <EOL> default_address = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Work : <EOL> address : Annotated [ str , cappa . Arg ( default = default_address , help = \"<STR_LIT>\" ) ] = default_address <EOL> def __call__ ( self ) -> None : <EOL> commands = self . get_commands ( ) <EOL> manager = Manager ( ) <EOL> django_env = self . resolve_django_env ( ) <EOL> for name , cmd in commands . items ( ) : <EOL> manager . add_process ( name , cmd , env = django_env ) <EOL> try : <EOL> manager . loop ( ) <EOL> finally : <EOL> manager . terminate ( ) <EOL> sys . exit ( manager . returncode ) <EOL> def resolve_django_env ( self ) -> dict : <EOL> current_dir = Path ( ) . resolve ( ) <EOL> env_file = current_dir / \"<STR_LIT>\" <EOL> env_vars = parse_dotenv ( env_file . read_text ( ) ) if env_file . exists ( ) else { } <EOL> return { <EOL> ** os . environ , <EOL> \"<STR_LIT>\" : str ( current_dir ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ** env_vars , <EOL> } <EOL> def get_commands ( self ) -> dict : <EOL> commands = { \"<STR_LIT>\" : default_server_cmd } <EOL> ", "gt": "pyproject_file = Path ( \"<STR_LIT>\" )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> ", "gt": "def test_user_name_and_email ( runner : CommandRunner , git_user_infos ) :"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> ", "gt": "arguments_list . append ( f\"<STR_LIT>\" )"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise ShellCodeError ( result . stderr ) <EOL> return ast . literal_eval ( result . stdout ) if eval_result else result . stdout . strip ( ) <EOL> def is_new_falco_cli_available ( ) -> bool : <EOL> try : <EOL> with network_request_with_progress ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) as response : <EOL> latest_version = response . json ( ) [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> current_version = falco_version <EOL> return latest_version != current_version <EOL> ", "gt": "except cappa . Exit :"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> skip_new_version_check = True , <EOL> ) ( ) <EOL> walk_directory ( temp_dir , tree ) <EOL> console = Console ( record = True ) <EOL> with console . capture ( ) : <EOL> console . print ( tree ) <EOL> console . save_svg ( <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> skip_new_version_check = True , <EOL> ) ( ) <EOL> walk_directory ( temp_dir , tree ) <EOL> ", "gt": "console = Console ( record = True )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_htmx_ext_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> ", "gt": "write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" )"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> ", "gt": "@ pytest . fixture"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . DateTimeField ( blank = True , null = True ) , <EOL> ", "gt": ") ,"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> run_in_shell ( reset_migrations_table , eval_result = False ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> stderr = subprocess . DEVNULL , <EOL> ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> ", "gt": "check = True ,"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> ", "gt": "\"<STR_LIT>\" : f\"<STR_LIT>\" ,"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> ", "gt": "html_theme_options = {"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . DateTimeField ( blank = True , null = True ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . ImageField ( blank = True , null = True , upload_to = \"<STR_LIT>\" ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> ", "gt": "name = \"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> ", "gt": "assert ( output / \"<STR_LIT>\" ) . exists ( )"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco import checks <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> def get_django_debug_value ( ) -> bool : <EOL> from django . conf import settings <EOL> return settings . DEBUG <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class RmMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) <EOL> django_debug_value = run_in_shell ( get_django_debug_value , eval_result = True ) <EOL> if not django_debug_value : <EOL> raise cappa . Exit ( <EOL> \"<STR_LIT>\" , <EOL> code = <NUM_LIT> , <EOL> ) <EOL> if not self . apps_dir : <EOL> self . apps_dir = Path ( ) / project_name <EOL> apps = set ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for folder in self . apps_dir . iterdir ( ) : <EOL> migration_dir = folder / \"<STR_LIT>\" <EOL> if not migration_dir . exists ( ) : <EOL> continue <EOL> apps . add ( folder . stem ) <EOL> for file in migration_dir . iterdir ( ) : <EOL> ", "gt": "if file . suffix == \"<STR_LIT>\" and file . name not in [ \"<STR_LIT>\" ] :"}
{"input": "from pathlib import Path <EOL> from typing import cast <EOL> from typing import TypedDict <EOL> import tomlkit <EOL> from typing_extensions import Unpack <EOL> class FalcoConfig ( TypedDict , total = False ) : <EOL> revision : str <EOL> blueprint : str <EOL> skip : list [ str ] <EOL> work : dict [ str , str ] <EOL> htmx : str <EOL> crud : \"<STR_LIT>\" <EOL> class CRUDConfig ( TypedDict ) : <EOL> blueprints : str <EOL> utils_path : str <EOL> login_required : bool <EOL> skip_git_check : bool <EOL> always_migrate : bool <EOL> def parse_crud_config_from_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def parse_crud_config_to_pyproject ( values : dict ) -> dict : <EOL> ", "gt": "return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) }"}
{"input": "import pytest <EOL> from falco . commands . work import default_address <EOL> from falco . commands . work import default_server_cmd <EOL> from falco . commands . work import Work <EOL> from falco . config import write_falco_config <EOL> def test_env_resolution ( tmp_path ) : <EOL> assert Work ( ) . resolve_django_env ( ) <EOL> def test_env_resolution_with_env ( tmp_path ) : <EOL> ( tmp_path / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in Work ( ) . resolve_django_env ( ) <EOL> def test_without_pyproject_file ( ) : <EOL> assert Work ( ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) } <EOL> def test_with_pyproject_file ( pyproject_toml ) : <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> assert Work ( ) . get_commands ( ) == { <EOL> \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> ", "gt": "def test_override_server ( pyproject_toml ) :"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ", "gt": "] ,"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> ", "gt": "partials_to_use = [ partials_to_use ]"}
{"input": "from pathlib import Path <EOL> from typing import cast <EOL> from typing import TypedDict <EOL> import tomlkit <EOL> from typing_extensions import Unpack <EOL> class FalcoConfig ( TypedDict , total = False ) : <EOL> revision : str <EOL> blueprint : str <EOL> skip : list [ str ] <EOL> work : dict [ str , str ] <EOL> htmx : str <EOL> crud : \"<STR_LIT>\" <EOL> class CRUDConfig ( TypedDict ) : <EOL> blueprints : str <EOL> utils_path : str <EOL> login_required : bool <EOL> skip_git_check : bool <EOL> always_migrate : bool <EOL> def parse_crud_config_from_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def parse_crud_config_to_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def write_falco_config ( pyproject_path : Path , ** kwargs : Unpack [ TypedDict ] ) -> None : <EOL> new_falco_config = kwargs <EOL> new_crud_config = parse_crud_config_to_pyproject ( new_falco_config . pop ( \"<STR_LIT>\" , { } ) ) <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> existing_falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) <EOL> ", "gt": "existing_crud_config = existing_falco_config . pop ( \"<STR_LIT>\" , { } )"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> output_file . touch ( exist_ok = True ) <EOL> output_file . write_text ( <EOL> ", "gt": "render_to_string ( imports_template , context )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> ", "gt": "capture_output = True ,"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> ", "gt": "serialize = False ,"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> ", "gt": "return Path ( project_dir )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_htmx_ext_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> ", "gt": "output = Path ( \"<STR_LIT>\" )"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> repo = name_to_urls . get ( blueprint , blueprint ) <EOL> if repo . startswith ( \"<STR_LIT>\" ) and use_local : <EOL> if local_repo := find_local_cookiecutter ( repo ) : <EOL> repo = str ( local_repo . resolve ( ) ) <EOL> else : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , repo , \"<STR_LIT>\" ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> revision = result . stdout . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] . split ( ) [ <NUM_LIT> ] . strip ( ) <EOL> ", "gt": "return repo , revision"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> ", "gt": "html_baseurl = \"<STR_LIT>\""}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : get_superuser_email ( project_name ) , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> } <EOL> def get_superuser_email ( project_name : str ) : <EOL> pyproject_file = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_file . exists ( ) : <EOL> pyproject = tomlkit . parse ( pyproject_file . read_text ( ) ) <EOL> if authors := pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , [ ] ) : <EOL> return authors [ <NUM_LIT> ] [ \"<STR_LIT>\" ] <EOL> return f\"<STR_LIT>\" <EOL> def parse ( env_content : str ) -> dict : <EOL> result = { } <EOL> for line in env_content . split ( \"<STR_LIT>\" ) : <EOL> stripped_line = line . strip ( ) <EOL> if stripped_line . startswith ( \"<STR_LIT>\" ) or not stripped_line : <EOL> continue <EOL> try : <EOL> key , value = stripped_line . split ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> except ValueError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> result [ key ] = value <EOL> return result <EOL> def get_updated ( env_content : str , config : dict , * , keep_original = False , keep_whitespace = False ) -> str : <EOL> content_list = env_content . split ( \"<STR_LIT>\" ) <EOL> content_dict = { line . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] : line for line in content_list if \"<STR_LIT>\" in line } <EOL> new_content_list = content_list . copy ( ) <EOL> for key , value in config . items ( ) : <EOL> line = content_dict . get ( key ) <EOL> if line is not None : <EOL> index = new_content_list . index ( line ) <EOL> if not keep_original : <EOL> new_content_list [ index ] = f\"<STR_LIT>\" <EOL> ", "gt": "else :"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_htmx_ext_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_download_to_output_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert not output . exists ( ) <EOL> ", "gt": "assert Path ( \"<STR_LIT>\" ) . exists ( )"}
{"input": "import importlib <EOL> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> from falco . utils import simple_progress <EOL> from jinja2 import Template <EOL> IMPORT_START_COMMENT = \"<STR_LIT>\" <EOL> IMPORT_END_COMMENT = \"<STR_LIT>\" <EOL> CODE_START_COMMENT = \"<STR_LIT>\" <EOL> CODE_END_COMMENT = \"<STR_LIT>\" <EOL> def render_to_string ( template_content : str , context : dict ) : <EOL> return Template ( template_content ) . render ( ** context ) <EOL> def get_crud_blueprints_path ( ) -> Path : <EOL> package = importlib . util . find_spec ( \"<STR_LIT>\" ) <EOL> if package is None : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / \"<STR_LIT>\" <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_python_formatters ( filepath : str | Path ) : <EOL> autoflake = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> filepath , <EOL> ] <EOL> black = [ \"<STR_LIT>\" , filepath ] <EOL> isort = [ \"<STR_LIT>\" , filepath ] <EOL> subprocess . run ( autoflake , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( isort , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( black , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_html_formatters ( filepath : str | Path ) : <EOL> djlint = [ \"<STR_LIT>\" , filepath , \"<STR_LIT>\" ] <EOL> subprocess . run ( djlint , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> def extract_python_file_templates ( file_content : str ) -> tuple [ str , str ] : <EOL> imports_template = extract_content_from ( file_content , IMPORT_START_COMMENT , IMPORT_END_COMMENT ) <EOL> ", "gt": "code_template = extract_content_from ( file_content , CODE_START_COMMENT , CODE_END_COMMENT )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) <EOL> module = parso . parse ( settings_file . read_text ( ) ) <EOL> for node in module . children : <EOL> try : <EOL> if ( <EOL> node . children [ <NUM_LIT> ] . type == parso . python . tree . ExprStmt . type <EOL> and node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] . value in names <EOL> ) : <EOL> apps = node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] <EOL> elements = apps . children [ <NUM_LIT> ] <EOL> elements . children . append ( parso . parse ( f\"<STR_LIT>\" ) ) <EOL> new_content = module . get_code ( ) <EOL> settings_file . write_text ( new_content ) <EOL> break <EOL> except AttributeError : <EOL> continue <EOL> ", "gt": "return settings_file"}
{"input": "import os <EOL> import sys <EOL> def main ( ) : <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> try : <EOL> from django . core . management import execute_from_command_line <EOL> except ImportError as exc : <EOL> raise ImportError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) from exc <EOL> execute_from_command_line ( sys . argv ) <EOL> if __name__ == \"<STR_LIT>\" : <EOL> ", "gt": "main ( )"}
{"input": "import io <EOL> import os <EOL> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import tomlkit <EOL> from cappa . testing import CommandRunner <EOL> def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> assert env_file . exists ( ) <EOL> assert env_template_file . exists ( ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> def test_print_value ( runner : CommandRunner , pyproject_toml ) : <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> with patch ( \"<STR_LIT>\" , new = io . StringIO ( ) ) as fake_stdout : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> stdout = fake_stdout . getvalue ( ) <EOL> assert not Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert \"<STR_LIT>\" in stdout <EOL> ", "gt": "def test_prod_config ( runner : CommandRunner , pyproject_toml ) :"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ", "gt": ") ,"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> existing_path = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> ", "gt": "filepath , _ = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> ", "gt": "with simple_progress ( \"<STR_LIT>\" ) :"}
{"input": "from django . urls import path <EOL> from . import views <EOL> app_name = \"<STR_LIT>\" <EOL> urlpatterns = [ <EOL> path ( \"<STR_LIT>\" , views . product_list , name = \"<STR_LIT>\" ) , <EOL> ", "gt": "path ( \"<STR_LIT>\" , views . product_create , name = \"<STR_LIT>\" ) ,"}
{"input": "import os <EOL> import sys <EOL> def main ( ) : <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> try : <EOL> from django . core . management import execute_from_command_line <EOL> except ImportError as exc : <EOL> ", "gt": "raise ImportError ("}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> content = response . content . decode ( \"<STR_LIT>\" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> filepath = self . resolve_filepath ( falco_config = falco_config ) <EOL> filepath . parent . mkdir ( parents = True , exist_ok = True ) <EOL> filepath . write_text ( content ) <EOL> return filepath <EOL> def resolve_filepath ( self , falco_config : dict ) -> Path : <EOL> if self . output : <EOL> filepath = self . output if str ( self . output ) . endswith ( \"<STR_LIT>\" ) else self . output / \"<STR_LIT>\" <EOL> elif self . output is None and \"<STR_LIT>\" in falco_config : <EOL> htmx_config = self . read_from_config ( falco_config ) <EOL> filepath , _ = htmx_config <EOL> else : <EOL> filepath = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "return filepath"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> ", "gt": "return resp"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = \"<STR_LIT>\" <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : BASE_DIR / \"<STR_LIT>\" , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "str ( blueprint_path ) ,"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ", "gt": ") ,"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = \"<STR_LIT>\" <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : BASE_DIR / \"<STR_LIT>\" , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> ] <EOL> LANGUAGE_CODE = \"<STR_LIT>\" <EOL> ", "gt": "TIME_ZONE = \"<STR_LIT>\""}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> ", "gt": "def test_htmx_with_pyproject_toml_custom_file_existing_config ( runner : CommandRunner ) :"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> ", "gt": "models_file = app_dir / \"<STR_LIT>\""}
{"input": "import importlib <EOL> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> from falco . utils import simple_progress <EOL> from jinja2 import Template <EOL> IMPORT_START_COMMENT = \"<STR_LIT>\" <EOL> IMPORT_END_COMMENT = \"<STR_LIT>\" <EOL> CODE_START_COMMENT = \"<STR_LIT>\" <EOL> CODE_END_COMMENT = \"<STR_LIT>\" <EOL> def render_to_string ( template_content : str , context : dict ) : <EOL> return Template ( template_content ) . render ( ** context ) <EOL> def get_crud_blueprints_path ( ) -> Path : <EOL> package = importlib . util . find_spec ( \"<STR_LIT>\" ) <EOL> if package is None : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / \"<STR_LIT>\" <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_python_formatters ( filepath : str | Path ) : <EOL> autoflake = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> filepath , <EOL> ] <EOL> black = [ \"<STR_LIT>\" , filepath ] <EOL> isort = [ \"<STR_LIT>\" , filepath ] <EOL> subprocess . run ( autoflake , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( isort , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> ", "gt": "subprocess . run ( black , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False )"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> ", "gt": "skip_new_version_check = True ,"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> partials_to_use = [ partials_to_use ] <EOL> rendered_partials = [ <EOL> render_to_string ( f\"<STR_LIT>\" , context = resp . context_data , request = request ) <EOL> for b in partials_to_use <EOL> ] <EOL> resp = HttpResponse ( <EOL> ", "gt": "content = \"<STR_LIT>\" . join ( rendered_partials ) ,"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> ", "gt": "context = { \"<STR_LIT>\" : project_name }"}
{"input": "import io <EOL> import os <EOL> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import tomlkit <EOL> from cappa . testing import CommandRunner <EOL> def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> assert env_file . exists ( ) <EOL> assert env_template_file . exists ( ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> def test_print_value ( runner : CommandRunner , pyproject_toml ) : <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> with patch ( \"<STR_LIT>\" , new = io . StringIO ( ) ) as fake_stdout : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> stdout = fake_stdout . getvalue ( ) <EOL> ", "gt": "assert not Path ( \"<STR_LIT>\" ) . exists ( )"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : get_superuser_email ( project_name ) , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> } <EOL> def get_superuser_email ( project_name : str ) : <EOL> pyproject_file = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_file . exists ( ) : <EOL> pyproject = tomlkit . parse ( pyproject_file . read_text ( ) ) <EOL> if authors := pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , [ ] ) : <EOL> return authors [ <NUM_LIT> ] [ \"<STR_LIT>\" ] <EOL> return f\"<STR_LIT>\" <EOL> def parse ( env_content : str ) -> dict : <EOL> result = { } <EOL> for line in env_content . split ( \"<STR_LIT>\" ) : <EOL> stripped_line = line . strip ( ) <EOL> if stripped_line . startswith ( \"<STR_LIT>\" ) or not stripped_line : <EOL> continue <EOL> try : <EOL> key , value = stripped_line . split ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> ", "gt": "except ValueError as e :"}
{"input": "from django . db import models <EOL> class Order ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT> ) <EOL> email = models . EmailField ( ) <EOL> address = models . CharField ( max_length = <NUM_LIT> ) <EOL> postal_code = models . CharField ( max_length = <NUM_LIT> ) <EOL> city = models . CharField ( max_length = <NUM_LIT> ) <EOL> products = models . ManyToManyField ( \"<STR_LIT>\" ) <EOL> created = models . DateTimeField ( auto_now_add = True ) <EOL> ", "gt": "completed = models . BooleanField ( default = False )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_user_name_and_email ( runner : CommandRunner , git_user_infos ) : <EOL> name , email = git_user_infos <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "from django . db import models <EOL> class Order ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT> ) <EOL> email = models . EmailField ( ) <EOL> address = models . CharField ( max_length = <NUM_LIT> ) <EOL> postal_code = models . CharField ( max_length = <NUM_LIT> ) <EOL> ", "gt": "city = models . CharField ( max_length = <NUM_LIT> )"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "models . ManyToManyField ("}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> repo = name_to_urls . get ( blueprint , blueprint ) <EOL> if repo . startswith ( \"<STR_LIT>\" ) and use_local : <EOL> if local_repo := find_local_cookiecutter ( repo ) : <EOL> repo = str ( local_repo . resolve ( ) ) <EOL> else : <EOL> msg = f\"<STR_LIT>\" <EOL> ", "gt": "raise cappa . Exit ( msg , code = <NUM_LIT> )"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> ", "gt": "keep_original = True ,"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_user_name_and_email ( runner : CommandRunner , git_user_infos ) : <EOL> name , email = git_user_infos <EOL> runner . invoke ( <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> ", "gt": "mock . returncode = <NUM_LIT>"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "from django . urls import path <EOL> from . import views <EOL> app_name = \"<STR_LIT>\" <EOL> urlpatterns = [ <EOL> path ( \"<STR_LIT>\" , views . product_list , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , views . product_create , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , views . product_detail , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , views . product_update , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , views . product_delete , name = \"<STR_LIT>\" ) , <EOL> ", "gt": "]"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_htmx_ext_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_download_to_output_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> ", "gt": "write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> run_in_shell ( reset_migrations_table , eval_result = False ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> stderr = subprocess . DEVNULL , <EOL> ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> stderr = subprocess . DEVNULL , <EOL> ) <EOL> ", "gt": "rich_print ( \"<STR_LIT>\" )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> run_in_shell ( reset_migrations_table , eval_result = False ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> stderr = subprocess . DEVNULL , <EOL> ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> stderr = subprocess . DEVNULL , <EOL> ", "gt": ")"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = \"<STR_LIT>\" <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : BASE_DIR / \"<STR_LIT>\" , <EOL> ", "gt": "}"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> ", "gt": "def pyproject_toml ( tmp_path ) :"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> repo = name_to_urls . get ( blueprint , blueprint ) <EOL> if repo . startswith ( \"<STR_LIT>\" ) and use_local : <EOL> if local_repo := find_local_cookiecutter ( repo ) : <EOL> repo = str ( local_repo . resolve ( ) ) <EOL> else : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , repo , \"<STR_LIT>\" ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> revision = result . stdout . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] . split ( ) [ <NUM_LIT> ] . strip ( ) <EOL> return repo , revision <EOL> def get_authors_info ( ) -> tuple [ str , str ] : <EOL> default_author_name = \"<STR_LIT>\" <EOL> default_author_email = \"<STR_LIT>\" <EOL> git_config_cmd = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> ", "gt": "try :"}
{"input": "from django . urls import path <EOL> from . import views <EOL> app_name = \"<STR_LIT>\" <EOL> urlpatterns = [ <EOL> path ( \"<STR_LIT>\" , views . product_list , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , views . product_create , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , views . product_detail , name = \"<STR_LIT>\" ) , <EOL> ", "gt": "path ( \"<STR_LIT>\" , views . product_update , name = \"<STR_LIT>\" ) ,"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "}"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "models . BooleanField ("}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ", "gt": "( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" )"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , <EOL> ", "gt": "( \"<STR_LIT>\" , models . TextField ( ) ) ,"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> repo = name_to_urls . get ( blueprint , blueprint ) <EOL> ", "gt": "if repo . startswith ( \"<STR_LIT>\" ) and use_local :"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> ", "gt": "help_text = \"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> root_dir = Path ( __file__ ) . parent . parent <EOL> readme = root_dir / \"<STR_LIT>\" <EOL> guides = root_dir / \"<STR_LIT>\" <EOL> guides_index = guides / \"<STR_LIT>\" <EOL> def get_rst_doc_title ( file : Path ) : <EOL> title = \"<STR_LIT>\" <EOL> for line in file . read_text ( ) . splitlines ( ) : <EOL> if line . startswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> title = line <EOL> return title <EOL> def guides_files ( ) : <EOL> index_content = guides_index . read_text ( ) <EOL> toc_tree_directive = \"<STR_LIT>\" <EOL> start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) <EOL> def valid_line ( line ) : <EOL> return bool ( line ) and not line . strip ( ) . startswith ( \"<STR_LIT>\" ) <EOL> lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( \"<STR_LIT>\" ) if valid_line ( line ) ] <EOL> return [ guides / f\"<STR_LIT>\" for line in lines ] <EOL> def get_guides_list ( ) : <EOL> guides_md = [ ] <EOL> for file in guides_files ( ) : <EOL> if file . name . startswith ( \"<STR_LIT>\" ) : <EOL> continue <EOL> link = f\"<STR_LIT>\" <EOL> title = get_rst_doc_title ( file ) <EOL> guides_md . append ( f\"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" + \"<STR_LIT>\" . join ( guides_md ) + \"<STR_LIT>\" <EOL> def update_readme ( start_comment , end_comment , new_content ) : <EOL> text = readme . read_text ( ) <EOL> start_index = text . find ( start_comment ) + len ( start_comment ) <EOL> end_index = text . find ( end_comment ) <EOL> new_content = text [ : start_index ] + new_content + text [ end_index : ] <EOL> readme . write_text ( new_content ) <EOL> def main ( ) : <EOL> update_readme ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> get_guides_list ( ) , <EOL> ) <EOL> ", "gt": "print ( \"<STR_LIT>\" )"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> ", "gt": "blank = True ,"}
{"input": "import subprocess <EOL> from contextlib import suppress <EOL> import cappa <EOL> def clean_git_repo ( * , ignore_dirty : bool = False ) -> None : <EOL> if ignore_dirty : <EOL> return <EOL> with suppress ( subprocess . CalledProcessError ) : <EOL> result = subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , capture_output = True , text = True , check = True ) <EOL> if result . stdout . strip ( ) == \"<STR_LIT>\" : <EOL> return <EOL> raise cappa . Exit ( <EOL> \"<STR_LIT>\" , <EOL> code = <NUM_LIT> , <EOL> ", "gt": ")"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> ", "gt": "for k , v in kwargs . items ( ) :"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise ShellCodeError ( result . stderr ) <EOL> return ast . literal_eval ( result . stdout ) if eval_result else result . stdout . strip ( ) <EOL> def is_new_falco_cli_available ( ) -> bool : <EOL> try : <EOL> with network_request_with_progress ( <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> ", "gt": "name = \"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> output_file . touch ( exist_ok = True ) <EOL> output_file . write_text ( <EOL> render_to_string ( imports_template , context ) <EOL> + render_to_string ( code_template , context ) <EOL> + output_file . read_text ( ) <EOL> ) <EOL> generated_files . append ( output_file ) <EOL> for file in generated_files : <EOL> run_python_formatters ( str ( file ) ) <EOL> ", "gt": "return output_dir"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from honcho . manager import Manager <EOL> from . sync_dotenv import parse as parse_dotenv <EOL> default_server_cmd = \"<STR_LIT>\" <EOL> default_address = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Work : <EOL> address : Annotated [ str , cappa . Arg ( default = default_address , help = \"<STR_LIT>\" ) ] = default_address <EOL> def __call__ ( self ) -> None : <EOL> commands = self . get_commands ( ) <EOL> manager = Manager ( ) <EOL> django_env = self . resolve_django_env ( ) <EOL> for name , cmd in commands . items ( ) : <EOL> manager . add_process ( name , cmd , env = django_env ) <EOL> try : <EOL> manager . loop ( ) <EOL> finally : <EOL> manager . terminate ( ) <EOL> ", "gt": "sys . exit ( manager . returncode )"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> ", "gt": "@ pytest . fixture"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> ", "gt": "WSGI_APPLICATION = \"<STR_LIT>\""}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . DateTimeField ( blank = True , null = True ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> ", "gt": "field = models . ImageField ( blank = True , null = True , upload_to = \"<STR_LIT>\" ) ,"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_htmx_ext_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_download_to_output_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> ", "gt": "output = Path ( \"<STR_LIT>\" )"}
{"input": "import subprocess <EOL> from contextlib import suppress <EOL> import cappa <EOL> def clean_git_repo ( * , ignore_dirty : bool = False ) -> None : <EOL> if ignore_dirty : <EOL> return <EOL> with suppress ( subprocess . CalledProcessError ) : <EOL> result = subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , capture_output = True , text = True , check = True ) <EOL> if result . stdout . strip ( ) == \"<STR_LIT>\" : <EOL> ", "gt": "return"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , <EOL> capture_output = True , <EOL> ", "gt": "text = True ,"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> existing_path = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> filepath , _ = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> ", "gt": "assert filepath == existing_path"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> ", "gt": "tree = Tree ("}
{"input": "import os <EOL> import sys <EOL> def main ( ) : <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> try : <EOL> from django . core . management import execute_from_command_line <EOL> except ImportError as exc : <EOL> raise ImportError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ", "gt": ") from exc"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> def makemigaration ( ) : <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = False ) <EOL> def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert not first_migration . exists ( ) <EOL> def test_rm_migrations_fake_apps_dir ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert first_migration . exists ( ) <EOL> ", "gt": "def test_rm_migrations_not_clean_repo ( django_project , runner : CommandRunner ) :"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> existing_path = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "runner . invoke ( \"<STR_LIT>\" )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ", "gt": "output = Path ( \"<STR_LIT>\" )"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> ", "gt": "if not isinstance ( partials_to_use , list ) :"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> output_file . touch ( exist_ok = True ) <EOL> output_file . write_text ( <EOL> render_to_string ( imports_template , context ) <EOL> + render_to_string ( code_template , context ) <EOL> + output_file . read_text ( ) <EOL> ) <EOL> generated_files . append ( output_file ) <EOL> for file in generated_files : <EOL> run_python_formatters ( str ( file ) ) <EOL> return output_dir <EOL> @ classmethod <EOL> def get_install_path ( cls , project_name : str , falco_config : FalcoConfig ) -> tuple [ Path , bool ] : <EOL> ", "gt": "if _import_path := falco_config . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" ) :"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> ", "gt": "dotenv_template_file . write_text ( dotenv_template_content )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import importlib <EOL> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> from falco . utils import simple_progress <EOL> from jinja2 import Template <EOL> IMPORT_START_COMMENT = \"<STR_LIT>\" <EOL> IMPORT_END_COMMENT = \"<STR_LIT>\" <EOL> CODE_START_COMMENT = \"<STR_LIT>\" <EOL> CODE_END_COMMENT = \"<STR_LIT>\" <EOL> def render_to_string ( template_content : str , context : dict ) : <EOL> return Template ( template_content ) . render ( ** context ) <EOL> def get_crud_blueprints_path ( ) -> Path : <EOL> package = importlib . util . find_spec ( \"<STR_LIT>\" ) <EOL> if package is None : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / \"<STR_LIT>\" <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_python_formatters ( filepath : str | Path ) : <EOL> autoflake = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> filepath , <EOL> ] <EOL> black = [ \"<STR_LIT>\" , filepath ] <EOL> isort = [ \"<STR_LIT>\" , filepath ] <EOL> subprocess . run ( autoflake , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( isort , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( black , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> ", "gt": "@ simple_progress ( \"<STR_LIT>\" )"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" : get_superuser_email ( project_name ) ,"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ", "gt": "output = Path ( \"<STR_LIT>\" )"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> partials_to_use = [ partials_to_use ] <EOL> rendered_partials = [ <EOL> render_to_string ( f\"<STR_LIT>\" , context = resp . context_data , request = request ) <EOL> for b in partials_to_use <EOL> ] <EOL> resp = HttpResponse ( <EOL> content = \"<STR_LIT>\" . join ( rendered_partials ) , <EOL> ", "gt": "status = resp . status_code ,"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> ", "gt": "[ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] ,"}
{"input": "import importlib <EOL> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> from falco . utils import simple_progress <EOL> from jinja2 import Template <EOL> IMPORT_START_COMMENT = \"<STR_LIT>\" <EOL> IMPORT_END_COMMENT = \"<STR_LIT>\" <EOL> CODE_START_COMMENT = \"<STR_LIT>\" <EOL> CODE_END_COMMENT = \"<STR_LIT>\" <EOL> def render_to_string ( template_content : str , context : dict ) : <EOL> return Template ( template_content ) . render ( ** context ) <EOL> def get_crud_blueprints_path ( ) -> Path : <EOL> package = importlib . util . find_spec ( \"<STR_LIT>\" ) <EOL> if package is None : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / \"<STR_LIT>\" <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_python_formatters ( filepath : str | Path ) : <EOL> autoflake = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "filepath ,"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) <EOL> module = parso . parse ( settings_file . read_text ( ) ) <EOL> ", "gt": "for node in module . children :"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> repo = name_to_urls . get ( blueprint , blueprint ) <EOL> if repo . startswith ( \"<STR_LIT>\" ) and use_local : <EOL> if local_repo := find_local_cookiecutter ( repo ) : <EOL> repo = str ( local_repo . resolve ( ) ) <EOL> else : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , repo , \"<STR_LIT>\" ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> revision = result . stdout . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] . split ( ) [ <NUM_LIT> ] . strip ( ) <EOL> return repo , revision <EOL> def get_authors_info ( ) -> tuple [ str , str ] : <EOL> default_author_name = \"<STR_LIT>\" <EOL> default_author_email = \"<STR_LIT>\" <EOL> git_config_cmd = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> try : <EOL> user_name_cmd = subprocess . run ( [ * git_config_cmd , \"<STR_LIT>\" ] , capture_output = True , text = True , check = False ) <EOL> user_email_cmd = subprocess . run ( [ * git_config_cmd , \"<STR_LIT>\" ] , capture_output = True , text = True , check = False ) <EOL> except FileNotFoundError : <EOL> return default_author_name , default_author_email <EOL> if user_email_cmd . returncode != <NUM_LIT> : <EOL> return default_author_name , default_author_email <EOL> return ( <EOL> user_name_cmd . stdout . strip ( \"<STR_LIT>\" ) , <EOL> user_email_cmd . stdout . strip ( \"<STR_LIT>\" ) , <EOL> ) <EOL> @ contextmanager <EOL> def change_directory ( new_directory : str | Path ) : <EOL> current_directory = Path . cwd ( ) <EOL> ", "gt": "try :"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> output_file . touch ( exist_ok = True ) <EOL> output_file . write_text ( <EOL> render_to_string ( imports_template , context ) <EOL> + render_to_string ( code_template , context ) <EOL> + output_file . read_text ( ) <EOL> ) <EOL> generated_files . append ( output_file ) <EOL> for file in generated_files : <EOL> run_python_formatters ( str ( file ) ) <EOL> return output_dir <EOL> @ classmethod <EOL> ", "gt": "def get_install_path ( cls , project_name : str , falco_config : FalcoConfig ) -> tuple [ Path , bool ] :"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> ", "gt": "for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) :"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : get_superuser_email ( project_name ) , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> } <EOL> def get_superuser_email ( project_name : str ) : <EOL> pyproject_file = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_file . exists ( ) : <EOL> pyproject = tomlkit . parse ( pyproject_file . read_text ( ) ) <EOL> ", "gt": "if authors := pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , [ ] ) :"}
{"input": "import pytest <EOL> from falco . commands . work import default_address <EOL> from falco . commands . work import default_server_cmd <EOL> from falco . commands . work import Work <EOL> from falco . config import write_falco_config <EOL> def test_env_resolution ( tmp_path ) : <EOL> assert Work ( ) . resolve_django_env ( ) <EOL> def test_env_resolution_with_env ( tmp_path ) : <EOL> ( tmp_path / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in Work ( ) . resolve_django_env ( ) <EOL> def test_without_pyproject_file ( ) : <EOL> assert Work ( ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) } <EOL> def test_with_pyproject_file ( pyproject_toml ) : <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> assert Work ( ) . get_commands ( ) == { <EOL> \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def test_override_server ( pyproject_toml ) : <EOL> ", "gt": "work = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" }"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = \"<STR_LIT>\" <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : BASE_DIR / \"<STR_LIT>\" , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> ", "gt": "]"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , <EOL> ", "gt": "capture_output = True ,"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> existing_path = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> filepath , _ = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == existing_path <EOL> ", "gt": "assert existing_path . exists ( )"}
{"input": "from pathlib import Path <EOL> root_dir = Path ( __file__ ) . parent . parent <EOL> readme = root_dir / \"<STR_LIT>\" <EOL> guides = root_dir / \"<STR_LIT>\" <EOL> guides_index = guides / \"<STR_LIT>\" <EOL> def get_rst_doc_title ( file : Path ) : <EOL> title = \"<STR_LIT>\" <EOL> for line in file . read_text ( ) . splitlines ( ) : <EOL> if line . startswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> title = line <EOL> return title <EOL> def guides_files ( ) : <EOL> index_content = guides_index . read_text ( ) <EOL> toc_tree_directive = \"<STR_LIT>\" <EOL> start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) <EOL> def valid_line ( line ) : <EOL> return bool ( line ) and not line . strip ( ) . startswith ( \"<STR_LIT>\" ) <EOL> lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( \"<STR_LIT>\" ) if valid_line ( line ) ] <EOL> return [ guides / f\"<STR_LIT>\" for line in lines ] <EOL> def get_guides_list ( ) : <EOL> guides_md = [ ] <EOL> ", "gt": "for file in guides_files ( ) :"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) <EOL> module = parso . parse ( settings_file . read_text ( ) ) <EOL> for node in module . children : <EOL> ", "gt": "try :"}
{"input": "from pathlib import Path <EOL> root_dir = Path ( __file__ ) . parent . parent <EOL> readme = root_dir / \"<STR_LIT>\" <EOL> guides = root_dir / \"<STR_LIT>\" <EOL> guides_index = guides / \"<STR_LIT>\" <EOL> def get_rst_doc_title ( file : Path ) : <EOL> title = \"<STR_LIT>\" <EOL> for line in file . read_text ( ) . splitlines ( ) : <EOL> if line . startswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> title = line <EOL> return title <EOL> def guides_files ( ) : <EOL> index_content = guides_index . read_text ( ) <EOL> toc_tree_directive = \"<STR_LIT>\" <EOL> start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) <EOL> def valid_line ( line ) : <EOL> return bool ( line ) and not line . strip ( ) . startswith ( \"<STR_LIT>\" ) <EOL> lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( \"<STR_LIT>\" ) if valid_line ( line ) ] <EOL> return [ guides / f\"<STR_LIT>\" for line in lines ] <EOL> def get_guides_list ( ) : <EOL> guides_md = [ ] <EOL> for file in guides_files ( ) : <EOL> if file . name . startswith ( \"<STR_LIT>\" ) : <EOL> continue <EOL> link = f\"<STR_LIT>\" <EOL> title = get_rst_doc_title ( file ) <EOL> guides_md . append ( f\"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" + \"<STR_LIT>\" . join ( guides_md ) + \"<STR_LIT>\" <EOL> def update_readme ( start_comment , end_comment , new_content ) : <EOL> text = readme . read_text ( ) <EOL> start_index = text . find ( start_comment ) + len ( start_comment ) <EOL> end_index = text . find ( end_comment ) <EOL> new_content = text [ : start_index ] + new_content + text [ end_index : ] <EOL> readme . write_text ( new_content ) <EOL> def main ( ) : <EOL> update_readme ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> get_guides_list ( ) , <EOL> ) <EOL> print ( \"<STR_LIT>\" ) <EOL> ", "gt": "if __name__ == \"<STR_LIT>\" :"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> html_logo = \"<STR_LIT>\" <EOL> html_favicon = \"<STR_LIT>\" <EOL> html_css_files = [ <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> ", "gt": "return None"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ", "gt": "( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) <EOL> module = parso . parse ( settings_file . read_text ( ) ) <EOL> for node in module . children : <EOL> try : <EOL> if ( <EOL> node . children [ <NUM_LIT> ] . type == parso . python . tree . ExprStmt . type <EOL> and node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] . value in names <EOL> ) : <EOL> ", "gt": "apps = node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ]"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> output_file . touch ( exist_ok = True ) <EOL> output_file . write_text ( <EOL> render_to_string ( imports_template , context ) <EOL> + render_to_string ( code_template , context ) <EOL> + output_file . read_text ( ) <EOL> ) <EOL> generated_files . append ( output_file ) <EOL> for file in generated_files : <EOL> ", "gt": "run_python_formatters ( str ( file ) )"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco import checks <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> def get_django_debug_value ( ) -> bool : <EOL> from django . conf import settings <EOL> return settings . DEBUG <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class RmMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) <EOL> django_debug_value = run_in_shell ( get_django_debug_value , eval_result = True ) <EOL> if not django_debug_value : <EOL> raise cappa . Exit ( <EOL> \"<STR_LIT>\" , <EOL> code = <NUM_LIT> , <EOL> ) <EOL> if not self . apps_dir : <EOL> self . apps_dir = Path ( ) / project_name <EOL> apps = set ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for folder in self . apps_dir . iterdir ( ) : <EOL> migration_dir = folder / \"<STR_LIT>\" <EOL> ", "gt": "if not migration_dir . exists ( ) :"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : <EOL> ", "gt": "pyproject_toml = Path ( \"<STR_LIT>\" )"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . EmailField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . ManyToManyField ( to = \"<STR_LIT>\" ) ) , <EOL> ", "gt": "] ,"}
{"input": "import subprocess <EOL> from contextlib import suppress <EOL> import cappa <EOL> def clean_git_repo ( * , ignore_dirty : bool = False ) -> None : <EOL> if ignore_dirty : <EOL> return <EOL> with suppress ( subprocess . CalledProcessError ) : <EOL> result = subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , capture_output = True , text = True , check = True ) <EOL> ", "gt": "if result . stdout . strip ( ) == \"<STR_LIT>\" :"}
{"input": "from django . urls import path <EOL> from . import views <EOL> app_name = \"<STR_LIT>\" <EOL> urlpatterns = [ <EOL> path ( \"<STR_LIT>\" , views . product_list , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , views . product_create , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , views . product_detail , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , views . product_update , name = \"<STR_LIT>\" ) , <EOL> ", "gt": "path ( \"<STR_LIT>\" , views . product_delete , name = \"<STR_LIT>\" ) ,"}
{"input": "from django . db import models <EOL> class Order ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT> ) <EOL> email = models . EmailField ( ) <EOL> address = models . CharField ( max_length = <NUM_LIT> ) <EOL> postal_code = models . CharField ( max_length = <NUM_LIT> ) <EOL> city = models . CharField ( max_length = <NUM_LIT> ) <EOL> ", "gt": "products = models . ManyToManyField ( \"<STR_LIT>\" )"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , <EOL> ( \"<STR_LIT>\" , models . TextField ( ) ) , <EOL> ( \"<STR_LIT>\" , models . DecimalField ( decimal_places = <NUM_LIT> , max_digits = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , <EOL> ( \"<STR_LIT>\" , models . DateTimeField ( default = django . utils . timezone . now ) ) , <EOL> ] , <EOL> ", "gt": ") ,"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> ", "gt": "run_in_shell ( reset_migrations_table , eval_result = False )"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = \"<STR_LIT>\" <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : BASE_DIR / \"<STR_LIT>\" , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> ] <EOL> LANGUAGE_CODE = \"<STR_LIT>\" <EOL> TIME_ZONE = \"<STR_LIT>\" <EOL> USE_I18N = True <EOL> USE_TZ = True <EOL> STATIC_URL = \"<STR_LIT>\" <EOL> DEFAULT_AUTO_FIELD = \"<STR_LIT>\" <EOL> CRISPY_ALLOWED_TEMPLATE_PACKS = \"<STR_LIT>\" <EOL> CRISPY_TEMPLATE_PACK = \"<STR_LIT>\" <EOL> SUPERUSER_EMAIL = \"<STR_LIT>\" <EOL> ", "gt": "SUPERUSER_PASSWORD = \"<STR_LIT>\""}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_user_name_and_email ( runner : CommandRunner , git_user_infos ) : <EOL> name , email = git_user_infos <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ", "gt": ")"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = \"<STR_LIT>\" <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : BASE_DIR / \"<STR_LIT>\" , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> ] <EOL> LANGUAGE_CODE = \"<STR_LIT>\" <EOL> TIME_ZONE = \"<STR_LIT>\" <EOL> USE_I18N = True <EOL> USE_TZ = True <EOL> STATIC_URL = \"<STR_LIT>\" <EOL> DEFAULT_AUTO_FIELD = \"<STR_LIT>\" <EOL> ", "gt": "CRISPY_ALLOWED_TEMPLATE_PACKS = \"<STR_LIT>\""}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> html_logo = \"<STR_LIT>\" <EOL> html_favicon = \"<STR_LIT>\" <EOL> html_css_files = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> html_js_files = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> ) , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "]"}
{"input": "from pathlib import Path <EOL> root_dir = Path ( __file__ ) . parent . parent <EOL> readme = root_dir / \"<STR_LIT>\" <EOL> guides = root_dir / \"<STR_LIT>\" <EOL> guides_index = guides / \"<STR_LIT>\" <EOL> def get_rst_doc_title ( file : Path ) : <EOL> title = \"<STR_LIT>\" <EOL> for line in file . read_text ( ) . splitlines ( ) : <EOL> if line . startswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> title = line <EOL> return title <EOL> def guides_files ( ) : <EOL> index_content = guides_index . read_text ( ) <EOL> toc_tree_directive = \"<STR_LIT>\" <EOL> start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) <EOL> def valid_line ( line ) : <EOL> return bool ( line ) and not line . strip ( ) . startswith ( \"<STR_LIT>\" ) <EOL> lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( \"<STR_LIT>\" ) if valid_line ( line ) ] <EOL> return [ guides / f\"<STR_LIT>\" for line in lines ] <EOL> def get_guides_list ( ) : <EOL> guides_md = [ ] <EOL> for file in guides_files ( ) : <EOL> ", "gt": "if file . name . startswith ( \"<STR_LIT>\" ) :"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> ", "gt": "def download ( self , version : str , falco_config : dict ) -> Path :"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> def makemigaration ( ) : <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = False ) <EOL> def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert not first_migration . exists ( ) <EOL> def test_rm_migrations_fake_apps_dir ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> ", "gt": "apps_dir = Path ( )"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> ", "gt": "def main ( ) :"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" : <NUM_LIT> ,"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> def makemigaration ( ) : <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = False ) <EOL> def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert not first_migration . exists ( ) <EOL> def test_rm_migrations_fake_apps_dir ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> ", "gt": "first_migration = apps_dir / \"<STR_LIT>\""}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> @ pytest . fixture <EOL> def git_user_infos ( ) : <EOL> name = \"<STR_LIT>\" <EOL> email = \"<STR_LIT>\" <EOL> def mock_run ( args , ** kwargs ) : <EOL> ", "gt": "if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] :"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> ", "gt": "pyproject_toml . unlink ( )"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco import checks <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> def get_django_debug_value ( ) -> bool : <EOL> from django . conf import settings <EOL> return settings . DEBUG <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class RmMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) <EOL> django_debug_value = run_in_shell ( get_django_debug_value , eval_result = True ) <EOL> if not django_debug_value : <EOL> raise cappa . Exit ( <EOL> \"<STR_LIT>\" , <EOL> code = <NUM_LIT> , <EOL> ) <EOL> ", "gt": "if not self . apps_dir :"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) ,"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) <EOL> module = parso . parse ( settings_file . read_text ( ) ) <EOL> for node in module . children : <EOL> try : <EOL> if ( <EOL> node . children [ <NUM_LIT> ] . type == parso . python . tree . ExprStmt . type <EOL> and node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] . value in names <EOL> ) : <EOL> apps = node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] <EOL> elements = apps . children [ <NUM_LIT> ] <EOL> elements . children . append ( parso . parse ( f\"<STR_LIT>\" ) ) <EOL> new_content = module . get_code ( ) <EOL> settings_file . write_text ( new_content ) <EOL> break <EOL> ", "gt": "except AttributeError :"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_htmx_ext_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> ", "gt": "def test_htmx_ext_download_to_output_file_existing_config ( runner : CommandRunner ) :"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> @ pytest . fixture <EOL> def git_user_infos ( ) : <EOL> name = \"<STR_LIT>\" <EOL> email = \"<STR_LIT>\" <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> ", "gt": "mock . returncode = <NUM_LIT>"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> html_logo = \"<STR_LIT>\" <EOL> html_favicon = \"<STR_LIT>\" <EOL> html_css_files = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ", "gt": "html_js_files = ["}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_existing_config ( runner : CommandRunner , pyproject_toml ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , crud = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "runner . invoke ( \"<STR_LIT>\" )"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> skip_new_version_check = True , <EOL> ) ( ) <EOL> walk_directory ( temp_dir , tree ) <EOL> console = Console ( record = True ) <EOL> ", "gt": "with console . capture ( ) :"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> ", "gt": "if self . is_root :"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> skip_new_version_check = True , <EOL> ) ( ) <EOL> walk_directory ( temp_dir , tree ) <EOL> console = Console ( record = True ) <EOL> with console . capture ( ) : <EOL> console . print ( tree ) <EOL> console . save_svg ( <EOL> \"<STR_LIT>\" , <EOL> title = \"<STR_LIT>\" , <EOL> ", "gt": "theme = DIMMED_MONOKAI ,"}
{"input": "from pathlib import Path <EOL> root_dir = Path ( __file__ ) . parent . parent <EOL> readme = root_dir / \"<STR_LIT>\" <EOL> guides = root_dir / \"<STR_LIT>\" <EOL> guides_index = guides / \"<STR_LIT>\" <EOL> def get_rst_doc_title ( file : Path ) : <EOL> title = \"<STR_LIT>\" <EOL> for line in file . read_text ( ) . splitlines ( ) : <EOL> if line . startswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> title = line <EOL> return title <EOL> def guides_files ( ) : <EOL> index_content = guides_index . read_text ( ) <EOL> toc_tree_directive = \"<STR_LIT>\" <EOL> start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) <EOL> def valid_line ( line ) : <EOL> return bool ( line ) and not line . strip ( ) . startswith ( \"<STR_LIT>\" ) <EOL> lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( \"<STR_LIT>\" ) if valid_line ( line ) ] <EOL> return [ guides / f\"<STR_LIT>\" for line in lines ] <EOL> def get_guides_list ( ) : <EOL> guides_md = [ ] <EOL> for file in guides_files ( ) : <EOL> if file . name . startswith ( \"<STR_LIT>\" ) : <EOL> continue <EOL> link = f\"<STR_LIT>\" <EOL> ", "gt": "title = get_rst_doc_title ( file )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> def makemigaration ( ) : <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = False ) <EOL> def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert not first_migration . exists ( ) <EOL> def test_rm_migrations_fake_apps_dir ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert first_migration . exists ( ) <EOL> def test_rm_migrations_not_clean_repo ( django_project , runner : CommandRunner ) : <EOL> ", "gt": "with pytest . raises ( cappa . Exit ) :"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> ", "gt": "[ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ,"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco import checks <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> def get_django_debug_value ( ) -> bool : <EOL> from django . conf import settings <EOL> return settings . DEBUG <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class RmMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> ", "gt": "checks . clean_git_repo ( ignore_dirty = self . skip_git_check )"}
{"input": "import os <EOL> import sys <EOL> def main ( ) : <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> try : <EOL> from django . core . management import execute_from_command_line <EOL> except ImportError as exc : <EOL> raise ImportError ( <EOL> ", "gt": "\"<STR_LIT>\""}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> ", "gt": "rich_print ( f\"<STR_LIT>\" )"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> partials_to_use = [ partials_to_use ] <EOL> rendered_partials = [ <EOL> render_to_string ( f\"<STR_LIT>\" , context = resp . context_data , request = request ) <EOL> for b in partials_to_use <EOL> ", "gt": "]"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from honcho . manager import Manager <EOL> from . sync_dotenv import parse as parse_dotenv <EOL> default_server_cmd = \"<STR_LIT>\" <EOL> default_address = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Work : <EOL> address : Annotated [ str , cappa . Arg ( default = default_address , help = \"<STR_LIT>\" ) ] = default_address <EOL> def __call__ ( self ) -> None : <EOL> commands = self . get_commands ( ) <EOL> manager = Manager ( ) <EOL> django_env = self . resolve_django_env ( ) <EOL> for name , cmd in commands . items ( ) : <EOL> manager . add_process ( name , cmd , env = django_env ) <EOL> try : <EOL> manager . loop ( ) <EOL> finally : <EOL> manager . terminate ( ) <EOL> sys . exit ( manager . returncode ) <EOL> def resolve_django_env ( self ) -> dict : <EOL> current_dir = Path ( ) . resolve ( ) <EOL> env_file = current_dir / \"<STR_LIT>\" <EOL> env_vars = parse_dotenv ( env_file . read_text ( ) ) if env_file . exists ( ) else { } <EOL> return { <EOL> ** os . environ , <EOL> \"<STR_LIT>\" : str ( current_dir ) , <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> ", "gt": "check = False ,"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> ", "gt": "keep_whitespace = True ,"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_existing_config ( runner : CommandRunner , pyproject_toml ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , crud = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> ", "gt": "assert ( output / \"<STR_LIT>\" ) . exists ( )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> def makemigaration ( ) : <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = False ) <EOL> def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ", "gt": "assert not first_migration . exists ( )"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> @ pytest . fixture <EOL> def git_user_infos ( ) : <EOL> name = \"<STR_LIT>\" <EOL> email = \"<STR_LIT>\" <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = name <EOL> return mock <EOL> ", "gt": "if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] :"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . BooleanField ( default = False ) , <EOL> ) , <EOL> ", "gt": "]"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> @ pytest . fixture <EOL> def git_user_infos ( ) : <EOL> name = \"<STR_LIT>\" <EOL> email = \"<STR_LIT>\" <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = name <EOL> return mock <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = email <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> ", "gt": "with patch ( \"<STR_LIT>\" , side_effect = mock_run ) :"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> ", "gt": "assert filepath == Path ( \"<STR_LIT>\" )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> ", "gt": "run_python_formatters ( self . register_app ( app_name = final_app_name ) )"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "models . ManyToManyField ("}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ", "gt": "("}
{"input": "import pytest <EOL> from falco . commands . work import default_address <EOL> from falco . commands . work import default_server_cmd <EOL> from falco . commands . work import Work <EOL> from falco . config import write_falco_config <EOL> def test_env_resolution ( tmp_path ) : <EOL> assert Work ( ) . resolve_django_env ( ) <EOL> def test_env_resolution_with_env ( tmp_path ) : <EOL> ( tmp_path / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in Work ( ) . resolve_django_env ( ) <EOL> def test_without_pyproject_file ( ) : <EOL> assert Work ( ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) } <EOL> def test_with_pyproject_file ( pyproject_toml ) : <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> assert Work ( ) . get_commands ( ) == { <EOL> \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) , <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) <EOL> module = parso . parse ( settings_file . read_text ( ) ) <EOL> for node in module . children : <EOL> try : <EOL> if ( <EOL> node . children [ <NUM_LIT> ] . type == parso . python . tree . ExprStmt . type <EOL> and node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] . value in names <EOL> ) : <EOL> apps = node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] <EOL> elements = apps . children [ <NUM_LIT> ] <EOL> ", "gt": "elements . children . append ( parso . parse ( f\"<STR_LIT>\" ) )"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from honcho . manager import Manager <EOL> from . sync_dotenv import parse as parse_dotenv <EOL> default_server_cmd = \"<STR_LIT>\" <EOL> default_address = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Work : <EOL> address : Annotated [ str , cappa . Arg ( default = default_address , help = \"<STR_LIT>\" ) ] = default_address <EOL> def __call__ ( self ) -> None : <EOL> commands = self . get_commands ( ) <EOL> manager = Manager ( ) <EOL> django_env = self . resolve_django_env ( ) <EOL> for name , cmd in commands . items ( ) : <EOL> manager . add_process ( name , cmd , env = django_env ) <EOL> try : <EOL> manager . loop ( ) <EOL> finally : <EOL> manager . terminate ( ) <EOL> sys . exit ( manager . returncode ) <EOL> def resolve_django_env ( self ) -> dict : <EOL> current_dir = Path ( ) . resolve ( ) <EOL> env_file = current_dir / \"<STR_LIT>\" <EOL> ", "gt": "env_vars = parse_dotenv ( env_file . read_text ( ) ) if env_file . exists ( ) else { }"}
{"input": "from django . urls import path <EOL> from . import views <EOL> app_name = \"<STR_LIT>\" <EOL> urlpatterns = [ <EOL> path ( \"<STR_LIT>\" , views . product_list , name = \"<STR_LIT>\" ) , <EOL> path ( \"<STR_LIT>\" , views . product_create , name = \"<STR_LIT>\" ) , <EOL> ", "gt": "path ( \"<STR_LIT>\" , views . product_detail , name = \"<STR_LIT>\" ) ,"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco import checks <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> def get_django_debug_value ( ) -> bool : <EOL> from django . conf import settings <EOL> return settings . DEBUG <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class RmMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> ", "gt": "def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) :"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_existing_config ( runner : CommandRunner , pyproject_toml ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "write_falco_config ( pyproject_path = pyproject_toml , crud = { \"<STR_LIT>\" : \"<STR_LIT>\" } )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> ", "gt": "serialize = False ,"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> ", "gt": "temp_dir = pathlib . Path ( temp )"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ", "gt": ")"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . EmailField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . ManyToManyField ( to = \"<STR_LIT>\" ) ) , <EOL> ] , <EOL> ", "gt": ") ,"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> content = response . content . decode ( \"<STR_LIT>\" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> filepath = self . resolve_filepath ( falco_config = falco_config ) <EOL> filepath . parent . mkdir ( parents = True , exist_ok = True ) <EOL> filepath . write_text ( content ) <EOL> return filepath <EOL> def resolve_filepath ( self , falco_config : dict ) -> Path : <EOL> if self . output : <EOL> filepath = self . output if str ( self . output ) . endswith ( \"<STR_LIT>\" ) else self . output / \"<STR_LIT>\" <EOL> elif self . output is None and \"<STR_LIT>\" in falco_config : <EOL> htmx_config = self . read_from_config ( falco_config ) <EOL> filepath , _ = htmx_config <EOL> else : <EOL> filepath = Path ( \"<STR_LIT>\" ) <EOL> return filepath <EOL> @ classmethod <EOL> def read_from_config ( cls , falco_config : dict ) -> HtmxConfig : <EOL> htmx = falco_config . get ( \"<STR_LIT>\" ) <EOL> ", "gt": "if not htmx :"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : get_superuser_email ( project_name ) , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> } <EOL> def get_superuser_email ( project_name : str ) : <EOL> pyproject_file = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_file . exists ( ) : <EOL> pyproject = tomlkit . parse ( pyproject_file . read_text ( ) ) <EOL> if authors := pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , [ ] ) : <EOL> return authors [ <NUM_LIT> ] [ \"<STR_LIT>\" ] <EOL> return f\"<STR_LIT>\" <EOL> def parse ( env_content : str ) -> dict : <EOL> result = { } <EOL> for line in env_content . split ( \"<STR_LIT>\" ) : <EOL> stripped_line = line . strip ( ) <EOL> if stripped_line . startswith ( \"<STR_LIT>\" ) or not stripped_line : <EOL> continue <EOL> try : <EOL> key , value = stripped_line . split ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> except ValueError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> result [ key ] = value <EOL> return result <EOL> def get_updated ( env_content : str , config : dict , * , keep_original = False , keep_whitespace = False ) -> str : <EOL> content_list = env_content . split ( \"<STR_LIT>\" ) <EOL> content_dict = { line . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] : line for line in content_list if \"<STR_LIT>\" in line } <EOL> new_content_list = content_list . copy ( ) <EOL> for key , value in config . items ( ) : <EOL> line = content_dict . get ( key ) <EOL> if line is not None : <EOL> index = new_content_list . index ( line ) <EOL> if not keep_original : <EOL> new_content_list [ index ] = f\"<STR_LIT>\" <EOL> else : <EOL> new_content_list . append ( f\"<STR_LIT>\" ) <EOL> if not keep_whitespace : <EOL> new_content_list = [ line . strip ( ) for line in new_content_list if line . strip ( ) ] <EOL> ", "gt": "return \"<STR_LIT>\" . join ( new_content_list )"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> ", "gt": "help_text = \"<STR_LIT>\" ,"}
{"input": "import importlib <EOL> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> from falco . utils import simple_progress <EOL> from jinja2 import Template <EOL> IMPORT_START_COMMENT = \"<STR_LIT>\" <EOL> IMPORT_END_COMMENT = \"<STR_LIT>\" <EOL> CODE_START_COMMENT = \"<STR_LIT>\" <EOL> CODE_END_COMMENT = \"<STR_LIT>\" <EOL> def render_to_string ( template_content : str , context : dict ) : <EOL> return Template ( template_content ) . render ( ** context ) <EOL> def get_crud_blueprints_path ( ) -> Path : <EOL> package = importlib . util . find_spec ( \"<STR_LIT>\" ) <EOL> if package is None : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / \"<STR_LIT>\" <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_python_formatters ( filepath : str | Path ) : <EOL> autoflake = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> filepath , <EOL> ] <EOL> ", "gt": "black = [ \"<STR_LIT>\" , filepath ]"}
{"input": "import io <EOL> import os <EOL> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import tomlkit <EOL> from cappa . testing import CommandRunner <EOL> def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> assert env_file . exists ( ) <EOL> assert env_template_file . exists ( ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> ", "gt": "runner . invoke ( \"<STR_LIT>\" )"}
{"input": "import importlib <EOL> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> from falco . utils import simple_progress <EOL> from jinja2 import Template <EOL> IMPORT_START_COMMENT = \"<STR_LIT>\" <EOL> IMPORT_END_COMMENT = \"<STR_LIT>\" <EOL> CODE_START_COMMENT = \"<STR_LIT>\" <EOL> CODE_END_COMMENT = \"<STR_LIT>\" <EOL> def render_to_string ( template_content : str , context : dict ) : <EOL> return Template ( template_content ) . render ( ** context ) <EOL> def get_crud_blueprints_path ( ) -> Path : <EOL> package = importlib . util . find_spec ( \"<STR_LIT>\" ) <EOL> if package is None : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / \"<STR_LIT>\" <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_python_formatters ( filepath : str | Path ) : <EOL> autoflake = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> filepath , <EOL> ] <EOL> black = [ \"<STR_LIT>\" , filepath ] <EOL> isort = [ \"<STR_LIT>\" , filepath ] <EOL> ", "gt": "subprocess . run ( autoflake , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False )"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise ShellCodeError ( result . stderr ) <EOL> return ast . literal_eval ( result . stdout ) if eval_result else result . stdout . strip ( ) <EOL> def is_new_falco_cli_available ( ) -> bool : <EOL> try : <EOL> with network_request_with_progress ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) as response : <EOL> latest_version = response . json ( ) [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> current_version = falco_version <EOL> return latest_version != current_version <EOL> except cappa . Exit : <EOL> ", "gt": "return False"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> @ pytest . fixture <EOL> def git_user_infos ( ) : <EOL> name = \"<STR_LIT>\" <EOL> email = \"<STR_LIT>\" <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = name <EOL> return mock <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> ", "gt": "mock . stdout = email"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_htmx_ext_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_download_to_output_file_existing_config ( runner : CommandRunner ) : <EOL> ", "gt": "pyproject_toml = Path ( \"<STR_LIT>\" )"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL> ", "gt": "model_name = \"<STR_LIT>\" ,"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> partials_to_use = [ partials_to_use ] <EOL> rendered_partials = [ <EOL> render_to_string ( f\"<STR_LIT>\" , context = resp . context_data , request = request ) <EOL> for b in partials_to_use <EOL> ] <EOL> resp = HttpResponse ( <EOL> content = \"<STR_LIT>\" . join ( rendered_partials ) , <EOL> status = resp . status_code , <EOL> ", "gt": "headers = resp . headers ,"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : get_superuser_email ( project_name ) , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> } <EOL> def get_superuser_email ( project_name : str ) : <EOL> pyproject_file = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_file . exists ( ) : <EOL> pyproject = tomlkit . parse ( pyproject_file . read_text ( ) ) <EOL> if authors := pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , [ ] ) : <EOL> return authors [ <NUM_LIT> ] [ \"<STR_LIT>\" ] <EOL> return f\"<STR_LIT>\" <EOL> def parse ( env_content : str ) -> dict : <EOL> result = { } <EOL> ", "gt": "for line in env_content . split ( \"<STR_LIT>\" ) :"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . EmailField ( max_length = <NUM_LIT> ) ) , <EOL> ", "gt": "( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) ,"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> ", "gt": "runner . invoke ( \"<STR_LIT>\" )"}
{"input": "from pathlib import Path <EOL> root_dir = Path ( __file__ ) . parent . parent <EOL> readme = root_dir / \"<STR_LIT>\" <EOL> guides = root_dir / \"<STR_LIT>\" <EOL> guides_index = guides / \"<STR_LIT>\" <EOL> def get_rst_doc_title ( file : Path ) : <EOL> title = \"<STR_LIT>\" <EOL> for line in file . read_text ( ) . splitlines ( ) : <EOL> if line . startswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> title = line <EOL> return title <EOL> def guides_files ( ) : <EOL> index_content = guides_index . read_text ( ) <EOL> toc_tree_directive = \"<STR_LIT>\" <EOL> start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) <EOL> def valid_line ( line ) : <EOL> return bool ( line ) and not line . strip ( ) . startswith ( \"<STR_LIT>\" ) <EOL> lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( \"<STR_LIT>\" ) if valid_line ( line ) ] <EOL> return [ guides / f\"<STR_LIT>\" for line in lines ] <EOL> def get_guides_list ( ) : <EOL> guides_md = [ ] <EOL> for file in guides_files ( ) : <EOL> if file . name . startswith ( \"<STR_LIT>\" ) : <EOL> continue <EOL> link = f\"<STR_LIT>\" <EOL> title = get_rst_doc_title ( file ) <EOL> guides_md . append ( f\"<STR_LIT>\" ) <EOL> ", "gt": "return \"<STR_LIT>\" + \"<STR_LIT>\" . join ( guides_md ) + \"<STR_LIT>\""}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ] , <EOL> options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> ", "gt": "} ,"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> ", "gt": "project_name = \"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> ", "gt": "filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> ", "gt": "def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) :"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> output_file . touch ( exist_ok = True ) <EOL> output_file . write_text ( <EOL> render_to_string ( imports_template , context ) <EOL> + render_to_string ( code_template , context ) <EOL> + output_file . read_text ( ) <EOL> ) <EOL> generated_files . append ( output_file ) <EOL> for file in generated_files : <EOL> run_python_formatters ( str ( file ) ) <EOL> return output_dir <EOL> @ classmethod <EOL> def get_install_path ( cls , project_name : str , falco_config : FalcoConfig ) -> tuple [ Path , bool ] : <EOL> if _import_path := falco_config . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" ) : <EOL> ", "gt": "return Path ( _import_path ) , True"}
{"input": "import importlib <EOL> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> from falco . utils import simple_progress <EOL> from jinja2 import Template <EOL> IMPORT_START_COMMENT = \"<STR_LIT>\" <EOL> IMPORT_END_COMMENT = \"<STR_LIT>\" <EOL> CODE_START_COMMENT = \"<STR_LIT>\" <EOL> CODE_END_COMMENT = \"<STR_LIT>\" <EOL> def render_to_string ( template_content : str , context : dict ) : <EOL> return Template ( template_content ) . render ( ** context ) <EOL> def get_crud_blueprints_path ( ) -> Path : <EOL> package = importlib . util . find_spec ( \"<STR_LIT>\" ) <EOL> if package is None : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / \"<STR_LIT>\" <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_python_formatters ( filepath : str | Path ) : <EOL> autoflake = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> filepath , <EOL> ] <EOL> black = [ \"<STR_LIT>\" , filepath ] <EOL> isort = [ \"<STR_LIT>\" , filepath ] <EOL> subprocess . run ( autoflake , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( isort , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( black , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_html_formatters ( filepath : str | Path ) : <EOL> djlint = [ \"<STR_LIT>\" , filepath , \"<STR_LIT>\" ] <EOL> subprocess . run ( djlint , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> def extract_python_file_templates ( file_content : str ) -> tuple [ str , str ] : <EOL> imports_template = extract_content_from ( file_content , IMPORT_START_COMMENT , IMPORT_END_COMMENT ) <EOL> code_template = extract_content_from ( file_content , CODE_START_COMMENT , CODE_END_COMMENT ) <EOL> return imports_template , code_template <EOL> def extract_content_from ( text : str , start_comment : str , end_comment : str ) : <EOL> ", "gt": "start_index = text . find ( start_comment ) + len ( start_comment )"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import pytest <EOL> from falco . commands . work import default_address <EOL> from falco . commands . work import default_server_cmd <EOL> from falco . commands . work import Work <EOL> from falco . config import write_falco_config <EOL> def test_env_resolution ( tmp_path ) : <EOL> assert Work ( ) . resolve_django_env ( ) <EOL> def test_env_resolution_with_env ( tmp_path ) : <EOL> ( tmp_path / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in Work ( ) . resolve_django_env ( ) <EOL> def test_without_pyproject_file ( ) : <EOL> assert Work ( ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) } <EOL> def test_with_pyproject_file ( pyproject_toml ) : <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> assert Work ( ) . get_commands ( ) == { <EOL> \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def test_override_server ( pyproject_toml ) : <EOL> work = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = work ) <EOL> assert Work ( ) . get_commands ( ) == work <EOL> ", "gt": "@ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] )"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise ShellCodeError ( result . stderr ) <EOL> return ast . literal_eval ( result . stdout ) if eval_result else result . stdout . strip ( ) <EOL> def is_new_falco_cli_available ( ) -> bool : <EOL> try : <EOL> with network_request_with_progress ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) as response : <EOL> latest_version = response . json ( ) [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> current_version = falco_version <EOL> ", "gt": "return latest_version != current_version"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> ", "gt": "verbose_name = \"<STR_LIT>\" ,"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> ", "gt": "html_context = {"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> partials_to_use = [ partials_to_use ] <EOL> rendered_partials = [ <EOL> render_to_string ( f\"<STR_LIT>\" , context = resp . context_data , request = request ) <EOL> for b in partials_to_use <EOL> ] <EOL> resp = HttpResponse ( <EOL> content = \"<STR_LIT>\" . join ( rendered_partials ) , <EOL> status = resp . status_code , <EOL> headers = resp . headers , <EOL> ) <EOL> return resp <EOL> return _view <EOL> return decorator <EOL> def _get_param_from_request ( request , param ) : <EOL> if param in request . GET : <EOL> return request . GET . getlist ( param ) <EOL> ", "gt": "if request . method == \"<STR_LIT>\" and param in request . POST :"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> ", "gt": "\"<STR_LIT>\" : ["}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ", "gt": ")"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> html_title = \"<STR_LIT>\" <EOL> html_context = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> html_theme_options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> html_logo = \"<STR_LIT>\" <EOL> html_favicon = \"<STR_LIT>\" <EOL> html_css_files = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> html_js_files = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> ) , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> ", "gt": "f\"<STR_LIT>\" ,"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> ", "gt": "model_name = \"<STR_LIT>\" ,"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> ", "gt": "yield"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> content = response . content . decode ( \"<STR_LIT>\" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> filepath = self . resolve_filepath ( falco_config = falco_config ) <EOL> filepath . parent . mkdir ( parents = True , exist_ok = True ) <EOL> filepath . write_text ( content ) <EOL> return filepath <EOL> def resolve_filepath ( self , falco_config : dict ) -> Path : <EOL> if self . output : <EOL> filepath = self . output if str ( self . output ) . endswith ( \"<STR_LIT>\" ) else self . output / \"<STR_LIT>\" <EOL> elif self . output is None and \"<STR_LIT>\" in falco_config : <EOL> htmx_config = self . read_from_config ( falco_config ) <EOL> filepath , _ = htmx_config <EOL> else : <EOL> filepath = Path ( \"<STR_LIT>\" ) <EOL> return filepath <EOL> @ classmethod <EOL> def read_from_config ( cls , falco_config : dict ) -> HtmxConfig : <EOL> htmx = falco_config . get ( \"<STR_LIT>\" ) <EOL> if not htmx : <EOL> return Path ( \"<STR_LIT>\" ) , None <EOL> try : <EOL> ", "gt": "filepath , version = htmx . split ( \"<STR_LIT>\" )"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> ", "gt": "if use_template is not None :"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> ", "gt": "else :"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> run_in_shell ( reset_migrations_table , eval_result = False ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> stderr = subprocess . DEVNULL , <EOL> ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> ", "gt": "stderr = subprocess . DEVNULL ,"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> ", "gt": "pyproject_toml . touch ( )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> run_in_shell ( reset_migrations_table , eval_result = False ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> stderr = subprocess . DEVNULL , <EOL> ) <EOL> subprocess . run ( <EOL> ", "gt": "[ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ,"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ", "gt": ")"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> repo = name_to_urls . get ( blueprint , blueprint ) <EOL> if repo . startswith ( \"<STR_LIT>\" ) and use_local : <EOL> if local_repo := find_local_cookiecutter ( repo ) : <EOL> ", "gt": "repo = str ( local_repo . resolve ( ) )"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> ", "gt": "for h in ("}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> ", "gt": "run_python_formatters ( models_file )"}
{"input": "import pytest <EOL> from falco . commands . work import default_address <EOL> from falco . commands . work import default_server_cmd <EOL> from falco . commands . work import Work <EOL> from falco . config import write_falco_config <EOL> def test_env_resolution ( tmp_path ) : <EOL> assert Work ( ) . resolve_django_env ( ) <EOL> def test_env_resolution_with_env ( tmp_path ) : <EOL> ( tmp_path / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in Work ( ) . resolve_django_env ( ) <EOL> def test_without_pyproject_file ( ) : <EOL> assert Work ( ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) } <EOL> def test_with_pyproject_file ( pyproject_toml ) : <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> assert Work ( ) . get_commands ( ) == { <EOL> \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> def test_override_server ( pyproject_toml ) : <EOL> work = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = work ) <EOL> assert Work ( ) . get_commands ( ) == work <EOL> @ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> def test_override_server_through_arg ( address ) : <EOL> ", "gt": "assert Work ( address = address ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = address ) }"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> ", "gt": "with simple_progress ( \"<STR_LIT>\" ) :"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> output_file . touch ( exist_ok = True ) <EOL> output_file . write_text ( <EOL> render_to_string ( imports_template , context ) <EOL> + render_to_string ( code_template , context ) <EOL> + output_file . read_text ( ) <EOL> ", "gt": ")"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_htmx_ext_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ", "gt": "assert output . exists ( )"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> ", "gt": "try :"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> ", "gt": "output_file . touch ( exist_ok = True )"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = \"<STR_LIT>\" <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : BASE_DIR / \"<STR_LIT>\" , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> ] <EOL> LANGUAGE_CODE = \"<STR_LIT>\" <EOL> TIME_ZONE = \"<STR_LIT>\" <EOL> USE_I18N = True <EOL> USE_TZ = True <EOL> ", "gt": "STATIC_URL = \"<STR_LIT>\""}
{"input": "from pathlib import Path <EOL> from typing import cast <EOL> from typing import TypedDict <EOL> import tomlkit <EOL> from typing_extensions import Unpack <EOL> class FalcoConfig ( TypedDict , total = False ) : <EOL> revision : str <EOL> blueprint : str <EOL> skip : list [ str ] <EOL> work : dict [ str , str ] <EOL> htmx : str <EOL> crud : \"<STR_LIT>\" <EOL> class CRUDConfig ( TypedDict ) : <EOL> blueprints : str <EOL> utils_path : str <EOL> login_required : bool <EOL> skip_git_check : bool <EOL> always_migrate : bool <EOL> def parse_crud_config_from_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def parse_crud_config_to_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def write_falco_config ( pyproject_path : Path , ** kwargs : Unpack [ TypedDict ] ) -> None : <EOL> new_falco_config = kwargs <EOL> new_crud_config = parse_crud_config_to_pyproject ( new_falco_config . pop ( \"<STR_LIT>\" , { } ) ) <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> existing_falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config = existing_falco_config . pop ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config . update ( new_crud_config ) <EOL> existing_falco_config . update ( { ** new_falco_config , \"<STR_LIT>\" : existing_crud_config } ) <EOL> tool = pyproject . get ( \"<STR_LIT>\" , { } ) <EOL> tool . update ( { \"<STR_LIT>\" : existing_falco_config } ) <EOL> pyproject [ \"<STR_LIT>\" ] = tool <EOL> pyproject_path . write_text ( tomlkit . dumps ( pyproject ) ) <EOL> def read_falco_config ( pyproject_path : Path ) -> FalcoConfig : <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) <EOL> crud_config = falco_config . pop ( \"<STR_LIT>\" , { } ) <EOL> crud_config = parse_crud_config_from_pyproject ( crud_config ) <EOL> ", "gt": "return cast ( FalcoConfig , { ** falco_config , \"<STR_LIT>\" : crud_config } )"}
{"input": "from pathlib import Path <EOL> from typing import cast <EOL> from typing import TypedDict <EOL> import tomlkit <EOL> from typing_extensions import Unpack <EOL> class FalcoConfig ( TypedDict , total = False ) : <EOL> revision : str <EOL> blueprint : str <EOL> skip : list [ str ] <EOL> work : dict [ str , str ] <EOL> htmx : str <EOL> crud : \"<STR_LIT>\" <EOL> class CRUDConfig ( TypedDict ) : <EOL> blueprints : str <EOL> utils_path : str <EOL> login_required : bool <EOL> skip_git_check : bool <EOL> always_migrate : bool <EOL> def parse_crud_config_from_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def parse_crud_config_to_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def write_falco_config ( pyproject_path : Path , ** kwargs : Unpack [ TypedDict ] ) -> None : <EOL> new_falco_config = kwargs <EOL> new_crud_config = parse_crud_config_to_pyproject ( new_falco_config . pop ( \"<STR_LIT>\" , { } ) ) <EOL> ", "gt": "pyproject = tomlkit . parse ( pyproject_path . read_text ( ) )"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco import checks <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> def get_django_debug_value ( ) -> bool : <EOL> from django . conf import settings <EOL> return settings . DEBUG <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class RmMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) <EOL> django_debug_value = run_in_shell ( get_django_debug_value , eval_result = True ) <EOL> if not django_debug_value : <EOL> ", "gt": "raise cappa . Exit ("}
{"input": "from pathlib import Path <EOL> from typing import cast <EOL> from typing import TypedDict <EOL> import tomlkit <EOL> from typing_extensions import Unpack <EOL> class FalcoConfig ( TypedDict , total = False ) : <EOL> revision : str <EOL> blueprint : str <EOL> skip : list [ str ] <EOL> work : dict [ str , str ] <EOL> htmx : str <EOL> crud : \"<STR_LIT>\" <EOL> class CRUDConfig ( TypedDict ) : <EOL> blueprints : str <EOL> utils_path : str <EOL> login_required : bool <EOL> skip_git_check : bool <EOL> always_migrate : bool <EOL> def parse_crud_config_from_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def parse_crud_config_to_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def write_falco_config ( pyproject_path : Path , ** kwargs : Unpack [ TypedDict ] ) -> None : <EOL> new_falco_config = kwargs <EOL> new_crud_config = parse_crud_config_to_pyproject ( new_falco_config . pop ( \"<STR_LIT>\" , { } ) ) <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> existing_falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config = existing_falco_config . pop ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config . update ( new_crud_config ) <EOL> ", "gt": "existing_falco_config . update ( { ** new_falco_config , \"<STR_LIT>\" : existing_crud_config } )"}
{"input": "from pathlib import Path <EOL> root_dir = Path ( __file__ ) . parent . parent <EOL> readme = root_dir / \"<STR_LIT>\" <EOL> guides = root_dir / \"<STR_LIT>\" <EOL> guides_index = guides / \"<STR_LIT>\" <EOL> def get_rst_doc_title ( file : Path ) : <EOL> title = \"<STR_LIT>\" <EOL> for line in file . read_text ( ) . splitlines ( ) : <EOL> if line . startswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> title = line <EOL> return title <EOL> def guides_files ( ) : <EOL> index_content = guides_index . read_text ( ) <EOL> toc_tree_directive = \"<STR_LIT>\" <EOL> start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) <EOL> def valid_line ( line ) : <EOL> return bool ( line ) and not line . strip ( ) . startswith ( \"<STR_LIT>\" ) <EOL> lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( \"<STR_LIT>\" ) if valid_line ( line ) ] <EOL> return [ guides / f\"<STR_LIT>\" for line in lines ] <EOL> def get_guides_list ( ) : <EOL> guides_md = [ ] <EOL> for file in guides_files ( ) : <EOL> if file . name . startswith ( \"<STR_LIT>\" ) : <EOL> continue <EOL> link = f\"<STR_LIT>\" <EOL> title = get_rst_doc_title ( file ) <EOL> guides_md . append ( f\"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" + \"<STR_LIT>\" . join ( guides_md ) + \"<STR_LIT>\" <EOL> def update_readme ( start_comment , end_comment , new_content ) : <EOL> ", "gt": "text = readme . read_text ( )"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> ", "gt": "assert Path ( \"<STR_LIT>\" ) . exists ( )"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from honcho . manager import Manager <EOL> from . sync_dotenv import parse as parse_dotenv <EOL> default_server_cmd = \"<STR_LIT>\" <EOL> default_address = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Work : <EOL> address : Annotated [ str , cappa . Arg ( default = default_address , help = \"<STR_LIT>\" ) ] = default_address <EOL> def __call__ ( self ) -> None : <EOL> commands = self . get_commands ( ) <EOL> manager = Manager ( ) <EOL> django_env = self . resolve_django_env ( ) <EOL> for name , cmd in commands . items ( ) : <EOL> manager . add_process ( name , cmd , env = django_env ) <EOL> try : <EOL> manager . loop ( ) <EOL> finally : <EOL> manager . terminate ( ) <EOL> sys . exit ( manager . returncode ) <EOL> def resolve_django_env ( self ) -> dict : <EOL> current_dir = Path ( ) . resolve ( ) <EOL> env_file = current_dir / \"<STR_LIT>\" <EOL> env_vars = parse_dotenv ( env_file . read_text ( ) ) if env_file . exists ( ) else { } <EOL> return { <EOL> ** os . environ , <EOL> ", "gt": "\"<STR_LIT>\" : str ( current_dir ) ,"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : get_superuser_email ( project_name ) , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> } <EOL> def get_superuser_email ( project_name : str ) : <EOL> pyproject_file = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_file . exists ( ) : <EOL> pyproject = tomlkit . parse ( pyproject_file . read_text ( ) ) <EOL> if authors := pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , [ ] ) : <EOL> return authors [ <NUM_LIT> ] [ \"<STR_LIT>\" ] <EOL> return f\"<STR_LIT>\" <EOL> ", "gt": "def parse ( env_content : str ) -> dict :"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_existing_config ( runner : CommandRunner , pyproject_toml ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , crud = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> ", "gt": "assert ( output / \"<STR_LIT>\" ) . exists ( )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_htmx_ext_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> ", "gt": "def test_htmx_ext_file_existing_config ( runner : CommandRunner ) :"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> ", "gt": "dotenv_template_content ,"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise ShellCodeError ( result . stderr ) <EOL> return ast . literal_eval ( result . stdout ) if eval_result else result . stdout . strip ( ) <EOL> def is_new_falco_cli_available ( ) -> bool : <EOL> try : <EOL> with network_request_with_progress ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": ") as response :"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = \"<STR_LIT>\" <EOL> ", "gt": "DATABASES = {"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { \"<STR_LIT>\" : project_name } <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> output_file . touch ( exist_ok = True ) <EOL> output_file . write_text ( <EOL> render_to_string ( imports_template , context ) <EOL> + render_to_string ( code_template , context ) <EOL> ", "gt": "+ output_file . read_text ( )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import pytest <EOL> from falco . commands . work import default_address <EOL> from falco . commands . work import default_server_cmd <EOL> from falco . commands . work import Work <EOL> from falco . config import write_falco_config <EOL> def test_env_resolution ( tmp_path ) : <EOL> assert Work ( ) . resolve_django_env ( ) <EOL> def test_env_resolution_with_env ( tmp_path ) : <EOL> ( tmp_path / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in Work ( ) . resolve_django_env ( ) <EOL> def test_without_pyproject_file ( ) : <EOL> assert Work ( ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) } <EOL> def test_with_pyproject_file ( pyproject_toml ) : <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> assert Work ( ) . get_commands ( ) == { <EOL> \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "}"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> content = response . content . decode ( \"<STR_LIT>\" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> filepath = self . resolve_filepath ( falco_config = falco_config ) <EOL> filepath . parent . mkdir ( parents = True , exist_ok = True ) <EOL> filepath . write_text ( content ) <EOL> return filepath <EOL> def resolve_filepath ( self , falco_config : dict ) -> Path : <EOL> if self . output : <EOL> filepath = self . output if str ( self . output ) . endswith ( \"<STR_LIT>\" ) else self . output / \"<STR_LIT>\" <EOL> elif self . output is None and \"<STR_LIT>\" in falco_config : <EOL> htmx_config = self . read_from_config ( falco_config ) <EOL> filepath , _ = htmx_config <EOL> else : <EOL> filepath = Path ( \"<STR_LIT>\" ) <EOL> return filepath <EOL> ", "gt": "@ classmethod"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> ", "gt": "return directory"}
{"input": "import importlib <EOL> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> from falco . utils import simple_progress <EOL> from jinja2 import Template <EOL> IMPORT_START_COMMENT = \"<STR_LIT>\" <EOL> IMPORT_END_COMMENT = \"<STR_LIT>\" <EOL> CODE_START_COMMENT = \"<STR_LIT>\" <EOL> CODE_END_COMMENT = \"<STR_LIT>\" <EOL> def render_to_string ( template_content : str , context : dict ) : <EOL> return Template ( template_content ) . render ( ** context ) <EOL> def get_crud_blueprints_path ( ) -> Path : <EOL> package = importlib . util . find_spec ( \"<STR_LIT>\" ) <EOL> if package is None : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / \"<STR_LIT>\" <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_python_formatters ( filepath : str | Path ) : <EOL> autoflake = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> filepath , <EOL> ] <EOL> black = [ \"<STR_LIT>\" , filepath ] <EOL> isort = [ \"<STR_LIT>\" , filepath ] <EOL> subprocess . run ( autoflake , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( isort , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( black , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def run_html_formatters ( filepath : str | Path ) : <EOL> djlint = [ \"<STR_LIT>\" , filepath , \"<STR_LIT>\" ] <EOL> subprocess . run ( djlint , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> def extract_python_file_templates ( file_content : str ) -> tuple [ str , str ] : <EOL> imports_template = extract_content_from ( file_content , IMPORT_START_COMMENT , IMPORT_END_COMMENT ) <EOL> code_template = extract_content_from ( file_content , CODE_START_COMMENT , CODE_END_COMMENT ) <EOL> ", "gt": "return imports_template , code_template"}
{"input": "from pathlib import Path <EOL> from typing import cast <EOL> from typing import TypedDict <EOL> import tomlkit <EOL> from typing_extensions import Unpack <EOL> class FalcoConfig ( TypedDict , total = False ) : <EOL> revision : str <EOL> blueprint : str <EOL> skip : list [ str ] <EOL> work : dict [ str , str ] <EOL> htmx : str <EOL> crud : \"<STR_LIT>\" <EOL> class CRUDConfig ( TypedDict ) : <EOL> blueprints : str <EOL> utils_path : str <EOL> login_required : bool <EOL> skip_git_check : bool <EOL> always_migrate : bool <EOL> def parse_crud_config_from_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def parse_crud_config_to_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def write_falco_config ( pyproject_path : Path , ** kwargs : Unpack [ TypedDict ] ) -> None : <EOL> new_falco_config = kwargs <EOL> new_crud_config = parse_crud_config_to_pyproject ( new_falco_config . pop ( \"<STR_LIT>\" , { } ) ) <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> existing_falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config = existing_falco_config . pop ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config . update ( new_crud_config ) <EOL> existing_falco_config . update ( { ** new_falco_config , \"<STR_LIT>\" : existing_crud_config } ) <EOL> tool = pyproject . get ( \"<STR_LIT>\" , { } ) <EOL> tool . update ( { \"<STR_LIT>\" : existing_falco_config } ) <EOL> pyproject [ \"<STR_LIT>\" ] = tool <EOL> pyproject_path . write_text ( tomlkit . dumps ( pyproject ) ) <EOL> def read_falco_config ( pyproject_path : Path ) -> FalcoConfig : <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> ", "gt": "falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) <EOL> module = parso . parse ( settings_file . read_text ( ) ) <EOL> for node in module . children : <EOL> try : <EOL> if ( <EOL> ", "gt": "node . children [ <NUM_LIT> ] . type == parso . python . tree . ExprStmt . type"}
{"input": "from pathlib import Path <EOL> root_dir = Path ( __file__ ) . parent . parent <EOL> readme = root_dir / \"<STR_LIT>\" <EOL> guides = root_dir / \"<STR_LIT>\" <EOL> guides_index = guides / \"<STR_LIT>\" <EOL> def get_rst_doc_title ( file : Path ) : <EOL> title = \"<STR_LIT>\" <EOL> for line in file . read_text ( ) . splitlines ( ) : <EOL> if line . startswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> title = line <EOL> return title <EOL> def guides_files ( ) : <EOL> index_content = guides_index . read_text ( ) <EOL> toc_tree_directive = \"<STR_LIT>\" <EOL> start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) <EOL> def valid_line ( line ) : <EOL> return bool ( line ) and not line . strip ( ) . startswith ( \"<STR_LIT>\" ) <EOL> lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( \"<STR_LIT>\" ) if valid_line ( line ) ] <EOL> return [ guides / f\"<STR_LIT>\" for line in lines ] <EOL> def get_guides_list ( ) : <EOL> guides_md = [ ] <EOL> for file in guides_files ( ) : <EOL> if file . name . startswith ( \"<STR_LIT>\" ) : <EOL> continue <EOL> link = f\"<STR_LIT>\" <EOL> title = get_rst_doc_title ( file ) <EOL> guides_md . append ( f\"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" + \"<STR_LIT>\" . join ( guides_md ) + \"<STR_LIT>\" <EOL> def update_readme ( start_comment , end_comment , new_content ) : <EOL> text = readme . read_text ( ) <EOL> start_index = text . find ( start_comment ) + len ( start_comment ) <EOL> end_index = text . find ( end_comment ) <EOL> ", "gt": "new_content = text [ : start_index ] + new_content + text [ end_index : ]"}
{"input": "import falco <EOL> project = \"<STR_LIT>\" <EOL> copyright = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> } <EOL> templates_path = [ \"<STR_LIT>\" ] <EOL> exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> html_theme = \"<STR_LIT>\" <EOL> html_static_path = [ \"<STR_LIT>\" ] <EOL> html_baseurl = \"<STR_LIT>\" <EOL> ", "gt": "html_title = \"<STR_LIT>\""}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> @ pytest . fixture <EOL> def git_user_infos ( ) : <EOL> name = \"<STR_LIT>\" <EOL> email = \"<STR_LIT>\" <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = name <EOL> return mock <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = email <EOL> return mock <EOL> ", "gt": "return original_run ( args , ** kwargs )"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> ", "gt": "primary_key = True ,"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> ", "gt": "help_text = \"<STR_LIT>\" ,"}
{"input": "import subprocess <EOL> from contextlib import suppress <EOL> import cappa <EOL> def clean_git_repo ( * , ignore_dirty : bool = False ) -> None : <EOL> if ignore_dirty : <EOL> return <EOL> with suppress ( subprocess . CalledProcessError ) : <EOL> result = subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , capture_output = True , text = True , check = True ) <EOL> if result . stdout . strip ( ) == \"<STR_LIT>\" : <EOL> return <EOL> raise cappa . Exit ( <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> @ pytest . fixture <EOL> def git_user_infos ( ) : <EOL> name = \"<STR_LIT>\" <EOL> email = \"<STR_LIT>\" <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> ", "gt": "mock . stdout = name"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file_existing_config ( runner : CommandRunner ) : <EOL> ", "gt": "pyproject_toml = Path ( \"<STR_LIT>\" )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> run_in_shell ( reset_migrations_table , eval_result = False ) <EOL> subprocess . run ( <EOL> ", "gt": "[ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ,"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_user_name_and_email ( runner : CommandRunner , git_user_infos ) : <EOL> name , email = git_user_infos <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "str ( blueprint_path ) ,"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> ", "gt": "with simple_progress ( description ) :"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> ", "gt": "def register_app ( self , app_name : str ) -> Path :"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . DateTimeField ( blank = True , null = True ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . ImageField ( blank = True , null = True , upload_to = \"<STR_LIT>\" ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . FileField ( blank = True , null = True , upload_to = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ", "gt": "]"}
{"input": "from pathlib import Path <EOL> from typing import cast <EOL> from typing import TypedDict <EOL> import tomlkit <EOL> from typing_extensions import Unpack <EOL> class FalcoConfig ( TypedDict , total = False ) : <EOL> revision : str <EOL> blueprint : str <EOL> skip : list [ str ] <EOL> work : dict [ str , str ] <EOL> htmx : str <EOL> crud : \"<STR_LIT>\" <EOL> class CRUDConfig ( TypedDict ) : <EOL> blueprints : str <EOL> utils_path : str <EOL> login_required : bool <EOL> skip_git_check : bool <EOL> always_migrate : bool <EOL> def parse_crud_config_from_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def parse_crud_config_to_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } <EOL> def write_falco_config ( pyproject_path : Path , ** kwargs : Unpack [ TypedDict ] ) -> None : <EOL> new_falco_config = kwargs <EOL> new_crud_config = parse_crud_config_to_pyproject ( new_falco_config . pop ( \"<STR_LIT>\" , { } ) ) <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> existing_falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config = existing_falco_config . pop ( \"<STR_LIT>\" , { } ) <EOL> existing_crud_config . update ( new_crud_config ) <EOL> existing_falco_config . update ( { ** new_falco_config , \"<STR_LIT>\" : existing_crud_config } ) <EOL> tool = pyproject . get ( \"<STR_LIT>\" , { } ) <EOL> tool . update ( { \"<STR_LIT>\" : existing_falco_config } ) <EOL> ", "gt": "pyproject [ \"<STR_LIT>\" ] = tool"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ", "gt": "( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) ,"}
{"input": "import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> related_name = \"<STR_LIT>\" , <EOL> related_query_name = \"<STR_LIT>\" , <EOL> to = \"<STR_LIT>\" , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ] , <EOL> options = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> partials_to_use = [ partials_to_use ] <EOL> rendered_partials = [ <EOL> render_to_string ( f\"<STR_LIT>\" , context = resp . context_data , request = request ) <EOL> ", "gt": "for b in partials_to_use"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> ", "gt": "elif partials_to_use is not None :"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . DateTimeField ( blank = True , null = True ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> ", "gt": "model_name = \"<STR_LIT>\" ,"}
{"input": "import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_template_file = Path ( \"<STR_LIT>\" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" <EOL> debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" <EOL> base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : \"<STR_LIT>\" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : get_superuser_email ( project_name ) , <EOL> \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> } <EOL> def get_superuser_email ( project_name : str ) : <EOL> pyproject_file = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_file . exists ( ) : <EOL> pyproject = tomlkit . parse ( pyproject_file . read_text ( ) ) <EOL> if authors := pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , [ ] ) : <EOL> return authors [ <NUM_LIT> ] [ \"<STR_LIT>\" ] <EOL> return f\"<STR_LIT>\" <EOL> def parse ( env_content : str ) -> dict : <EOL> result = { } <EOL> for line in env_content . split ( \"<STR_LIT>\" ) : <EOL> stripped_line = line . strip ( ) <EOL> if stripped_line . startswith ( \"<STR_LIT>\" ) or not stripped_line : <EOL> continue <EOL> try : <EOL> key , value = stripped_line . split ( \"<STR_LIT>\" , <NUM_LIT> ) <EOL> except ValueError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> result [ key ] = value <EOL> ", "gt": "return result"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> ", "gt": "} ,"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco import checks <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> def get_django_debug_value ( ) -> bool : <EOL> from django . conf import settings <EOL> return settings . DEBUG <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class RmMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) <EOL> django_debug_value = run_in_shell ( get_django_debug_value , eval_result = True ) <EOL> if not django_debug_value : <EOL> raise cappa . Exit ( <EOL> \"<STR_LIT>\" , <EOL> code = <NUM_LIT> , <EOL> ", "gt": ")"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> ", "gt": "field = models . DateTimeField ( auto_now_add = True , default = django . utils . timezone . now ) ,"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . DateTimeField ( blank = True , null = True ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = models . ImageField ( blank = True , null = True , upload_to = \"<STR_LIT>\" ) , <EOL> ", "gt": ") ,"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> partials_to_use = [ partials_to_use ] <EOL> rendered_partials = [ <EOL> render_to_string ( f\"<STR_LIT>\" , context = resp . context_data , request = request ) <EOL> for b in partials_to_use <EOL> ] <EOL> resp = HttpResponse ( <EOL> content = \"<STR_LIT>\" . join ( rendered_partials ) , <EOL> status = resp . status_code , <EOL> headers = resp . headers , <EOL> ", "gt": ")"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> content = response . content . decode ( \"<STR_LIT>\" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> msg = f\"<STR_LIT>\" <EOL> ", "gt": "raise cappa . Exit ( msg , code = <NUM_LIT> )"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco import checks <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> def get_django_debug_value ( ) -> bool : <EOL> from django . conf import settings <EOL> return settings . DEBUG <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class RmMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) <EOL> django_debug_value = run_in_shell ( get_django_debug_value , eval_result = True ) <EOL> if not django_debug_value : <EOL> raise cappa . Exit ( <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from honcho . manager import Manager <EOL> from . sync_dotenv import parse as parse_dotenv <EOL> default_server_cmd = \"<STR_LIT>\" <EOL> default_address = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Work : <EOL> address : Annotated [ str , cappa . Arg ( default = default_address , help = \"<STR_LIT>\" ) ] = default_address <EOL> def __call__ ( self ) -> None : <EOL> commands = self . get_commands ( ) <EOL> manager = Manager ( ) <EOL> django_env = self . resolve_django_env ( ) <EOL> for name , cmd in commands . items ( ) : <EOL> manager . add_process ( name , cmd , env = django_env ) <EOL> try : <EOL> manager . loop ( ) <EOL> finally : <EOL> manager . terminate ( ) <EOL> sys . exit ( manager . returncode ) <EOL> def resolve_django_env ( self ) -> dict : <EOL> current_dir = Path ( ) . resolve ( ) <EOL> env_file = current_dir / \"<STR_LIT>\" <EOL> env_vars = parse_dotenv ( env_file . read_text ( ) ) if env_file . exists ( ) else { } <EOL> return { <EOL> ** os . environ , <EOL> \"<STR_LIT>\" : str ( current_dir ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ** env_vars , <EOL> ", "gt": "}"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> ", "gt": "result = subprocess . run ("}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> def makemigaration ( ) : <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = False ) <EOL> def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / \"<STR_LIT>\" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert not first_migration . exists ( ) <EOL> def test_rm_migrations_fake_apps_dir ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> ", "gt": "makemigaration ( )"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from honcho . manager import Manager <EOL> from . sync_dotenv import parse as parse_dotenv <EOL> default_server_cmd = \"<STR_LIT>\" <EOL> default_address = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Work : <EOL> address : Annotated [ str , cappa . Arg ( default = default_address , help = \"<STR_LIT>\" ) ] = default_address <EOL> def __call__ ( self ) -> None : <EOL> commands = self . get_commands ( ) <EOL> manager = Manager ( ) <EOL> django_env = self . resolve_django_env ( ) <EOL> for name , cmd in commands . items ( ) : <EOL> manager . add_process ( name , cmd , env = django_env ) <EOL> try : <EOL> manager . loop ( ) <EOL> finally : <EOL> manager . terminate ( ) <EOL> sys . exit ( manager . returncode ) <EOL> def resolve_django_env ( self ) -> dict : <EOL> current_dir = Path ( ) . resolve ( ) <EOL> env_file = current_dir / \"<STR_LIT>\" <EOL> env_vars = parse_dotenv ( env_file . read_text ( ) ) if env_file . exists ( ) else { } <EOL> return { <EOL> ** os . environ , <EOL> \"<STR_LIT>\" : str ( current_dir ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ** env_vars , <EOL> } <EOL> def get_commands ( self ) -> dict : <EOL> commands = { \"<STR_LIT>\" : default_server_cmd } <EOL> pyproject_file = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_file . exists ( ) : <EOL> user_commands = read_falco_config ( pyproject_path = pyproject_file ) . get ( \"<STR_LIT>\" , { } ) <EOL> else : <EOL> user_commands = { } <EOL> commands |= user_commands <EOL> commands [ \"<STR_LIT>\" ] = commands [ \"<STR_LIT>\" ] . format ( address = self . address ) <EOL> ", "gt": "return commands"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> ", "gt": "def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType :"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> ", "gt": "app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) )"}
{"input": "from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return \"<STR_LIT>\" <EOL> with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( \"<STR_LIT>\" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> ", "gt": "assert filepath == output"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ", "gt": "]"}
{"input": "import io <EOL> import os <EOL> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import tomlkit <EOL> from cappa . testing import CommandRunner <EOL> def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> assert env_file . exists ( ) <EOL> assert env_template_file . exists ( ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> def test_print_value ( runner : CommandRunner , pyproject_toml ) : <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> with patch ( \"<STR_LIT>\" , new = io . StringIO ( ) ) as fake_stdout : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> stdout = fake_stdout . getvalue ( ) <EOL> assert not Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert \"<STR_LIT>\" in stdout <EOL> def test_prod_config ( runner : CommandRunner , pyproject_toml ) : <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> pyproject = tomlkit . parse ( pyproject_toml . read_text ( ) ) <EOL> pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] = [ { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } ] <EOL> pyproject_toml . write_text ( tomlkit . dumps ( pyproject ) ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> ", "gt": "assert \"<STR_LIT>\" in Path ( \"<STR_LIT>\" ) . read_text ( )"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> partials_to_use = [ partials_to_use ] <EOL> rendered_partials = [ <EOL> render_to_string ( f\"<STR_LIT>\" , context = resp . context_data , request = request ) <EOL> for b in partials_to_use <EOL> ] <EOL> resp = HttpResponse ( <EOL> content = \"<STR_LIT>\" . join ( rendered_partials ) , <EOL> status = resp . status_code , <EOL> headers = resp . headers , <EOL> ) <EOL> return resp <EOL> return _view <EOL> return decorator <EOL> def _get_param_from_request ( request , param ) : <EOL> if param in request . GET : <EOL> return request . GET . getlist ( param ) <EOL> if request . method == \"<STR_LIT>\" and param in request . POST : <EOL> ", "gt": "return request . POST . getlist ( param )"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> content = response . content . decode ( \"<STR_LIT>\" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> filepath = self . resolve_filepath ( falco_config = falco_config ) <EOL> filepath . parent . mkdir ( parents = True , exist_ok = True ) <EOL> filepath . write_text ( content ) <EOL> return filepath <EOL> def resolve_filepath ( self , falco_config : dict ) -> Path : <EOL> if self . output : <EOL> filepath = self . output if str ( self . output ) . endswith ( \"<STR_LIT>\" ) else self . output / \"<STR_LIT>\" <EOL> elif self . output is None and \"<STR_LIT>\" in falco_config : <EOL> htmx_config = self . read_from_config ( falco_config ) <EOL> filepath , _ = htmx_config <EOL> else : <EOL> filepath = Path ( \"<STR_LIT>\" ) <EOL> return filepath <EOL> @ classmethod <EOL> def read_from_config ( cls , falco_config : dict ) -> HtmxConfig : <EOL> htmx = falco_config . get ( \"<STR_LIT>\" ) <EOL> if not htmx : <EOL> return Path ( \"<STR_LIT>\" ) , None <EOL> try : <EOL> filepath , version = htmx . split ( \"<STR_LIT>\" ) <EOL> ", "gt": "except ValueError :"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> ", "gt": "def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path :"}
{"input": "from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = \"<STR_LIT>\" <EOL> HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : <EOL> try : <EOL> return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != \"<STR_LIT>\" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> \"<STR_LIT>\" <EOL> if version == latest_version <EOL> else f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f\"<STR_LIT>\" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : <EOL> content = response . content . decode ( \"<STR_LIT>\" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> filepath = self . resolve_filepath ( falco_config = falco_config ) <EOL> filepath . parent . mkdir ( parents = True , exist_ok = True ) <EOL> filepath . write_text ( content ) <EOL> return filepath <EOL> def resolve_filepath ( self , falco_config : dict ) -> Path : <EOL> if self . output : <EOL> filepath = self . output if str ( self . output ) . endswith ( \"<STR_LIT>\" ) else self . output / \"<STR_LIT>\" <EOL> elif self . output is None and \"<STR_LIT>\" in falco_config : <EOL> htmx_config = self . read_from_config ( falco_config ) <EOL> filepath , _ = htmx_config <EOL> else : <EOL> filepath = Path ( \"<STR_LIT>\" ) <EOL> return filepath <EOL> @ classmethod <EOL> def read_from_config ( cls , falco_config : dict ) -> HtmxConfig : <EOL> htmx = falco_config . get ( \"<STR_LIT>\" ) <EOL> if not htmx : <EOL> ", "gt": "return Path ( \"<STR_LIT>\" ) , None"}
{"input": "from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = \"<STR_LIT>\" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f\"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> if response . lower ( ) == \"<STR_LIT>\" : <EOL> rich_print ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> config = { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , <EOL> \"<STR_LIT>\" : revision , <EOL> \"<STR_LIT>\" : DEFAULT_SKIP , <EOL> \"<STR_LIT>\" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) <EOL> msg = f\"<STR_LIT>\" <EOL> msg += ( <EOL> f\"<STR_LIT>\" <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> \"<STR_LIT>\" : self . project_name , <EOL> \"<STR_LIT>\" : author_name , <EOL> \"<STR_LIT>\" : author_email , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / \"<STR_LIT>\" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> repo = name_to_urls . get ( blueprint , blueprint ) <EOL> if repo . startswith ( \"<STR_LIT>\" ) and use_local : <EOL> if local_repo := find_local_cookiecutter ( repo ) : <EOL> repo = str ( local_repo . resolve ( ) ) <EOL> else : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , repo , \"<STR_LIT>\" ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> revision = result . stdout . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] . split ( ) [ <NUM_LIT> ] . strip ( ) <EOL> return repo , revision <EOL> def get_authors_info ( ) -> tuple [ str , str ] : <EOL> default_author_name = \"<STR_LIT>\" <EOL> default_author_email = \"<STR_LIT>\" <EOL> git_config_cmd = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> try : <EOL> user_name_cmd = subprocess . run ( [ * git_config_cmd , \"<STR_LIT>\" ] , capture_output = True , text = True , check = False ) <EOL> ", "gt": "user_email_cmd = subprocess . run ( [ * git_config_cmd , \"<STR_LIT>\" ] , capture_output = True , text = True , check = False )"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> @ pytest . fixture <EOL> ", "gt": "def git_user_infos ( ) :"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_user_name_and_email ( runner : CommandRunner , git_user_infos ) : <EOL> name , email = git_user_infos <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> pyproject_content = ( Path ( \"<STR_LIT>\" ) / \"<STR_LIT>\" ) . read_text ( ) <EOL> ", "gt": "assert name in pyproject_content"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ", "gt": ")"}
{"input": "import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" <EOL> branch = tree . add ( <EOL> f\"<STR_LIT>\" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , \"<STR_LIT>\" ) <EOL> text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> text_filename . stylize ( f\"<STR_LIT>\" ) <EOL> icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = \"<STR_LIT>\" , <EOL> directory = temp_dir . resolve ( ) , <EOL> ", "gt": "is_root = True ,"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = \"<STR_LIT>\" <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : BASE_DIR / \"<STR_LIT>\" , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> ", "gt": "{"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "] ,"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , <EOL> ( \"<STR_LIT>\" , models . TextField ( ) ) , <EOL> ( \"<STR_LIT>\" , models . DecimalField ( decimal_places = <NUM_LIT> , max_digits = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , <EOL> ( \"<STR_LIT>\" , models . DateTimeField ( default = django . utils . timezone . now ) ) , <EOL> ] , <EOL> ) , <EOL> ", "gt": "]"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> ", "gt": "runner . invoke ("}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "import io <EOL> import os <EOL> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import tomlkit <EOL> from cappa . testing import CommandRunner <EOL> def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> assert env_file . exists ( ) <EOL> assert env_template_file . exists ( ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> assert \"<STR_LIT>\" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_file . write_text ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in env_file . read_text ( ) <EOL> def test_print_value ( runner : CommandRunner , pyproject_toml ) : <EOL> env_template_file = Path ( \"<STR_LIT>\" ) <EOL> env_template_file . write_text ( \"<STR_LIT>\" ) <EOL> with patch ( \"<STR_LIT>\" , new = io . StringIO ( ) ) as fake_stdout : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> stdout = fake_stdout . getvalue ( ) <EOL> assert not Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert \"<STR_LIT>\" in stdout <EOL> def test_prod_config ( runner : CommandRunner , pyproject_toml ) : <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> pyproject = tomlkit . parse ( pyproject_toml . read_text ( ) ) <EOL> pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] = [ { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } ] <EOL> pyproject_toml . write_text ( tomlkit . dumps ( pyproject ) ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in Path ( \"<STR_LIT>\" ) . read_text ( ) <EOL> ", "gt": "assert \"<STR_LIT>\" in Path ( \"<STR_LIT>\" ) . read_text ( )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return f\"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f\"<STR_LIT>\" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / \"<STR_LIT>\" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) <EOL> app_config_file = app_dir / \"<STR_LIT>\" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( \"<STR_LIT>\" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) <EOL> module = parso . parse ( settings_file . read_text ( ) ) <EOL> for node in module . children : <EOL> try : <EOL> if ( <EOL> node . children [ <NUM_LIT> ] . type == parso . python . tree . ExprStmt . type <EOL> and node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] . value in names <EOL> ) : <EOL> apps = node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] <EOL> ", "gt": "elements = apps . children [ <NUM_LIT> ]"}
{"input": "import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , <EOL> ( \"<STR_LIT>\" , models . TextField ( ) ) , <EOL> ( \"<STR_LIT>\" , models . DecimalField ( decimal_places = <NUM_LIT> , max_digits = <NUM_LIT> ) ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , <EOL> ", "gt": "( \"<STR_LIT>\" , models . DateTimeField ( default = django . utils . timezone . now ) ) ,"}
{"input": "import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / \"<STR_LIT>\" <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) <EOL> settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> ( project_dir / \"<STR_LIT>\" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = \"<STR_LIT>\" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / \"<STR_LIT>\" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> @ pytest . fixture <EOL> def git_user_infos ( ) : <EOL> name = \"<STR_LIT>\" <EOL> email = \"<STR_LIT>\" <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> ", "gt": "mock = MagicMock ( )"}
{"input": "from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == \"<STR_LIT>\" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = \"<STR_LIT>\" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , \"<STR_LIT>\" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "\"<STR_LIT>\" ,"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) <EOL> rich_print ( f\"<STR_LIT>\" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> ", "gt": "output_dir . mkdir ( parents = True , exist_ok = True )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_existing_config ( runner : CommandRunner , pyproject_toml ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , crud = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> ", "gt": "output = Path ( \"<STR_LIT>\" )"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> run_in_shell ( reset_migrations_table , eval_result = False ) <EOL> subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> ", "gt": "stderr = subprocess . DEVNULL ,"}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> ", "gt": "primary_key = True ,"}
{"input": "from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = \"<STR_LIT>\" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = \"<STR_LIT>\" <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : BASE_DIR / \"<STR_LIT>\" , <EOL> } <EOL> } <EOL> ", "gt": "AUTH_PASSWORD_VALIDATORS = ["}
{"input": "from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> ", "gt": "field = models . BooleanField ( default = False ) ,"}
{"input": "import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( \"<STR_LIT>\" ) <EOL> RICH_SUCCESS_MARKER = \"<STR_LIT>\" <EOL> RICH_ERROR_MARKER = \"<STR_LIT>\" <EOL> RICH_INFO_MARKER = \"<STR_LIT>\" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( \"<STR_LIT>\" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> else : <EOL> arguments_list . append ( f\"<STR_LIT>\" ) <EOL> arguments = \"<STR_LIT>\" . join ( arguments_list ) <EOL> func_call = f\"<STR_LIT>\" <EOL> code = f\"<STR_LIT>\" <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise ShellCodeError ( result . stderr ) <EOL> return ast . literal_eval ( result . stdout ) if eval_result else result . stdout . strip ( ) <EOL> def is_new_falco_cli_available ( ) -> bool : <EOL> ", "gt": "try :"}
{"input": "import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( \"<STR_LIT>\" ) : <EOL> result = subprocess . run ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> ", "gt": "RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name )"}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> f\"<STR_LIT>\" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert \"<STR_LIT>\" in config_keys <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> ", "gt": "runner . invoke ("}
{"input": "from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> assert Path ( \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" , str ( output . resolve ( ) ) ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> def test_install_crud_utils_to_existing_config ( runner : CommandRunner , pyproject_toml ) : <EOL> pyproject_toml = Path ( \"<STR_LIT>\" ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , crud = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> output = Path ( \"<STR_LIT>\" ) <EOL> runner . invoke ( \"<STR_LIT>\" ) <EOL> assert ( output / \"<STR_LIT>\" ) . exists ( ) <EOL> ", "gt": "assert ( output / \"<STR_LIT>\" ) . exists ( )"}
{"input": "from pathlib import Path <EOL> root_dir = Path ( __file__ ) . parent . parent <EOL> readme = root_dir / \"<STR_LIT>\" <EOL> guides = root_dir / \"<STR_LIT>\" <EOL> guides_index = guides / \"<STR_LIT>\" <EOL> def get_rst_doc_title ( file : Path ) : <EOL> title = \"<STR_LIT>\" <EOL> for line in file . read_text ( ) . splitlines ( ) : <EOL> if line . startswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> title = line <EOL> return title <EOL> def guides_files ( ) : <EOL> index_content = guides_index . read_text ( ) <EOL> toc_tree_directive = \"<STR_LIT>\" <EOL> start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) <EOL> def valid_line ( line ) : <EOL> return bool ( line ) and not line . strip ( ) . startswith ( \"<STR_LIT>\" ) <EOL> lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( \"<STR_LIT>\" ) if valid_line ( line ) ] <EOL> return [ guides / f\"<STR_LIT>\" for line in lines ] <EOL> def get_guides_list ( ) : <EOL> guides_md = [ ] <EOL> for file in guides_files ( ) : <EOL> if file . name . startswith ( \"<STR_LIT>\" ) : <EOL> continue <EOL> link = f\"<STR_LIT>\" <EOL> title = get_rst_doc_title ( file ) <EOL> guides_md . append ( f\"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" + \"<STR_LIT>\" . join ( guides_md ) + \"<STR_LIT>\" <EOL> def update_readme ( start_comment , end_comment , new_content ) : <EOL> text = readme . read_text ( ) <EOL> start_index = text . find ( start_comment ) + len ( start_comment ) <EOL> end_index = text . find ( end_comment ) <EOL> new_content = text [ : start_index ] + new_content + text [ end_index : ] <EOL> readme . write_text ( new_content ) <EOL> ", "gt": "def main ( ) :"}
