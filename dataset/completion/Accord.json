{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } )", "gt": "@ Retention ( RetentionPolicy . SOURCE ) private @ interface State {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } )", "gt": "@ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } )", "gt": "@ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth", "gt": "= Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth", "gt": "= Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight", "gt": "= Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator", "gt": ". addUpdateListener ( new AnimatorUpdater ( ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void", "gt": "setState ( @ State int state ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case", "gt": "ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator", "gt": ". setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case", "gt": "ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator", "gt": ". setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView", "gt": ". postDelayed ( mHideRunnable , delay ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int", "gt": "top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas", "gt": ". translate ( mVerticalThumbWidth , top ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas", "gt": ". scale ( - <NUM_LIT> , <NUM_LIT> ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas", "gt": ". scale ( - <NUM_LIT> , <NUM_LIT> ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas", "gt": ". translate ( - mVerticalThumbWidth , - top ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas", "gt": ". translate ( left , <NUM_LIT> ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas", "gt": ". translate ( - left , - top ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas", "gt": ". translate ( <NUM_LIT> , top ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas", "gt": ". translate ( left , <NUM_LIT> ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas", "gt": ". translate ( - left , - top ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void", "gt": "updateScrollPosition ( int offsetX , int offsetY ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int", "gt": "verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int", "gt": "horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float", "gt": "middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY", "gt": "= ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if", "gt": "( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if", "gt": "( me . getAction ( ) == MotionEvent . ACTION_DOWN ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean", "gt": "insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else", "gt": "if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo", "gt": "( me . getX ( ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo", "gt": "( me . getY ( ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int", "gt": "scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView", "gt": ". scrollBy ( <NUM_LIT> , scrollingBy ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ; if ( Math . abs ( mHorizontalThumbCenterX - x ) < <NUM_LIT> ) { return ; } int", "gt": "scrollingBy = scrollTo ( mHorizontalDragX , x , scrollbarRange , mRecyclerView . computeHorizontalScrollRange ( ) , mRecyclerView . computeHorizontalScrollOffset ( ) , mRecyclerViewWidth ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ; if ( Math . abs ( mHorizontalThumbCenterX - x ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mHorizontalDragX , x , scrollbarRange , mRecyclerView . computeHorizontalScrollRange ( ) , mRecyclerView . computeHorizontalScrollOffset ( ) , mRecyclerViewWidth ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView", "gt": ". scrollBy ( scrollingBy , <NUM_LIT> ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ; if ( Math . abs ( mHorizontalThumbCenterX - x ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mHorizontalDragX , x , scrollbarRange , mRecyclerView . computeHorizontalScrollRange ( ) , mRecyclerView . computeHorizontalScrollOffset ( ) , mRecyclerViewWidth ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( scrollingBy , <NUM_LIT> ) ; } mHorizontalDragX = x ; } private int scrollTo ( float oldDragPos , float newDragPos , int [ ] scrollbarRange , int scrollRange , int scrollOffset , int viewLength ) { int", "gt": "scrollbarLength = scrollbarRange [ <NUM_LIT> ] - scrollbarRange [ <NUM_LIT> ] ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ; if ( Math . abs ( mHorizontalThumbCenterX - x ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mHorizontalDragX , x , scrollbarRange , mRecyclerView . computeHorizontalScrollRange ( ) , mRecyclerView . computeHorizontalScrollOffset ( ) , mRecyclerViewWidth ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( scrollingBy , <NUM_LIT> ) ; } mHorizontalDragX = x ; } private int scrollTo ( float oldDragPos , float newDragPos , int [ ] scrollbarRange , int scrollRange , int scrollOffset , int viewLength ) { int scrollbarLength = scrollbarRange [ <NUM_LIT> ] - scrollbarRange [ <NUM_LIT> ] ; if ( scrollbarLength == <NUM_LIT> ) { return <NUM_LIT> ; } float", "gt": "percentage = ( ( newDragPos - oldDragPos ) / ( float ) scrollbarLength ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ; if ( Math . abs ( mHorizontalThumbCenterX - x ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mHorizontalDragX , x , scrollbarRange , mRecyclerView . computeHorizontalScrollRange ( ) , mRecyclerView . computeHorizontalScrollOffset ( ) , mRecyclerViewWidth ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( scrollingBy , <NUM_LIT> ) ; } mHorizontalDragX = x ; } private int scrollTo ( float oldDragPos , float newDragPos , int [ ] scrollbarRange , int scrollRange , int scrollOffset , int viewLength ) { int scrollbarLength = scrollbarRange [ <NUM_LIT> ] - scrollbarRange [ <NUM_LIT> ] ; if ( scrollbarLength == <NUM_LIT> ) { return <NUM_LIT> ; } float percentage = ( ( newDragPos - oldDragPos ) / ( float ) scrollbarLength ) ; int totalPossibleOffset = scrollRange - viewLength ; int", "gt": "scrollingBy = ( int ) ( percentage * totalPossibleOffset ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ; if ( Math . abs ( mHorizontalThumbCenterX - x ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mHorizontalDragX , x , scrollbarRange , mRecyclerView . computeHorizontalScrollRange ( ) , mRecyclerView . computeHorizontalScrollOffset ( ) , mRecyclerViewWidth ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( scrollingBy , <NUM_LIT> ) ; } mHorizontalDragX = x ; } private int scrollTo ( float oldDragPos , float newDragPos , int [ ] scrollbarRange , int scrollRange , int scrollOffset , int viewLength ) { int scrollbarLength = scrollbarRange [ <NUM_LIT> ] - scrollbarRange [ <NUM_LIT> ] ; if ( scrollbarLength == <NUM_LIT> ) { return <NUM_LIT> ; } float percentage = ( ( newDragPos - oldDragPos ) / ( float ) scrollbarLength ) ; int totalPossibleOffset = scrollRange - viewLength ; int scrollingBy = ( int ) ( percentage * totalPossibleOffset ) ; int absoluteOffset = scrollOffset + scrollingBy ; if", "gt": "( absoluteOffset < totalPossibleOffset && absoluteOffset >= <NUM_LIT> ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static", "gt": "final int GT = <NUM_LIT> << <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static", "gt": "final int EQ = <NUM_LIT> << <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static", "gt": "final int LT = <NUM_LIT> << <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static", "gt": "final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static", "gt": "final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static", "gt": "final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static", "gt": "final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static", "gt": "final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static", "gt": "final int MASK = GT | EQ | LT ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } )", "gt": "@ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int", "gt": "mRvStart , mRvEnd , mChildStart , mChildEnd ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void", "gt": "addFlags ( @ ViewBounds int flags ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if", "gt": "( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if", "gt": "( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if", "gt": "( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if", "gt": "( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if", "gt": "( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if", "gt": "( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final", "gt": "int start = mCallback . getParentStart ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final", "gt": "int end = mCallback . getParentEnd ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final int end = mCallback . getParentEnd ( ) ; final", "gt": "int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final int end = mCallback . getParentEnd ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ; View acceptableMatch = null ; for ( int i = fromIndex ; i != toIndex ; i += next ) { final", "gt": "View child = mCallback . getChildAt ( i ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final int end = mCallback . getParentEnd ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ; View acceptableMatch = null ; for ( int i = fromIndex ; i != toIndex ; i += next ) { final View child = mCallback . getChildAt ( i ) ; final int childStart = mCallback . getChildStart ( child ) ; final", "gt": "int childEnd = mCallback . getChildEnd ( child ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final int end = mCallback . getParentEnd ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ; View acceptableMatch = null ; for ( int i = fromIndex ; i != toIndex ; i += next ) { final View child = mCallback . getChildAt ( i ) ; final int childStart = mCallback . getChildStart ( child ) ; final int childEnd = mCallback . getChildEnd ( child ) ; mBoundFlags", "gt": ". setBounds ( start , end , childStart , childEnd ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final int end = mCallback . getParentEnd ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ; View acceptableMatch = null ; for ( int i = fromIndex ; i != toIndex ; i += next ) { final View child = mCallback . getChildAt ( i ) ; final int childStart = mCallback . getChildStart ( child ) ; final int childEnd = mCallback . getChildEnd ( child ) ; mBoundFlags . setBounds ( start , end , childStart , childEnd ) ; if ( preferredBoundFlags != <NUM_LIT> ) { mBoundFlags . resetFlags ( ) ; mBoundFlags . addFlags ( preferredBoundFlags ) ; if", "gt": "( mBoundFlags . boundsMatch ( ) ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final int end = mCallback . getParentEnd ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ; View acceptableMatch = null ; for ( int i = fromIndex ; i != toIndex ; i += next ) { final View child = mCallback . getChildAt ( i ) ; final int childStart = mCallback . getChildStart ( child ) ; final int childEnd = mCallback . getChildEnd ( child ) ; mBoundFlags . setBounds ( start , end , childStart , childEnd ) ; if ( preferredBoundFlags != <NUM_LIT> ) { mBoundFlags . resetFlags ( ) ; mBoundFlags . addFlags ( preferredBoundFlags ) ; if ( mBoundFlags . boundsMatch ( ) ) { return child ; } } if ( acceptableBoundFlags != <NUM_LIT> ) { mBoundFlags . resetFlags ( ) ; mBoundFlags . addFlags ( acceptableBoundFlags ) ; if ( mBoundFlags . boundsMatch ( ) ) { acceptableMatch = child ; } } } return acceptableMatch ; } boolean", "gt": "isViewWithinBoundFlags ( View child , @ ViewBounds int boundsFlags ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding", "gt": ". set ( left , top , right , bottom ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context", "gt": "context = mView . getContext ( ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context context = mView . getContext ( ) ; mTrackDrawable", "gt": "= Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_track , android . R . attr . colorControlNormal , context ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . DEFAULT ; return this ; } @ NonNull public FastScrollerBuilder useMd2Style ( ) { Context", "gt": "context = mView . getContext ( ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . DEFAULT ; return this ; } @ NonNull public FastScrollerBuilder useMd2Style ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable", "gt": "= Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_thumb , android . R . attr . colorControlActivated , context ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . DEFAULT ; return this ; } @ NonNull public FastScrollerBuilder useMd2Style ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . MD2 ; return this ; } public void setAnimationHelper ( @ Nullable FastScroller . AnimationHelper animationHelper ) { mAnimationHelper = animationHelper ; } public void disableScrollbarAutoHide ( ) { DefaultAnimationHelper", "gt": "animationHelper = new DefaultAnimationHelper ( mView ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . DEFAULT ; return this ; } @ NonNull public FastScrollerBuilder useMd2Style ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . MD2 ; return this ; } public void setAnimationHelper ( @ Nullable FastScroller . AnimationHelper animationHelper ) { mAnimationHelper = animationHelper ; } public void disableScrollbarAutoHide ( ) { DefaultAnimationHelper animationHelper = new DefaultAnimationHelper ( mView ) ; animationHelper . setScrollbarAutoHideEnabled ( false ) ; mAnimationHelper = animationHelper ; } @ NonNull public FastScroller build ( ) { return", "gt": "new FastScroller ( mView , getOrCreateViewHelper ( ) , mPadding , mTrackDrawable , mThumbDrawable , mPopupStyle , getOrCreateAnimationHelper ( ) ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . DEFAULT ; return this ; } @ NonNull public FastScrollerBuilder useMd2Style ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . MD2 ; return this ; } public void setAnimationHelper ( @ Nullable FastScroller . AnimationHelper animationHelper ) { mAnimationHelper = animationHelper ; } public void disableScrollbarAutoHide ( ) { DefaultAnimationHelper animationHelper = new DefaultAnimationHelper ( mView ) ; animationHelper . setScrollbarAutoHideEnabled ( false ) ; mAnimationHelper = animationHelper ; } @ NonNull public FastScroller build ( ) { return new FastScroller ( mView , getOrCreateViewHelper ( ) , mPadding , mTrackDrawable , mThumbDrawable , mPopupStyle , getOrCreateAnimationHelper ( ) ) ; } @ NonNull private FastScroller . ViewHelper getOrCreateViewHelper ( ) { if ( mViewHelper != null ) { return mViewHelper ; } if ( mView instanceof ViewHelperProvider ) { return ( ( ViewHelperProvider ) mView ) . getViewHelper ( ) ; } else if ( mView instanceof RecyclerView ) { return new RecyclerViewHelper ( ( RecyclerView ) mView , mPopupTextProvider ) ; } else", "gt": "if ( mView instanceof NestedScrollView ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . DEFAULT ; return this ; } @ NonNull public FastScrollerBuilder useMd2Style ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . MD2 ; return this ; } public void setAnimationHelper ( @ Nullable FastScroller . AnimationHelper animationHelper ) { mAnimationHelper = animationHelper ; } public void disableScrollbarAutoHide ( ) { DefaultAnimationHelper animationHelper = new DefaultAnimationHelper ( mView ) ; animationHelper . setScrollbarAutoHideEnabled ( false ) ; mAnimationHelper = animationHelper ; } @ NonNull public FastScroller build ( ) { return new FastScroller ( mView , getOrCreateViewHelper ( ) , mPadding , mTrackDrawable , mThumbDrawable , mPopupStyle , getOrCreateAnimationHelper ( ) ) ; } @ NonNull private FastScroller . ViewHelper getOrCreateViewHelper ( ) { if ( mViewHelper != null ) { return mViewHelper ; } if ( mView instanceof ViewHelperProvider ) { return ( ( ViewHelperProvider ) mView ) . getViewHelper ( ) ; } else if ( mView instanceof RecyclerView ) { return new RecyclerViewHelper ( ( RecyclerView ) mView , mPopupTextProvider ) ; } else if ( mView instanceof NestedScrollView ) { throw", "gt": "new UnsupportedOperationException ( \"<STR_LIT>\" + FastScrollNestedScrollView . class . getSimpleName ( ) + \"<STR_LIT>\" + NestedScrollView . class . getSimpleName ( ) + \"<STR_LIT>\" ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . DEFAULT ; return this ; } @ NonNull public FastScrollerBuilder useMd2Style ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . MD2 ; return this ; } public void setAnimationHelper ( @ Nullable FastScroller . AnimationHelper animationHelper ) { mAnimationHelper = animationHelper ; } public void disableScrollbarAutoHide ( ) { DefaultAnimationHelper animationHelper = new DefaultAnimationHelper ( mView ) ; animationHelper . setScrollbarAutoHideEnabled ( false ) ; mAnimationHelper = animationHelper ; } @ NonNull public FastScroller build ( ) { return new FastScroller ( mView , getOrCreateViewHelper ( ) , mPadding , mTrackDrawable , mThumbDrawable , mPopupStyle , getOrCreateAnimationHelper ( ) ) ; } @ NonNull private FastScroller . ViewHelper getOrCreateViewHelper ( ) { if ( mViewHelper != null ) { return mViewHelper ; } if ( mView instanceof ViewHelperProvider ) { return ( ( ViewHelperProvider ) mView ) . getViewHelper ( ) ; } else if ( mView instanceof RecyclerView ) { return new RecyclerViewHelper ( ( RecyclerView ) mView , mPopupTextProvider ) ; } else if ( mView instanceof NestedScrollView ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + FastScrollNestedScrollView . class . getSimpleName ( ) + \"<STR_LIT>\" + NestedScrollView . class . getSimpleName ( ) + \"<STR_LIT>\" ) ; } else if ( mView instanceof ScrollView ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + FastScrollScrollView . class . getSimpleName ( ) + \"<STR_LIT>\" + ScrollView . class . getSimpleName ( ) + \"<STR_LIT>\" ) ; } else if ( mView instanceof WebView ) { throw", "gt": "new UnsupportedOperationException ( \"<STR_LIT>\" + FastScrollWebView . class . getSimpleName ( ) + \"<STR_LIT>\" + WebView . class . getSimpleName ( ) + \"<STR_LIT>\" ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if", "gt": "( itemDelegate != null && itemDelegate instanceof ItemDelegate ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate", "gt": "= new ItemDelegate ( this ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return", "gt": "mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView", "gt": ". getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if", "gt": "( host instanceof RecyclerView && ! shouldIgnore ( ) ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView", "gt": "rv = ( RecyclerView ) host ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if", "gt": "( rv . getLayoutManager ( ) != null ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates", "gt": ". put ( itemView , delegate ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return", "gt": "mOriginalItemDelegates . remove ( itemView ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super", "gt": ". onInitializeAccessibilityNodeInfo ( host , info ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else", "gt": "if ( super . performAccessibilityAction ( host , action , args ) ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return", "gt": "mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat", "gt": "originalDelegate = mOriginalItemDelegates . get ( host ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate", "gt": ". sendAccessibilityEvent ( host , eventType ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super", "gt": ". sendAccessibilityEvent ( host , eventType ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat", "gt": "originalDelegate = mOriginalItemDelegates . get ( host ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super", "gt": ". sendAccessibilityEventUnchecked ( host , event ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return", "gt": "originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return", "gt": "super . dispatchPopulateAccessibilityEvent ( host , event ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return super . dispatchPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate", "gt": ". onPopulateAccessibilityEvent ( host , event ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return super . dispatchPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onPopulateAccessibilityEvent ( host , event ) ; } else { super . onPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat", "gt": "originalDelegate = mOriginalItemDelegates . get ( host ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return super . dispatchPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onPopulateAccessibilityEvent ( host , event ) ; } else { super . onPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityEvent ( host , event ) ; } else { super", "gt": ". onInitializeAccessibilityEvent ( host , event ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return super . dispatchPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onPopulateAccessibilityEvent ( host , event ) ; } else { super . onPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityEvent ( host , event ) ; } else { super . onInitializeAccessibilityEvent ( host , event ) ; } } @ Override public boolean onRequestSendAccessibilityEvent ( @ NonNull ViewGroup host , @ NonNull View child , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . onRequestSendAccessibilityEvent ( host , child , event ) ; } else { return", "gt": "super . onRequestSendAccessibilityEvent ( host , child , event ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return super . dispatchPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onPopulateAccessibilityEvent ( host , event ) ; } else { super . onPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityEvent ( host , event ) ; } else { super . onInitializeAccessibilityEvent ( host , event ) ; } } @ Override public boolean onRequestSendAccessibilityEvent ( @ NonNull ViewGroup host , @ NonNull View child , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . onRequestSendAccessibilityEvent ( host , child , event ) ; } else { return super . onRequestSendAccessibilityEvent ( host , child , event ) ; } } @ Override @ Nullable public AccessibilityNodeProviderCompat getAccessibilityNodeProvider ( @ NonNull View host ) { AccessibilityDelegateCompat", "gt": "originalDelegate = mOriginalItemDelegates . get ( host ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return super . dispatchPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onPopulateAccessibilityEvent ( host , event ) ; } else { super . onPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityEvent ( host , event ) ; } else { super . onInitializeAccessibilityEvent ( host , event ) ; } } @ Override public boolean onRequestSendAccessibilityEvent ( @ NonNull ViewGroup host , @ NonNull View child , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . onRequestSendAccessibilityEvent ( host , child , event ) ; } else { return super . onRequestSendAccessibilityEvent ( host , child , event ) ; } } @ Override @ Nullable public AccessibilityNodeProviderCompat getAccessibilityNodeProvider ( @ NonNull View host ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . getAccessibilityNodeProvider ( host ) ; } else { return", "gt": "super . getAccessibilityNodeProvider ( host ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . appcompat . graphics . drawable . DrawableWrapperCompat ; import androidx . core . graphics . drawable . DrawableCompat ; @ SuppressLint ( \"<STR_LIT>\" ) class AutoMirrorDrawable extends DrawableWrapperCompat { public AutoMirrorDrawable ( @ NonNull Drawable drawable ) { super ( drawable ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { if ( needMirroring ( ) ) { float centerX = getBounds ( ) . exactCenterX ( ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> , centerX , <NUM_LIT> ) ; super . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> , centerX , <NUM_LIT> ) ; } else { super . draw ( canvas ) ; } } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { super . onLayoutDirectionChanged ( layoutDirection ) ; return true ; } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return", "gt": "DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ;"}
