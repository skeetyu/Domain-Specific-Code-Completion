{"input": "import javax . net . ssl . SSLSocket ; import javax . net . ssl . SSLSession ; import java . io . IOException ; import java . net . InetSocketAddress ; public class SSLSocketExample { public static void main ( String [ ] args ) throws IOException { SSLSocket sslSocket = createSSLSocket ( \"<STR_LIT>\" , <NUM_LIT> ) ; SSLSession sslSession = sslSocket . getSession ( ) ; String hostname = sslSession . getPeerHost ( ) ; sslSocket . close ( ) ; } private static SSLSocket createSSLSocket ( String host , int port ) throws IOException { SSLSocket", "gt": "sslSocket = ( SSLSocket ) SSLSocketFactory . getDefault ( ) . createSocket ( ) ;", "repo": "semgrep-rules-android-security"}
{"input": "public class MainActivity extends Activity { @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Context context = getApplicationContext ( ) ; Toast . makeText ( this , message , Toast . LENGTH_LONG ) . show ( ) ; Toast", "gt": ". makeText ( context , message , Toast . LENGTH_LONG ) . show ( ) ;", "repo": "semgrep-rules-android-security"}
{"input": "public class BroadcastReceiverLeakActivity extends AppCompatActivity { private BroadcastReceiver broadcastReceiver ; private void registerBroadCastReceiver ( ) { broadcastReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { } } ; registerReceiver ( broadcastReceiver , new IntentFilter ( \"<STR_LIT>\" ) ) ; } @ Override protected void onStart ( ) { super . onStart ( ) ; registerBroadCastReceiver ( ) ; } @ Override protected void onStop ( ) { super . onStop ( ) ; if ( broadcastReceiver != null ) { } } } public class BroadcastReceiverLeakActivity2 extends AppCompatActivity { private BroadcastReceiver broadcastReceiver ; private void registerBroadCastReceiver ( ) { broadcastReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { } } ; registerReceiver", "gt": "( broadcastReceiver , new IntentFilter ( \"<STR_LIT>\" ) ) ;", "repo": "semgrep-rules-android-security"}
{"input": "import javax . net . ssl . SSLSocket ; import javax . net . ssl . SSLSession ; import java . io . IOException ; import java . net . InetSocketAddress ; public class SSLSocketExample { public static void main ( String [ ] args ) throws IOException { SSLSocket sslSocket = createSSLSocket ( \"<STR_LIT>\" , <NUM_LIT> ) ; SSLSession sslSession = sslSocket . getSession ( ) ; String hostname = sslSession . getPeerHost ( ) ; sslSocket . close ( ) ; } private static SSLSocket createSSLSocket ( String host , int port ) throws IOException { SSLSocket sslSocket = ( SSLSocket ) SSLSocketFactory . getDefault ( ) . createSocket ( ) ; sslSocket", "gt": ". connect ( new InetSocketAddress ( host , port ) ) ;", "repo": "semgrep-rules-android-security"}
{"input": "public class MainActivity extends Activity { @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Context context = getApplicationContext ( ) ; Toast", "gt": ". makeText ( this , message , Toast . LENGTH_LONG ) . show ( ) ;", "repo": "semgrep-rules-android-security"}
{"input": "import javax . net . ssl . SSLSocket ; import javax . net . ssl . SSLSession ; import java . io . IOException ; import java . net . InetSocketAddress ; public class SSLSocketExample { public static void main ( String [ ] args ) throws IOException { SSLSocket sslSocket = createSSLSocket ( \"<STR_LIT>\" , <NUM_LIT> ) ; SSLSession sslSession = sslSocket . getSession ( ) ; String", "gt": "hostname = sslSession . getPeerHost ( ) ;", "repo": "semgrep-rules-android-security"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . changelogs ) , getString ( R . string . des_changelogs ) , R . drawable . ic_changelog ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . report ) , getString ( R . string . des_report ) , R . drawable . ic_report ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . feature_request ) , getString ( R . string . des_feature_request ) , R . drawable . ic_feature ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . github ) , getString ( R . string . des_github ) , R . drawable . ic_github ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . telegram_channel ) , getString ( R . string . des_telegram_channel ) , R . drawable . ic_telegram ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . license ) , getString ( R . string . des_license ) , R . drawable . ic_license ) ) ; adapter = new AboutAdapter ( items , this ) ; adapter . setAdapterListener ( this ) ; recyclerView . setAdapter ( adapter ) ; } @ Override public void onCheckUpdate ( ) { new FetchLatestVersionCode ( this , this ) . execute ( Preferences . buildGradleUrl ) ; } @ Override public void onResult ( int result ) { switch ( result ) { case Preferences . UPDATE_AVAILABLE : Utils . showBottomSheetUpdate ( this ) ; break ; case", "gt": "Preferences . UPDATE_NOT_AVAILABLE : Toast . makeText ( this , getString ( R . string . already_latest_version ) , Toast . LENGTH_SHORT ) . show ( ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout", "gt": "= findViewById ( R . id . appBarLayout ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items", "gt": ". add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items", "gt": ". add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . changelogs ) , getString ( R . string . des_changelogs ) , R . drawable . ic_changelog ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . report ) , getString ( R . string . des_report ) , R . drawable . ic_report ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . feature_request ) , getString ( R . string . des_feature_request ) , R . drawable . ic_feature ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . github ) , getString ( R . string . des_github ) , R . drawable . ic_github ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . telegram_channel ) , getString ( R . string . des_telegram_channel ) , R . drawable . ic_telegram ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . license ) , getString ( R . string . des_license ) , R . drawable . ic_license ) ) ; adapter", "gt": "= new AboutAdapter ( items , this ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . changelogs ) , getString ( R . string . des_changelogs ) , R . drawable . ic_changelog ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . report ) , getString ( R . string . des_report ) , R . drawable . ic_report ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . feature_request ) , getString ( R . string . des_feature_request ) , R . drawable . ic_feature ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . github ) , getString ( R . string . des_github ) , R . drawable . ic_github ) ) ; items", "gt": ". add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . telegram_channel ) , getString ( R . string . des_telegram_channel ) , R . drawable . ic_telegram ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items", "gt": ". add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items", "gt": ". add ( new Category ( getString ( R . string . app ) ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items", "gt": ". add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView", "gt": ". setLayoutManager ( new LinearLayoutManager ( this ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items", "gt": ". add ( new Category ( getString ( R . string . contributors ) ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . changelogs ) , getString ( R . string . des_changelogs ) , R . drawable . ic_changelog ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . report ) , getString ( R . string . des_report ) , R . drawable . ic_report ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . feature_request ) , getString ( R . string . des_feature_request ) , R . drawable . ic_feature ) ) ; items", "gt": ". add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . github ) , getString ( R . string . des_github ) , R . drawable . ic_github ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel", "gt": "= new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView", "gt": ". setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo", "gt": "pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView", "gt": "imageView = findViewById ( R . id . arrow_back ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . changelogs ) , getString ( R . string . des_changelogs ) , R . drawable . ic_changelog ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . report ) , getString ( R . string . des_report ) , R . drawable . ic_report ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . feature_request ) , getString ( R . string . des_feature_request ) , R . drawable . ic_feature ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . github ) , getString ( R . string . des_github ) , R . drawable . ic_github ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . telegram_channel ) , getString ( R . string . des_telegram_channel ) , R . drawable . ic_telegram ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . license ) , getString ( R . string . des_license ) , R . drawable . ic_license ) ) ; adapter = new AboutAdapter ( items , this ) ; adapter . setAdapterListener ( this ) ; recyclerView . setAdapter ( adapter ) ; } @ Override public void onCheckUpdate ( ) { new", "gt": "FetchLatestVersionCode ( this , this ) . execute ( Preferences . buildGradleUrl ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items", "gt": ". add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items", "gt": ". add ( new Category ( getString ( R . string . lead_developer ) ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . changelogs ) , getString ( R . string . des_changelogs ) , R . drawable . ic_changelog ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . report ) , getString ( R . string . des_report ) , R . drawable . ic_report ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . feature_request ) , getString ( R . string . des_feature_request ) , R . drawable . ic_feature ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . github ) , getString ( R . string . des_github ) , R . drawable . ic_github ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . telegram_channel ) , getString ( R . string . des_telegram_channel ) , R . drawable . ic_telegram ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . license ) , getString ( R . string . des_license ) , R . drawable . ic_license ) ) ; adapter = new AboutAdapter ( items , this ) ; adapter . setAdapterListener ( this ) ; recyclerView . setAdapter ( adapter ) ; } @ Override public void onCheckUpdate ( ) { new FetchLatestVersionCode ( this , this ) . execute ( Preferences . buildGradleUrl ) ; } @ Override public void onResult ( int result ) { switch ( result ) { case", "gt": "Preferences . UPDATE_AVAILABLE : Utils . showBottomSheetUpdate ( this ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items", "gt": ". add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items", "gt": ". add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . changelogs ) , getString ( R . string . des_changelogs ) , R . drawable . ic_changelog ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . report ) , getString ( R . string . des_report ) , R . drawable . ic_report ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . feature_request ) , getString ( R . string . des_feature_request ) , R . drawable . ic_feature ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . github ) , getString ( R . string . des_github ) , R . drawable . ic_github ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . telegram_channel ) , getString ( R . string . des_telegram_channel ) , R . drawable . ic_telegram ) ) ; items", "gt": ". add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . license ) , getString ( R . string . des_license ) , R . drawable . ic_license ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } items", "gt": ". add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . changelogs ) , getString ( R . string . des_changelogs ) , R . drawable . ic_changelog ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items", "gt": ". add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items", "gt": ". add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . changelogs ) , getString ( R . string . des_changelogs ) , R . drawable . ic_changelog ) ) ; items", "gt": ". add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . report ) , getString ( R . string . des_report ) , R . drawable . ic_report ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items", "gt": "= new ArrayList < > ( ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView", "gt": "= findViewById ( R . id . about_list ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items", "gt": ". add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . changelogs ) , getString ( R . string . des_changelogs ) , R . drawable . ic_changelog ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . report ) , getString ( R . string . des_report ) , R . drawable . ic_report ) ) ; items", "gt": ". add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . feature_request ) , getString ( R . string . des_feature_request ) , R . drawable . ic_feature ) ) ;", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch", "gt": "( PackageManager . NameNotFoundException ignored ) {", "repo": "aShellYou"}
{"input": "package in . hridayan . ashell . activities ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . AboutViewModel ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . adapters . AboutAdapter ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class AboutActivity extends AppCompatActivity implements AboutAdapter . AdapterListener , FetchLatestVersionCodeCallback { private RecyclerView recyclerView ; private AboutAdapter adapter ; private List < Object > items ; private AppBarLayout appBarLayout ; private AboutViewModel viewModel ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerView ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( AboutViewModel . class ) ; recyclerView = findViewById ( R . id . about_list ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; items = new ArrayList < > ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; items . add ( new Category ( getString ( R . string . lead_developer ) ) ) ; items . add ( new Category . LeadDeveloperItem ( \"<STR_LIT>\" , getString ( R . string . hridayan_about ) , R . mipmap . dp_hridayan ) ) ; items . add ( new Category ( getString ( R . string . contributors ) ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . krishna_about ) , R . mipmap . dp_krishna ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . rikka_about ) , R . mipmap . dp_shizuku ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . sunilpaulmathew_about ) , R . mipmap . dp_sunilpaulmathew ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . khun_htetz_about ) , R . mipmap . dp_adb_otg ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . drDisagree_about ) , R . mipmap . dp_drdisagree ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . marciozomb13_about ) , R . mipmap . dp_marciozomb13 ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . weiguangtwk_about ) , R . mipmap . dp_weiguangtwk ) ) ; items . add ( new Category . ContributorsItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , getString ( R . string . winzort_about ) , R . mipmap . dp_winzort ) ) ; items . add ( new Category ( getString ( R . string . app ) ) ) ; try { PackageInfo pInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <NUM_LIT> ) ; String version = pInfo . versionName ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . version ) , version , R . drawable . ic_version_tag ) ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . changelogs ) , getString ( R . string . des_changelogs ) , R . drawable . ic_changelog ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . report ) , getString ( R . string . des_report ) , R . drawable . ic_report ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . feature_request ) , getString ( R . string . des_feature_request ) , R . drawable . ic_feature ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . github ) , getString ( R . string . des_github ) , R . drawable . ic_github ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . telegram_channel ) , getString ( R . string . des_telegram_channel ) , R . drawable . ic_telegram ) ) ; items . add ( new Category . AppItem ( \"<STR_LIT>\" , getString ( R . string . license ) , getString ( R . string . des_license ) , R . drawable . ic_license ) ) ; adapter = new AboutAdapter ( items , this ) ; adapter . setAdapterListener ( this ) ; recyclerView . setAdapter ( adapter ) ; } @ Override public void onCheckUpdate ( ) { new FetchLatestVersionCode ( this , this ) . execute ( Preferences . buildGradleUrl ) ; } @ Override public void onResult ( int result ) { switch ( result ) { case Preferences . UPDATE_AVAILABLE : Utils . showBottomSheetUpdate ( this ) ; break ; case Preferences . UPDATE_NOT_AVAILABLE : Toast . makeText ( this , getString ( R . string . already_latest_version ) , Toast . LENGTH_SHORT ) . show ( ) ; break ; case", "gt": "Preferences . CONNECTION_ERROR : Toast . makeText ( this , getString ( R . string . check_internet ) , Toast . LENGTH_SHORT ) . show ( ) ;", "repo": "aShellYou"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult result = implementation . getMaxZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openSettings ( PluginCall call ) { try { implementation . openSettings ( call ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isGoogleBarcodeScannerModuleAvailable ( PluginCall call ) { try { implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , isAvailable ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult result = implementation . getMaxZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openSettings ( PluginCall call ) { try { implementation . openSettings ( call ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isGoogleBarcodeScannerModuleAvailable ( PluginCall call ) { try { implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , isAvailable ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void installGoogleBarcodeScannerModule ( PluginCall call ) { try { implementation . installGoogleBarcodeScannerModule ( new InstallGoogleBarcodeScannerModuleResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ Override @ PluginMethod public void requestPermissions ( PluginCall call ) { if ( isPermissionDeclared ( CAMERA ) ) { super . requestPermissions ( call ) ; } else { checkPermissions ( call ) ; } } public void requestPermissionForAlias ( @ NonNull String alias , @ NonNull PluginCall call , @ NonNull String callbackName ) { super . requestPermissionForAlias ( alias , call , callbackName ) ; } @ ActivityCallback public void openSettingsResult ( PluginCall call , ActivityResult result ) { try { if ( call == null ) { Logger . debug ( \"<STR_LIT>\" ) ; return ; } call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PermissionCallback private void cameraPermissionsCallback ( PluginCall call ) { if ( call . getMethodName ( ) . equals ( \"<STR_LIT>\" ) ) { startScan ( call ) ; } } public void notifyBarcodeScannedListener ( Barcode barcode , Point imageSize ) { try { Point screenSize = this . getScreenSize ( ) ; JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , imageSize , screenSize ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResult ) ; notifyListeners ( BARCODE_SCANNED_EVENT , result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } public void notifyScanErrorListener ( String message ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , message ) ; notifyListeners ( SCAN_ERROR_EVENT , result ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult result = implementation . getMaxZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openSettings ( PluginCall call ) { try { implementation . openSettings ( call ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : connectedPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; triangleResult . put ( faceMeshPointResult ) ; } if ( triangleResult . length ( ) > <NUM_LIT> ) { trianglesResult . put ( triangleResult ) ; } } if ( trianglesResult . length ( ) > <NUM_LIT> ) { result", "gt": ". put ( \"<STR_LIT>\" , trianglesResult ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult", "gt": "result = implementation . getMaxZoomRatio ( ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List", "gt": "< Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call", "gt": ". resolve ( result . toJSObject ( ) ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for", "gt": "( FaceMeshPoint faceMeshPoint : connectedPoints ) {", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : connectedPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; triangleResult . put ( faceMeshPointResult ) ; } if ( triangleResult . length ( ) > <NUM_LIT> ) { trianglesResult . put ( triangleResult ) ; } } if ( trianglesResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , trianglesResult ) ; } return result ; } private JSObject createBoundsResult ( Rect boundingBox ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , boundingBox . left ) ; result . put ( \"<STR_LIT>\" , boundingBox . top ) ; result . put ( \"<STR_LIT>\" , boundingBox . right ) ; result . put ( \"<STR_LIT>\" , boundingBox . bottom ) ; return result ; } private JSObject createFaceMeshPointResult ( int index , PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , index ) ; result . put ( \"<STR_LIT>\" , createPointResult ( point ) ) ; return result ; } private JSObject createPointResult ( PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , point . getX ( ) ) ; result . put ( \"<STR_LIT>\" , point . getY ( ) ) ; result . put ( \"<STR_LIT>\" , point . getZ ( ) ) ; return result ; } private String contourType ( @ FaceMesh . ContourType int contourType ) { switch ( contourType ) { case FaceMesh . FACE_OVAL : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYEBROW_TOP : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYEBROW_BOTTOM : return \"<STR_LIT>\" ; case FaceMesh . RIGHT_EYEBROW_TOP : return \"<STR_LIT>\" ; case", "gt": "FaceMesh . RIGHT_EYEBROW_BOTTOM : return \"<STR_LIT>\" ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult result = implementation . getMaxZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openSettings ( PluginCall call ) { try { implementation . openSettings ( call ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isGoogleBarcodeScannerModuleAvailable ( PluginCall call ) { try { implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , isAvailable ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void installGoogleBarcodeScannerModule ( PluginCall call ) { try { implementation . installGoogleBarcodeScannerModule ( new InstallGoogleBarcodeScannerModuleResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ Override @ PluginMethod public void requestPermissions ( PluginCall call ) { if ( isPermissionDeclared ( CAMERA ) ) { super . requestPermissions ( call ) ; } else { checkPermissions ( call ) ; } } public void requestPermissionForAlias ( @ NonNull String alias , @ NonNull PluginCall call , @ NonNull String callbackName ) { super . requestPermissionForAlias ( alias , call , callbackName ) ; } @ ActivityCallback public void openSettingsResult ( PluginCall call , ActivityResult result ) { try { if ( call == null ) { Logger . debug ( \"<STR_LIT>\" ) ; return ; } call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PermissionCallback private void cameraPermissionsCallback ( PluginCall call ) { if ( call . getMethodName ( ) . equals ( \"<STR_LIT>\" ) ) { startScan ( call ) ; } } public void notifyBarcodeScannedListener ( Barcode barcode , Point imageSize ) { try { Point screenSize = this . getScreenSize ( ) ; JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , imageSize , screenSize ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResult ) ; notifyListeners ( BARCODE_SCANNED_EVENT , result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } public void notifyScanErrorListener ( String message ) { try { JSObject", "gt": "result = new JSObject ( ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult result = implementation . getMaxZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openSettings ( PluginCall call ) { try { implementation . openSettings ( call ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isGoogleBarcodeScannerModuleAvailable ( PluginCall call ) { try { implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , isAvailable ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void installGoogleBarcodeScannerModule ( PluginCall call ) { try { implementation . installGoogleBarcodeScannerModule ( new InstallGoogleBarcodeScannerModuleResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult result = implementation . getMaxZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openSettings ( PluginCall call ) { try { implementation . openSettings ( call ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isGoogleBarcodeScannerModuleAvailable ( PluginCall call ) { try { implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , isAvailable ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void installGoogleBarcodeScannerModule ( PluginCall call ) { try { implementation . installGoogleBarcodeScannerModule ( new InstallGoogleBarcodeScannerModuleResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ Override @ PluginMethod public void requestPermissions ( PluginCall call ) { if ( isPermissionDeclared ( CAMERA ) ) { super . requestPermissions ( call ) ; } else { checkPermissions ( call ) ; } } public void requestPermissionForAlias ( @ NonNull String alias , @ NonNull PluginCall call , @ NonNull String callbackName ) { super . requestPermissionForAlias ( alias , call , callbackName ) ; } @ ActivityCallback public void openSettingsResult ( PluginCall call , ActivityResult result ) { try { if ( call == null ) { Logger . debug ( \"<STR_LIT>\" ) ; return ; } call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PermissionCallback private void cameraPermissionsCallback ( PluginCall call ) { if ( call . getMethodName ( ) . equals ( \"<STR_LIT>\" ) ) { startScan ( call ) ; } } public void notifyBarcodeScannedListener ( Barcode barcode , Point imageSize ) { try { Point screenSize = this . getScreenSize ( ) ; JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , imageSize , screenSize ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResult ) ; notifyListeners ( BARCODE_SCANNED_EVENT , result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } public void notifyScanErrorListener ( String message ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , message ) ; notifyListeners ( SCAN_ERROR_EVENT , result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } public void notifyGoogleBarcodeScannerModuleInstallProgressListener ( int state , @ Nullable Integer progress ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , state ) ; if ( progress != null ) { result", "gt": ". put ( \"<STR_LIT>\" , progress ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult result = implementation . getMaxZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : connectedPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; triangleResult . put ( faceMeshPointResult ) ; } if ( triangleResult . length ( ) > <NUM_LIT> ) { trianglesResult . put ( triangleResult ) ; } } if ( trianglesResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , trianglesResult ) ; } return result ; } private JSObject createBoundsResult ( Rect boundingBox ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , boundingBox . left ) ; result . put ( \"<STR_LIT>\" , boundingBox . top ) ; result . put ( \"<STR_LIT>\" , boundingBox . right ) ; result . put ( \"<STR_LIT>\" , boundingBox . bottom ) ; return result ; } private JSObject createFaceMeshPointResult ( int index , PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , index ) ; result . put ( \"<STR_LIT>\" , createPointResult ( point ) ) ; return result ; } private JSObject createPointResult ( PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , point . getX ( ) ) ; result . put ( \"<STR_LIT>\" , point . getY ( ) ) ; result . put ( \"<STR_LIT>\" , point . getZ ( ) ) ; return result ; } private String contourType ( @ FaceMesh . ContourType int contourType ) { switch ( contourType ) { case FaceMesh . FACE_OVAL : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYEBROW_TOP : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYEBROW_BOTTOM : return \"<STR_LIT>\" ; case FaceMesh . RIGHT_EYEBROW_TOP : return \"<STR_LIT>\" ; case FaceMesh . RIGHT_EYEBROW_BOTTOM : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYE : return \"<STR_LIT>\" ; case FaceMesh . RIGHT_EYE : return \"<STR_LIT>\" ; case FaceMesh . UPPER_LIP_TOP : return \"<STR_LIT>\" ; case FaceMesh . UPPER_LIP_BOTTOM : return \"<STR_LIT>\" ; case FaceMesh . LOWER_LIP_TOP : return \"<STR_LIT>\" ; case", "gt": "FaceMesh . LOWER_LIP_BOTTOM : return \"<STR_LIT>\" ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : connectedPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; triangleResult . put ( faceMeshPointResult ) ; } if ( triangleResult . length ( ) > <NUM_LIT> ) { trianglesResult . put ( triangleResult ) ; } } if ( trianglesResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , trianglesResult ) ; } return result ; } private JSObject createBoundsResult ( Rect boundingBox ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , boundingBox . left ) ; result . put ( \"<STR_LIT>\" , boundingBox . top ) ; result . put ( \"<STR_LIT>\" , boundingBox . right ) ; result . put ( \"<STR_LIT>\" , boundingBox . bottom ) ; return result ; } private JSObject createFaceMeshPointResult ( int index , PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , index ) ; result . put ( \"<STR_LIT>\" , createPointResult ( point ) ) ; return result ; } private JSObject createPointResult ( PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , point . getX ( ) ) ; result . put ( \"<STR_LIT>\" , point . getY ( ) ) ; result . put ( \"<STR_LIT>\" , point . getZ ( ) ) ; return result ; } private String contourType ( @ FaceMesh . ContourType int contourType ) { switch ( contourType ) { case FaceMesh . FACE_OVAL : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYEBROW_TOP : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYEBROW_BOTTOM : return \"<STR_LIT>\" ; case FaceMesh . RIGHT_EYEBROW_TOP : return \"<STR_LIT>\" ; case FaceMesh . RIGHT_EYEBROW_BOTTOM : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYE : return \"<STR_LIT>\" ; case FaceMesh . RIGHT_EYE : return \"<STR_LIT>\" ; case", "gt": "FaceMesh . UPPER_LIP_TOP : return \"<STR_LIT>\" ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject", "gt": "result = new JSObject ( ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facedetection ; import android . graphics . PointF ; import android . graphics . Rect ; import android . net . Uri ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . face . Face ; import com . google . mlkit . vision . face . FaceContour ; import com . google . mlkit . vision . face . FaceDetectorOptions ; import com . google . mlkit . vision . face . FaceLandmark ; import io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes . ProcessImageResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class FaceDetectionPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String ERROR_PROCESS_IMAGE_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; private FaceDetection implementation ; @ Override public void load ( ) { try { implementation = new FaceDetection ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void processImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" , null ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } Integer performanceMode = call . getInt ( \"<STR_LIT>\" , FaceDetectorOptions . PERFORMANCE_MODE_FAST ) ; Integer landmarkMode = call . getInt ( \"<STR_LIT>\" , FaceDetectorOptions . LANDMARK_MODE_NONE ) ; Integer contourMode = call . getInt ( \"<STR_LIT>\" , FaceDetectorOptions . CONTOUR_MODE_NONE ) ; Integer classificationMode = call . getInt ( \"<STR_LIT>\" , FaceDetectorOptions . CLASSIFICATION_MODE_NONE ) ; Float minFaceSize = call . getFloat ( \"<STR_LIT>\" , <NUM_LIT> ) ; Boolean enableTracking = call . getBoolean ( \"<STR_LIT>\" , false ) ; InputImage image = implementation . createInputImageFromFilePath ( path ) ; if ( image == null ) { call . reject ( ERROR_LOAD_IMAGE_FAILED ) ; return ; } ProcessImageOptions options = new ProcessImageOptions ( image , performanceMode , landmarkMode , contourMode , classificationMode , minFaceSize , enableTracking ) ; implementation . processImage ( options , new ProcessImageResultCallback ( ) { @ Override public void success ( ProcessImageResult result ) { call", "gt": ". resolve ( result . toJSObject ( ) ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : connectedPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; triangleResult . put ( faceMeshPointResult ) ; } if ( triangleResult . length ( ) > <NUM_LIT> ) { trianglesResult . put ( triangleResult ) ; } } if ( trianglesResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , trianglesResult ) ; } return result ; } private JSObject createBoundsResult ( Rect boundingBox ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , boundingBox . left ) ; result . put ( \"<STR_LIT>\" , boundingBox . top ) ; result . put ( \"<STR_LIT>\" , boundingBox . right ) ; result . put ( \"<STR_LIT>\" , boundingBox . bottom ) ; return result ; } private JSObject createFaceMeshPointResult ( int index , PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , index ) ; result . put ( \"<STR_LIT>\" , createPointResult ( point ) ) ; return result ; } private JSObject createPointResult ( PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , point . getX ( ) ) ; result", "gt": ". put ( \"<STR_LIT>\" , point . getY ( ) ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult result = implementation . getMaxZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openSettings ( PluginCall call ) { try { implementation . openSettings ( call ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isGoogleBarcodeScannerModuleAvailable ( PluginCall call ) { try { implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , isAvailable ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void installGoogleBarcodeScannerModule ( PluginCall call ) { try { implementation . installGoogleBarcodeScannerModule ( new InstallGoogleBarcodeScannerModuleResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ Override @ PluginMethod public void requestPermissions ( PluginCall call ) { if ( isPermissionDeclared ( CAMERA ) ) { super . requestPermissions ( call ) ; } else { checkPermissions ( call ) ; } } public void requestPermissionForAlias ( @ NonNull String alias , @ NonNull PluginCall call , @ NonNull String callbackName ) { super", "gt": ". requestPermissionForAlias ( alias , call , callbackName ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : connectedPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; triangleResult . put ( faceMeshPointResult ) ; } if ( triangleResult . length ( ) > <NUM_LIT> ) { trianglesResult . put ( triangleResult ) ; } } if ( trianglesResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , trianglesResult ) ; } return result ; } private JSObject createBoundsResult ( Rect boundingBox ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , boundingBox . left ) ; result . put ( \"<STR_LIT>\" , boundingBox . top ) ; result . put ( \"<STR_LIT>\" , boundingBox . right ) ; result . put ( \"<STR_LIT>\" , boundingBox . bottom ) ; return result ; } private JSObject createFaceMeshPointResult ( int index , PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , index ) ; result . put ( \"<STR_LIT>\" , createPointResult ( point ) ) ; return result ; } private JSObject createPointResult ( PointF3D point ) { JSObject", "gt": "result = new JSObject ( ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult result = implementation . getMaxZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : connectedPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; triangleResult . put ( faceMeshPointResult ) ; } if ( triangleResult . length ( ) > <NUM_LIT> ) { trianglesResult . put ( triangleResult ) ; } } if ( trianglesResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , trianglesResult ) ; } return result ; } private JSObject createBoundsResult ( Rect boundingBox ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , boundingBox . left ) ; result . put ( \"<STR_LIT>\" , boundingBox . top ) ; result . put ( \"<STR_LIT>\" , boundingBox . right ) ; result . put ( \"<STR_LIT>\" , boundingBox . bottom ) ; return result ; } private JSObject createFaceMeshPointResult ( int index , PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , index ) ; result . put ( \"<STR_LIT>\" , createPointResult ( point ) ) ; return result ; } private JSObject createPointResult ( PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , point . getX ( ) ) ; result . put ( \"<STR_LIT>\" , point . getY ( ) ) ; result . put ( \"<STR_LIT>\" , point . getZ ( ) ) ; return result ; } private String contourType ( @ FaceMesh . ContourType int contourType ) { switch ( contourType ) { case FaceMesh . FACE_OVAL : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYEBROW_TOP : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYEBROW_BOTTOM : return \"<STR_LIT>\" ; case FaceMesh . RIGHT_EYEBROW_TOP : return \"<STR_LIT>\" ; case FaceMesh . RIGHT_EYEBROW_BOTTOM : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYE : return \"<STR_LIT>\" ; case FaceMesh . RIGHT_EYE : return \"<STR_LIT>\" ; case FaceMesh . UPPER_LIP_TOP : return \"<STR_LIT>\" ; case FaceMesh . UPPER_LIP_BOTTOM : return \"<STR_LIT>\" ; case FaceMesh . LOWER_LIP_TOP : return \"<STR_LIT>\" ; case FaceMesh . LOWER_LIP_BOTTOM : return \"<STR_LIT>\" ; case", "gt": "FaceMesh . NOSE_BRIDGE : return \"<STR_LIT>\" ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : connectedPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; triangleResult . put ( faceMeshPointResult ) ; } if ( triangleResult . length ( ) > <NUM_LIT> ) { trianglesResult . put ( triangleResult ) ; } } if ( trianglesResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , trianglesResult ) ; } return result ; } private JSObject createBoundsResult ( Rect boundingBox ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , boundingBox . left ) ; result . put ( \"<STR_LIT>\" , boundingBox . top ) ; result . put ( \"<STR_LIT>\" , boundingBox . right ) ; result . put ( \"<STR_LIT>\" , boundingBox . bottom ) ; return result ; } private JSObject createFaceMeshPointResult ( int index , PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , index ) ; result . put ( \"<STR_LIT>\" , createPointResult ( point ) ) ; return result ; } private JSObject createPointResult ( PointF3D point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , point . getX ( ) ) ; result . put ( \"<STR_LIT>\" , point . getY ( ) ) ; result . put ( \"<STR_LIT>\" , point . getZ ( ) ) ; return result ; } private String contourType ( @ FaceMesh . ContourType int contourType ) { switch ( contourType ) { case FaceMesh . FACE_OVAL : return \"<STR_LIT>\" ; case FaceMesh . LEFT_EYEBROW_TOP : return \"<STR_LIT>\" ; case", "gt": "FaceMesh . LEFT_EYEBROW_BOTTOM : return \"<STR_LIT>\" ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : connectedPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject", "gt": "faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : connectedPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; triangleResult . put ( faceMeshPointResult ) ; } if ( triangleResult . length ( ) > <NUM_LIT> ) { trianglesResult . put ( triangleResult ) ; } } if ( trianglesResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , trianglesResult ) ; } return result ; } private JSObject createBoundsResult ( Rect boundingBox ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , boundingBox . left ) ; result", "gt": ". put ( \"<STR_LIT>\" , boundingBox . top ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult result = implementation . getMaxZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openSettings ( PluginCall call ) { try { implementation . openSettings ( call ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isGoogleBarcodeScannerModuleAvailable ( PluginCall call ) { try { implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , isAvailable ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void installGoogleBarcodeScannerModule ( PluginCall call ) { try { implementation . installGoogleBarcodeScannerModule ( new InstallGoogleBarcodeScannerModuleResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ Override @ PluginMethod public void requestPermissions ( PluginCall call ) { if ( isPermissionDeclared ( CAMERA ) ) { super . requestPermissions ( call ) ; } else { checkPermissions ( call ) ; } } public void requestPermissionForAlias ( @ NonNull String alias , @ NonNull PluginCall call , @ NonNull String callbackName ) { super . requestPermissionForAlias ( alias , call , callbackName ) ; } @ ActivityCallback public void openSettingsResult ( PluginCall call , ActivityResult result ) { try { if ( call == null ) { Logger . debug ( \"<STR_LIT>\" ) ; return ; } call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PermissionCallback private void cameraPermissionsCallback ( PluginCall call ) { if ( call . getMethodName ( ) . equals ( \"<STR_LIT>\" ) ) { startScan ( call ) ; } } public void notifyBarcodeScannedListener ( Barcode barcode , Point imageSize ) { try { Point screenSize = this . getScreenSize ( ) ; JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , imageSize , screenSize ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResult ) ; notifyListeners ( BARCODE_SCANNED_EVENT , result ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facedetection ; import android . graphics . PointF ; import android . graphics . Rect ; import android . net . Uri ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . face . Face ; import com . google . mlkit . vision . face . FaceContour ; import com . google . mlkit . vision . face . FaceDetectorOptions ; import com . google . mlkit . vision . face . FaceLandmark ; import io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes . ProcessImageResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class FaceDetectionPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String ERROR_PROCESS_IMAGE_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; private FaceDetection implementation ; @ Override public void load ( ) { try { implementation = new FaceDetection ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void processImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" , null ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } Integer performanceMode = call . getInt ( \"<STR_LIT>\" , FaceDetectorOptions . PERFORMANCE_MODE_FAST ) ; Integer landmarkMode = call . getInt ( \"<STR_LIT>\" , FaceDetectorOptions . LANDMARK_MODE_NONE ) ; Integer contourMode = call . getInt ( \"<STR_LIT>\" , FaceDetectorOptions . CONTOUR_MODE_NONE ) ; Integer", "gt": "classificationMode = call . getInt ( \"<STR_LIT>\" , FaceDetectorOptions . CLASSIFICATION_MODE_NONE ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean", "gt": "isCameraActive = implementation . isCameraActive ( ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray", "gt": "triangleResult = new JSArray ( ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . Manifest ; import android . graphics . Point ; import android . util . DisplayMetrics ; import androidx . activity . result . ActivityResult ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import com . google . mlkit . vision . barcode . common . Barcode ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; import java . util . List ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = { @ Permission ( strings = { Manifest . permission . CAMERA } , alias = BarcodeScannerPlugin . CAMERA ) } ) public class BarcodeScannerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String CAMERA = \"<STR_LIT>\" ; public static final String BARCODE_SCANNED_EVENT = \"<STR_LIT>\" ; public static final String SCAN_ERROR_EVENT = \"<STR_LIT>\" ; public static final String GOOGLE_BARCODE_SCANNER_MODULE_INSTALL_PROGRESS_EVENT = \"<STR_LIT>\" ; public static final String ERROR_SCAN_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_ZOOM_RATIO_MISSING = \"<STR_LIT>\" ; public static final String ERROR_NO_ACTIVE_SCAN_SESSION = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED = \"<STR_LIT>\" ; public static final String ERROR_PERMISSION_DENIED = \"<STR_LIT>\" ; private BarcodeScanner implementation ; @ Override public void load ( ) { try { implementation = new BarcodeScanner ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startScan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; String lensFacingOption = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int lensFacing = lensFacingOption . equals ( \"<STR_LIT>\" ) ? CameraSelector . LENS_FACING_FRONT : CameraSelector . LENS_FACING_BACK ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; scanSettings . lensFacing = lensFacing ; boolean granted = implementation . requestCameraPermissionIfNotDetermined ( call ) ; if ( ! granted ) { return ; } getActivity ( ) . runOnUiThread ( ( ) -> { implementation . startScan ( scanSettings , new StartScanResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void stopScan ( PluginCall call ) { try { getActivity ( ) . runOnUiThread ( ( ) -> { implementation . stopScan ( ) ; call . resolve ( ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void readBarcodesFromImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . readBarcodesFromImage ( path , scanSettings , new ReadBarcodesFromImageResultCallback ( ) { @ Override public void success ( List < Barcode > barcodes ) { JSArray barcodeResults = new JSArray ( ) ; for ( Barcode barcode : barcodes ) { barcodeResults . put ( BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , \"<STR_LIT>\" , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void scan ( PluginCall call ) { try { List < String > formatsOption = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) . toList ( ) ; int [ ] formats = BarcodeScannerHelper . convertStringsToBarcodeScannerFormats ( formatsOption . toArray ( new String [ <NUM_LIT> ] ) ) ; ScanSettings scanSettings = new ScanSettings ( ) ; scanSettings . formats = formats ; implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { if ( isAvailable ) { implementation . scan ( scanSettings , ( new ScanResultCallback ( ) { @ Override public void success ( Barcode barcode ) { JSObject barcodeResult = BarcodeScannerHelper . createBarcodeResultForBarcode ( barcode , null , null ) ; JSArray barcodeResults = new JSArray ( ) ; barcodeResults . put ( barcodeResult ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , barcodeResults ) ; call . resolve ( result ) ; } @ Override public void cancel ( ) { call . reject ( ERROR_SCAN_CANCELED ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ) ; } else { call . reject ( ERROR_GOOGLE_BARCODE_SCANNER_MODULE_NOT_AVAILABLE ) ; } } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isSupported ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void enableTorch ( PluginCall call ) { try { implementation . enableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void disableTorch ( PluginCall call ) { try { implementation . disableTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void toggleTorch ( PluginCall call ) { try { implementation . toggleTorch ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchEnabled ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchEnabled ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isTorchAvailable ( PluginCall call ) { try { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , implementation . isTorchAvailable ( ) ) ; call . resolve ( result ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setZoomRatio ( PluginCall call ) { try { Float zoomRatio = call . getFloat ( \"<STR_LIT>\" ) ; if ( zoomRatio == null ) { call . reject ( ERROR_ZOOM_RATIO_MISSING ) ; return ; } SetZoomRatioOptions options = new SetZoomRatioOptions ( zoomRatio ) ; implementation . setZoomRatio ( options ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetZoomRatioResult result = implementation . getZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMinZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMinZoomRatioResult result = implementation . getMinZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getMaxZoomRatio ( PluginCall call ) { try { boolean isCameraActive = implementation . isCameraActive ( ) ; if ( ! isCameraActive ) { call . reject ( ERROR_NO_ACTIVE_SCAN_SESSION ) ; return ; } GetMaxZoomRatioResult result = implementation . getMaxZoomRatio ( ) ; call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openSettings ( PluginCall call ) { try { implementation . openSettings ( call ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void isGoogleBarcodeScannerModuleAvailable ( PluginCall call ) { try { implementation . isGoogleBarcodeScannerModuleAvailable ( new IsGoogleBarodeScannerModuleAvailableResultCallback ( ) { @ Override public void success ( boolean isAvailable ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , isAvailable ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-mlkit"}
{"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . common . PointF3D ; import com . google . mlkit . vision . common . Triangle ; import com . google . mlkit . vision . facemesh . FaceMesh ; import com . google . mlkit . vision . facemesh . FaceMeshPoint ; import java . util . List ; public class ProcessImageResult { private final List < FaceMesh > faceMeshs ; @ FaceMesh . ContourType private final int [ ] contourTypes = { FaceMesh . FACE_OVAL , FaceMesh . LEFT_EYEBROW_TOP , FaceMesh . LEFT_EYEBROW_BOTTOM , FaceMesh . RIGHT_EYEBROW_TOP , FaceMesh . RIGHT_EYEBROW_BOTTOM , FaceMesh . LEFT_EYE , FaceMesh . RIGHT_EYE , FaceMesh . UPPER_LIP_TOP , FaceMesh . UPPER_LIP_BOTTOM , FaceMesh . LOWER_LIP_TOP , FaceMesh . LOWER_LIP_BOTTOM , FaceMesh . NOSE_BRIDGE } ; public ProcessImageResult ( List < FaceMesh > faceMeshs ) { this . faceMeshs = faceMeshs ; } public JSObject toJSObject ( ) { JSArray faceMeshsResult = this . createFaceMeshsResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , faceMeshsResult ) ; return result ; } private JSArray createFaceMeshsResult ( ) { JSArray result = new JSArray ( ) ; for ( FaceMesh faceMesh : faceMeshs ) { JSObject faceMeshResult = this . createFaceMeshResult ( faceMesh ) ; result . put ( faceMeshResult ) ; } return result ; } private JSObject createFaceMeshResult ( FaceMesh faceMesh ) { JSObject result = new JSObject ( ) ; Rect boundingBox = faceMesh . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSObject contoursResult = new JSObject ( ) ; for ( int contourType : contourTypes ) { JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getPoints ( contourType ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { contoursResult . put ( contourType ( contourType ) , faceMeshPointsResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } JSArray faceMeshPointsResult = new JSArray ( ) ; List < FaceMeshPoint > faceMeshPoints = faceMesh . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : faceMeshPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; faceMeshPointsResult . put ( faceMeshPointResult ) ; } if ( faceMeshPointsResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , faceMeshPointsResult ) ; } JSArray trianglesResult = new JSArray ( ) ; List < Triangle < FaceMeshPoint > > triangles = faceMesh . getAllTriangles ( ) ; for ( Triangle < FaceMeshPoint > triangle : triangles ) { JSArray triangleResult = new JSArray ( ) ; List < FaceMeshPoint > connectedPoints = triangle . getAllPoints ( ) ; for ( FaceMeshPoint faceMeshPoint : connectedPoints ) { int index = faceMeshPoint . getIndex ( ) ; PointF3D position = faceMeshPoint . getPosition ( ) ; JSObject faceMeshPointResult = this . createFaceMeshPointResult ( index , position ) ; triangleResult . put ( faceMeshPointResult ) ; } if ( triangleResult . length ( ) > <NUM_LIT> ) { trianglesResult . put ( triangleResult ) ; } } if ( trianglesResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , trianglesResult ) ; } return result ; } private JSObject createBoundsResult ( Rect boundingBox ) { JSObject result = new JSObject ( ) ; result", "gt": ". put ( \"<STR_LIT>\" , boundingBox . left ) ;", "repo": "capacitor-mlkit"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this", "gt": ". signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult = proxyClass . getName ( ) ; } else if ( target != null ) { invokeResult = method . invoke ( target , args ) ; } else { Class < ? > returnType = method . getReturnType ( ) ; if ( returnType . isPrimitive ( ) ) { if ( boolean . class == returnType ) { invokeResult = false ; } else if ( int . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( long . class == returnType ) { invokeResult = <NUM_LIT> ; } else", "gt": "if ( short . class == returnType ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { result", "gt": "= parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) , result . getClass ( ) ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS", "gt": "= object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult = proxyClass . getName ( ) ; } else", "gt": "if ( target != null ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else", "gt": "if ( method . equals ( TO_STRING ) ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult", "gt": "= proxyClass . getName ( ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int", "gt": "result = Objects . hash ( name ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult = proxyClass . getName ( ) ; } else if ( target != null ) { invokeResult = method . invoke ( target , args ) ; } else { Class < ? > returnType = method . getReturnType ( ) ; if ( returnType . isPrimitive ( ) ) { if ( boolean . class == returnType ) { invokeResult = false ; } else if ( int . class == returnType ) { invokeResult = <NUM_LIT> ; } else", "gt": "if ( long . class == returnType ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else", "gt": "if ( method . equals ( EQUALS ) ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult = proxyClass . getName ( ) ; } else if ( target != null ) { invokeResult = method . invoke ( target , args ) ; } else { Class", "gt": "< ? > returnType = method . getReturnType ( ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult = proxyClass . getName ( ) ; } else if ( target != null ) { invokeResult", "gt": "= method . invoke ( target , args ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature", "gt": "that = ( MethodSignature ) o ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result", "gt": "= <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) , result . getClass ( ) ) ; } else { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) ) ; } parcel . recycle ( ) ; return result ; } @ Override protected IBinder asBinder ( ) { IBinder proxyBinder = getProxyBinder ( ) ; return proxyBinder != null ? proxyBinder : ( IBinder ) invoke ( ) ; } @ Override protected boolean isMultiProcessEnabled ( ) { return false ; } } ; private Map < String , IBinder > binderCacheMap ; @ Override protected IBinder onTargetBinderObtain ( ) { IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; return", "gt": "serviceManager . getService ( IWebViewUpdateService . SERVICE ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if", "gt": "( this == o ) return true ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE", "gt": "= object . getDeclaredMethod ( \"<STR_LIT>\" ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult", "gt": "= System . identityHashCode ( proxy ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if", "gt": "( o == null || getClass ( ) != o . getClass ( ) ) return false ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if", "gt": "( method . equals ( HASH_CODE ) ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult = proxyClass . getName ( ) ; } else if ( target != null ) { invokeResult = method . invoke ( target , args ) ; } else { Class < ? > returnType = method . getReturnType ( ) ; if ( returnType . isPrimitive ( ) ) { if ( boolean . class == returnType ) { invokeResult = false ; } else if ( int . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( long . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( short . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( byte . class == returnType ) { invokeResult = <NUM_LIT> ; } else", "gt": "if ( double . class == returnType ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if", "gt": "( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this", "gt": ". paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) , result . getClass ( ) ) ; } else { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) ) ; } parcel . recycle ( ) ; return result ; } @ Override protected IBinder asBinder ( ) { IBinder proxyBinder = getProxyBinder ( ) ; return proxyBinder != null ? proxyBinder : ( IBinder ) invoke ( ) ; } @ Override protected boolean isMultiProcessEnabled ( ) { return false ; } } ; private Map < String , IBinder > binderCacheMap ; @ Override protected IBinder onTargetBinderObtain ( ) { IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; return serviceManager . getService ( IWebViewUpdateService . SERVICE ) ; } @ Override protected ProxyBinder onProxyBinderCreate ( IBinder binder ) { IWebViewUpdateService service = RuntimeAccess . staticAccess ( IWebViewUpdateService . class ) ; IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; IInterface oldInterface = service . asInterface ( binder ) ; proxy . setTarget ( oldInterface ) ; IInterface proxyInterface = ( IInterface ) proxy . get ( ) ; ProxyBinder proxyBinder = new ProxyBinder ( oldInterface , proxyInterface ) ; binderCacheMap = serviceManager . getServiceCache ( ) ; return proxyBinder ; } @ Override protected void onTargetBinderRestore ( IBinder binder ) { binderCacheMap", "gt": ". put ( IWebViewUpdateService . SERVICE , binder ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING", "gt": "= object . getDeclaredMethod ( \"<STR_LIT>\" ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult = proxyClass . getName ( ) ; } else if ( target != null ) { invokeResult = method . invoke ( target , args ) ; } else { Class < ? > returnType = method . getReturnType ( ) ; if ( returnType . isPrimitive ( ) ) { if", "gt": "( boolean . class == returnType ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) , result . getClass ( ) ) ; } else { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) ) ; } parcel . recycle ( ) ; return result ; } @ Override protected IBinder asBinder ( ) { IBinder proxyBinder = getProxyBinder ( ) ; return proxyBinder != null ? proxyBinder : ( IBinder ) invoke ( ) ; } @ Override protected boolean isMultiProcessEnabled ( ) { return false ; } } ; private Map < String , IBinder > binderCacheMap ; @ Override protected IBinder onTargetBinderObtain ( ) { IServiceManager", "gt": "serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult = proxyClass . getName ( ) ; } else if ( target != null ) { invokeResult = method . invoke ( target , args ) ; } else { Class < ? > returnType = method . getReturnType ( ) ; if", "gt": "( returnType . isPrimitive ( ) ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) , result . getClass ( ) ) ; } else { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) ) ; } parcel . recycle ( ) ; return result ; } @ Override protected IBinder asBinder ( ) { IBinder proxyBinder = getProxyBinder ( ) ; return proxyBinder != null ? proxyBinder : ( IBinder ) invoke ( ) ; } @ Override protected boolean isMultiProcessEnabled ( ) { return false ; } } ; private Map < String , IBinder > binderCacheMap ; @ Override protected IBinder onTargetBinderObtain ( ) { IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; return serviceManager . getService ( IWebViewUpdateService . SERVICE ) ; } @ Override protected ProxyBinder onProxyBinderCreate ( IBinder binder ) { IWebViewUpdateService service = RuntimeAccess . staticAccess ( IWebViewUpdateService . class ) ; IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; IInterface", "gt": "oldInterface = service . asInterface ( binder ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) , result . getClass ( ) ) ; } else { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) ) ; } parcel . recycle ( ) ; return result ; } @ Override protected IBinder asBinder ( ) { IBinder proxyBinder = getProxyBinder ( ) ; return", "gt": "proxyBinder != null ? proxyBinder : ( IBinder ) invoke ( ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) , result . getClass ( ) ) ; } else { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) ) ; } parcel . recycle ( ) ; return result ; } @ Override protected IBinder asBinder ( ) { IBinder proxyBinder = getProxyBinder ( ) ; return proxyBinder != null ? proxyBinder : ( IBinder ) invoke ( ) ; } @ Override protected boolean isMultiProcessEnabled ( ) { return false ; } } ; private Map < String , IBinder > binderCacheMap ; @ Override protected IBinder onTargetBinderObtain ( ) { IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; return serviceManager . getService ( IWebViewUpdateService . SERVICE ) ; } @ Override protected ProxyBinder onProxyBinderCreate ( IBinder binder ) { IWebViewUpdateService", "gt": "service = RuntimeAccess . staticAccess ( IWebViewUpdateService . class ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult = proxyClass . getName ( ) ; } else if ( target != null ) { invokeResult = method . invoke ( target , args ) ; } else { Class < ? > returnType = method . getReturnType ( ) ; if ( returnType . isPrimitive ( ) ) { if ( boolean . class == returnType ) { invokeResult = false ; } else if ( int . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( long . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( short . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( byte . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( double . class == returnType ) { invokeResult = <NUM_LIT> ; } else", "gt": "if ( float . class == returnType ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . util ; import android . os . Handler ; import android . os . Looper ; public class HandlerUtils { private static final Handler MAIN_HANDLER = new Handler ( Looper . getMainLooper ( ) ) ; public static void runInMainThread ( Runnable runnable ) { if", "gt": "( Looper . myLooper ( ) == Looper . getMainLooper ( ) ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult = proxyClass . getName ( ) ; } else if ( target != null ) { invokeResult = method . invoke ( target , args ) ; } else { Class < ? > returnType = method . getReturnType ( ) ; if ( returnType . isPrimitive ( ) ) { if ( boolean . class == returnType ) { invokeResult = false ; } else if ( int . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( long . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( short . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( byte . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( double . class == returnType ) { invokeResult = <NUM_LIT> ; } else if ( float . class == returnType ) { invokeResult = <NUM_LIT> ; } else", "gt": "if ( char . class == returnType ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) , result . getClass ( ) ) ; } else { result", "gt": "= parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) , result . getClass ( ) ) ; } else { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) ) ; } parcel . recycle ( ) ; return result ; } @ Override protected IBinder asBinder ( ) { IBinder proxyBinder = getProxyBinder ( ) ; return proxyBinder != null ? proxyBinder : ( IBinder ) invoke ( ) ; } @ Override protected boolean isMultiProcessEnabled ( ) { return false ; } } ; private Map < String , IBinder > binderCacheMap ; @ Override protected IBinder onTargetBinderObtain ( ) { IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; return serviceManager . getService ( IWebViewUpdateService . SERVICE ) ; } @ Override protected ProxyBinder onProxyBinderCreate ( IBinder binder ) { IWebViewUpdateService service = RuntimeAccess . staticAccess ( IWebViewUpdateService . class ) ; IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; IInterface oldInterface = service . asInterface ( binder ) ; proxy . setTarget ( oldInterface ) ; IInterface proxyInterface = ( IInterface ) proxy . get ( ) ; ProxyBinder proxyBinder = new ProxyBinder ( oldInterface , proxyInterface ) ; binderCacheMap = serviceManager . getServiceCache ( ) ; return proxyBinder ; } @ Override protected void onTargetBinderRestore ( IBinder binder ) { binderCacheMap . put ( IWebViewUpdateService . SERVICE , binder ) ; } @ Override protected void onProxyBinderReplace ( ProxyBinder binder ) { binderCacheMap", "gt": ". put ( IWebViewUpdateService . SERVICE , binder ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . reflect ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Queue ; class ReflectProxy { private final Object mProxyLock = new Object ( ) ; private final Map < MethodSignature , Invoke > mInvokeMap = new HashMap < > ( ) ; private Class < ? > [ ] mAllInterfaces ; private Class < ? > mProxyClass ; private Class < ? > mClass ; private String mClassName ; private Object mTargetObject ; public ReflectProxy ( Class < ? > clazz ) { this . mClass = clazz ; } public ReflectProxy ( String className ) { this . mClassName = className ; } public void addInvoke ( Invoke invoke ) throws ReflectException { addInvoke ( invoke , true ) ; } public void addInvoke ( Invoke invoke , boolean override ) throws ReflectException { if ( invoke == null ) return ; synchronized ( mProxyLock ) { prepareAllInterface ( ) ; try { if ( ! override && mInvokeMap . containsKey ( invoke . signature ) ) { return ; } mInvokeMap . put ( invoke . signature , invoke ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setTarget ( Object target ) { this . mTargetObject = target ; } public Object newProxyInstance ( ) throws ReflectException { synchronized ( mProxyLock ) { try { prepareAllInterface ( ) ; return Proxy . newProxyInstance ( mProxyClass . getClassLoader ( ) , mAllInterfaces , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxyObject , Method method , Object [ ] args ) { InvokeContext invokeContext = new InvokeContext ( mTargetObject , proxyObject , mProxyClass , args , method ) ; Invoke invoke = mInvokeMap . get ( invokeContext . signature ) ; if ( invoke != null ) { invoke . onInvoke ( invokeContext ) ; } return invokeContext . replace ? invokeContext . replaceResult : invokeContext . invoke ( ) ; } } ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareAllInterface ( ) throws ReflectException { synchronized ( mProxyLock ) { try { if ( mAllInterfaces != null && mAllInterfaces . length != <NUM_LIT> ) { return ; } if ( mProxyClass == null ) { mProxyClass = mClass ; } if ( mProxyClass == null ) { mProxyClass = Class . forName ( mClassName ) ; } List < Class < ? > > interfaceList = new ArrayList < > ( ) ; Queue < Class < ? > > findClassQueue = new LinkedList < > ( ) ; findClassQueue . add ( mProxyClass ) ; while ( ! findClassQueue . isEmpty ( ) ) { Class < ? > findClass = findClassQueue . remove ( ) ; if ( findClass . isInterface ( ) ) { if ( ! interfaceList . contains ( findClass ) ) { interfaceList . add ( findClass ) ; } } Class < ? > superClass = findClass != Object . class ? findClass . getSuperclass ( ) : null ; if ( superClass != null ) { findClassQueue . add ( superClass ) ; } Class < ? > [ ] interfaces = findClass . getInterfaces ( ) ; findClassQueue . addAll ( Arrays . asList ( interfaces ) ) ; } if ( interfaceList . size ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( mProxyClass + \"<STR_LIT>\" ) ; } mAllInterfaces = new Class [ interfaceList . size ( ) ] ; mAllInterfaces = interfaceList . toArray ( mAllInterfaces ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public static abstract class Invoke { private final MethodSignature signature ; public Invoke ( String name , Class < ? > ... paramTypes ) { signature = new MethodSignature ( name , paramTypes ) ; } protected abstract void onInvoke ( InvokeContext invokeContext ) ; public String getName ( ) { return signature . name ; } public Class < ? > [ ] getParamTypes ( ) { return signature . paramTypes ; } MethodSignature getSignature ( ) { return signature ; } } static class MethodSignature { private final String name ; private final Class < ? > [ ] paramTypes ; public MethodSignature ( String name , Class < ? > [ ] paramTypes ) { this . name = name ; this . paramTypes = paramTypes == null ? new Class < ? > [ <NUM_LIT> ] : paramTypes ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MethodSignature that = ( MethodSignature ) o ; return Objects . equals ( name , that . name ) && Arrays . equals ( paramTypes , that . paramTypes ) ; } @ Override public int hashCode ( ) { int result = Objects . hash ( name ) ; result = <NUM_LIT> * result + Arrays . hashCode ( paramTypes ) ; return result ; } } public static class InvokeContext { public final Object target ; public final Object proxy ; public final Class < ? > proxyClass ; public final Object [ ] args ; private final Method method ; private Object replaceResult ; private Object invokeResult ; private boolean invokeCalled ; private boolean replace ; private static final Method HASH_CODE ; private static final Method EQUALS ; private static final Method TO_STRING ; private final MethodSignature signature ; static { Class < Object > object = Object . class ; try { HASH_CODE = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; EQUALS = object . getDeclaredMethod ( \"<STR_LIT>\" , object ) ; TO_STRING = object . getDeclaredMethod ( \"<STR_LIT>\" ) ; } catch ( NoSuchMethodException e ) { throw new Error ( e ) ; } } public InvokeContext ( Object target , Object proxy , Class < ? > proxyClass , Object [ ] args , Method method ) { this . target = target ; this . proxy = proxy ; this . proxyClass = proxyClass ; this . args = args ; this . method = method ; this . signature = new MethodSignature ( method . getName ( ) , method . getParameterTypes ( ) ) ; } public final void setResult ( Object replaceResult ) { this . replaceResult = replaceResult ; this . replace = true ; } public final Object invoke ( ) throws ReflectException { try { if ( invokeCalled ) { return invokeResult ; } if ( method . equals ( HASH_CODE ) ) { invokeResult = System . identityHashCode ( proxy ) ; } else if ( method . equals ( EQUALS ) ) { invokeResult = proxy == args [ <NUM_LIT> ] ; } else if ( method . equals ( TO_STRING ) ) { invokeResult = proxyClass . getName ( ) ; } else if ( target != null ) { invokeResult = method . invoke ( target , args ) ; } else { Class < ? > returnType = method . getReturnType ( ) ; if ( returnType . isPrimitive ( ) ) { if ( boolean . class == returnType ) { invokeResult = false ; } else", "gt": "if ( int . class == returnType ) {", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) , result . getClass ( ) ) ; } else { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) ) ; } parcel . recycle ( ) ; return result ; } @ Override protected IBinder asBinder ( ) { IBinder proxyBinder = getProxyBinder ( ) ; return proxyBinder != null ? proxyBinder : ( IBinder ) invoke ( ) ; } @ Override protected boolean isMultiProcessEnabled ( ) { return false ; } } ; private Map < String , IBinder > binderCacheMap ; @ Override protected IBinder onTargetBinderObtain ( ) { IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; return serviceManager . getService ( IWebViewUpdateService . SERVICE ) ; } @ Override protected ProxyBinder onProxyBinderCreate ( IBinder binder ) { IWebViewUpdateService service = RuntimeAccess . staticAccess ( IWebViewUpdateService . class ) ; IServiceManager", "gt": "serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . norman . webviewup . lib . hook ; import static android . os . Parcelable . PARCELABLE_WRITE_RETURN_VALUE ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . Parcelable ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewProviderResponse ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . WebViewUpdateServiceProxy ; import java . util . Map ; public class WebViewUpdateServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; public WebViewUpdateServiceHook ( Context context , String packageName ) { this . context = context ; this . webViewPackageName = packageName ; } private final WebViewUpdateServiceProxy proxy = new WebViewUpdateServiceProxy ( ) { @ Override protected Object waitForAndGetProvider ( ) { Object result = invoke ( ) ; PackageInfo packageInfo ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( webViewPackageName , PackageManager . GET_SHARED_LIBRARY_FILES | PackageManager . GET_SIGNATURES | PackageManager . GET_META_DATA ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new RuntimeException ( e ) ; } IWebViewProviderResponse webViewProviderResponse = RuntimeAccess . objectAccess ( IWebViewProviderResponse . class , result ) ; webViewProviderResponse . setPackageInfo ( packageInfo ) ; Parcel parcel = Parcel . obtain ( ) ; parcel . writeParcelable ( ( Parcelable ) result , <NUM_LIT> ) ; parcel . setDataPosition ( parcel . dataSize ( ) - <NUM_LIT> ) ; parcel . writeInt ( <NUM_LIT> ) ; parcel . setDataPosition ( <NUM_LIT> ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) , result . getClass ( ) ) ; } else { result = parcel . readParcelable ( result . getClass ( ) . getClassLoader ( ) ) ; } parcel . recycle ( ) ; return result ; } @ Override protected IBinder asBinder ( ) { IBinder proxyBinder = getProxyBinder ( ) ; return proxyBinder != null ? proxyBinder : ( IBinder ) invoke ( ) ; } @ Override protected boolean isMultiProcessEnabled ( ) { return false ; } } ; private Map < String , IBinder > binderCacheMap ; @ Override protected IBinder onTargetBinderObtain ( ) { IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; return serviceManager . getService ( IWebViewUpdateService . SERVICE ) ; } @ Override protected ProxyBinder onProxyBinderCreate ( IBinder binder ) { IWebViewUpdateService service = RuntimeAccess . staticAccess ( IWebViewUpdateService . class ) ; IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; IInterface oldInterface = service . asInterface ( binder ) ; proxy . setTarget ( oldInterface ) ; IInterface proxyInterface = ( IInterface ) proxy . get ( ) ; ProxyBinder proxyBinder = new ProxyBinder ( oldInterface , proxyInterface ) ; binderCacheMap", "gt": "= serviceManager . getServiceCache ( ) ;", "repo": "WebViewUpgrade"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position , String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , null , selection , selectionArgs , null , null , \"<STR_LIT>\" , String . valueOf ( position ) + \"<STR_LIT>\" ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position ) { return getConversationAtPosition ( position , null ) ; } public List < Conversation > getAllConversations ( ) { Cursor", "gt": "cursor = db . query ( DatabaseHelper . tableName , null , null , null , null , null , \"<STR_LIT>\" ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . baidu . aip . asrwakeup3 . core . util ; import android . os . Handler ; import android . os . Message ; import android . util . Log ; public class MyLogger { private static final String TAG = \"<STR_LIT>\" ; private static final String INFO = \"<STR_LIT>\" ; private static final String ERROR = \"<STR_LIT>\" ; private static final boolean ENABLE = true ; private static Handler handler ; public static void info ( String message ) { info ( TAG , message ) ; } public static void info ( String tag , String message ) { log ( INFO , tag , message ) ; } public static void error ( String message ) { error ( TAG , message ) ; } public static void error ( String tag , String message ) { log ( ERROR , tag , message ) ; } public static void setHandler ( Handler handler ) { MyLogger . handler = handler ; } private static void log ( String level , String tag , String message ) { if ( ! ENABLE ) { return ; } if ( level . equals ( INFO ) ) { Log . i ( tag , message ) ; } else if ( level . equals ( ERROR ) ) { Log", "gt": ". e ( tag , message ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . baidu . aip . asrwakeup3 . core . wakeup . listener ; import com . baidu . aip . asrwakeup3 . core . wakeup . WakeUpResult ; public interface IWakeupListener { void", "gt": "onSuccess ( String word , WakeUpResult result ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList = findViewById ( R . id . rv_online_temp_list ) ; rvTemplateList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; templateListAdapter = new OnlineTemplateListAdapter ( ) ; rvTemplateList . setAdapter ( templateListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . RIGHT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; templateListAdapter . notifyDataSetChanged ( ) ; Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . tag ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . content ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } } ) . attachToRecyclerView ( rvTemplateList ) ; ( findViewById ( R . id . bt_online_temp_back ) ) . setOnClickListener ( ( view ) -> { finish ( ) ; } ) ; ( findViewById ( R . id . bt_online_temp_share ) ) . setOnClickListener ( ( view ) -> { Intent", "gt": "intent = new Intent ( ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position , String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , null , selection , selectionArgs , null , null , \"<STR_LIT>\" , String . valueOf ( position ) + \"<STR_LIT>\" ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position ) { return getConversationAtPosition ( position , null ) ; } public List < Conversation > getAllConversations ( ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , null , null , null , null , \"<STR_LIT>\" ) ; List < Conversation > conversations = new ArrayList < > ( ) ; while ( cursor . moveToNext ( ) ) { Conversation conversation = getConversationByCursor ( cursor ) ; conversations . add ( conversation ) ; } return conversations ; } public long addConversation ( Conversation conversation ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , conversation . time . format ( DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ) ; values . put ( \"<STR_LIT>\" , conversation . title ) ; values . put ( \"<STR_LIT>\" , conversation . messages . toJson ( ) . toString ( ) ) ; conversation . id = db . insert ( DatabaseHelper . tableName , null , values ) ; return conversation . id ; } public void updateConversation ( Conversation conversation ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , conversation . time . format ( DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ) ; values . put ( \"<STR_LIT>\" , conversation . title ) ; values . put ( \"<STR_LIT>\" , conversation . messages . toJson ( ) . toString ( ) ) ; db . update ( DatabaseHelper . tableName , values , \"<STR_LIT>\" , new String [ ] { String . valueOf ( conversation . id ) } ) ; } public void removeConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { Conversation conversation = getConversationByCursor ( cursor , false ) ; conversation . messages . deleteAllImageFiles ( ) ; } db . delete ( DatabaseHelper . tableName , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } ) ; } public void removeConversation ( Conversation conversation ) { removeConversation ( conversation . id ) ; } public void removeAllConversations ( ) { File imageDir = new File ( ChatMessage . getImagePath ( \"<STR_LIT>\" ) ) . getParentFile ( ) ; if", "gt": "( imageDir . exists ( ) ) {", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position , String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , null , selection , selectionArgs , null , null , \"<STR_LIT>\" , String . valueOf ( position ) + \"<STR_LIT>\" ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position ) { return getConversationAtPosition ( position , null ) ; } public List < Conversation > getAllConversations ( ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , null , null , null , null , \"<STR_LIT>\" ) ; List < Conversation > conversations = new ArrayList < > ( ) ; while", "gt": "( cursor . moveToNext ( ) ) {", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position , String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , null , selection , selectionArgs , null , null , \"<STR_LIT>\" , String . valueOf ( position ) + \"<STR_LIT>\" ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position ) { return getConversationAtPosition ( position , null ) ; } public List < Conversation > getAllConversations ( ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , null , null , null , null , \"<STR_LIT>\" ) ; List < Conversation > conversations = new ArrayList < > ( ) ; while ( cursor . moveToNext ( ) ) { Conversation conversation = getConversationByCursor ( cursor ) ; conversations . add ( conversation ) ; } return conversations ; } public long addConversation ( Conversation conversation ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , conversation . time . format ( DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ) ; values . put ( \"<STR_LIT>\" , conversation . title ) ; values . put ( \"<STR_LIT>\" , conversation . messages . toJson ( ) . toString ( ) ) ; conversation . id = db . insert ( DatabaseHelper . tableName , null , values ) ; return conversation . id ; } public void updateConversation ( Conversation conversation ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , conversation . time . format ( DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ) ; values", "gt": ". put ( \"<STR_LIT>\" , conversation . title ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList = findViewById ( R . id . rv_online_temp_list ) ; rvTemplateList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; templateListAdapter = new OnlineTemplateListAdapter ( ) ; rvTemplateList . setAdapter ( templateListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . RIGHT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; templateListAdapter . notifyDataSetChanged ( ) ; Intent", "gt": "intent = new Intent ( ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . baidu . aip . asrwakeup3 . core . util . bluetooth ; import android . bluetooth . BluetoothHeadset ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . media . AudioManager ; import android . util . Log ; public class BluetoothReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( BluetoothHeadset . ACTION_CONNECTION_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( true ) ; } else if ( state == BluetoothHeadset . STATE_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( false ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( BluetoothHeadset . ACTION_AUDIO_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_AUDIO_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( state == BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( AudioManager . ACTION_SCO_AUDIO_STATE_UPDATED ) ) { int state = intent . getIntExtra ( AudioManager . EXTRA_SCO_AUDIO_STATE , AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) ; if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager", "gt": ". getInstance ( context ) . bluetoothHeadetScoConnectionChanged ( true ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList", "gt": "= findViewById ( R . id . rv_online_temp_list ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position , String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , null , selection , selectionArgs , null , null , \"<STR_LIT>\" , String . valueOf ( position ) + \"<STR_LIT>\" ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position ) { return getConversationAtPosition ( position , null ) ; } public List < Conversation > getAllConversations ( ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , null , null , null , null , \"<STR_LIT>\" ) ; List < Conversation > conversations = new ArrayList < > ( ) ; while ( cursor . moveToNext ( ) ) { Conversation conversation = getConversationByCursor ( cursor ) ; conversations . add ( conversation ) ; } return conversations ; } public long addConversation ( Conversation conversation ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , conversation . time . format ( DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ) ; values . put ( \"<STR_LIT>\" , conversation . title ) ; values . put ( \"<STR_LIT>\" , conversation . messages . toJson ( ) . toString ( ) ) ; conversation . id = db . insert ( DatabaseHelper . tableName , null , values ) ; return conversation . id ; } public void updateConversation ( Conversation conversation ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , conversation . time . format ( DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ) ; values . put ( \"<STR_LIT>\" , conversation . title ) ; values . put ( \"<STR_LIT>\" , conversation . messages . toJson ( ) . toString ( ) ) ; db . update ( DatabaseHelper . tableName , values , \"<STR_LIT>\" , new String [ ] { String . valueOf ( conversation . id ) } ) ; } public void removeConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { Conversation conversation = getConversationByCursor ( cursor , false ) ; conversation . messages . deleteAllImageFiles ( ) ; } db . delete ( DatabaseHelper . tableName , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } ) ; } public void removeConversation ( Conversation conversation ) { removeConversation ( conversation . id ) ; } public void removeAllConversations ( ) { File", "gt": "imageDir = new File ( ChatMessage . getImagePath ( \"<STR_LIT>\" ) ) . getParentFile ( ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList = findViewById ( R . id . rv_online_temp_list ) ; rvTemplateList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; templateListAdapter = new OnlineTemplateListAdapter ( ) ; rvTemplateList . setAdapter ( templateListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . RIGHT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; templateListAdapter . notifyDataSetChanged ( ) ; Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . tag ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . content ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } } ) . attachToRecyclerView ( rvTemplateList ) ; ( findViewById ( R . id . bt_online_temp_back ) ) . setOnClickListener ( ( view ) -> { finish ( ) ; } ) ; ( findViewById ( R . id . bt_online_temp_share ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . new_discussion_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; ( findViewById ( R . id . bt_online_temp_github ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . discussions_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; new Thread ( ( ) -> { OkHttpClient client = new OkHttpClient ( ) ; Request", "gt": "request = new Request . Builder ( ) . url ( getString ( R . string . shared_templates_url ) ) . build ( ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList = findViewById ( R . id . rv_online_temp_list ) ; rvTemplateList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; templateListAdapter = new OnlineTemplateListAdapter ( ) ; rvTemplateList . setAdapter ( templateListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . RIGHT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; templateListAdapter . notifyDataSetChanged ( ) ; Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . tag ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . content ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } } ) . attachToRecyclerView ( rvTemplateList ) ; ( findViewById ( R . id . bt_online_temp_back ) ) . setOnClickListener ( ( view ) -> { finish ( ) ; } ) ; ( findViewById ( R . id . bt_online_temp_share ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . new_discussion_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; ( findViewById ( R . id . bt_online_temp_github ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . discussions_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; new Thread ( ( ) -> { OkHttpClient client = new OkHttpClient ( ) ; Request request = new Request . Builder ( ) . url ( getString ( R . string . shared_templates_url ) ) . build ( ) ; try { Response response = client . newCall ( request ) . execute ( ) ; JSONArray jsonArray = new JSONArray ( response . body ( ) . string ( ) ) ; Log . d ( \"<STR_LIT>\" , jsonArray . toString ( ) ) ; onlineTemplates . clear ( ) ; for ( int i = <NUM_LIT> ; i < jsonArray . size ( ) ; i ++ ) { JSONObject jsonObject = jsonArray . getJSONObject ( i ) ; OnlineTemplate onlineTemplate = new OnlineTemplate ( ) ; onlineTemplate . tag = jsonObject . getStr ( \"<STR_LIT>\" ) ; onlineTemplate . content = jsonObject . getStr ( \"<STR_LIT>\" ) ; onlineTemplate . title = jsonObject . getStr ( \"<STR_LIT>\" ) ; onlineTemplate . description = jsonObject . getStr ( \"<STR_LIT>\" ) ; onlineTemplate . pageUrl = jsonObject . getStr ( \"<STR_LIT>\" ) ; onlineTemplates . add ( onlineTemplate ) ; } runOnUiThread ( ( ) -> { findViewById ( R . id . tv_online_temp_status ) . setVisibility ( View . GONE ) ; templateListAdapter . notifyDataSetChanged ( ) ; } ) ; } catch ( IOException e ) { (", "gt": "( TextView ) findViewById ( R . id . tv_online_temp_status ) ) . setText ( R . string . text_online_temp_error ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper", "gt": "= new DatabaseHelper ( context ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position , String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , null , selection , selectionArgs , null , null , \"<STR_LIT>\" , String . valueOf ( position ) + \"<STR_LIT>\" ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position ) { return getConversationAtPosition ( position , null ) ; } public List < Conversation > getAllConversations ( ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , null , null , null , null , \"<STR_LIT>\" ) ; List < Conversation > conversations = new ArrayList < > ( ) ; while ( cursor . moveToNext ( ) ) { Conversation conversation = getConversationByCursor ( cursor ) ; conversations . add ( conversation ) ; } return conversations ; } public long addConversation ( Conversation conversation ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , conversation . time . format ( DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ) ; values . put ( \"<STR_LIT>\" , conversation . title ) ; values", "gt": ". put ( \"<STR_LIT>\" , conversation . messages . toJson ( ) . toString ( ) ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . baidu . aip . asrwakeup3 . core . util . bluetooth ; import android . bluetooth . BluetoothHeadset ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . media . AudioManager ; import android . util . Log ; public class BluetoothReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( BluetoothHeadset . ACTION_CONNECTION_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( true ) ; } else if ( state == BluetoothHeadset . STATE_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( false ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( BluetoothHeadset . ACTION_AUDIO_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_AUDIO_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( state == BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( AudioManager . ACTION_SCO_AUDIO_STATE_UPDATED ) ) { int state = intent . getIntExtra ( AudioManager . EXTRA_SCO_AUDIO_STATE , AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) ; if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetScoConnectionChanged ( true ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetScoConnectionChanged ( false ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTING ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_ERROR ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else", "gt": "if ( action . equals ( BluetoothHeadset . ACTION_VENDOR_SPECIFIC_HEADSET_EVENT ) ) {", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position , String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , null , selection , selectionArgs , null , null , \"<STR_LIT>\" , String . valueOf ( position ) + \"<STR_LIT>\" ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position ) { return getConversationAtPosition ( position , null ) ; } public List < Conversation > getAllConversations ( ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , null , null , null , null , \"<STR_LIT>\" ) ; List < Conversation > conversations = new ArrayList < > ( ) ; while ( cursor . moveToNext ( ) ) { Conversation conversation = getConversationByCursor ( cursor ) ; conversations . add ( conversation ) ; } return conversations ; } public long addConversation ( Conversation conversation ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , conversation . time . format ( DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ) ; values . put ( \"<STR_LIT>\" , conversation . title ) ; values . put ( \"<STR_LIT>\" , conversation . messages . toJson ( ) . toString ( ) ) ; conversation . id = db . insert ( DatabaseHelper . tableName , null , values ) ; return conversation . id ; } public void updateConversation ( Conversation conversation ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , conversation . time . format ( DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ) ; values . put ( \"<STR_LIT>\" , conversation . title ) ; values . put ( \"<STR_LIT>\" , conversation . messages . toJson ( ) . toString ( ) ) ; db . update ( DatabaseHelper . tableName , values , \"<STR_LIT>\" , new String [ ] { String . valueOf ( conversation . id ) } ) ; } public void removeConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { Conversation conversation = getConversationByCursor ( cursor , false ) ; conversation . messages . deleteAllImageFiles ( ) ; } db . delete ( DatabaseHelper . tableName , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } ) ; } public void removeConversation ( Conversation conversation ) { removeConversation ( conversation . id ) ; } public void removeAllConversations ( ) { File imageDir = new File ( ChatMessage . getImagePath ( \"<STR_LIT>\" ) ) . getParentFile ( ) ; if ( imageDir . exists ( ) ) { for ( File file : imageDir . listFiles ( ) ) { file . delete ( ) ; } } db", "gt": ". delete ( DatabaseHelper . tableName , null , null ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList = findViewById ( R . id . rv_online_temp_list ) ; rvTemplateList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; templateListAdapter = new OnlineTemplateListAdapter ( ) ; rvTemplateList . setAdapter ( templateListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . RIGHT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; templateListAdapter . notifyDataSetChanged ( ) ; Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . tag ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . content ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } } ) . attachToRecyclerView ( rvTemplateList ) ; ( findViewById ( R . id . bt_online_temp_back ) ) . setOnClickListener ( ( view ) -> { finish ( ) ; } ) ; ( findViewById ( R . id . bt_online_temp_share ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . new_discussion_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; ( findViewById ( R . id . bt_online_temp_github ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . discussions_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; new Thread ( ( ) -> { OkHttpClient client = new OkHttpClient ( ) ; Request request = new Request . Builder ( ) . url ( getString ( R . string . shared_templates_url ) ) . build ( ) ; try { Response response = client . newCall ( request ) . execute ( ) ; JSONArray jsonArray = new JSONArray ( response . body ( ) . string ( ) ) ; Log . d ( \"<STR_LIT>\" , jsonArray . toString ( ) ) ; onlineTemplates . clear ( ) ; for ( int i = <NUM_LIT> ; i < jsonArray . size ( ) ; i ++ ) { JSONObject jsonObject = jsonArray . getJSONObject ( i ) ; OnlineTemplate onlineTemplate = new OnlineTemplate ( ) ; onlineTemplate . tag = jsonObject . getStr ( \"<STR_LIT>\" ) ; onlineTemplate . content = jsonObject . getStr ( \"<STR_LIT>\" ) ; onlineTemplate . title = jsonObject . getStr ( \"<STR_LIT>\" ) ; onlineTemplate . description = jsonObject . getStr ( \"<STR_LIT>\" ) ; onlineTemplate . pageUrl = jsonObject . getStr ( \"<STR_LIT>\" ) ; onlineTemplates . add ( onlineTemplate ) ; } runOnUiThread ( ( ) -> { findViewById", "gt": "( R . id . tv_online_temp_status ) . setVisibility ( View . GONE ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList = findViewById ( R . id . rv_online_temp_list ) ; rvTemplateList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; templateListAdapter = new OnlineTemplateListAdapter ( ) ; rvTemplateList . setAdapter ( templateListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . RIGHT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; templateListAdapter . notifyDataSetChanged ( ) ; Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . tag ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . content ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } } ) . attachToRecyclerView ( rvTemplateList ) ; ( findViewById ( R . id . bt_online_temp_back ) ) . setOnClickListener ( ( view ) -> { finish ( ) ; } ) ; ( findViewById ( R . id . bt_online_temp_share ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . new_discussion_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; ( findViewById ( R . id . bt_online_temp_github ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri", "gt": "content_url = Uri . parse ( getString ( R . string . discussions_url ) ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String", "gt": "[ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] {", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList = findViewById ( R . id . rv_online_temp_list ) ; rvTemplateList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; templateListAdapter = new OnlineTemplateListAdapter ( ) ; rvTemplateList . setAdapter ( templateListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . RIGHT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; templateListAdapter . notifyDataSetChanged ( ) ; Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . tag ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . content ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } } ) . attachToRecyclerView ( rvTemplateList ) ; ( findViewById ( R . id . bt_online_temp_back ) ) . setOnClickListener ( ( view ) -> { finish ( ) ; } ) ; ( findViewById ( R . id . bt_online_temp_share ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . new_discussion_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; ( findViewById ( R . id . bt_online_temp_github ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . discussions_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; new Thread ( ( ) -> { OkHttpClient client = new OkHttpClient ( ) ; Request request = new Request . Builder ( ) . url ( getString ( R . string . shared_templates_url ) ) . build ( ) ; try { Response response = client . newCall ( request ) . execute ( ) ; JSONArray jsonArray = new JSONArray ( response . body ( ) . string ( ) ) ; Log", "gt": ". d ( \"<STR_LIT>\" , jsonArray . toString ( ) ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList = findViewById ( R . id . rv_online_temp_list ) ; rvTemplateList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; templateListAdapter = new OnlineTemplateListAdapter ( ) ; rvTemplateList . setAdapter ( templateListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . RIGHT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; templateListAdapter . notifyDataSetChanged ( ) ; Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . tag ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . content ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } } ) . attachToRecyclerView ( rvTemplateList ) ; ( findViewById ( R . id . bt_online_temp_back ) ) . setOnClickListener ( ( view ) -> { finish ( ) ; } ) ; ( findViewById ( R . id . bt_online_temp_share ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri", "gt": "content_url = Uri . parse ( getString ( R . string . new_discussion_url ) ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } ,", "gt": "selection , selectionArgs , null , null , null ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . baidu . aip . asrwakeup3 . core . util . bluetooth ; import android . bluetooth . BluetoothHeadset ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . media . AudioManager ; import android . util . Log ; public class BluetoothReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( BluetoothHeadset . ACTION_CONNECTION_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( true ) ; } else if ( state == BluetoothHeadset . STATE_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( false ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( BluetoothHeadset . ACTION_AUDIO_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_AUDIO_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( state == BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( AudioManager . ACTION_SCO_AUDIO_STATE_UPDATED ) ) { int state = intent . getIntExtra ( AudioManager . EXTRA_SCO_AUDIO_STATE , AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) ; if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetScoConnectionChanged ( true ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetScoConnectionChanged ( false ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTING ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_ERROR ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( BluetoothHeadset . ACTION_VENDOR_SPECIFIC_HEADSET_EVENT ) ) { String command = intent . getStringExtra ( BluetoothHeadset . EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD ) ; int type = intent . getIntExtra ( BluetoothHeadset . EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE , - <NUM_LIT> ) ; String commandType ; switch ( type ) { case BluetoothHeadset . AT_CMD_TYPE_ACTION : commandType = \"<STR_LIT>\" ; break ; case BluetoothHeadset . AT_CMD_TYPE_READ : commandType = \"<STR_LIT>\" ; break ; case BluetoothHeadset . AT_CMD_TYPE_TEST : commandType = \"<STR_LIT>\" ; break ; case BluetoothHeadset . AT_CMD_TYPE_SET : commandType = \"<STR_LIT>\" ; break ; case BluetoothHeadset . AT_CMD_TYPE_BASIC : commandType = \"<STR_LIT>\" ; break ; default : commandType = \"<STR_LIT>\" ; break ; } Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" + commandType + \"<STR_LIT>\" + command ) ; } else { Log", "gt": ". w ( \"<STR_LIT>\" , \"<STR_LIT>\" + action ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList = findViewById ( R . id . rv_online_temp_list ) ; rvTemplateList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; templateListAdapter = new OnlineTemplateListAdapter ( ) ; rvTemplateList . setAdapter ( templateListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . RIGHT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; templateListAdapter . notifyDataSetChanged ( ) ; Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . tag ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . content ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } } ) . attachToRecyclerView ( rvTemplateList ) ; ( findViewById ( R . id . bt_online_temp_back ) ) . setOnClickListener ( ( view ) -> { finish ( ) ; } ) ; ( findViewById ( R . id . bt_online_temp_share ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . new_discussion_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; ( findViewById ( R . id . bt_online_temp_github ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . discussions_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; new Thread ( ( ) -> { OkHttpClient client = new OkHttpClient ( ) ; Request request = new Request . Builder ( ) . url ( getString ( R . string . shared_templates_url ) ) . build ( ) ; try { Response response = client . newCall ( request ) . execute ( ) ; JSONArray jsonArray = new JSONArray ( response . body ( ) . string ( ) ) ; Log . d ( \"<STR_LIT>\" , jsonArray . toString ( ) ) ; onlineTemplates . clear ( ) ; for ( int i = <NUM_LIT> ; i < jsonArray . size ( ) ; i ++ ) { JSONObject jsonObject = jsonArray . getJSONObject ( i ) ; OnlineTemplate", "gt": "onlineTemplate = new OnlineTemplate ( ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position , String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , null , selection , selectionArgs , null , null , \"<STR_LIT>\" , String . valueOf ( position ) + \"<STR_LIT>\" ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position ) { return getConversationAtPosition ( position , null ) ; } public List < Conversation > getAllConversations ( ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , null , null , null , null , \"<STR_LIT>\" ) ; List < Conversation > conversations = new ArrayList < > ( ) ; while ( cursor . moveToNext ( ) ) { Conversation conversation = getConversationByCursor ( cursor ) ; conversations . add ( conversation ) ; } return conversations ; } public long addConversation ( Conversation conversation ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , conversation . time . format ( DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ) ; values . put ( \"<STR_LIT>\" , conversation . title ) ; values . put ( \"<STR_LIT>\" , conversation . messages . toJson ( ) . toString ( ) ) ; conversation . id = db . insert ( DatabaseHelper . tableName , null , values ) ; return conversation . id ; } public void updateConversation ( Conversation conversation ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , conversation . time . format ( DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ) ; values . put ( \"<STR_LIT>\" , conversation . title ) ; values . put ( \"<STR_LIT>\" , conversation . messages . toJson ( ) . toString ( ) ) ; db . update ( DatabaseHelper . tableName , values , \"<STR_LIT>\" , new String [ ] { String . valueOf ( conversation . id ) } ) ; } public void removeConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { Conversation conversation = getConversationByCursor ( cursor , false ) ; conversation", "gt": ". messages . deleteAllImageFiles ( ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation", "gt": ". title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position , String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , null , selection , selectionArgs , null , null , \"<STR_LIT>\" , String . valueOf ( position ) + \"<STR_LIT>\" ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position ) { return", "gt": "getConversationAtPosition ( position , null ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . baidu . aip . asrwakeup3 . core . wakeup . listener ; import com . baidu . aip . asrwakeup3 . core . wakeup . WakeUpResult ; public interface IWakeupListener { void onSuccess ( String word , WakeUpResult result ) ; void onStop ( ) ; void", "gt": "onError ( int errorCode , String errorMessge , WakeUpResult result ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if", "gt": "( cursor . moveToFirst ( ) ) {", "repo": "gpt-assistant-android"}
{"input": "package com . baidu . aip . asrwakeup3 . core . util . bluetooth ; import android . bluetooth . BluetoothHeadset ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . media . AudioManager ; import android . util . Log ; public class BluetoothReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( BluetoothHeadset . ACTION_CONNECTION_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( true ) ; } else if ( state == BluetoothHeadset . STATE_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( false ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( BluetoothHeadset . ACTION_AUDIO_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_AUDIO_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( state == BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( AudioManager . ACTION_SCO_AUDIO_STATE_UPDATED ) ) { int state = intent . getIntExtra ( AudioManager . EXTRA_SCO_AUDIO_STATE , AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) ; if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetScoConnectionChanged ( true ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager", "gt": ". getInstance ( context ) . bluetoothHeadetScoConnectionChanged ( false ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList = findViewById ( R . id . rv_online_temp_list ) ; rvTemplateList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; templateListAdapter = new OnlineTemplateListAdapter ( ) ; rvTemplateList . setAdapter ( templateListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . RIGHT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; templateListAdapter . notifyDataSetChanged ( ) ; Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . tag ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . content ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } } ) . attachToRecyclerView ( rvTemplateList ) ; ( findViewById ( R . id . bt_online_temp_back ) ) . setOnClickListener ( ( view ) -> { finish ( ) ; } ) ; ( findViewById ( R . id . bt_online_temp_share ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . new_discussion_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; ( findViewById ( R . id . bt_online_temp_github ) ) . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( getString ( R . string . discussions_url ) ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } ) ; new Thread ( ( ) -> { OkHttpClient client = new OkHttpClient ( ) ; Request request = new Request . Builder ( ) . url ( getString ( R . string . shared_templates_url ) ) . build ( ) ; try { Response response = client . newCall ( request ) . execute ( ) ; JSONArray jsonArray = new JSONArray ( response . body ( ) . string ( ) ) ; Log . d ( \"<STR_LIT>\" , jsonArray . toString ( ) ) ; onlineTemplates . clear ( ) ; for ( int i = <NUM_LIT> ; i < jsonArray . size ( ) ; i ++ ) { JSONObject jsonObject = jsonArray . getJSONObject ( i ) ; OnlineTemplate onlineTemplate = new OnlineTemplate ( ) ; onlineTemplate . tag = jsonObject . getStr ( \"<STR_LIT>\" ) ; onlineTemplate", "gt": ". content = jsonObject . getStr ( \"<STR_LIT>\" ) ;", "repo": "gpt-assistant-android"}
{"input": "package com . baidu . aip . asrwakeup3 . core . util . bluetooth ; import android . bluetooth . BluetoothHeadset ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . media . AudioManager ; import android . util . Log ; public class BluetoothReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( BluetoothHeadset . ACTION_CONNECTION_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( true ) ; } else if ( state == BluetoothHeadset . STATE_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( false ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( BluetoothHeadset . ACTION_AUDIO_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_AUDIO_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( state == BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( AudioManager . ACTION_SCO_AUDIO_STATE_UPDATED ) ) { int state = intent . getIntExtra ( AudioManager . EXTRA_SCO_AUDIO_STATE , AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) ; if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetScoConnectionChanged ( true ) ; } else", "gt": "if ( state == AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) {", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position , String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String", "gt": "[ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] {", "repo": "gpt-assistant-android"}
{"input": "package com . baidu . aip . asrwakeup3 . core . util . bluetooth ; import android . bluetooth . BluetoothHeadset ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . media . AudioManager ; import android . util . Log ; public class BluetoothReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( BluetoothHeadset . ACTION_CONNECTION_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( true ) ; } else if ( state == BluetoothHeadset . STATE_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetConnectionChanged ( false ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( BluetoothHeadset . ACTION_AUDIO_STATE_CHANGED ) ) { int state = intent . getIntExtra ( BluetoothHeadset . EXTRA_STATE , BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) ; if ( state == BluetoothHeadset . STATE_AUDIO_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( state == BluetoothHeadset . STATE_AUDIO_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } } else if ( action . equals ( AudioManager . ACTION_SCO_AUDIO_STATE_UPDATED ) ) { int state = intent . getIntExtra ( AudioManager . EXTRA_SCO_AUDIO_STATE , AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) ; if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetScoConnectionChanged ( true ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . bluetoothHeadetScoConnectionChanged ( false ) ; } else", "gt": "if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTING ) {", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . LinearLayout ; import android . widget . TextView ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class OnlineTemplatesActivity extends Activity { private class OnlineTemplate { public String tag , content , title , description , pageUrl ; } private class OnlineTemplateListAdapter extends RecyclerView . Adapter < OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder > { @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . oline_temp_list_item , parent , false ) ; return new OnlineTemplatesActivity . OnlineTemplateListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { OnlineTemplate onlineTemplate = onlineTemplates . get ( position ) ; holder . tvTitle . setText ( onlineTemplate . title ) ; holder . tvDesc . setText ( onlineTemplate . description . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } @ Override public int getItemCount ( ) { return onlineTemplates . size ( ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDesc ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_online_temp_item_title ) ; tvDesc = itemView . findViewById ( R . id . tv_online_temp_item_desc ) ; llOuter = itemView . findViewById ( R . id . ll_online_temp_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { OnlineTemplate onlineTemplate = onlineTemplates . get ( getAdapterPosition ( ) ) ; if ( onlineTemplate . pageUrl != null ) { Intent intent = new Intent ( ) ; intent . setAction ( \"<STR_LIT>\" ) ; Uri content_url = Uri . parse ( onlineTemplate . pageUrl ) ; intent . setData ( content_url ) ; startActivity ( intent ) ; } } ) ; } } } List < OnlineTemplate > onlineTemplates = new ArrayList < > ( ) ; RecyclerView rvTemplateList ; OnlineTemplateListAdapter templateListAdapter ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_online_templates ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; rvTemplateList = findViewById ( R . id . rv_online_temp_list ) ; rvTemplateList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; templateListAdapter = new OnlineTemplateListAdapter ( ) ; rvTemplateList . setAdapter ( templateListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . RIGHT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; templateListAdapter . notifyDataSetChanged ( ) ; Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . tag ) ; intent . putExtra ( \"<STR_LIT>\" , onlineTemplates . get ( position ) . content ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } } ) . attachToRecyclerView ( rvTemplateList ) ; (", "gt": "findViewById ( R . id . bt_online_temp_back ) ) . setOnClickListener ( ( view ) -> {", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final", "gt": "static private int version = <NUM_LIT> ;", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor", "gt": "cursor = db . query ( DatabaseHelper . tableName , new String [ ] {", "repo": "gpt-assistant-android"}
{"input": "package com . skythinker . gptassistant ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Base64 ; import android . util . Log ; import androidx . annotation . Nullable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import cn . hutool . crypto . digest . MD5 ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; @ SuppressLint ( \"<STR_LIT>\" ) public class ChatManager { public static class ChatMessage { static private Context context ; static public void setContext ( Context context ) { ChatMessage . context = context ; } public enum ChatRole { SYSTEM , USER , ASSISTANT , FUNCTION ; public static ChatRole fromName ( String name ) { for ( ChatRole role : ChatRole . values ( ) ) { if ( role . name ( ) . equals ( name ) ) { return role ; } } return null ; } } public ChatRole role ; public String contentText ; public String contentImageBase64 ; private String imageUuid ; public String functionName ; public ChatMessage ( ChatRole role ) { this . role = role ; } public ChatMessage setText ( String text ) { this . contentText = text ; return this ; } public ChatMessage setFunction ( String name ) { this . functionName = name ; return this ; } public ChatMessage setImage ( String base64 ) { this . contentImageBase64 = base64 ; this . imageUuid = UUID . randomUUID ( ) . toString ( ) ; return this ; } public void deleteImageFile ( ) { if ( imageUuid != null ) { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } public void saveImageFile ( ) { if ( imageUuid != null && contentImageBase64 != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( ! file . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( Base64 . decode ( contentImageBase64 , Base64 . NO_WRAP ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void loadImageFile ( ) { if ( imageUuid != null ) { try { File file = new File ( getImagePath ( imageUuid ) ) ; if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ fis . available ( ) ] ; fis . read ( buffer ) ; contentImageBase64 = Base64 . encodeToString ( buffer , Base64 . NO_WRAP ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } static public String getImagePath ( String uuid ) { return context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" ; } public JSONObject toJson ( ) { saveImageFile ( ) ; JSONObject json = new JSONObject ( ) ; json . putOpt ( \"<STR_LIT>\" , role . name ( ) ) . putOpt ( \"<STR_LIT>\" , contentText ) . putOpt ( \"<STR_LIT>\" , imageUuid ) . putOpt ( \"<STR_LIT>\" , functionName ) ; return json ; } public static ChatMessage fromJson ( JSONObject json , boolean loadImage ) { ChatMessage msg = new ChatMessage ( ChatRole . fromName ( json . getStr ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; msg . contentText = json . getStr ( \"<STR_LIT>\" , null ) ; msg . imageUuid = json . getStr ( \"<STR_LIT>\" , null ) ; msg . functionName = json . getStr ( \"<STR_LIT>\" , null ) ; if ( loadImage ) { msg . loadImageFile ( ) ; } return msg ; } } public static class MessageList extends ArrayList < ChatMessage > { public void deleteAllImageFiles ( ) { for ( ChatMessage msg : this ) { msg . deleteImageFile ( ) ; } } public JSONArray toJson ( ) { JSONArray json = new JSONArray ( ) ; for ( ChatMessage msg : this ) { json . put ( msg . toJson ( ) ) ; } return json ; } public static MessageList fromJson ( JSONArray json , boolean loadImages ) { MessageList list = new MessageList ( ) ; for ( int i = <NUM_LIT> ; i < json . size ( ) ; i ++ ) { list . add ( ChatMessage . fromJson ( json . getJSONObject ( i ) , loadImages ) ) ; } return list ; } } public static class Conversation { public long id ; public LocalDateTime time ; public String title ; public MessageList messages ; public Conversation ( ) { id = - <NUM_LIT> ; time = LocalDateTime . now ( ) ; title = \"<STR_LIT>\" ; messages = new MessageList ( ) ; } public void updateTime ( ) { time = LocalDateTime . now ( ) ; } } private class DatabaseHelper extends SQLiteOpenHelper { final static private String databaseName = \"<STR_LIT>\" ; final static private String tableName = \"<STR_LIT>\" ; final static private int version = <NUM_LIT> ; public DatabaseHelper ( Context context ) { super ( context , databaseName , null , version ) ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; sqLiteDatabase . execSQL ( sql ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } } private DatabaseHelper dbHelper ; private SQLiteDatabase db ; public ChatManager ( Context context ) { dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; } public void destroy ( ) { db . close ( ) ; } private String escapeLikeText ( String text ) { return text . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public long getConversationCount ( String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , new String [ ] { \"<STR_LIT>\" } , selection , selectionArgs , null , null , null ) ; cursor . moveToFirst ( ) ; return cursor . getLong ( <NUM_LIT> ) ; } public long getConversationCount ( ) { return getConversationCount ( null ) ; } private Conversation getConversationByCursor ( Cursor cursor , boolean loadImages ) { Conversation conversation = new Conversation ( ) ; conversation . id = cursor . getLong ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . time = LocalDateTime . parse ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , DateTimeFormatter . ISO_LOCAL_DATE_TIME ) ; conversation . title = cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; conversation . messages = MessageList . fromJson ( new JSONArray ( cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) , loadImages ) ; return conversation ; } private Conversation getConversationByCursor ( Cursor cursor ) { return getConversationByCursor ( cursor , true ) ; } public Conversation getConversation ( long id ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position , String filterTitleText ) { String selection = ( filterTitleText == null ) ? null : \"<STR_LIT>\" ; String [ ] selectionArgs = ( filterTitleText == null ) ? null : new String [ ] { \"<STR_LIT>\" + escapeLikeText ( filterTitleText ) + \"<STR_LIT>\" } ; Cursor cursor = db . query ( DatabaseHelper . tableName , null , selection , selectionArgs , null , null , \"<STR_LIT>\" , String . valueOf ( position ) + \"<STR_LIT>\" ) ; if ( cursor . moveToFirst ( ) ) { return getConversationByCursor ( cursor ) ; } return null ; } public Conversation getConversationAtPosition ( int position ) { return getConversationAtPosition ( position , null ) ; } public List < Conversation > getAllConversations ( ) { Cursor cursor = db . query ( DatabaseHelper . tableName , null , null , null , null , null , \"<STR_LIT>\" ) ; List", "gt": "< Conversation > conversations = new ArrayList < > ( ) ;", "repo": "gpt-assistant-android"}
{"input": "package org . woheller69 . weather . activities ; import android . content . Context ; import android . os . Bundle ; import com . google . android . material . floatingactionbutton . FloatingActionButton ; import androidx . appcompat . app . AlertDialog ; import androidx . fragment . app . FragmentManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . recyclerview . widget . ItemTouchHelper ; import android . view . Gravity ; import android . view . View ; import android . view . WindowManager ; import android . widget . EditText ; import android . widget . Toast ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . City ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . dialogs . AddLocationDialogOmGeocodingAPI ; import org . woheller69 . weather . ui . RecycleList . RecyclerItemClickListener ; import org . woheller69 . weather . ui . RecycleList . RecyclerOverviewListAdapter ; import org . woheller69 . weather . ui . RecycleList . SimpleItemTouchHelperCallback ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; public class ManageLocationsActivity extends NavigationActivity { private SQLiteHelper database ; private ItemTouchHelper . Callback callback ; private ItemTouchHelper touchHelper ; RecyclerOverviewListAdapter adapter ; List < CityToWatch > cities ; Context context ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_manage_locations ) ; context = this ; database = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; try { cities = database . getAllCitiesToWatch ( ) ; Collections . sort ( cities , new Comparator < CityToWatch > ( ) { @ Override public int compare ( CityToWatch o1 , CityToWatch o2 ) { return o1 . getRank ( ) - o2 . getRank ( ) ; } } ) ; } catch ( NullPointerException e ) { e . printStackTrace ( ) ; Toast toast = Toast . makeText ( getBaseContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) ; toast . show ( ) ; } RecyclerView recyclerView = ( RecyclerView ) findViewById ( R . id . list_view_cities ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( this ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; recyclerView . addOnItemTouchListener ( new RecyclerItemClickListener ( getBaseContext ( ) , recyclerView , new RecyclerItemClickListener . OnItemClickListener ( ) { @ Override public void onItemClick ( View view , int position ) { AlertDialog . Builder alert = new AlertDialog . Builder ( context ) ; final EditText edittext = new EditText ( context ) ; edittext . setText ( adapter . getCityName ( position ) ) ; edittext . setTextSize ( <NUM_LIT> ) ; edittext . setGravity ( Gravity . CENTER ) ; alert . setTitle ( getString ( R . string . edit_location_hint_name ) ) ; alert . setView ( edittext ) ; alert . setPositiveButton ( getString ( R . string . dialog_edit_change_button ) , ( dialog , whichButton ) -> adapter . renameCity ( position , String . valueOf ( edittext . getText ( ) ) ) ) ; alert . setNegativeButton ( getString ( R . string . dialog_add_close_button ) , ( dialog , whichButton ) -> { } ) ; alert . show ( ) ; } public void onLongItemClick ( View view , int position ) { } } ) ) ; adapter = new RecyclerOverviewListAdapter ( getApplicationContext ( ) , cities ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setFocusable ( false ) ; callback = new SimpleItemTouchHelperCallback ( adapter ) ; touchHelper = new ItemTouchHelper ( callback ) ; touchHelper . attachToRecyclerView ( recyclerView ) ; FloatingActionButton addFab1 = ( FloatingActionButton ) findViewById ( R . id . fabAddLocation ) ; if ( addFab1 != null ) { addFab1 . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { FragmentManager fragmentManager = getSupportFragmentManager ( ) ; AddLocationDialogOmGeocodingAPI addLocationDialog = new AddLocationDialogOmGeocodingAPI ( ) ; addLocationDialog . show ( fragmentManager , \"<STR_LIT>\" ) ; getSupportFragmentManager ( ) . executePendingTransactions ( ) ; } } ) ; } } @ Override protected void onResume ( ) { super . onResume ( ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; } @ Override protected int getNavigationDrawerID ( ) { return R . id . nav_manage ; } public void addCityToList ( City city ) { CityToWatch newCity = convertCityToWatched ( city ) ; long", "gt": "id = database . addCityToWatch ( newCity ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else { return R . drawable . ic_wind_lightred ; } } public static Drawable colorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_violet , null ) ; } } public static Integer widgetColorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_green ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_yellow ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_orange ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_lightred ; } else { return R . drawable . rounded_violet ; } } public static Integer getDayShort ( int day ) { switch ( day ) { case Calendar . MONDAY : day = R . string . abbreviation_monday ; break ; case Calendar . TUESDAY : day = R . string . abbreviation_tuesday ; break ; case Calendar . WEDNESDAY : day = R . string . abbreviation_wednesday ; break ; case Calendar . THURSDAY : day = R . string . abbreviation_thursday ; break ; case Calendar . FRIDAY : day = R . string . abbreviation_friday ; break ; case Calendar . SATURDAY : day = R . string . abbreviation_saturday ; break ; case Calendar . SUNDAY : day = R . string . abbreviation_sunday ; break ; default : day = R . string . abbreviation_monday ; } return day ; } public static Integer getDayLong ( int day ) { switch ( day ) { case Calendar . MONDAY : day = R . string . monday ; break ; case Calendar . TUESDAY : day = R . string . tuesday ; break ; case Calendar . WEDNESDAY : day = R . string . wednesday ; break ; case Calendar . THURSDAY : day = R . string . thursday ; break ; case Calendar . FRIDAY : day = R . string . friday ; break ; case Calendar . SATURDAY : day = R . string . saturday ; break ; case Calendar . SUNDAY : day = R . string . sunday ; break ; default : day = R . string . monday ; } return day ; } public static String removeMinusIfZerosOnly ( String string ) { return", "gt": "string . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . CHART ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . DAY ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . DETAILS ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . EMPTY ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . OVERVIEW ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . WEEK ; import android . annotation . SuppressLint ; import android . content . Context ; import android . os . Bundle ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fragment . app . Fragment ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . recyclerview . widget . StaggeredGridLayoutManager ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ForecastCityActivity ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter ; import org . woheller69 . weather . ui . RecycleList . OnSwipeDownListener ; import org . woheller69 . weather . ui . updater . IUpdateableCityUI ; import org . woheller69 . weather . ui . updater . ViewUpdater ; import org . woheller69 . weather . ui . viewPager . WeatherPagerAdapter ; import java . util . List ; public class WeatherCityFragment extends Fragment implements IUpdateableCityUI { private static final int MINGRIDWIDTH = <NUM_LIT> ; private int mCityId = - <NUM_LIT> ; private int [ ] mDataSetTypes = new int [ ] { } ; private static int [ ] mFull = { OVERVIEW , DAY , WEEK , CHART } ; private static int [ ] mEmpty = { EMPTY } ; private CityWeatherAdapter mAdapter ; private RecyclerView recyclerView ; public static WeatherCityFragment newInstance ( Bundle args ) { WeatherCityFragment weatherCityFragment = new WeatherCityFragment ( ) ; weatherCityFragment . setArguments ( args ) ; return weatherCityFragment ; } public void setAdapter ( CityWeatherAdapter adapter ) { mAdapter = adapter ; if ( recyclerView != null ) { recyclerView . setAdapter ( mAdapter ) ; recyclerView . setFocusable ( false ) ; recyclerView . setLayoutManager ( getLayoutManager ( getContext ( ) ) ) ; } } public void loadData ( ) { CurrentWeatherData currentWeatherData = SQLiteHelper . getInstance ( getContext ( ) ) . getCurrentWeatherByCityId ( mCityId ) ; if ( currentWeatherData . getTimestamp ( ) == <NUM_LIT> ) mDataSetTypes = mEmpty ; else mDataSetTypes = mFull ; mAdapter = new CityWeatherAdapter ( currentWeatherData , mDataSetTypes , getContext ( ) ) ; setAdapter ( mAdapter ) ; } @ Override public void onAttach ( @ NonNull Context context ) { super . onAttach ( context ) ; ViewUpdater . addSubscriber ( this ) ; } @ Override public void onDetach ( ) { ViewUpdater . removeSubscriber ( this ) ; super . onDetach ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { final", "gt": "View v = inflater . inflate ( R . layout . fragment_weather_forecast_city_overview , container , false ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else { return R . drawable . ic_wind_lightred ; } } public static Drawable colorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else", "gt": "if ( uvindex <= <NUM_LIT> ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else { return R . drawable . ic_wind_lightred ; } } public static Drawable colorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_violet , null ) ; } } public static Integer widgetColorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_green ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_yellow ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_orange ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_lightred ; } else { return R . drawable . rounded_violet ; } } public static Integer getDayShort ( int day ) { switch ( day ) { case Calendar . MONDAY : day = R . string . abbreviation_monday ; break ; case Calendar . TUESDAY : day = R . string . abbreviation_tuesday ; break ; case Calendar . WEDNESDAY : day = R . string . abbreviation_wednesday ; break ; case Calendar . THURSDAY : day = R . string . abbreviation_thursday ; break ; case Calendar . FRIDAY : day = R . string . abbreviation_friday ; break ; case Calendar . SATURDAY : day = R . string . abbreviation_saturday ; break ; case", "gt": "Calendar . SUNDAY : day = R . string . abbreviation_sunday ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . services ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Handler ; import androidx . preference . PreferenceManager ; import androidx . core . app . JobIntentService ; import android . widget . Toast ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . NavigationActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . weather_api . IHttpRequestForWeatherAPI ; import org . woheller69 . weather . weather_api . open_meteo . OMHttpRequestForWeatherAPI ; import java . io . IOException ; import java . net . InetAddress ; import java . net . URL ; import java . util . List ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class UpdateDataService extends JobIntentService { public static final String UPDATE_FORECAST_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_ALL_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_SINGLE_ACTION = \"<STR_LIT>\" ; public static final String CITY_ID = \"<STR_LIT>\" ; public static final String SKIP_UPDATE_INTERVAL = \"<STR_LIT>\" ; private static final long MIN_UPDATE_INTERVAL = <NUM_LIT> ; private SQLiteHelper dbHelper ; private SharedPreferences prefManager ; public UpdateDataService ( ) { super ( ) ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; dbHelper = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; } @ Override protected void onHandleWork ( Intent intent ) { if ( ! isOnline ( <NUM_LIT> ) ) { Handler h = new Handler ( getApplicationContext ( ) . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { if ( NavigationActivity . isVisible ) Toast . makeText ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . error_no_internet ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; return ; } if ( intent != null ) { if ( UPDATE_ALL_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateAll ( intent ) ; else if ( UPDATE_FORECAST_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateForecastAction ( intent ) ; else if ( UPDATE_SINGLE_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateSingle ( intent ) ; } } private void handleUpdateAll ( Intent intent ) { List < CityToWatch > cities = dbHelper . getAllCitiesToWatch ( ) ; for ( CityToWatch c : cities ) { handleUpdateForecastAction ( intent , c . getCityId ( ) , c . getLatitude ( ) , c . getLongitude ( ) ) ; } } private void handleUpdateSingle ( Intent intent ) { int cityId = intent . getIntExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; CityToWatch city = dbHelper . getCityToWatch ( cityId ) ; handleUpdateForecastAction ( intent , cityId , city . getLatitude ( ) , city . getLongitude ( ) ) ; } private void handleUpdateForecastAction ( Intent intent , int cityId , float lat , float lon ) { boolean skipUpdateInterval = intent . getBooleanExtra ( SKIP_UPDATE_INTERVAL , false ) ; long timestamp = <NUM_LIT> ; long systemTime = System . currentTimeMillis ( ) / <NUM_LIT> ; long updateInterval = ( long ) ( Float . parseFloat ( prefManager . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) * <NUM_LIT> * <NUM_LIT> ) ; List < HourlyForecast > hourlyForecasts = dbHelper . getForecastsByCityId ( cityId ) ; if ( hourlyForecasts . size ( ) > <NUM_LIT> ) { timestamp = hourlyForecasts . get ( <NUM_LIT> ) . getTimestamp ( ) ; } if ( skipUpdateInterval ) { if ( ( timestamp + MIN_UPDATE_INTERVAL - systemTime ) > <NUM_LIT> ) skipUpdateInterval = false ; } if ( skipUpdateInterval || timestamp + updateInterval - systemTime <= <NUM_LIT> ) { IHttpRequestForWeatherAPI omHttpRequestForWeatherAPI = new OMHttpRequestForWeatherAPI ( getApplicationContext ( ) ) ; omHttpRequestForWeatherAPI . perform ( lat , lon , cityId ) ; } } private boolean isOnline ( int timeOut ) { InetAddress inetAddress = null ; try { Future < InetAddress > future = Executors . newSingleThreadExecutor ( ) . submit ( ( ) -> { try { URL url = new URL ( BuildConfig . BASE_URL ) ; return InetAddress . getByName ( url . getHost ( ) ) ; } catch ( IOException e ) { return null ; } } ) ; inetAddress = future . get ( timeOut , TimeUnit . MILLISECONDS ) ; future . cancel ( true ) ; } catch ( InterruptedException | ExecutionException | TimeoutException e ) { } return inetAddress != null && ! inetAddress . toString ( ) . isEmpty ( ) ; } private void handleUpdateForecastAction ( Intent intent ) { int", "gt": "cityId = intent . getIntExtra ( CITY_ID , - <NUM_LIT> ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return", "gt": "ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . services ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Handler ; import androidx . preference . PreferenceManager ; import androidx . core . app . JobIntentService ; import android . widget . Toast ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . NavigationActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . weather_api . IHttpRequestForWeatherAPI ; import org . woheller69 . weather . weather_api . open_meteo . OMHttpRequestForWeatherAPI ; import java . io . IOException ; import java . net . InetAddress ; import java . net . URL ; import java . util . List ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class UpdateDataService extends JobIntentService { public static final String UPDATE_FORECAST_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_ALL_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_SINGLE_ACTION = \"<STR_LIT>\" ; public static final String CITY_ID = \"<STR_LIT>\" ; public static final String SKIP_UPDATE_INTERVAL = \"<STR_LIT>\" ; private static final long MIN_UPDATE_INTERVAL = <NUM_LIT> ; private SQLiteHelper dbHelper ; private SharedPreferences prefManager ; public UpdateDataService ( ) { super ( ) ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; dbHelper = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; } @ Override protected void onHandleWork ( Intent intent ) { if ( ! isOnline ( <NUM_LIT> ) ) { Handler h = new Handler ( getApplicationContext ( ) . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { if ( NavigationActivity . isVisible ) Toast . makeText ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . error_no_internet ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; return ; } if ( intent != null ) { if ( UPDATE_ALL_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateAll ( intent ) ; else if ( UPDATE_FORECAST_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateForecastAction ( intent ) ; else if ( UPDATE_SINGLE_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateSingle ( intent ) ; } } private void handleUpdateAll ( Intent intent ) { List < CityToWatch > cities = dbHelper . getAllCitiesToWatch ( ) ; for ( CityToWatch c : cities ) { handleUpdateForecastAction ( intent , c . getCityId ( ) , c . getLatitude ( ) , c . getLongitude ( ) ) ; } } private void handleUpdateSingle ( Intent intent ) { int cityId = intent . getIntExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; CityToWatch city = dbHelper . getCityToWatch ( cityId ) ; handleUpdateForecastAction ( intent , cityId , city . getLatitude ( ) , city . getLongitude ( ) ) ; } private void handleUpdateForecastAction ( Intent intent , int cityId , float lat , float lon ) { boolean skipUpdateInterval = intent . getBooleanExtra ( SKIP_UPDATE_INTERVAL , false ) ; long timestamp = <NUM_LIT> ; long systemTime = System . currentTimeMillis ( ) / <NUM_LIT> ; long updateInterval = ( long ) ( Float . parseFloat ( prefManager . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) * <NUM_LIT> * <NUM_LIT> ) ; List < HourlyForecast > hourlyForecasts = dbHelper . getForecastsByCityId ( cityId ) ; if ( hourlyForecasts . size ( ) > <NUM_LIT> ) { timestamp = hourlyForecasts . get ( <NUM_LIT> ) . getTimestamp ( ) ; } if ( skipUpdateInterval ) { if ( ( timestamp + MIN_UPDATE_INTERVAL - systemTime ) > <NUM_LIT> ) skipUpdateInterval = false ; } if ( skipUpdateInterval || timestamp + updateInterval - systemTime <= <NUM_LIT> ) { IHttpRequestForWeatherAPI omHttpRequestForWeatherAPI = new OMHttpRequestForWeatherAPI ( getApplicationContext ( ) ) ; omHttpRequestForWeatherAPI . perform ( lat , lon , cityId ) ; } } private boolean isOnline ( int timeOut ) { InetAddress inetAddress = null ; try { Future < InetAddress > future = Executors . newSingleThreadExecutor ( ) . submit ( ( ) -> { try { URL url = new URL ( BuildConfig . BASE_URL ) ; return InetAddress . getByName ( url . getHost ( ) ) ; } catch ( IOException e ) { return null ; } } ) ; inetAddress = future . get ( timeOut , TimeUnit . MILLISECONDS ) ; future . cancel ( true ) ; } catch ( InterruptedException | ExecutionException | TimeoutException e ) { } return", "gt": "inetAddress != null && ! inetAddress . toString ( ) . isEmpty ( ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else", "gt": "if ( wind_speed < <NUM_LIT> ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . activities ; import android . content . Context ; import android . os . Bundle ; import com . google . android . material . floatingactionbutton . FloatingActionButton ; import androidx . appcompat . app . AlertDialog ; import androidx . fragment . app . FragmentManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . recyclerview . widget . ItemTouchHelper ; import android . view . Gravity ; import android . view . View ; import android . view . WindowManager ; import android . widget . EditText ; import android . widget . Toast ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . City ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . dialogs . AddLocationDialogOmGeocodingAPI ; import org . woheller69 . weather . ui . RecycleList . RecyclerItemClickListener ; import org . woheller69 . weather . ui . RecycleList . RecyclerOverviewListAdapter ; import org . woheller69 . weather . ui . RecycleList . SimpleItemTouchHelperCallback ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; public class ManageLocationsActivity extends NavigationActivity { private SQLiteHelper database ; private ItemTouchHelper . Callback callback ; private ItemTouchHelper touchHelper ; RecyclerOverviewListAdapter adapter ; List < CityToWatch > cities ; Context context ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_manage_locations ) ; context = this ; database = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; try { cities = database . getAllCitiesToWatch ( ) ; Collections . sort ( cities , new Comparator < CityToWatch > ( ) { @ Override public int compare ( CityToWatch o1 , CityToWatch o2 ) { return o1 . getRank ( ) - o2 . getRank ( ) ; } } ) ; } catch ( NullPointerException e ) { e . printStackTrace ( ) ; Toast toast = Toast . makeText ( getBaseContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) ; toast . show ( ) ; } RecyclerView recyclerView = ( RecyclerView ) findViewById ( R . id . list_view_cities ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( this ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; recyclerView . addOnItemTouchListener ( new RecyclerItemClickListener ( getBaseContext ( ) , recyclerView , new RecyclerItemClickListener . OnItemClickListener ( ) { @ Override public void onItemClick ( View view , int position ) { AlertDialog . Builder alert = new AlertDialog . Builder ( context ) ; final EditText edittext = new EditText ( context ) ; edittext . setText ( adapter . getCityName ( position ) ) ; edittext . setTextSize ( <NUM_LIT> ) ; edittext . setGravity ( Gravity . CENTER ) ; alert . setTitle ( getString ( R . string . edit_location_hint_name ) ) ; alert . setView ( edittext ) ; alert . setPositiveButton ( getString ( R . string . dialog_edit_change_button ) , ( dialog , whichButton ) -> adapter . renameCity ( position , String . valueOf ( edittext . getText ( ) ) ) ) ; alert . setNegativeButton ( getString ( R . string . dialog_add_close_button ) , ( dialog , whichButton ) -> { } ) ; alert . show ( ) ; } public void onLongItemClick ( View view , int position ) { } } ) ) ; adapter = new RecyclerOverviewListAdapter ( getApplicationContext ( ) , cities ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setFocusable ( false ) ; callback", "gt": "= new SimpleItemTouchHelperCallback ( adapter ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else { return R . drawable . ic_wind_lightred ; } } public static Drawable colorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_violet , null ) ; } } public static Integer widgetColorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_green ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_yellow ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_orange ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_lightred ; } else { return R . drawable . rounded_violet ; } } public static Integer getDayShort ( int day ) { switch ( day ) { case Calendar . MONDAY : day = R . string . abbreviation_monday ; break ; case Calendar . TUESDAY : day = R . string . abbreviation_tuesday ; break ; case Calendar . WEDNESDAY : day = R . string . abbreviation_wednesday ; break ; case Calendar . THURSDAY : day = R . string . abbreviation_thursday ; break ; case Calendar . FRIDAY : day = R . string . abbreviation_friday ; break ; case Calendar . SATURDAY : day = R . string . abbreviation_saturday ; break ; case Calendar . SUNDAY : day = R . string . abbreviation_sunday ; break ; default : day = R . string . abbreviation_monday ; } return day ; } public static Integer getDayLong ( int day ) { switch ( day ) { case Calendar . MONDAY : day = R . string . monday ; break ; case Calendar . TUESDAY : day = R . string . tuesday ; break ; case Calendar . WEDNESDAY : day = R . string . wednesday ; break ; case Calendar . THURSDAY : day = R . string . thursday ; break ; case Calendar . FRIDAY : day = R . string . friday ; break ; case Calendar . SATURDAY : day = R . string . saturday ; break ; case Calendar . SUNDAY : day = R . string . sunday ; break ; default", "gt": ": day = R . string . monday ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . services ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Handler ; import androidx . preference . PreferenceManager ; import androidx . core . app . JobIntentService ; import android . widget . Toast ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . NavigationActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . weather_api . IHttpRequestForWeatherAPI ; import org . woheller69 . weather . weather_api . open_meteo . OMHttpRequestForWeatherAPI ; import java . io . IOException ; import java . net . InetAddress ; import java . net . URL ; import java . util . List ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class UpdateDataService extends JobIntentService { public static final String UPDATE_FORECAST_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_ALL_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_SINGLE_ACTION = \"<STR_LIT>\" ; public static final String CITY_ID = \"<STR_LIT>\" ; public static final String SKIP_UPDATE_INTERVAL = \"<STR_LIT>\" ; private static final long MIN_UPDATE_INTERVAL = <NUM_LIT> ; private SQLiteHelper dbHelper ; private SharedPreferences prefManager ; public UpdateDataService ( ) { super ( ) ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; dbHelper = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; } @ Override protected void onHandleWork ( Intent intent ) { if ( ! isOnline ( <NUM_LIT> ) ) { Handler h = new Handler ( getApplicationContext ( ) . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { if ( NavigationActivity . isVisible ) Toast . makeText ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . error_no_internet ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; return ; } if ( intent != null ) { if ( UPDATE_ALL_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateAll ( intent ) ; else if ( UPDATE_FORECAST_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateForecastAction ( intent ) ; else if ( UPDATE_SINGLE_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateSingle ( intent ) ; } } private void handleUpdateAll ( Intent intent ) { List < CityToWatch > cities = dbHelper . getAllCitiesToWatch ( ) ; for ( CityToWatch c : cities ) { handleUpdateForecastAction ( intent , c . getCityId ( ) , c . getLatitude ( ) , c . getLongitude ( ) ) ; } } private void handleUpdateSingle ( Intent intent ) { int cityId = intent . getIntExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; CityToWatch city = dbHelper . getCityToWatch ( cityId ) ; handleUpdateForecastAction ( intent , cityId , city . getLatitude ( ) , city . getLongitude ( ) ) ; } private void handleUpdateForecastAction ( Intent intent , int cityId , float lat , float lon ) { boolean skipUpdateInterval = intent . getBooleanExtra ( SKIP_UPDATE_INTERVAL , false ) ; long timestamp = <NUM_LIT> ; long systemTime = System . currentTimeMillis ( ) / <NUM_LIT> ; long updateInterval = ( long ) ( Float . parseFloat ( prefManager . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) * <NUM_LIT> * <NUM_LIT> ) ; List < HourlyForecast > hourlyForecasts = dbHelper . getForecastsByCityId ( cityId ) ; if ( hourlyForecasts . size ( ) > <NUM_LIT> ) { timestamp = hourlyForecasts . get ( <NUM_LIT> ) . getTimestamp ( ) ; } if ( skipUpdateInterval ) { if ( ( timestamp + MIN_UPDATE_INTERVAL - systemTime ) > <NUM_LIT> ) skipUpdateInterval = false ; } if ( skipUpdateInterval || timestamp + updateInterval - systemTime <= <NUM_LIT> ) { IHttpRequestForWeatherAPI omHttpRequestForWeatherAPI = new OMHttpRequestForWeatherAPI ( getApplicationContext ( ) ) ; omHttpRequestForWeatherAPI . perform ( lat , lon , cityId ) ; } } private boolean isOnline ( int timeOut ) { InetAddress inetAddress = null ; try { Future < InetAddress > future = Executors . newSingleThreadExecutor ( ) . submit ( ( ) -> { try { URL url = new URL ( BuildConfig . BASE_URL ) ; return InetAddress . getByName ( url . getHost ( ) ) ; } catch ( IOException e ) { return null ; } } ) ; inetAddress = future . get ( timeOut , TimeUnit . MILLISECONDS ) ; future . cancel ( true ) ; } catch ( InterruptedException | ExecutionException | TimeoutException e ) { } return inetAddress != null && ! inetAddress . toString ( ) . isEmpty ( ) ; } private void handleUpdateForecastAction ( Intent intent ) { int cityId = intent . getIntExtra ( CITY_ID , - <NUM_LIT> ) ; float lat = <NUM_LIT> ; float lon = <NUM_LIT> ; List < CityToWatch > citiesToWatch = dbHelper . getAllCitiesToWatch ( ) ; for ( int i = <NUM_LIT> ; i < citiesToWatch . size ( ) ; i ++ ) { CityToWatch city = citiesToWatch . get ( i ) ; if ( city . getCityId ( ) == cityId ) { lat", "gt": "= city . getLatitude ( ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else { return R . drawable . ic_wind_lightred ; } } public static Drawable colorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_violet , null ) ; } } public static Integer widgetColorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_green ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_yellow ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_orange ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_lightred ; } else { return R . drawable . rounded_violet ; } } public static Integer getDayShort ( int day ) { switch ( day ) { case Calendar . MONDAY : day = R . string . abbreviation_monday ; break ; case Calendar . TUESDAY : day = R . string . abbreviation_tuesday ; break ; case", "gt": "Calendar . WEDNESDAY : day = R . string . abbreviation_wednesday ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . services ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Handler ; import androidx . preference . PreferenceManager ; import androidx . core . app . JobIntentService ; import android . widget . Toast ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . NavigationActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . weather_api . IHttpRequestForWeatherAPI ; import org . woheller69 . weather . weather_api . open_meteo . OMHttpRequestForWeatherAPI ; import java . io . IOException ; import java . net . InetAddress ; import java . net . URL ; import java . util . List ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class UpdateDataService extends JobIntentService { public static final String UPDATE_FORECAST_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_ALL_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_SINGLE_ACTION = \"<STR_LIT>\" ; public static final String CITY_ID = \"<STR_LIT>\" ; public static final String SKIP_UPDATE_INTERVAL = \"<STR_LIT>\" ; private static final long MIN_UPDATE_INTERVAL = <NUM_LIT> ; private SQLiteHelper dbHelper ; private SharedPreferences prefManager ; public UpdateDataService ( ) { super ( ) ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; dbHelper = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; } @ Override protected void onHandleWork ( Intent intent ) { if ( ! isOnline ( <NUM_LIT> ) ) { Handler h = new Handler ( getApplicationContext ( ) . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { if ( NavigationActivity . isVisible ) Toast . makeText ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . error_no_internet ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; return ; } if ( intent != null ) { if ( UPDATE_ALL_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateAll ( intent ) ; else if ( UPDATE_FORECAST_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateForecastAction ( intent ) ; else if ( UPDATE_SINGLE_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateSingle ( intent ) ; } } private void handleUpdateAll ( Intent intent ) { List < CityToWatch > cities = dbHelper . getAllCitiesToWatch ( ) ; for ( CityToWatch c : cities ) { handleUpdateForecastAction ( intent , c . getCityId ( ) , c . getLatitude ( ) , c . getLongitude ( ) ) ; } } private void handleUpdateSingle ( Intent intent ) { int cityId = intent . getIntExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; CityToWatch city = dbHelper . getCityToWatch ( cityId ) ; handleUpdateForecastAction ( intent , cityId , city . getLatitude ( ) , city . getLongitude ( ) ) ; } private void handleUpdateForecastAction ( Intent intent , int cityId , float lat , float lon ) { boolean skipUpdateInterval = intent . getBooleanExtra ( SKIP_UPDATE_INTERVAL , false ) ; long timestamp = <NUM_LIT> ; long systemTime = System . currentTimeMillis ( ) / <NUM_LIT> ; long updateInterval = ( long ) ( Float . parseFloat ( prefManager . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) * <NUM_LIT> * <NUM_LIT> ) ; List < HourlyForecast > hourlyForecasts = dbHelper . getForecastsByCityId ( cityId ) ; if ( hourlyForecasts . size ( ) > <NUM_LIT> ) { timestamp = hourlyForecasts . get ( <NUM_LIT> ) . getTimestamp ( ) ; } if ( skipUpdateInterval ) { if ( ( timestamp + MIN_UPDATE_INTERVAL - systemTime ) > <NUM_LIT> ) skipUpdateInterval = false ; } if ( skipUpdateInterval || timestamp + updateInterval - systemTime <= <NUM_LIT> ) { IHttpRequestForWeatherAPI omHttpRequestForWeatherAPI = new OMHttpRequestForWeatherAPI ( getApplicationContext ( ) ) ; omHttpRequestForWeatherAPI . perform ( lat , lon , cityId ) ; } } private boolean isOnline ( int timeOut ) { InetAddress inetAddress = null ; try { Future < InetAddress > future = Executors . newSingleThreadExecutor ( ) . submit ( ( ) -> { try { URL url = new URL ( BuildConfig . BASE_URL ) ; return InetAddress . getByName ( url . getHost ( ) ) ; } catch ( IOException e ) { return null ; } } ) ; inetAddress = future . get ( timeOut , TimeUnit . MILLISECONDS ) ; future . cancel ( true ) ; } catch ( InterruptedException | ExecutionException | TimeoutException e ) { } return inetAddress != null && ! inetAddress . toString ( ) . isEmpty ( ) ; } private void handleUpdateForecastAction ( Intent intent ) { int cityId = intent . getIntExtra ( CITY_ID , - <NUM_LIT> ) ; float lat = <NUM_LIT> ; float lon = <NUM_LIT> ; List < CityToWatch > citiesToWatch = dbHelper . getAllCitiesToWatch ( ) ; for ( int i = <NUM_LIT> ; i < citiesToWatch . size ( ) ; i ++ ) { CityToWatch", "gt": "city = citiesToWatch . get ( i ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return", "gt": "ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else", "gt": "if ( wind_speed < <NUM_LIT> ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . CHART ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . DAY ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . DETAILS ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . EMPTY ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . OVERVIEW ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . WEEK ; import android . annotation . SuppressLint ; import android . content . Context ; import android . os . Bundle ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fragment . app . Fragment ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . recyclerview . widget . StaggeredGridLayoutManager ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ForecastCityActivity ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter ; import org . woheller69 . weather . ui . RecycleList . OnSwipeDownListener ; import org . woheller69 . weather . ui . updater . IUpdateableCityUI ; import org . woheller69 . weather . ui . updater . ViewUpdater ; import org . woheller69 . weather . ui . viewPager . WeatherPagerAdapter ; import java . util . List ; public class WeatherCityFragment extends Fragment implements IUpdateableCityUI { private static final int MINGRIDWIDTH = <NUM_LIT> ; private int mCityId = - <NUM_LIT> ; private int [ ] mDataSetTypes = new int [ ] { } ; private static int [ ] mFull = { OVERVIEW , DAY , WEEK , CHART } ; private static int [ ] mEmpty = { EMPTY } ; private CityWeatherAdapter mAdapter ; private RecyclerView recyclerView ; public static WeatherCityFragment newInstance ( Bundle args ) { WeatherCityFragment weatherCityFragment = new WeatherCityFragment ( ) ; weatherCityFragment . setArguments ( args ) ; return weatherCityFragment ; } public void setAdapter ( CityWeatherAdapter adapter ) { mAdapter = adapter ; if ( recyclerView != null ) { recyclerView . setAdapter ( mAdapter ) ; recyclerView . setFocusable ( false ) ; recyclerView . setLayoutManager ( getLayoutManager ( getContext ( ) ) ) ; } } public void loadData ( ) { CurrentWeatherData currentWeatherData = SQLiteHelper . getInstance ( getContext ( ) ) . getCurrentWeatherByCityId ( mCityId ) ; if ( currentWeatherData . getTimestamp ( ) == <NUM_LIT> ) mDataSetTypes = mEmpty ; else mDataSetTypes = mFull ; mAdapter = new CityWeatherAdapter ( currentWeatherData , mDataSetTypes , getContext ( ) ) ; setAdapter ( mAdapter ) ; } @ Override public void onAttach ( @ NonNull Context context ) { super . onAttach ( context ) ; ViewUpdater . addSubscriber ( this ) ; } @ Override public void onDetach ( ) { ViewUpdater . removeSubscriber ( this ) ; super . onDetach ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { final View v = inflater . inflate ( R . layout . fragment_weather_forecast_city_overview , container , false ) ; recyclerView = v . findViewById ( R . id . weatherForecastRecyclerView ) ; recyclerView . setLayoutManager ( getLayoutManager ( getContext ( ) ) ) ; recyclerView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; if ( ! recyclerView . canScrollVertically ( - <NUM_LIT> ) ) { recyclerView . setOnTouchListener ( new OnSwipeDownListener ( getContext ( ) ) { public void onSwipeDown ( ) { WeatherPagerAdapter . refreshSingleData ( getContext ( ) , true , mCityId ) ; ForecastCityActivity . startRefreshAnimation ( ) ; } } ) ; } else recyclerView . setOnTouchListener ( null ) ; } } ) ; Bundle args = getArguments ( ) ; mCityId = args . getInt ( \"<STR_LIT>\" ) ; loadData ( ) ; return v ; } public RecyclerView . LayoutManager getLayoutManager ( Context context ) { int widthPixels = context . getResources ( ) . getDisplayMetrics ( ) . widthPixels ; float density = context . getResources ( ) . getDisplayMetrics ( ) . density ; float width = widthPixels / density ; if ( width > MINGRIDWIDTH ) { return new StaggeredGridLayoutManager ( <NUM_LIT> , StaggeredGridLayoutManager . VERTICAL ) ; } else { return new LinearLayoutManager ( context ) ; } } @ Override public void processNewCurrentWeatherData ( CurrentWeatherData data ) { if", "gt": "( data != null && data . getCity_id ( ) == mCityId ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . services ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Handler ; import androidx . preference . PreferenceManager ; import androidx . core . app . JobIntentService ; import android . widget . Toast ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . NavigationActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . weather_api . IHttpRequestForWeatherAPI ; import org . woheller69 . weather . weather_api . open_meteo . OMHttpRequestForWeatherAPI ; import java . io . IOException ; import java . net . InetAddress ; import java . net . URL ; import java . util . List ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class UpdateDataService extends JobIntentService { public static final String UPDATE_FORECAST_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_ALL_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_SINGLE_ACTION = \"<STR_LIT>\" ; public static final String CITY_ID = \"<STR_LIT>\" ; public static final String SKIP_UPDATE_INTERVAL = \"<STR_LIT>\" ; private static final long MIN_UPDATE_INTERVAL = <NUM_LIT> ; private SQLiteHelper dbHelper ; private SharedPreferences prefManager ; public UpdateDataService ( ) { super ( ) ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; dbHelper = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; } @ Override protected void onHandleWork ( Intent intent ) { if ( ! isOnline ( <NUM_LIT> ) ) { Handler h = new Handler ( getApplicationContext ( ) . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { if ( NavigationActivity . isVisible ) Toast . makeText ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . error_no_internet ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; return ; } if ( intent != null ) { if ( UPDATE_ALL_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateAll ( intent ) ; else if ( UPDATE_FORECAST_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateForecastAction ( intent ) ; else if ( UPDATE_SINGLE_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateSingle ( intent ) ; } } private void handleUpdateAll ( Intent intent ) { List < CityToWatch > cities = dbHelper . getAllCitiesToWatch ( ) ; for ( CityToWatch c : cities ) { handleUpdateForecastAction ( intent , c . getCityId ( ) , c . getLatitude ( ) , c . getLongitude ( ) ) ; } } private void handleUpdateSingle ( Intent intent ) { int cityId = intent . getIntExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; CityToWatch city = dbHelper . getCityToWatch ( cityId ) ; handleUpdateForecastAction ( intent , cityId , city . getLatitude ( ) , city . getLongitude ( ) ) ; } private void handleUpdateForecastAction ( Intent intent , int cityId , float lat , float lon ) { boolean skipUpdateInterval = intent . getBooleanExtra ( SKIP_UPDATE_INTERVAL , false ) ; long timestamp = <NUM_LIT> ; long systemTime = System . currentTimeMillis ( ) / <NUM_LIT> ; long updateInterval = ( long ) ( Float . parseFloat ( prefManager . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) * <NUM_LIT> * <NUM_LIT> ) ; List < HourlyForecast > hourlyForecasts = dbHelper . getForecastsByCityId ( cityId ) ; if ( hourlyForecasts . size ( ) > <NUM_LIT> ) { timestamp = hourlyForecasts . get ( <NUM_LIT> ) . getTimestamp ( ) ; } if ( skipUpdateInterval ) { if ( ( timestamp + MIN_UPDATE_INTERVAL - systemTime ) > <NUM_LIT> ) skipUpdateInterval = false ; } if ( skipUpdateInterval || timestamp + updateInterval - systemTime <= <NUM_LIT> ) { IHttpRequestForWeatherAPI omHttpRequestForWeatherAPI = new OMHttpRequestForWeatherAPI ( getApplicationContext ( ) ) ; omHttpRequestForWeatherAPI . perform ( lat , lon , cityId ) ; } } private boolean isOnline ( int timeOut ) { InetAddress inetAddress = null ; try { Future", "gt": "< InetAddress > future = Executors . newSingleThreadExecutor ( ) . submit ( ( ) -> {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . services ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Handler ; import androidx . preference . PreferenceManager ; import androidx . core . app . JobIntentService ; import android . widget . Toast ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . NavigationActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . weather_api . IHttpRequestForWeatherAPI ; import org . woheller69 . weather . weather_api . open_meteo . OMHttpRequestForWeatherAPI ; import java . io . IOException ; import java . net . InetAddress ; import java . net . URL ; import java . util . List ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class UpdateDataService extends JobIntentService { public static final String UPDATE_FORECAST_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_ALL_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_SINGLE_ACTION = \"<STR_LIT>\" ; public static final String CITY_ID = \"<STR_LIT>\" ; public static final String SKIP_UPDATE_INTERVAL = \"<STR_LIT>\" ; private static final long MIN_UPDATE_INTERVAL = <NUM_LIT> ; private SQLiteHelper dbHelper ; private SharedPreferences prefManager ; public UpdateDataService ( ) { super ( ) ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; dbHelper = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; } @ Override protected void onHandleWork ( Intent intent ) { if ( ! isOnline ( <NUM_LIT> ) ) { Handler h = new Handler ( getApplicationContext ( ) . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { if ( NavigationActivity . isVisible ) Toast . makeText ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . error_no_internet ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; return ; } if ( intent != null ) { if ( UPDATE_ALL_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateAll ( intent ) ; else if ( UPDATE_FORECAST_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateForecastAction ( intent ) ; else if ( UPDATE_SINGLE_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateSingle ( intent ) ; } } private void handleUpdateAll ( Intent intent ) { List < CityToWatch > cities = dbHelper . getAllCitiesToWatch ( ) ; for ( CityToWatch c : cities ) { handleUpdateForecastAction ( intent , c . getCityId ( ) , c . getLatitude ( ) , c . getLongitude ( ) ) ; } } private void handleUpdateSingle ( Intent intent ) { int cityId = intent . getIntExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; CityToWatch city = dbHelper . getCityToWatch ( cityId ) ; handleUpdateForecastAction ( intent , cityId , city . getLatitude ( ) , city . getLongitude ( ) ) ; } private void handleUpdateForecastAction ( Intent intent , int cityId , float lat , float lon ) { boolean skipUpdateInterval = intent . getBooleanExtra ( SKIP_UPDATE_INTERVAL , false ) ; long timestamp = <NUM_LIT> ; long systemTime = System . currentTimeMillis ( ) / <NUM_LIT> ; long updateInterval = ( long ) ( Float . parseFloat ( prefManager . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) * <NUM_LIT> * <NUM_LIT> ) ; List < HourlyForecast > hourlyForecasts = dbHelper . getForecastsByCityId ( cityId ) ; if ( hourlyForecasts . size ( ) > <NUM_LIT> ) { timestamp = hourlyForecasts . get ( <NUM_LIT> ) . getTimestamp ( ) ; } if ( skipUpdateInterval ) { if ( ( timestamp + MIN_UPDATE_INTERVAL - systemTime ) > <NUM_LIT> ) skipUpdateInterval = false ; } if", "gt": "( skipUpdateInterval || timestamp + updateInterval - systemTime <= <NUM_LIT> ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return", "gt": "ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else { return R . drawable . ic_wind_lightred ; } } public static Drawable colorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_violet , null ) ; } } public static Integer widgetColorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_green ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_yellow ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_orange ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_lightred ; } else { return R . drawable . rounded_violet ; } } public static Integer getDayShort ( int day ) { switch ( day ) { case Calendar . MONDAY : day = R . string . abbreviation_monday ; break ; case Calendar . TUESDAY : day = R . string . abbreviation_tuesday ; break ; case Calendar . WEDNESDAY : day = R . string . abbreviation_wednesday ; break ; case", "gt": "Calendar . THURSDAY : day = R . string . abbreviation_thursday ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . services ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Handler ; import androidx . preference . PreferenceManager ; import androidx . core . app . JobIntentService ; import android . widget . Toast ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . NavigationActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . weather_api . IHttpRequestForWeatherAPI ; import org . woheller69 . weather . weather_api . open_meteo . OMHttpRequestForWeatherAPI ; import java . io . IOException ; import java . net . InetAddress ; import java . net . URL ; import java . util . List ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class UpdateDataService extends JobIntentService { public static final String UPDATE_FORECAST_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_ALL_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_SINGLE_ACTION = \"<STR_LIT>\" ; public static final String CITY_ID = \"<STR_LIT>\" ; public static final String SKIP_UPDATE_INTERVAL = \"<STR_LIT>\" ; private static final long MIN_UPDATE_INTERVAL = <NUM_LIT> ; private SQLiteHelper dbHelper ; private SharedPreferences prefManager ; public UpdateDataService ( ) { super ( ) ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; dbHelper = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; } @ Override protected void onHandleWork ( Intent intent ) { if ( ! isOnline ( <NUM_LIT> ) ) { Handler h = new Handler ( getApplicationContext ( ) . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { if ( NavigationActivity . isVisible ) Toast . makeText ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . error_no_internet ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; return ; } if ( intent != null ) { if ( UPDATE_ALL_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateAll ( intent ) ; else if ( UPDATE_FORECAST_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateForecastAction ( intent ) ; else if ( UPDATE_SINGLE_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateSingle ( intent ) ; } } private void handleUpdateAll ( Intent intent ) { List < CityToWatch > cities = dbHelper . getAllCitiesToWatch ( ) ; for ( CityToWatch c : cities ) { handleUpdateForecastAction ( intent , c . getCityId ( ) , c . getLatitude ( ) , c . getLongitude ( ) ) ; } } private void handleUpdateSingle ( Intent intent ) { int cityId = intent . getIntExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; CityToWatch city = dbHelper . getCityToWatch ( cityId ) ; handleUpdateForecastAction ( intent , cityId , city . getLatitude ( ) , city . getLongitude ( ) ) ; } private void handleUpdateForecastAction ( Intent intent , int cityId , float lat , float lon ) { boolean skipUpdateInterval = intent . getBooleanExtra ( SKIP_UPDATE_INTERVAL , false ) ; long timestamp = <NUM_LIT> ; long systemTime = System . currentTimeMillis ( ) / <NUM_LIT> ; long updateInterval = ( long ) ( Float . parseFloat ( prefManager . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) * <NUM_LIT> * <NUM_LIT> ) ; List < HourlyForecast > hourlyForecasts = dbHelper . getForecastsByCityId ( cityId ) ; if ( hourlyForecasts . size ( ) > <NUM_LIT> ) { timestamp = hourlyForecasts . get ( <NUM_LIT> ) . getTimestamp ( ) ; } if ( skipUpdateInterval ) { if ( ( timestamp + MIN_UPDATE_INTERVAL - systemTime ) > <NUM_LIT> ) skipUpdateInterval = false ; } if ( skipUpdateInterval || timestamp + updateInterval - systemTime <= <NUM_LIT> ) { IHttpRequestForWeatherAPI omHttpRequestForWeatherAPI = new OMHttpRequestForWeatherAPI ( getApplicationContext ( ) ) ; omHttpRequestForWeatherAPI . perform ( lat , lon , cityId ) ; } } private boolean isOnline ( int timeOut ) { InetAddress inetAddress = null ; try { Future < InetAddress > future = Executors . newSingleThreadExecutor ( ) . submit ( ( ) -> { try { URL url = new URL ( BuildConfig . BASE_URL ) ; return InetAddress . getByName ( url . getHost ( ) ) ; } catch ( IOException e ) { return null ; } } ) ; inetAddress = future . get ( timeOut , TimeUnit . MILLISECONDS ) ; future . cancel ( true ) ; } catch", "gt": "( InterruptedException | ExecutionException | TimeoutException e ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else", "gt": "if ( wind_speed < <NUM_LIT> ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else", "gt": "if ( wind_speed < <NUM_LIT> ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else { return R . drawable . ic_wind_lightred ; } } public static Drawable colorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_violet , null ) ; } } public static Integer widgetColorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_green ; } else", "gt": "if ( uvindex <= <NUM_LIT> ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else", "gt": "if ( wind_speed < <NUM_LIT> ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . services ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Handler ; import androidx . preference . PreferenceManager ; import androidx . core . app . JobIntentService ; import android . widget . Toast ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . NavigationActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . weather_api . IHttpRequestForWeatherAPI ; import org . woheller69 . weather . weather_api . open_meteo . OMHttpRequestForWeatherAPI ; import java . io . IOException ; import java . net . InetAddress ; import java . net . URL ; import java . util . List ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class UpdateDataService extends JobIntentService { public static final String UPDATE_FORECAST_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_ALL_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_SINGLE_ACTION = \"<STR_LIT>\" ; public static final String CITY_ID = \"<STR_LIT>\" ; public static final String SKIP_UPDATE_INTERVAL = \"<STR_LIT>\" ; private static final long MIN_UPDATE_INTERVAL = <NUM_LIT> ; private SQLiteHelper dbHelper ; private SharedPreferences prefManager ; public UpdateDataService ( ) { super ( ) ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; dbHelper = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; } @ Override protected void onHandleWork ( Intent intent ) { if ( ! isOnline ( <NUM_LIT> ) ) { Handler h = new Handler ( getApplicationContext ( ) . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { if ( NavigationActivity . isVisible ) Toast . makeText ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . error_no_internet ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; return ; } if ( intent != null ) { if ( UPDATE_ALL_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateAll ( intent ) ; else if ( UPDATE_FORECAST_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateForecastAction ( intent ) ; else if ( UPDATE_SINGLE_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateSingle ( intent ) ; } } private void handleUpdateAll ( Intent intent ) { List < CityToWatch > cities = dbHelper . getAllCitiesToWatch ( ) ; for ( CityToWatch c : cities ) { handleUpdateForecastAction ( intent , c . getCityId ( ) , c . getLatitude ( ) , c . getLongitude ( ) ) ; } } private void handleUpdateSingle ( Intent intent ) { int cityId = intent . getIntExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; CityToWatch", "gt": "city = dbHelper . getCityToWatch ( cityId ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . services ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Handler ; import androidx . preference . PreferenceManager ; import androidx . core . app . JobIntentService ; import android . widget . Toast ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . NavigationActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . weather_api . IHttpRequestForWeatherAPI ; import org . woheller69 . weather . weather_api . open_meteo . OMHttpRequestForWeatherAPI ; import java . io . IOException ; import java . net . InetAddress ; import java . net . URL ; import java . util . List ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class UpdateDataService extends JobIntentService { public static final String UPDATE_FORECAST_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_ALL_ACTION = \"<STR_LIT>\" ; public static final String UPDATE_SINGLE_ACTION = \"<STR_LIT>\" ; public static final String CITY_ID = \"<STR_LIT>\" ; public static final String SKIP_UPDATE_INTERVAL = \"<STR_LIT>\" ; private static final long MIN_UPDATE_INTERVAL = <NUM_LIT> ; private SQLiteHelper dbHelper ; private SharedPreferences prefManager ; public UpdateDataService ( ) { super ( ) ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; dbHelper = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; } @ Override protected void onHandleWork ( Intent intent ) { if ( ! isOnline ( <NUM_LIT> ) ) { Handler h = new Handler ( getApplicationContext ( ) . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { if ( NavigationActivity . isVisible ) Toast . makeText ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . error_no_internet ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; return ; } if ( intent != null ) { if ( UPDATE_ALL_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateAll ( intent ) ; else if ( UPDATE_FORECAST_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateForecastAction ( intent ) ; else if ( UPDATE_SINGLE_ACTION . equals ( intent . getAction ( ) ) ) handleUpdateSingle ( intent ) ; } } private void handleUpdateAll ( Intent intent ) { List < CityToWatch > cities = dbHelper . getAllCitiesToWatch ( ) ; for ( CityToWatch c : cities ) { handleUpdateForecastAction", "gt": "( intent , c . getCityId ( ) , c . getLatitude ( ) , c . getLongitude ( ) ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else", "gt": "if ( wind_speed < <NUM_LIT> ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else { return R . drawable . ic_wind_lightred ; } } public static Drawable colorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_violet , null ) ; } } public static Integer widgetColorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_green ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_yellow ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_orange ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_lightred ; } else { return R . drawable . rounded_violet ; } } public static Integer getDayShort ( int day ) { switch ( day ) { case Calendar . MONDAY : day = R . string . abbreviation_monday ; break ; case", "gt": "Calendar . TUESDAY : day = R . string . abbreviation_tuesday ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . CHART ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . DAY ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . DETAILS ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . EMPTY ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . OVERVIEW ; import static org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter . WEEK ; import android . annotation . SuppressLint ; import android . content . Context ; import android . os . Bundle ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fragment . app . Fragment ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . recyclerview . widget . StaggeredGridLayoutManager ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ForecastCityActivity ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . ui . RecycleList . CityWeatherAdapter ; import org . woheller69 . weather . ui . RecycleList . OnSwipeDownListener ; import org . woheller69 . weather . ui . updater . IUpdateableCityUI ; import org . woheller69 . weather . ui . updater . ViewUpdater ; import org . woheller69 . weather . ui . viewPager . WeatherPagerAdapter ; import java . util . List ; public class WeatherCityFragment extends Fragment implements IUpdateableCityUI { private static final int MINGRIDWIDTH = <NUM_LIT> ; private int mCityId = - <NUM_LIT> ; private int [ ] mDataSetTypes = new int [ ] { } ; private static int [ ] mFull = { OVERVIEW , DAY , WEEK , CHART } ; private static int [ ] mEmpty = { EMPTY } ; private CityWeatherAdapter mAdapter ; private RecyclerView recyclerView ; public static WeatherCityFragment newInstance ( Bundle args ) { WeatherCityFragment weatherCityFragment = new WeatherCityFragment ( ) ; weatherCityFragment . setArguments ( args ) ; return weatherCityFragment ; } public void setAdapter ( CityWeatherAdapter adapter ) { mAdapter = adapter ; if ( recyclerView != null ) { recyclerView . setAdapter ( mAdapter ) ; recyclerView . setFocusable ( false ) ; recyclerView . setLayoutManager ( getLayoutManager ( getContext ( ) ) ) ; } } public void loadData ( ) { CurrentWeatherData currentWeatherData = SQLiteHelper . getInstance ( getContext ( ) ) . getCurrentWeatherByCityId ( mCityId ) ; if ( currentWeatherData . getTimestamp ( ) == <NUM_LIT> ) mDataSetTypes = mEmpty ; else mDataSetTypes = mFull ; mAdapter = new CityWeatherAdapter ( currentWeatherData , mDataSetTypes , getContext ( ) ) ; setAdapter ( mAdapter ) ; } @ Override public void onAttach ( @ NonNull Context context ) { super . onAttach ( context ) ; ViewUpdater . addSubscriber ( this ) ; } @ Override public void onDetach ( ) { ViewUpdater . removeSubscriber ( this ) ; super . onDetach ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { final View v = inflater . inflate ( R . layout . fragment_weather_forecast_city_overview , container , false ) ; recyclerView = v . findViewById ( R . id . weatherForecastRecyclerView ) ; recyclerView . setLayoutManager ( getLayoutManager ( getContext ( ) ) ) ; recyclerView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; if ( ! recyclerView . canScrollVertically ( - <NUM_LIT> ) ) { recyclerView . setOnTouchListener ( new OnSwipeDownListener ( getContext ( ) ) { public void onSwipeDown ( ) { WeatherPagerAdapter . refreshSingleData ( getContext ( ) , true , mCityId ) ; ForecastCityActivity . startRefreshAnimation ( ) ; } } ) ; } else recyclerView . setOnTouchListener ( null ) ; } } ) ; Bundle args = getArguments ( ) ; mCityId", "gt": "= args . getInt ( \"<STR_LIT>\" ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else", "gt": "if ( wind_speed < <NUM_LIT> ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else { return R . drawable . ic_wind_lightred ; } } public static Drawable colorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return", "gt": "ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . activities ; import android . content . Context ; import android . os . Bundle ; import com . google . android . material . floatingactionbutton . FloatingActionButton ; import androidx . appcompat . app . AlertDialog ; import androidx . fragment . app . FragmentManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . recyclerview . widget . ItemTouchHelper ; import android . view . Gravity ; import android . view . View ; import android . view . WindowManager ; import android . widget . EditText ; import android . widget . Toast ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . City ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . dialogs . AddLocationDialogOmGeocodingAPI ; import org . woheller69 . weather . ui . RecycleList . RecyclerItemClickListener ; import org . woheller69 . weather . ui . RecycleList . RecyclerOverviewListAdapter ; import org . woheller69 . weather . ui . RecycleList . SimpleItemTouchHelperCallback ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; public class ManageLocationsActivity extends NavigationActivity { private SQLiteHelper database ; private ItemTouchHelper . Callback callback ; private ItemTouchHelper touchHelper ; RecyclerOverviewListAdapter adapter ; List < CityToWatch > cities ; Context context ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_manage_locations ) ; context = this ; database = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; try { cities = database . getAllCitiesToWatch ( ) ; Collections . sort ( cities , new Comparator < CityToWatch > ( ) { @ Override public int compare ( CityToWatch o1 , CityToWatch o2 ) { return o1 . getRank ( ) - o2 . getRank ( ) ; } } ) ; } catch ( NullPointerException e ) { e . printStackTrace ( ) ; Toast toast = Toast . makeText ( getBaseContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) ; toast . show ( ) ; } RecyclerView recyclerView = ( RecyclerView ) findViewById ( R . id . list_view_cities ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( this ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; recyclerView . addOnItemTouchListener ( new RecyclerItemClickListener ( getBaseContext ( ) , recyclerView , new RecyclerItemClickListener . OnItemClickListener ( ) { @ Override public void onItemClick ( View view , int position ) { AlertDialog . Builder alert = new AlertDialog . Builder ( context ) ; final EditText edittext = new EditText ( context ) ; edittext . setText ( adapter . getCityName ( position ) ) ; edittext . setTextSize ( <NUM_LIT> ) ; edittext . setGravity ( Gravity . CENTER ) ; alert . setTitle ( getString ( R . string . edit_location_hint_name ) ) ; alert . setView ( edittext ) ; alert . setPositiveButton ( getString ( R . string . dialog_edit_change_button ) , ( dialog , whichButton ) -> adapter . renameCity ( position , String . valueOf ( edittext . getText ( ) ) ) ) ; alert . setNegativeButton ( getString ( R . string . dialog_add_close_button ) , ( dialog , whichButton ) -> { } ) ; alert . show ( ) ; } public void onLongItemClick ( View view , int position ) { } } ) ) ; adapter = new RecyclerOverviewListAdapter ( getApplicationContext ( ) , cities ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setFocusable ( false ) ; callback = new SimpleItemTouchHelperCallback ( adapter ) ; touchHelper = new ItemTouchHelper ( callback ) ; touchHelper . attachToRecyclerView ( recyclerView ) ; FloatingActionButton addFab1 = ( FloatingActionButton ) findViewById ( R . id . fabAddLocation ) ; if ( addFab1 != null ) { addFab1 . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { FragmentManager fragmentManager = getSupportFragmentManager ( ) ; AddLocationDialogOmGeocodingAPI", "gt": "addLocationDialog = new AddLocationDialogOmGeocodingAPI ( ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else { return R . drawable . ic_wind_lightred ; } } public static Drawable colorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_violet , null ) ; } } public static Integer widgetColorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_green ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_yellow ; } else", "gt": "if ( uvindex <= <NUM_LIT> ) {", "repo": "omweather"}
{"input": "package org . woheller69 . weather . activities ; import android . content . Context ; import android . os . Bundle ; import com . google . android . material . floatingactionbutton . FloatingActionButton ; import androidx . appcompat . app . AlertDialog ; import androidx . fragment . app . FragmentManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . recyclerview . widget . ItemTouchHelper ; import android . view . Gravity ; import android . view . View ; import android . view . WindowManager ; import android . widget . EditText ; import android . widget . Toast ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . City ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . dialogs . AddLocationDialogOmGeocodingAPI ; import org . woheller69 . weather . ui . RecycleList . RecyclerItemClickListener ; import org . woheller69 . weather . ui . RecycleList . RecyclerOverviewListAdapter ; import org . woheller69 . weather . ui . RecycleList . SimpleItemTouchHelperCallback ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; public class ManageLocationsActivity extends NavigationActivity { private SQLiteHelper database ; private ItemTouchHelper . Callback callback ; private ItemTouchHelper touchHelper ; RecyclerOverviewListAdapter adapter ; List < CityToWatch > cities ; Context context ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_manage_locations ) ; context = this ; database = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; try { cities = database . getAllCitiesToWatch ( ) ; Collections . sort ( cities , new Comparator < CityToWatch > ( ) { @ Override public int compare ( CityToWatch o1 , CityToWatch o2 ) { return o1 . getRank ( ) - o2 . getRank ( ) ; } } ) ; } catch ( NullPointerException e ) { e . printStackTrace ( ) ; Toast toast = Toast . makeText ( getBaseContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) ; toast . show ( ) ; } RecyclerView recyclerView = ( RecyclerView ) findViewById ( R . id . list_view_cities ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( this ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; recyclerView . addOnItemTouchListener ( new RecyclerItemClickListener ( getBaseContext ( ) , recyclerView , new RecyclerItemClickListener . OnItemClickListener ( ) { @ Override public void onItemClick ( View view , int position ) { AlertDialog . Builder alert = new AlertDialog . Builder ( context ) ; final EditText edittext = new EditText ( context ) ; edittext . setText ( adapter . getCityName ( position ) ) ; edittext . setTextSize ( <NUM_LIT> ) ; edittext . setGravity ( Gravity . CENTER ) ; alert", "gt": ". setTitle ( getString ( R . string . edit_location_hint_name ) ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . activities ; import android . content . Context ; import android . os . Bundle ; import com . google . android . material . floatingactionbutton . FloatingActionButton ; import androidx . appcompat . app . AlertDialog ; import androidx . fragment . app . FragmentManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . recyclerview . widget . ItemTouchHelper ; import android . view . Gravity ; import android . view . View ; import android . view . WindowManager ; import android . widget . EditText ; import android . widget . Toast ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . City ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . dialogs . AddLocationDialogOmGeocodingAPI ; import org . woheller69 . weather . ui . RecycleList . RecyclerItemClickListener ; import org . woheller69 . weather . ui . RecycleList . RecyclerOverviewListAdapter ; import org . woheller69 . weather . ui . RecycleList . SimpleItemTouchHelperCallback ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; public class ManageLocationsActivity extends NavigationActivity { private SQLiteHelper database ; private ItemTouchHelper . Callback callback ; private ItemTouchHelper touchHelper ; RecyclerOverviewListAdapter adapter ; List < CityToWatch > cities ; Context context ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_manage_locations ) ; context = this ; database = SQLiteHelper . getInstance ( getApplicationContext ( ) ) ; try { cities = database . getAllCitiesToWatch ( ) ; Collections . sort ( cities , new Comparator < CityToWatch > ( ) { @ Override public int compare ( CityToWatch o1 , CityToWatch o2 ) { return o1 . getRank ( ) - o2 . getRank ( ) ; } } ) ; } catch ( NullPointerException e ) { e . printStackTrace ( ) ; Toast toast = Toast . makeText ( getBaseContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) ; toast . show ( ) ; } RecyclerView recyclerView = ( RecyclerView ) findViewById ( R . id . list_view_cities ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( this ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; recyclerView . addOnItemTouchListener ( new RecyclerItemClickListener ( getBaseContext ( ) , recyclerView , new RecyclerItemClickListener . OnItemClickListener ( ) { @ Override public void onItemClick ( View view , int position ) { AlertDialog . Builder alert = new AlertDialog . Builder ( context ) ; final EditText edittext = new EditText ( context ) ; edittext . setText ( adapter . getCityName ( position ) ) ; edittext . setTextSize ( <NUM_LIT> ) ; edittext . setGravity ( Gravity . CENTER ) ; alert . setTitle ( getString ( R . string . edit_location_hint_name ) ) ; alert . setView ( edittext ) ; alert . setPositiveButton ( getString ( R . string . dialog_edit_change_button ) , ( dialog , whichButton ) -> adapter . renameCity ( position , String . valueOf ( edittext . getText ( ) ) ) ) ; alert . setNegativeButton ( getString ( R . string . dialog_add_close_button ) , ( dialog , whichButton ) -> { } ) ; alert . show ( ) ; } public void onLongItemClick ( View view , int position ) { } } ) ) ; adapter = new RecyclerOverviewListAdapter ( getApplicationContext ( ) , cities ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setFocusable ( false ) ; callback = new SimpleItemTouchHelperCallback ( adapter ) ; touchHelper = new ItemTouchHelper ( callback ) ; touchHelper . attachToRecyclerView ( recyclerView ) ; FloatingActionButton addFab1 = ( FloatingActionButton ) findViewById ( R . id . fabAddLocation ) ; if ( addFab1 != null ) { addFab1 . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { FragmentManager fragmentManager = getSupportFragmentManager ( ) ; AddLocationDialogOmGeocodingAPI addLocationDialog = new AddLocationDialogOmGeocodingAPI ( ) ; addLocationDialog", "gt": ". show ( fragmentManager , \"<STR_LIT>\" ) ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_red , null ) ; } } public static int colorWindSpeedWidget ( float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_empty ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_yellow ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_orange ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else if ( wind_speed < <NUM_LIT> ) { return R . drawable . ic_wind_lightred ; } else { return R . drawable . ic_wind_lightred ; } } public static Drawable colorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_orange , null ) ; } else if ( uvindex <= <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_lightred , null ) ; } else { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_violet , null ) ; } } public static Integer widgetColorUVindex ( Context context , int uvindex ) { if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_green ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_yellow ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_orange ; } else if ( uvindex <= <NUM_LIT> ) { return R . drawable . rounded_lightred ; } else { return R . drawable . rounded_violet ; } } public static Integer getDayShort ( int day ) { switch ( day ) { case Calendar . MONDAY : day = R . string . abbreviation_monday ; break ; case Calendar . TUESDAY : day = R . string . abbreviation_tuesday ; break ; case Calendar . WEDNESDAY : day = R . string . abbreviation_wednesday ; break ; case Calendar . THURSDAY : day = R . string . abbreviation_thursday ; break ; case Calendar . FRIDAY : day = R . string . abbreviation_friday ; break ; case Calendar . SATURDAY : day = R . string . abbreviation_saturday ; break ; case Calendar . SUNDAY : day = R . string . abbreviation_sunday ; break ; default : day = R . string . abbreviation_monday ; } return day ; } public static Integer getDayLong ( int day ) { switch ( day ) { case", "gt": "Calendar . MONDAY : day = R . string . monday ;", "repo": "omweather"}
{"input": "package org . woheller69 . weather . ui . Help ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . preference . PreferenceManager ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . math . RoundingMode ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import static java . lang . Boolean . TRUE ; public final class StringFormatUtils { private static final DecimalFormat decimalFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; private static final DecimalFormat intFormat = new DecimalFormat ( \"<STR_LIT>\" ) ; public static String formatDecimal ( float decimal ) { decimalFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( decimalFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal ) { intFormat . setRoundingMode ( RoundingMode . HALF_UP ) ; return removeMinusIfZerosOnly ( intFormat . format ( decimal ) ) ; } public static String formatInt ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatInt ( decimal ) ) , appendix ) ; } public static String formatDecimal ( float decimal , String appendix ) { return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( formatDecimal ( decimal ) ) , appendix ) ; } public static String formatDecimalTemperature ( Context context , float decimal , String appendix ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { return String . format ( \"<STR_LIT>\" , formatDecimal ( decimal ) , appendix ) ; } else { return String . format ( \"<STR_LIT>\" , formatInt ( decimal ) , appendix ) ; } } public static String formatTemperature ( Context context , float temperature ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ) ; return formatDecimalTemperature ( context , prefManager . convertTemperatureFromCelsius ( temperature ) , prefManager . getTemperatureUnit ( ) ) ; } public static String formatPrecipitation ( Context context , float precipitation ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( precipitation < <NUM_LIT> ) return formatDecimal ( precipitation , context . getString ( R . string . units_mm ) ) ; else return formatInt ( precipitation , context . getString ( R . string . units_mm ) ) ; } else { DecimalFormat inchFormatter = new DecimalFormat ( \"<STR_LIT>\" ) ; inchFormatter . setRoundingMode ( RoundingMode . HALF_UP ) ; return String . format ( \"<STR_LIT>\" , removeMinusIfZerosOnly ( inchFormatter . format ( precipitation / <NUM_LIT> ) ) , context . getString ( R . string . units_in ) ) ; } } public static String formatTimeWithoutZone ( Context context , long time ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; SimpleDateFormat df ; if ( android . text . format . DateFormat . is24HourFormat ( context ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } else { df = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; } return df . format ( time ) ; } public static String formatDate ( long time ) { java . text . DateFormat df = java . text . DateFormat . getDateInstance ( DateFormat . SHORT ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; return df . format ( time ) ; } public static String formatWindSpeed ( Context context , float wind_speed ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else if ( wind_speed < <NUM_LIT> ) { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } else { return formatInt ( <NUM_LIT> , context . getString ( R . string . units_Bft ) ) ; } } else if ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_km_h ) ) ; } else return formatInt ( ( float ) ( wind_speed * <NUM_LIT> ) , context . getString ( R . string . units_mph ) ) ; } public static Drawable colorWindSpeed ( Context context , float wind_speed ) { if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ; } else if ( wind_speed < <NUM_LIT> ) { return", "gt": "ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_yellow , null ) ;", "repo": "omweather"}
{"input": "package com . appspa . demo . custom ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . demo . entity . CustomResult ; import com . google . gson . Gson ; public class CustomUpdateParser implements IUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { return getParseResult ( json ) ; } private UpdateEntity getParseResult ( String json ) { CustomResult result = new Gson ( ) . fromJson ( json , CustomResult . class ) ; if ( result != null && result . success && result . data != null ) { CustomResult . VersionInfo data = result . data ; DownloadEntity mPatchDownloadEntity = null ; if ( data . patchInfo != null && data . patchInfo . downloadUrl != null ) { mPatchDownloadEntity = new DownloadEntity ( ) ; mPatchDownloadEntity . setDownloadUrl ( data . patchInfo . downloadUrl ) ; mPatchDownloadEntity . setTip ( data . patchInfo . tip ) ; mPatchDownloadEntity . setSize ( data . patchInfo . size ) ; mPatchDownloadEntity . setMd5 ( data . patchInfo . md5 ) ; mPatchDownloadEntity . setWholeMd5 ( data . patchInfo . tMd5 ) ; mPatchDownloadEntity . setIsPatch ( true ) ; } DownloadEntity downloadEntity = new DownloadEntity ( ) ; downloadEntity . setMd5 ( data . md5 ) ; downloadEntity . setDownloadUrl ( data . downloadUrl ) ; downloadEntity . setSize ( data . size ) ; return new UpdateEntity ( ) . setHasUpdate ( true ) . setForce ( data . isForce ) . setIsIgnorable ( data . isIgnorable ) . setIsSilent ( data . isSilent ) . setVersionCode ( data . versionCode ) . setVersionName ( data . versionName ) . setUpdateContent ( data . changeLog ) . setDownLoadEntity ( downloadEntity ) . setPatchDownloadEntity ( mPatchDownloadEntity ) ; } return", "gt": "new UpdateEntity ( ) . setHasUpdate ( false ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . demo . custom ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . demo . entity . CustomResult ; import com . google . gson . Gson ; public class CustomUpdateParser implements IUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { return getParseResult ( json ) ; } private UpdateEntity getParseResult ( String json ) { CustomResult result = new Gson ( ) . fromJson ( json , CustomResult . class ) ; if ( result != null && result . success && result . data != null ) { CustomResult . VersionInfo data = result . data ; DownloadEntity mPatchDownloadEntity = null ; if ( data . patchInfo != null && data . patchInfo . downloadUrl != null ) { mPatchDownloadEntity = new DownloadEntity ( ) ; mPatchDownloadEntity . setDownloadUrl ( data . patchInfo . downloadUrl ) ; mPatchDownloadEntity . setTip ( data . patchInfo . tip ) ; mPatchDownloadEntity", "gt": ". setSize ( data . patchInfo . size ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . demo . custom ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . demo . entity . CustomResult ; import com . google . gson . Gson ; public class CustomUpdateParser implements IUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { return getParseResult ( json ) ; } private UpdateEntity getParseResult ( String json ) { CustomResult result = new Gson ( ) . fromJson ( json , CustomResult . class ) ; if ( result != null && result . success && result . data != null ) { CustomResult . VersionInfo data = result . data ; DownloadEntity mPatchDownloadEntity = null ; if ( data . patchInfo != null && data . patchInfo . downloadUrl != null ) { mPatchDownloadEntity = new DownloadEntity ( ) ; mPatchDownloadEntity . setDownloadUrl ( data . patchInfo . downloadUrl ) ; mPatchDownloadEntity . setTip ( data . patchInfo . tip ) ; mPatchDownloadEntity . setSize ( data . patchInfo . size ) ; mPatchDownloadEntity . setMd5 ( data . patchInfo . md5 ) ; mPatchDownloadEntity . setWholeMd5 ( data . patchInfo . tMd5 ) ; mPatchDownloadEntity . setIsPatch ( true ) ; } DownloadEntity downloadEntity = new DownloadEntity ( ) ; downloadEntity . setMd5 ( data . md5 ) ; downloadEntity . setDownloadUrl ( data . downloadUrl ) ; downloadEntity . setSize ( data . size ) ; return new UpdateEntity ( ) . setHasUpdate ( true ) . setForce ( data . isForce ) . setIsIgnorable ( data . isIgnorable ) . setIsSilent ( data . isSilent ) . setVersionCode ( data . versionCode ) . setVersionName ( data . versionName ) . setUpdateContent ( data . changeLog ) . setDownLoadEntity ( downloadEntity ) . setPatchDownloadEntity ( mPatchDownloadEntity ) ; } return new UpdateEntity ( ) . setHasUpdate ( false ) ; } @ Override public void parseJson ( String json , @ NonNull IUpdateParseCallback callback ) throws Exception { callback", "gt": ". onParseResult ( getParseResult ( json ) ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . proxy . impl ; import android . app . Activity ; import android . content . Context ; import androidx . annotation . NonNull ; import androidx . fragment . app . FragmentActivity ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . widget . UpdateDialog ; import com . appspa . update . widget . UpdateDialogActivity ; import com . appspa . update . widget . UpdateDialogFragment ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . IUpdateProxy ; public class DefaultUpdatePrompter implements IUpdatePrompter { @ Override public void showPrompt ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy , @ NonNull PromptEntity promptEntity ) { Context context = updateProxy . getContext ( ) ; if ( context == null ) { UpdateLog . e ( \"<STR_LIT>\" ) ; return ; } beforeShowPrompt ( updateEntity , promptEntity ) ; UpdateLog . d ( \"<STR_LIT>\" + promptEntity ) ; if ( context instanceof FragmentActivity ) { UpdateDialogFragment . show ( ( ( FragmentActivity ) context ) . getSupportFragmentManager ( ) , updateEntity , getPrompterProxy ( updateProxy ) , promptEntity ) ; } else if ( context instanceof Activity ) { UpdateDialog", "gt": ". newInstance ( context , updateEntity , getPrompterProxy ( updateProxy ) , promptEntity ) . show ( ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . widget ; import android . app . Dialog ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . view . MotionEvent ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import androidx . annotation . IdRes ; import androidx . core . content . ContextCompat ; import com . appspa . update . R ; import com . appspa . update . utils . DialogUtils ; public abstract class BaseDialog extends Dialog { private View mContentView ; private boolean mIsSyncSystemUiVisibility ; public BaseDialog ( Context context , int layoutId ) { this ( context , R . style . XUpdate_Dialog , layoutId ) ; } public BaseDialog ( Context context , View contentView ) { this ( context , R . style . XUpdate_Dialog , contentView ) ; } public BaseDialog ( Context context ) { super ( context , R . style . XUpdate_Dialog ) ; } public BaseDialog ( Context context , int theme , int layoutId ) { super ( context , theme ) ; init ( layoutId ) ; } public BaseDialog ( Context context , int theme , View contentView ) { super ( context , theme ) ; init ( contentView ) ; } private void init ( int layoutId ) { View view = getLayoutInflater ( ) . inflate ( layoutId , null ) ; init ( view ) ; } private void init ( View view ) { setContentView ( view ) ; mContentView = view ; setCanceledOnTouchOutside ( true ) ; initViews ( ) ; initListeners ( ) ; } @ Override public < T extends View > T findViewById ( @ IdRes int id ) { return mContentView . findViewById ( id ) ; } protected abstract void initViews ( ) ; protected abstract void initListeners ( ) ; protected BaseDialog setDialogSize ( int width , int height ) { Window window = getWindow ( ) ; if ( window != null ) { WindowManager . LayoutParams p = getWindow ( ) . getAttributes ( ) ; p . width = width ; p . height = height ; window . setAttributes ( p ) ; } return this ; } protected String getString ( int resId ) { return getContext ( ) . getResources ( ) . getString ( resId ) ; } protected Drawable getDrawable ( int resId ) { return ContextCompat . getDrawable ( getContext ( ) , resId ) ; } public BaseDialog setIsSyncSystemUiVisibility ( boolean isSyncSystemUiVisibility ) { mIsSyncSystemUiVisibility = isSyncSystemUiVisibility ; return this ; } @ Override public void show ( ) { showIfSync ( mIsSyncSystemUiVisibility ) ; } public void showIfSync ( boolean isSyncSystemUiVisibility ) { if ( isSyncSystemUiVisibility ) { boolean", "gt": "isHandled = DialogUtils . showWindow ( DialogUtils . findActivity ( getContext ( ) ) , getWindow ( ) , new DialogUtils . IWindowShower ( ) {", "repo": "app-space-android"}
{"input": "package com . appspa . demo . custom ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . demo . entity . CustomResult ; import com . google . gson . Gson ; public class CustomUpdateParser implements IUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { return getParseResult ( json ) ; } private UpdateEntity getParseResult ( String json ) { CustomResult result = new Gson ( ) . fromJson ( json , CustomResult . class ) ; if ( result != null && result . success && result . data != null ) { CustomResult . VersionInfo data = result . data ; DownloadEntity mPatchDownloadEntity = null ; if ( data . patchInfo != null && data . patchInfo . downloadUrl != null ) { mPatchDownloadEntity = new DownloadEntity ( ) ; mPatchDownloadEntity . setDownloadUrl ( data . patchInfo . downloadUrl ) ; mPatchDownloadEntity . setTip ( data . patchInfo . tip ) ; mPatchDownloadEntity . setSize ( data . patchInfo . size ) ; mPatchDownloadEntity . setMd5 ( data . patchInfo . md5 ) ; mPatchDownloadEntity . setWholeMd5 ( data . patchInfo . tMd5 ) ; mPatchDownloadEntity . setIsPatch ( true ) ; } DownloadEntity downloadEntity = new DownloadEntity ( ) ; downloadEntity . setMd5 ( data . md5 ) ; downloadEntity . setDownloadUrl ( data . downloadUrl ) ; downloadEntity . setSize ( data . size ) ; return", "gt": "new UpdateEntity ( ) . setHasUpdate ( true ) . setForce ( data . isForce ) . setIsIgnorable ( data . isIgnorable ) . setIsSilent ( data . isSilent ) . setVersionCode ( data . versionCode ) . setVersionName ( data . versionName ) . setUpdateContent ( data . changeLog ) . setDownLoadEntity ( downloadEntity ) . setPatchDownloadEntity ( mPatchDownloadEntity ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . demo . custom ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . demo . entity . CustomResult ; import com . google . gson . Gson ; public class CustomUpdateParser implements IUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { return getParseResult ( json ) ; } private UpdateEntity getParseResult ( String json ) { CustomResult result = new Gson ( ) . fromJson ( json , CustomResult . class ) ; if ( result != null && result . success && result . data != null ) { CustomResult . VersionInfo data = result . data ; DownloadEntity mPatchDownloadEntity = null ; if ( data . patchInfo != null && data . patchInfo . downloadUrl != null ) { mPatchDownloadEntity = new DownloadEntity ( ) ; mPatchDownloadEntity . setDownloadUrl ( data . patchInfo . downloadUrl ) ; mPatchDownloadEntity . setTip ( data . patchInfo . tip ) ; mPatchDownloadEntity . setSize ( data . patchInfo . size ) ; mPatchDownloadEntity . setMd5 ( data . patchInfo . md5 ) ; mPatchDownloadEntity . setWholeMd5 ( data . patchInfo . tMd5 ) ; mPatchDownloadEntity . setIsPatch ( true ) ; } DownloadEntity downloadEntity = new DownloadEntity ( ) ; downloadEntity . setMd5 ( data . md5 ) ; downloadEntity", "gt": ". setDownloadUrl ( data . downloadUrl ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . widget ; import android . app . Dialog ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . view . MotionEvent ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import androidx . annotation . IdRes ; import androidx . core . content . ContextCompat ; import com . appspa . update . R ; import com . appspa . update . utils . DialogUtils ; public abstract class BaseDialog extends Dialog { private View mContentView ; private boolean mIsSyncSystemUiVisibility ; public BaseDialog ( Context context , int layoutId ) { this ( context , R . style . XUpdate_Dialog , layoutId ) ; } public BaseDialog ( Context context , View contentView ) { this ( context , R . style . XUpdate_Dialog , contentView ) ; } public BaseDialog ( Context context ) { super ( context , R . style . XUpdate_Dialog ) ; } public BaseDialog ( Context context , int theme , int layoutId ) { super ( context , theme ) ; init ( layoutId ) ; } public BaseDialog ( Context context , int theme , View contentView ) { super ( context , theme ) ; init ( contentView ) ; } private void init ( int layoutId ) { View view = getLayoutInflater ( ) . inflate ( layoutId , null ) ; init ( view ) ; } private void init ( View view ) { setContentView ( view ) ; mContentView = view ; setCanceledOnTouchOutside ( true ) ; initViews ( ) ; initListeners ( ) ; } @ Override public < T extends View > T findViewById ( @ IdRes int id ) { return mContentView . findViewById ( id ) ; } protected abstract void initViews ( ) ; protected abstract void initListeners ( ) ; protected BaseDialog setDialogSize ( int width , int height ) { Window window = getWindow ( ) ; if ( window != null ) { WindowManager . LayoutParams p = getWindow ( ) . getAttributes ( ) ; p . width = width ; p . height = height ; window . setAttributes ( p ) ; } return this ; } protected String getString ( int resId ) { return getContext ( ) . getResources ( ) . getString ( resId ) ; } protected Drawable getDrawable ( int resId ) { return ContextCompat . getDrawable ( getContext ( ) , resId ) ; } public BaseDialog setIsSyncSystemUiVisibility ( boolean isSyncSystemUiVisibility ) { mIsSyncSystemUiVisibility = isSyncSystemUiVisibility ; return this ; } @ Override public void show ( ) { showIfSync ( mIsSyncSystemUiVisibility ) ; } public void showIfSync ( boolean isSyncSystemUiVisibility ) { if ( isSyncSystemUiVisibility ) { boolean isHandled = DialogUtils . showWindow ( DialogUtils . findActivity ( getContext ( ) ) , getWindow ( ) , new DialogUtils . IWindowShower ( ) { @ Override public void show ( Window window ) { performShow ( ) ; } } ) ; if ( ! isHandled ) { performShow ( ) ; } } else { performShow ( ) ; } } protected void performShow ( ) { super . show ( ) ; } @ Override public boolean onTouchEvent ( MotionEvent ev ) { if", "gt": "( ev . getAction ( ) == MotionEvent . ACTION_DOWN ) {", "repo": "app-space-android"}
{"input": "package com . appspa . update . widget ; import android . app . Dialog ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . view . MotionEvent ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import androidx . annotation . IdRes ; import androidx . core . content . ContextCompat ; import com . appspa . update . R ; import com . appspa . update . utils . DialogUtils ; public abstract class BaseDialog extends Dialog { private View mContentView ; private boolean mIsSyncSystemUiVisibility ; public BaseDialog ( Context context , int layoutId ) { this ( context , R . style . XUpdate_Dialog , layoutId ) ; } public BaseDialog ( Context context , View contentView ) { this ( context , R . style . XUpdate_Dialog , contentView ) ; } public BaseDialog ( Context context ) { super ( context , R . style . XUpdate_Dialog ) ; } public BaseDialog ( Context context , int theme , int layoutId ) { super ( context , theme ) ; init ( layoutId ) ; } public BaseDialog ( Context context , int theme , View contentView ) { super ( context , theme ) ; init ( contentView ) ; } private void init ( int layoutId ) { View view = getLayoutInflater ( ) . inflate ( layoutId , null ) ; init ( view ) ; } private void init ( View view ) { setContentView ( view ) ; mContentView = view ; setCanceledOnTouchOutside ( true ) ; initViews ( ) ; initListeners ( ) ; } @ Override public < T extends View > T findViewById ( @ IdRes int id ) { return mContentView . findViewById ( id ) ; } protected abstract void initViews ( ) ; protected abstract void initListeners ( ) ; protected BaseDialog setDialogSize ( int width , int height ) { Window window = getWindow ( ) ; if ( window != null ) { WindowManager . LayoutParams p = getWindow ( ) . getAttributes ( ) ; p . width = width ; p . height = height ; window . setAttributes ( p ) ; } return this ; } protected String getString ( int resId ) { return getContext ( ) . getResources ( ) . getString ( resId ) ; } protected Drawable getDrawable ( int resId ) { return ContextCompat . getDrawable ( getContext ( ) , resId ) ; } public BaseDialog setIsSyncSystemUiVisibility ( boolean isSyncSystemUiVisibility ) { mIsSyncSystemUiVisibility = isSyncSystemUiVisibility ; return this ; } @ Override public void show ( ) { showIfSync ( mIsSyncSystemUiVisibility ) ; } public void showIfSync ( boolean isSyncSystemUiVisibility ) { if ( isSyncSystemUiVisibility ) { boolean isHandled = DialogUtils . showWindow ( DialogUtils . findActivity ( getContext ( ) ) , getWindow ( ) , new DialogUtils . IWindowShower ( ) { @ Override public void show ( Window window ) { performShow ( ) ; } } ) ; if ( ! isHandled ) { performShow ( ) ; } } else { performShow ( ) ; } } protected void performShow ( ) { super . show ( ) ; } @ Override public boolean onTouchEvent ( MotionEvent ev ) { if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN ) { if ( DialogUtils . isShouldHideInput ( getWindow ( ) , ev ) ) { DialogUtils . hideSoftInput ( getCurrentFocus ( ) ) ; } } return", "gt": "super . onTouchEvent ( ev ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . utils ; import java . io . BufferedReader ; import java . io . DataOutputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . List ; class ShellUtils { public static final String COMMAND_SU = \"<STR_LIT>\" ; public static final String COMMAND_SH = \"<STR_LIT>\" ; public static final String COMMAND_EXIT = \"<STR_LIT>\" ; public static final String COMMAND_LINE_END = \"<STR_LIT>\" ; private ShellUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static boolean checkRootPermission ( ) { return execCommand ( \"<STR_LIT>\" , true , false ) . result == <NUM_LIT> ; } public static CommandResult execCommand ( String command , boolean isRoot ) { return execCommand ( new String [ ] { command } , isRoot , true ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , true ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot ) { return execCommand ( commands , isRoot , true ) ; } public static CommandResult execCommand ( String command , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( new String [ ] { command } , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot , boolean isNeedResultMsg ) { int result = - <NUM_LIT> ; if ( commands == null || commands . length == <NUM_LIT> ) { return new CommandResult ( result , null , null ) ; } Process process = null ; BufferedReader successResult = null ; BufferedReader errorResult = null ; StringBuilder successMsg = null ; StringBuilder errorMsg = null ; DataOutputStream os = null ; try { process = Runtime . getRuntime ( ) . exec ( isRoot ? COMMAND_SU : COMMAND_SH ) ; os = new DataOutputStream ( process . getOutputStream ( ) ) ; for ( String command : commands ) { if ( command == null ) { continue ; } os . write ( command . getBytes ( ) ) ; os . writeBytes ( COMMAND_LINE_END ) ; os . flush ( ) ; } os . writeBytes ( COMMAND_EXIT ) ; os . flush ( ) ; result = process . waitFor ( ) ; if ( isNeedResultMsg ) { successMsg = new StringBuilder ( ) ; errorMsg = new StringBuilder ( ) ; successResult", "gt": "= new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . widget ; import android . app . Dialog ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . view . MotionEvent ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import androidx . annotation . IdRes ; import androidx . core . content . ContextCompat ; import com . appspa . update . R ; import com . appspa . update . utils . DialogUtils ; public abstract class BaseDialog extends Dialog { private View mContentView ; private boolean mIsSyncSystemUiVisibility ; public BaseDialog ( Context context , int layoutId ) { this ( context , R . style . XUpdate_Dialog , layoutId ) ; } public BaseDialog ( Context context , View contentView ) { this ( context , R . style . XUpdate_Dialog , contentView ) ; } public BaseDialog ( Context context ) { super ( context , R . style . XUpdate_Dialog ) ; } public BaseDialog ( Context context , int theme , int layoutId ) { super ( context , theme ) ; init ( layoutId ) ; } public BaseDialog ( Context context , int theme , View contentView ) { super ( context , theme ) ; init ( contentView ) ; } private void init ( int layoutId ) { View view = getLayoutInflater ( ) . inflate ( layoutId , null ) ; init ( view ) ; } private void init ( View view ) { setContentView ( view ) ; mContentView = view ; setCanceledOnTouchOutside ( true ) ; initViews ( ) ; initListeners ( ) ; } @ Override public < T extends View > T findViewById ( @ IdRes int id ) { return mContentView . findViewById ( id ) ; } protected abstract void initViews ( ) ; protected abstract void initListeners ( ) ; protected BaseDialog setDialogSize ( int width , int height ) { Window window = getWindow ( ) ; if ( window != null ) { WindowManager . LayoutParams p = getWindow ( ) . getAttributes ( ) ; p . width = width ; p . height = height ; window . setAttributes ( p ) ; } return this ; } protected String getString ( int resId ) { return", "gt": "getContext ( ) . getResources ( ) . getString ( resId ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . demo . custom ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . demo . entity . CustomResult ; import com . google . gson . Gson ; public class CustomUpdateParser implements IUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { return getParseResult ( json ) ; } private UpdateEntity getParseResult ( String json ) { CustomResult result = new Gson ( ) . fromJson ( json , CustomResult . class ) ; if ( result != null && result . success && result . data != null ) { CustomResult . VersionInfo data = result . data ; DownloadEntity mPatchDownloadEntity = null ; if ( data . patchInfo != null && data . patchInfo . downloadUrl != null ) { mPatchDownloadEntity = new DownloadEntity ( ) ; mPatchDownloadEntity . setDownloadUrl ( data . patchInfo . downloadUrl ) ; mPatchDownloadEntity . setTip ( data . patchInfo . tip ) ; mPatchDownloadEntity . setSize ( data . patchInfo . size ) ; mPatchDownloadEntity . setMd5 ( data . patchInfo . md5 ) ; mPatchDownloadEntity", "gt": ". setWholeMd5 ( data . patchInfo . tMd5 ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . widget ; import android . app . Dialog ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . view . MotionEvent ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import androidx . annotation . IdRes ; import androidx . core . content . ContextCompat ; import com . appspa . update . R ; import com . appspa . update . utils . DialogUtils ; public abstract class BaseDialog extends Dialog { private View mContentView ; private boolean mIsSyncSystemUiVisibility ; public BaseDialog ( Context context , int layoutId ) { this ( context , R . style . XUpdate_Dialog , layoutId ) ; } public BaseDialog ( Context context , View contentView ) { this ( context , R . style . XUpdate_Dialog , contentView ) ; } public BaseDialog ( Context context ) { super ( context , R . style . XUpdate_Dialog ) ; } public BaseDialog ( Context context , int theme , int layoutId ) { super ( context , theme ) ; init ( layoutId ) ; } public BaseDialog ( Context context , int theme , View contentView ) { super ( context , theme ) ; init ( contentView ) ; } private void init ( int layoutId ) { View view = getLayoutInflater ( ) . inflate ( layoutId , null ) ; init ( view ) ; } private void init ( View view ) { setContentView ( view ) ; mContentView = view ; setCanceledOnTouchOutside ( true ) ; initViews ( ) ; initListeners ( ) ; } @ Override public < T extends View > T findViewById ( @ IdRes int id ) { return mContentView . findViewById ( id ) ; } protected abstract void initViews ( ) ; protected abstract void initListeners ( ) ; protected BaseDialog setDialogSize ( int width , int height ) { Window window = getWindow ( ) ; if ( window != null ) { WindowManager . LayoutParams p = getWindow ( ) . getAttributes ( ) ; p . width = width ; p . height = height ; window . setAttributes ( p ) ; } return this ; } protected String getString ( int resId ) { return getContext ( ) . getResources ( ) . getString ( resId ) ; } protected Drawable getDrawable ( int resId ) { return ContextCompat . getDrawable ( getContext ( ) , resId ) ; } public BaseDialog setIsSyncSystemUiVisibility ( boolean isSyncSystemUiVisibility ) { mIsSyncSystemUiVisibility = isSyncSystemUiVisibility ; return this ; } @ Override public void show ( ) { showIfSync ( mIsSyncSystemUiVisibility ) ; } public void showIfSync ( boolean isSyncSystemUiVisibility ) { if ( isSyncSystemUiVisibility ) { boolean isHandled = DialogUtils . showWindow ( DialogUtils . findActivity ( getContext ( ) ) , getWindow ( ) , new DialogUtils . IWindowShower ( ) { @ Override public void show ( Window window ) { performShow ( ) ; } } ) ; if ( ! isHandled ) { performShow ( ) ; } } else { performShow ( ) ; } } protected void performShow ( ) { super . show ( ) ; } @ Override public boolean onTouchEvent ( MotionEvent ev ) { if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN ) { if", "gt": "( DialogUtils . isShouldHideInput ( getWindow ( ) , ev ) ) {", "repo": "app-space-android"}
{"input": "package com . appspa . demo . custom ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . demo . entity . CustomResult ; import com . google . gson . Gson ; public class CustomUpdateParser implements IUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { return getParseResult ( json ) ; } private UpdateEntity getParseResult ( String json ) { CustomResult result = new Gson ( ) . fromJson ( json , CustomResult . class ) ; if ( result != null && result . success && result . data != null ) { CustomResult . VersionInfo data = result . data ; DownloadEntity mPatchDownloadEntity = null ; if ( data . patchInfo != null && data . patchInfo . downloadUrl != null ) { mPatchDownloadEntity = new DownloadEntity ( ) ; mPatchDownloadEntity . setDownloadUrl ( data . patchInfo . downloadUrl ) ; mPatchDownloadEntity", "gt": ". setTip ( data . patchInfo . tip ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . demo . custom ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . demo . entity . CustomResult ; import com . google . gson . Gson ; public class CustomUpdateParser implements IUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { return getParseResult ( json ) ; } private UpdateEntity getParseResult ( String json ) { CustomResult result = new Gson ( ) . fromJson ( json , CustomResult . class ) ; if ( result != null && result . success && result . data != null ) { CustomResult . VersionInfo data = result . data ; DownloadEntity mPatchDownloadEntity = null ; if ( data . patchInfo != null && data . patchInfo . downloadUrl != null ) { mPatchDownloadEntity = new DownloadEntity ( ) ; mPatchDownloadEntity . setDownloadUrl ( data . patchInfo . downloadUrl ) ; mPatchDownloadEntity . setTip ( data . patchInfo . tip ) ; mPatchDownloadEntity . setSize ( data . patchInfo . size ) ; mPatchDownloadEntity . setMd5 ( data . patchInfo . md5 ) ; mPatchDownloadEntity . setWholeMd5 ( data . patchInfo . tMd5 ) ; mPatchDownloadEntity . setIsPatch ( true ) ; } DownloadEntity downloadEntity = new DownloadEntity ( ) ; downloadEntity", "gt": ". setMd5 ( data . md5 ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . widget ; import android . app . Dialog ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . view . MotionEvent ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import androidx . annotation . IdRes ; import androidx . core . content . ContextCompat ; import com . appspa . update . R ; import com . appspa . update . utils . DialogUtils ; public abstract class BaseDialog extends Dialog { private View mContentView ; private boolean mIsSyncSystemUiVisibility ; public BaseDialog ( Context context , int layoutId ) { this ( context , R . style . XUpdate_Dialog , layoutId ) ; } public BaseDialog ( Context context , View contentView ) { this ( context , R . style . XUpdate_Dialog , contentView ) ; } public BaseDialog ( Context context ) { super ( context , R . style . XUpdate_Dialog ) ; } public BaseDialog ( Context context , int theme , int layoutId ) { super ( context , theme ) ; init ( layoutId ) ; } public BaseDialog ( Context context , int theme , View contentView ) { super ( context , theme ) ; init ( contentView ) ; } private void init ( int layoutId ) { View view = getLayoutInflater ( ) . inflate ( layoutId , null ) ; init ( view ) ; } private void init ( View view ) { setContentView ( view ) ; mContentView = view ; setCanceledOnTouchOutside ( true ) ; initViews ( ) ; initListeners ( ) ; } @ Override public < T extends View > T findViewById ( @ IdRes int id ) { return mContentView . findViewById ( id ) ; } protected abstract void initViews ( ) ; protected abstract void initListeners ( ) ; protected BaseDialog setDialogSize ( int width , int height ) { Window window = getWindow ( ) ; if ( window != null ) { WindowManager . LayoutParams p = getWindow ( ) . getAttributes ( ) ; p . width = width ; p . height = height ; window . setAttributes ( p ) ; } return this ; } protected String getString ( int resId ) { return getContext ( ) . getResources ( ) . getString ( resId ) ; } protected Drawable getDrawable ( int resId ) { return ContextCompat . getDrawable ( getContext ( ) , resId ) ; } public BaseDialog setIsSyncSystemUiVisibility ( boolean isSyncSystemUiVisibility ) { mIsSyncSystemUiVisibility = isSyncSystemUiVisibility ; return this ; } @ Override public void show ( ) { showIfSync ( mIsSyncSystemUiVisibility ) ; } public void showIfSync ( boolean isSyncSystemUiVisibility ) { if ( isSyncSystemUiVisibility ) { boolean isHandled = DialogUtils . showWindow ( DialogUtils . findActivity ( getContext ( ) ) , getWindow ( ) , new DialogUtils . IWindowShower ( ) { @ Override public void show ( Window window ) { performShow ( ) ; } } ) ; if ( ! isHandled ) { performShow ( ) ; } } else { performShow ( ) ; } } protected void performShow ( ) { super . show ( ) ; } @ Override public boolean onTouchEvent ( MotionEvent ev ) { if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN ) { if ( DialogUtils . isShouldHideInput ( getWindow ( ) , ev ) ) { DialogUtils", "gt": ". hideSoftInput ( getCurrentFocus ( ) ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . demo . custom ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . demo . entity . CustomResult ; import com . google . gson . Gson ; public class CustomUpdateParser implements IUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { return getParseResult ( json ) ; } private UpdateEntity getParseResult ( String json ) { CustomResult result = new Gson ( ) . fromJson ( json , CustomResult . class ) ; if ( result != null && result . success && result . data != null ) { CustomResult . VersionInfo data = result . data ; DownloadEntity mPatchDownloadEntity = null ; if ( data . patchInfo != null && data . patchInfo . downloadUrl != null ) { mPatchDownloadEntity = new DownloadEntity ( ) ; mPatchDownloadEntity . setDownloadUrl ( data . patchInfo . downloadUrl ) ; mPatchDownloadEntity . setTip ( data . patchInfo . tip ) ; mPatchDownloadEntity . setSize ( data . patchInfo . size ) ; mPatchDownloadEntity . setMd5 ( data . patchInfo . md5 ) ; mPatchDownloadEntity . setWholeMd5 ( data . patchInfo . tMd5 ) ; mPatchDownloadEntity . setIsPatch ( true ) ; } DownloadEntity", "gt": "downloadEntity = new DownloadEntity ( ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . utils ; import java . io . BufferedReader ; import java . io . DataOutputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . List ; class ShellUtils { public static final String COMMAND_SU = \"<STR_LIT>\" ; public static final String COMMAND_SH = \"<STR_LIT>\" ; public static final String COMMAND_EXIT = \"<STR_LIT>\" ; public static final String COMMAND_LINE_END = \"<STR_LIT>\" ; private ShellUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static boolean checkRootPermission ( ) { return execCommand ( \"<STR_LIT>\" , true , false ) . result == <NUM_LIT> ; } public static CommandResult execCommand ( String command , boolean isRoot ) { return execCommand ( new String [ ] { command } , isRoot , true ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , true ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot ) { return execCommand ( commands , isRoot , true ) ; } public static CommandResult execCommand ( String command , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( new String [ ] { command } , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot , boolean isNeedResultMsg ) { int result = - <NUM_LIT> ; if ( commands == null || commands . length == <NUM_LIT> ) { return new CommandResult ( result , null , null ) ; } Process process = null ; BufferedReader successResult = null ; BufferedReader errorResult = null ; StringBuilder successMsg = null ; StringBuilder errorMsg = null ; DataOutputStream os = null ; try { process = Runtime . getRuntime ( ) . exec ( isRoot ? COMMAND_SU : COMMAND_SH ) ; os = new DataOutputStream ( process . getOutputStream ( ) ) ; for ( String command : commands ) { if ( command == null ) { continue ; } os . write ( command . getBytes ( ) ) ; os . writeBytes ( COMMAND_LINE_END ) ; os . flush ( ) ; } os . writeBytes ( COMMAND_EXIT ) ; os . flush ( ) ; result = process . waitFor ( ) ; if ( isNeedResultMsg ) { successMsg = new StringBuilder ( ) ; errorMsg = new StringBuilder ( ) ; successResult = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; errorResult = new BufferedReader ( new InputStreamReader ( process . getErrorStream ( ) ) ) ; String s ; while ( ( s = successResult . readLine ( ) ) != null ) { successMsg . append ( s ) ; } while", "gt": "( ( s = errorResult . readLine ( ) ) != null ) {", "repo": "app-space-android"}
{"input": "package com . appspa . update . proxy . impl ; import android . app . Activity ; import android . content . Context ; import androidx . annotation . NonNull ; import androidx . fragment . app . FragmentActivity ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . widget . UpdateDialog ; import com . appspa . update . widget . UpdateDialogActivity ; import com . appspa . update . widget . UpdateDialogFragment ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . IUpdateProxy ; public class DefaultUpdatePrompter implements IUpdatePrompter { @ Override public void showPrompt ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy , @ NonNull PromptEntity promptEntity ) { Context context = updateProxy . getContext ( ) ; if ( context == null ) { UpdateLog . e ( \"<STR_LIT>\" ) ; return ; } beforeShowPrompt ( updateEntity , promptEntity ) ; UpdateLog . d ( \"<STR_LIT>\" + promptEntity ) ; if ( context instanceof FragmentActivity ) { UpdateDialogFragment . show ( ( ( FragmentActivity ) context ) . getSupportFragmentManager ( ) , updateEntity , getPrompterProxy ( updateProxy ) , promptEntity ) ; } else if ( context instanceof Activity ) { UpdateDialog . newInstance ( context , updateEntity , getPrompterProxy ( updateProxy ) , promptEntity ) . show ( ) ; } else { UpdateDialogActivity . show ( context , updateEntity , getPrompterProxy ( updateProxy ) , promptEntity ) ; } } protected void beforeShowPrompt ( @ NonNull UpdateEntity updateEntity , @ NonNull PromptEntity promptEntity ) { if", "gt": "( updateEntity . isForce ( ) ) {", "repo": "app-space-android"}
{"input": "package com . appspa . update . widget ; import android . app . Dialog ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . view . MotionEvent ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import androidx . annotation . IdRes ; import androidx . core . content . ContextCompat ; import com . appspa . update . R ; import com . appspa . update . utils . DialogUtils ; public abstract class BaseDialog extends Dialog { private View mContentView ; private boolean mIsSyncSystemUiVisibility ; public BaseDialog ( Context context , int layoutId ) { this ( context , R . style . XUpdate_Dialog , layoutId ) ; } public BaseDialog ( Context context , View contentView ) { this ( context , R . style . XUpdate_Dialog , contentView ) ; } public BaseDialog ( Context context ) { super ( context , R . style . XUpdate_Dialog ) ; } public BaseDialog ( Context context , int theme , int layoutId ) { super ( context , theme ) ; init ( layoutId ) ; } public BaseDialog ( Context context , int theme , View contentView ) { super ( context , theme ) ; init ( contentView ) ; } private void init ( int layoutId ) { View view = getLayoutInflater ( ) . inflate ( layoutId , null ) ; init ( view ) ; } private void init ( View view ) { setContentView ( view ) ; mContentView = view ; setCanceledOnTouchOutside ( true ) ; initViews ( ) ; initListeners ( ) ; } @ Override public < T extends View > T findViewById ( @ IdRes int id ) { return mContentView . findViewById ( id ) ; } protected abstract void initViews ( ) ; protected abstract void initListeners ( ) ; protected BaseDialog setDialogSize ( int width , int height ) { Window window = getWindow ( ) ; if ( window != null ) { WindowManager", "gt": ". LayoutParams p = getWindow ( ) . getAttributes ( ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . proxy . impl ; import android . app . Activity ; import android . content . Context ; import androidx . annotation . NonNull ; import androidx . fragment . app . FragmentActivity ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . widget . UpdateDialog ; import com . appspa . update . widget . UpdateDialogActivity ; import com . appspa . update . widget . UpdateDialogFragment ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . IUpdateProxy ; public class DefaultUpdatePrompter implements IUpdatePrompter { @ Override public void showPrompt ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy , @ NonNull PromptEntity promptEntity ) { Context context = updateProxy . getContext ( ) ; if ( context == null ) { UpdateLog . e ( \"<STR_LIT>\" ) ; return ; } beforeShowPrompt ( updateEntity , promptEntity ) ; UpdateLog", "gt": ". d ( \"<STR_LIT>\" + promptEntity ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . utils ; import java . io . BufferedReader ; import java . io . DataOutputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . List ; class ShellUtils { public static final String COMMAND_SU = \"<STR_LIT>\" ; public static final String COMMAND_SH = \"<STR_LIT>\" ; public static final String COMMAND_EXIT = \"<STR_LIT>\" ; public static final String COMMAND_LINE_END = \"<STR_LIT>\" ; private ShellUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static boolean checkRootPermission ( ) { return execCommand ( \"<STR_LIT>\" , true , false ) . result == <NUM_LIT> ; } public static CommandResult execCommand ( String command , boolean isRoot ) { return execCommand ( new String [ ] { command } , isRoot , true ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , true ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot ) { return execCommand ( commands , isRoot , true ) ; } public static CommandResult execCommand ( String command , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( new String [ ] { command } , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot , boolean isNeedResultMsg ) { int result = - <NUM_LIT> ; if ( commands == null || commands . length == <NUM_LIT> ) { return new CommandResult ( result , null , null ) ; } Process process = null ; BufferedReader successResult = null ; BufferedReader errorResult = null ; StringBuilder successMsg = null ; StringBuilder errorMsg = null ; DataOutputStream os = null ; try { process = Runtime . getRuntime ( ) . exec ( isRoot ? COMMAND_SU : COMMAND_SH ) ; os = new DataOutputStream ( process . getOutputStream ( ) ) ; for ( String command : commands ) { if ( command == null ) { continue ; } os . write ( command . getBytes ( ) ) ; os . writeBytes ( COMMAND_LINE_END ) ; os . flush ( ) ; } os . writeBytes ( COMMAND_EXIT ) ; os . flush ( ) ; result = process . waitFor ( ) ; if ( isNeedResultMsg ) { successMsg = new StringBuilder ( ) ; errorMsg = new StringBuilder ( ) ; successResult = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; errorResult", "gt": "= new BufferedReader ( new InputStreamReader ( process . getErrorStream ( ) ) ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . demo . custom ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . demo . entity . CustomResult ; import com . google . gson . Gson ; public class CustomUpdateParser implements IUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { return getParseResult ( json ) ; } private UpdateEntity getParseResult ( String json ) { CustomResult result = new Gson ( ) . fromJson ( json , CustomResult . class ) ; if ( result != null && result . success && result . data != null ) { CustomResult . VersionInfo data = result . data ; DownloadEntity mPatchDownloadEntity = null ; if ( data . patchInfo != null && data . patchInfo . downloadUrl != null ) { mPatchDownloadEntity = new DownloadEntity ( ) ; mPatchDownloadEntity . setDownloadUrl ( data . patchInfo . downloadUrl ) ; mPatchDownloadEntity . setTip ( data . patchInfo . tip ) ; mPatchDownloadEntity . setSize ( data . patchInfo . size ) ; mPatchDownloadEntity . setMd5 ( data . patchInfo . md5 ) ; mPatchDownloadEntity . setWholeMd5 ( data . patchInfo . tMd5 ) ; mPatchDownloadEntity . setIsPatch ( true ) ; } DownloadEntity downloadEntity = new DownloadEntity ( ) ; downloadEntity . setMd5 ( data . md5 ) ; downloadEntity . setDownloadUrl ( data . downloadUrl ) ; downloadEntity", "gt": ". setSize ( data . size ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . utils ; import java . io . BufferedReader ; import java . io . DataOutputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . List ; class ShellUtils { public static final String COMMAND_SU = \"<STR_LIT>\" ; public static final String COMMAND_SH = \"<STR_LIT>\" ; public static final String COMMAND_EXIT = \"<STR_LIT>\" ; public static final String COMMAND_LINE_END = \"<STR_LIT>\" ; private ShellUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static boolean checkRootPermission ( ) { return execCommand ( \"<STR_LIT>\" , true , false ) . result == <NUM_LIT> ; } public static CommandResult execCommand ( String command , boolean isRoot ) { return execCommand ( new String [ ] { command } , isRoot , true ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , true ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot ) { return execCommand ( commands , isRoot , true ) ; } public static CommandResult execCommand ( String command , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( new String [ ] { command } , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot , boolean isNeedResultMsg ) { int result = - <NUM_LIT> ; if ( commands == null || commands . length == <NUM_LIT> ) { return new CommandResult ( result , null , null ) ; } Process process = null ; BufferedReader successResult = null ; BufferedReader errorResult = null ; StringBuilder successMsg = null ; StringBuilder errorMsg = null ; DataOutputStream os = null ; try { process = Runtime . getRuntime ( ) . exec ( isRoot ? COMMAND_SU : COMMAND_SH ) ; os = new DataOutputStream ( process . getOutputStream ( ) ) ; for ( String command : commands ) { if ( command == null ) { continue ; } os . write ( command . getBytes ( ) ) ; os . writeBytes ( COMMAND_LINE_END ) ; os . flush ( ) ; } os . writeBytes ( COMMAND_EXIT ) ; os . flush ( ) ; result = process . waitFor ( ) ; if ( isNeedResultMsg ) { successMsg = new StringBuilder ( ) ; errorMsg = new StringBuilder ( ) ; successResult = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; errorResult = new BufferedReader ( new InputStreamReader ( process . getErrorStream ( ) ) ) ; String s ; while ( ( s = successResult . readLine ( ) ) != null ) { successMsg . append ( s ) ; } while ( ( s = errorResult . readLine ( ) ) != null ) { errorMsg . append ( s ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { if ( os != null ) { os . close ( ) ; } if ( successResult != null ) { successResult . close ( ) ; } if ( errorResult != null ) { errorResult . close ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( process != null ) { process . destroy ( ) ; } } return", "gt": "new CommandResult ( result , successMsg == null ? null : successMsg . toString ( ) , errorMsg == null ? null : errorMsg . toString ( ) ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . proxy . impl ; import android . app . Activity ; import android . content . Context ; import androidx . annotation . NonNull ; import androidx . fragment . app . FragmentActivity ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . widget . UpdateDialog ; import com . appspa . update . widget . UpdateDialogActivity ; import com . appspa . update . widget . UpdateDialogFragment ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . IUpdateProxy ; public class DefaultUpdatePrompter implements IUpdatePrompter { @ Override public void showPrompt ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy , @ NonNull PromptEntity promptEntity ) { Context context = updateProxy . getContext ( ) ; if ( context == null ) { UpdateLog . e ( \"<STR_LIT>\" ) ; return ; } beforeShowPrompt ( updateEntity , promptEntity ) ; UpdateLog . d ( \"<STR_LIT>\" + promptEntity ) ; if ( context instanceof FragmentActivity ) { UpdateDialogFragment . show ( ( ( FragmentActivity ) context ) . getSupportFragmentManager ( ) , updateEntity , getPrompterProxy ( updateProxy ) , promptEntity ) ; } else", "gt": "if ( context instanceof Activity ) {", "repo": "app-space-android"}
{"input": "package com . appspa . update . widget ; import android . app . Dialog ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . view . MotionEvent ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import androidx . annotation . IdRes ; import androidx . core . content . ContextCompat ; import com . appspa . update . R ; import com . appspa . update . utils . DialogUtils ; public abstract class BaseDialog extends Dialog { private View mContentView ; private boolean mIsSyncSystemUiVisibility ; public BaseDialog ( Context context , int layoutId ) { this ( context , R . style . XUpdate_Dialog , layoutId ) ; } public BaseDialog ( Context context , View contentView ) { this ( context , R . style . XUpdate_Dialog , contentView ) ; } public BaseDialog ( Context context ) { super ( context , R . style . XUpdate_Dialog ) ; } public BaseDialog ( Context context , int theme , int layoutId ) { super ( context , theme ) ; init ( layoutId ) ; } public BaseDialog ( Context context , int theme , View contentView ) { super ( context , theme ) ; init ( contentView ) ; } private void init ( int layoutId ) { View view = getLayoutInflater ( ) . inflate ( layoutId , null ) ; init ( view ) ; } private void init ( View view ) { setContentView ( view ) ; mContentView = view ; setCanceledOnTouchOutside ( true ) ; initViews ( ) ; initListeners ( ) ; } @ Override public < T extends View > T findViewById ( @ IdRes int id ) { return mContentView . findViewById ( id ) ; } protected abstract void initViews ( ) ; protected abstract void initListeners ( ) ; protected BaseDialog setDialogSize ( int width , int height ) { Window window = getWindow ( ) ; if ( window != null ) { WindowManager . LayoutParams p = getWindow ( ) . getAttributes ( ) ; p . width = width ; p . height = height ; window . setAttributes ( p ) ; } return this ; } protected String getString ( int resId ) { return getContext ( ) . getResources ( ) . getString ( resId ) ; } protected Drawable getDrawable ( int resId ) { return", "gt": "ContextCompat . getDrawable ( getContext ( ) , resId ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . proxy . impl ; import android . app . Activity ; import android . content . Context ; import androidx . annotation . NonNull ; import androidx . fragment . app . FragmentActivity ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . widget . UpdateDialog ; import com . appspa . update . widget . UpdateDialogActivity ; import com . appspa . update . widget . UpdateDialogFragment ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . IUpdateProxy ; public class DefaultUpdatePrompter implements IUpdatePrompter { @ Override public void showPrompt ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy , @ NonNull PromptEntity promptEntity ) { Context context = updateProxy . getContext ( ) ; if ( context == null ) { UpdateLog . e ( \"<STR_LIT>\" ) ; return ; } beforeShowPrompt ( updateEntity , promptEntity ) ; UpdateLog . d ( \"<STR_LIT>\" + promptEntity ) ; if ( context instanceof FragmentActivity ) { UpdateDialogFragment", "gt": ". show ( ( ( FragmentActivity ) context ) . getSupportFragmentManager ( ) , updateEntity , getPrompterProxy ( updateProxy ) , promptEntity ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . demo . custom ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . demo . entity . CustomResult ; import com . google . gson . Gson ; public class CustomUpdateParser implements IUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { return getParseResult ( json ) ; } private UpdateEntity getParseResult ( String json ) { CustomResult result = new Gson ( ) . fromJson ( json , CustomResult . class ) ; if ( result != null && result . success && result . data != null ) { CustomResult . VersionInfo data = result . data ; DownloadEntity mPatchDownloadEntity = null ; if ( data . patchInfo != null && data . patchInfo . downloadUrl != null ) { mPatchDownloadEntity = new DownloadEntity ( ) ; mPatchDownloadEntity . setDownloadUrl ( data . patchInfo . downloadUrl ) ; mPatchDownloadEntity . setTip ( data . patchInfo . tip ) ; mPatchDownloadEntity . setSize ( data . patchInfo . size ) ; mPatchDownloadEntity", "gt": ". setMd5 ( data . patchInfo . md5 ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . utils ; import java . io . BufferedReader ; import java . io . DataOutputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . List ; class ShellUtils { public static final String COMMAND_SU = \"<STR_LIT>\" ; public static final String COMMAND_SH = \"<STR_LIT>\" ; public static final String COMMAND_EXIT = \"<STR_LIT>\" ; public static final String COMMAND_LINE_END = \"<STR_LIT>\" ; private ShellUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static boolean checkRootPermission ( ) { return execCommand ( \"<STR_LIT>\" , true , false ) . result == <NUM_LIT> ; } public static CommandResult execCommand ( String command , boolean isRoot ) { return execCommand ( new String [ ] { command } , isRoot , true ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , true ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot ) { return execCommand ( commands , isRoot , true ) ; } public static CommandResult execCommand ( String command , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( new String [ ] { command } , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot , boolean isNeedResultMsg ) { int result = - <NUM_LIT> ; if ( commands == null || commands . length == <NUM_LIT> ) { return new CommandResult ( result , null , null ) ; } Process process = null ; BufferedReader successResult = null ; BufferedReader errorResult = null ; StringBuilder successMsg = null ; StringBuilder errorMsg = null ; DataOutputStream os = null ; try { process = Runtime . getRuntime ( ) . exec ( isRoot ? COMMAND_SU : COMMAND_SH ) ; os = new DataOutputStream ( process . getOutputStream ( ) ) ; for ( String command : commands ) { if ( command == null ) { continue ; } os . write ( command . getBytes ( ) ) ; os . writeBytes ( COMMAND_LINE_END ) ; os . flush ( ) ; } os . writeBytes ( COMMAND_EXIT ) ; os . flush ( ) ; result", "gt": "= process . waitFor ( ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . proxy . impl ; import android . app . Activity ; import android . content . Context ; import androidx . annotation . NonNull ; import androidx . fragment . app . FragmentActivity ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . widget . UpdateDialog ; import com . appspa . update . widget . UpdateDialogActivity ; import com . appspa . update . widget . UpdateDialogFragment ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . IUpdateProxy ; public class DefaultUpdatePrompter implements IUpdatePrompter { @ Override public void showPrompt ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy , @ NonNull PromptEntity promptEntity ) { Context context = updateProxy . getContext ( ) ; if ( context == null ) { UpdateLog . e ( \"<STR_LIT>\" ) ; return ; } beforeShowPrompt ( updateEntity , promptEntity ) ; UpdateLog . d ( \"<STR_LIT>\" + promptEntity ) ; if ( context instanceof FragmentActivity ) { UpdateDialogFragment . show ( ( ( FragmentActivity ) context ) . getSupportFragmentManager ( ) , updateEntity , getPrompterProxy ( updateProxy ) , promptEntity ) ; } else if ( context instanceof Activity ) { UpdateDialog . newInstance ( context , updateEntity , getPrompterProxy ( updateProxy ) , promptEntity ) . show ( ) ; } else { UpdateDialogActivity", "gt": ". show ( context , updateEntity , getPrompterProxy ( updateProxy ) , promptEntity ) ;", "repo": "app-space-android"}
{"input": "package com . appspa . update . utils ; import java . io . BufferedReader ; import java . io . DataOutputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . List ; class ShellUtils { public static final String COMMAND_SU = \"<STR_LIT>\" ; public static final String COMMAND_SH = \"<STR_LIT>\" ; public static final String COMMAND_EXIT = \"<STR_LIT>\" ; public static final String COMMAND_LINE_END = \"<STR_LIT>\" ; private ShellUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static boolean checkRootPermission ( ) { return execCommand ( \"<STR_LIT>\" , true , false ) . result == <NUM_LIT> ; } public static CommandResult execCommand ( String command , boolean isRoot ) { return execCommand ( new String [ ] { command } , isRoot , true ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , true ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot ) { return execCommand ( commands , isRoot , true ) ; } public static CommandResult execCommand ( String command , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( new String [ ] { command } , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( List < String > commands , boolean isRoot , boolean isNeedResultMsg ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , isNeedResultMsg ) ; } public static CommandResult execCommand ( String [ ] commands , boolean isRoot , boolean isNeedResultMsg ) { int result = - <NUM_LIT> ; if ( commands == null || commands . length == <NUM_LIT> ) { return new CommandResult ( result , null , null ) ; } Process process = null ; BufferedReader successResult = null ; BufferedReader errorResult = null ; StringBuilder successMsg = null ; StringBuilder errorMsg = null ; DataOutputStream os = null ; try { process = Runtime . getRuntime ( ) . exec ( isRoot ? COMMAND_SU : COMMAND_SH ) ; os = new DataOutputStream ( process . getOutputStream ( ) ) ; for ( String command : commands ) { if ( command == null ) { continue ; } os . write ( command . getBytes ( ) ) ; os . writeBytes ( COMMAND_LINE_END ) ; os . flush ( ) ; } os . writeBytes ( COMMAND_EXIT ) ; os . flush ( ) ; result = process . waitFor ( ) ; if ( isNeedResultMsg ) { successMsg = new StringBuilder ( ) ; errorMsg = new StringBuilder ( ) ; successResult = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; errorResult = new BufferedReader ( new InputStreamReader ( process . getErrorStream ( ) ) ) ; String s ; while", "gt": "( ( s = successResult . readLine ( ) ) != null ) {", "repo": "app-space-android"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long totalSize = dis . readLong ( ) ; long startRange = dis . readLong ( ) ; long endRange = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , startRange / <NUM_LIT> / <NUM_LIT> , endRange / <NUM_LIT> / <NUM_LIT> , totalSize / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File", "gt": "file = new File ( filePath ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import androidx . annotation . Nullable ; import java . util . ArrayList ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . bean . BookMark ; @ SuppressLint ( \"<STR_LIT>\" ) public class ConfigDB extends SQLiteOpenHelper { public static final int VERSION = <NUM_LIT> ; public ConfigDB ( @ Nullable Context context ) { super ( context , \"<STR_LIT>\" , null , VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } public long addLocalBookmark ( String path ) { ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , path ) ; return getWritableDatabase ( ) . insert ( \"<STR_LIT>\" , null , cv ) ; } public long addRemoteBookmark ( String path ) { ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , path ) ; return getWritableDatabase ( ) . insert ( \"<STR_LIT>\" , null , cv ) ; } public boolean checkLocalBookmarkExists ( String path ) { Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" , new String [ ] { path } ) ; boolean exists = cursor . moveToFirst ( ) ; cursor . close ( ) ; return exists ; } public boolean checkRemoteBookmarkExists ( String path ) { Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" , new String [ ] { path } ) ; boolean exists = cursor . moveToFirst ( ) ; cursor . close ( ) ; return exists ; } public long removeLocalBookmark ( int id ) { return getWritableDatabase ( ) . delete ( \"<STR_LIT>\" , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } ) ; } public long removeRemoteBookmark ( int id ) { return getWritableDatabase ( ) . delete ( \"<STR_LIT>\" , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } ) ; } public List < BookMark > getAllLocalBookmark ( ) { return getAllBookmarks ( \"<STR_LIT>\" ) ; } public List < BookMark > getAllRemoteBookmark ( ) { return getAllBookmarks ( \"<STR_LIT>\" ) ; } private List < BookMark > getAllBookmarks ( String tableName ) { Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" + tableName , null ) ; List < BookMark > bookmarks = new ArrayList < > ( cursor . getCount ( ) ) ; while ( cursor . moveToNext ( ) ) { bookmarks", "gt": ". add ( new BookMark ( cursor . getInt ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) , cursor . getString ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ) ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE_SLICE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( job . getTotalSize ( ) ) ; dos . writeLong ( job . startRange ) ; dos . writeLong ( job . endRange ) ; RandomAccessFile", "gt": "raf = new RandomAccessFile ( nextFile , \"<STR_LIT>\" ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE_SLICE ) ; dos . writeUTF ( remotePath ) ; dos", "gt": ". writeLong ( nextFile . lastModified ( ) ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE_SLICE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( job . getTotalSize ( ) ) ; dos . writeLong ( job . startRange ) ; dos . writeLong ( job . endRange ) ; RandomAccessFile raf = new RandomAccessFile ( nextFile , \"<STR_LIT>\" ) ; raf . seek ( job . startRange ) ; int outputLength = ( int ) ( job . endRange - job . startRange ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; boolean canContinue = true ; while ( canContinue ) { int len ; if ( outputLength >= <NUM_LIT> ) { len = <NUM_LIT> ; outputLength -= <NUM_LIT> ; } else { len = outputLength ; canContinue = false ; } int", "gt": "read = raf . read ( buffer , <NUM_LIT> , len ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos", "gt": ". writeLong ( nextFile . lastModified ( ) ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE_SLICE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( job . getTotalSize ( ) ) ; dos . writeLong ( job . startRange ) ; dos", "gt": ". writeLong ( job . endRange ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE_SLICE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( job . getTotalSize ( ) ) ; dos", "gt": ". writeLong ( job . startRange ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import androidx . annotation . Nullable ; import java . util . ArrayList ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . bean . BookMark ; @ SuppressLint ( \"<STR_LIT>\" ) public class ConfigDB extends SQLiteOpenHelper { public static final int VERSION = <NUM_LIT> ; public ConfigDB ( @ Nullable Context context ) { super ( context , \"<STR_LIT>\" , null , VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } public long addLocalBookmark ( String path ) { ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , path ) ; return getWritableDatabase ( ) . insert ( \"<STR_LIT>\" , null , cv ) ; } public long addRemoteBookmark ( String path ) { ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , path ) ; return getWritableDatabase ( ) . insert ( \"<STR_LIT>\" , null , cv ) ; } public boolean checkLocalBookmarkExists ( String path ) { Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" , new String [ ] { path } ) ; boolean", "gt": "exists = cursor . moveToFirst ( ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long totalSize = dis . readLong ( ) ; long startRange = dis . readLong ( ) ; long endRange = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , startRange / <NUM_LIT> / <NUM_LIT> , endRange / <NUM_LIT> / <NUM_LIT> , totalSize / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } RandomAccessFile randomAccessFile = newRAF ( file , totalSize ) ; randomAccessFile . seek ( startRange ) ; int downloadLength = ( int ) ( endRange - startRange ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; boolean canContinue = true ; while ( canContinue ) { int len ; if ( downloadLength >= <NUM_LIT> ) { len = <NUM_LIT> ; downloadLength -= <NUM_LIT> ; } else { len = downloadLength ; canContinue = false ; } dis . readFully ( buffer , <NUM_LIT> , len ) ; randomAccessFile . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } randomAccessFile . close ( ) ; file . setLastModified ( lastModified ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } } System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; } catch ( IOException e ) { System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; e . printStackTrace ( ) ; if ( onExceptionListener != null ) { onExceptionListener . onException ( e ) ; } } } public static synchronized RandomAccessFile newRAF ( File path , long totalSize ) throws IOException { if ( ! path . exists ( ) ) { RandomAccessFile", "gt": "randomAccessFile = new RandomAccessFile ( path , \"<STR_LIT>\" ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long", "gt": "lastModified = dis . readLong ( ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long totalSize = dis . readLong ( ) ; long startRange = dis . readLong ( ) ; long", "gt": "endRange = dis . readLong ( ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import androidx . annotation . Nullable ; import java . util . ArrayList ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . bean . BookMark ; @ SuppressLint ( \"<STR_LIT>\" ) public class ConfigDB extends SQLiteOpenHelper { public static final int VERSION = <NUM_LIT> ; public ConfigDB ( @ Nullable Context context ) { super ( context , \"<STR_LIT>\" , null , VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } public long addLocalBookmark ( String path ) { ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , path ) ; return getWritableDatabase ( ) . insert ( \"<STR_LIT>\" , null , cv ) ; } public long addRemoteBookmark ( String path ) { ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , path ) ; return getWritableDatabase ( ) . insert ( \"<STR_LIT>\" , null , cv ) ; } public boolean checkLocalBookmarkExists ( String path ) { Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" , new String [ ] { path } ) ; boolean exists = cursor . moveToFirst ( ) ; cursor . close ( ) ; return exists ; } public boolean checkRemoteBookmarkExists ( String path ) { Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" , new String [ ] { path } ) ; boolean", "gt": "exists = cursor . moveToFirst ( ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long totalSize = dis . readLong ( ) ; long startRange = dis . readLong ( ) ; long endRange = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , startRange / <NUM_LIT> / <NUM_LIT> , endRange / <NUM_LIT> / <NUM_LIT> , totalSize / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } RandomAccessFile randomAccessFile = newRAF ( file , totalSize ) ; randomAccessFile . seek ( startRange ) ; int downloadLength = ( int ) ( endRange - startRange ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; boolean canContinue = true ; while ( canContinue ) { int len ; if ( downloadLength >= <NUM_LIT> ) { len = <NUM_LIT> ; downloadLength -= <NUM_LIT> ; } else { len = downloadLength ; canContinue = false ; } dis . readFully ( buffer , <NUM_LIT> , len ) ; randomAccessFile", "gt": ". write ( buffer , <NUM_LIT> , len ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long", "gt": "totalSize = dis . readLong ( ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent", "gt": "( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . AlertDialog ; import android . os . DeadObjectException ; import android . os . RemoteException ; import android . view . View ; import android . widget . FrameLayout ; import android . widget . Toast ; import androidx . appcompat . widget . Toolbar ; import androidx . recyclerview . widget . RecyclerView ; import com . l4digital . fastscroll . FastScroller ; import java . util . ArrayList ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . async . CDParentTask ; import top . weixiansen574 . hybridfilexfer . async . CDTask ; import top . weixiansen574 . hybridfilexfer . core . Utils ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public abstract class IIServiceFileSelectAdapter extends FileSelectAdapter < ParcelableRemoteFile > implements FastScroller . SectionIndexer { protected String currentDir ; protected List < ParcelableRemoteFile > currentFiles = new ArrayList < > ( ) ; protected ITransferService service ; public IIServiceFileSelectAdapter ( Activity context , View . OnTouchListener onTouchListener , Toolbar fileSelectToolbar , FrameLayout frameLayout , View listInView , ITransferService service ) { super ( context , onTouchListener , fileSelectToolbar , frameLayout , listInView ) ; this . service = service ; } @ Override protected String getFileName ( ParcelableRemoteFile item ) { return item . getName ( ) ; } @ Override protected String getPath ( ParcelableRemoteFile item ) { return item . getPath ( ) ; } @ Override protected boolean isDir ( ParcelableRemoteFile item ) { return item . isDirectory ( ) ; } @ Override protected ParcelableRemoteFile getItem ( int position ) { return currentFiles . get ( position ) ; } @ Override protected List < ParcelableRemoteFile > getAllItems ( ) { return currentFiles ; } public abstract List < ParcelableRemoteFile > listTargetFiles ( String path ) throws RemoteException ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void cd ( String path ) { System . out . println ( \"<STR_LIT>\" + path ) ; enterLoadingState ( ) ; CDHandler handler = new CDHandler ( this ) ; new CDTask ( handler , this , path ) . execute ( ) ; } private static class CDHandler implements CDTask . EventHandle { private final IIServiceFileSelectAdapter adapter ; public CDHandler ( IIServiceFileSelectAdapter adapter ) { this . adapter = adapter ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onSuccess ( List < ParcelableRemoteFile > files , String path ) { adapter . currentFiles = files ; adapter . currentDir = path ; adapter . notifyDataSetChanged ( ) ; adapter . exitLoadingState ( ) ; } @ Override public void onPermissionDenied ( ) { adapter . exitLoadingState ( ) ; Toast . makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onError ( Throwable th ) { adapter . handleIIServiceExceptions ( th ) ; } } @ Override public String getCurrentDir ( ) { return currentDir ; } @ Override protected long getFileDate ( ParcelableRemoteFile item ) { return item . getLastModified ( ) ; } @ Override protected long getFileSize ( ParcelableRemoteFile item ) { return item . getSize ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void cdParent ( ) { enterLoadingState ( ) ; CDParentHandler handler = new CDParentHandler ( this ) ; new CDParentTask ( handler , this , Utils . replaceBackslashToSlash ( currentDir ) ) . execute ( ) ; } public void handleIIServiceExceptions ( Throwable e ) { e . printStackTrace ( ) ; if ( e instanceof DeadObjectException ) { new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( e . getMessage ( ) ) . setCancelable ( false ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog , which ) -> { context . finish ( ) ; } ) . show ( ) ; } else { Toast . makeText ( context , e . toString ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } private static class CDParentHandler implements CDParentTask . EventHandler { private final IIServiceFileSelectAdapter adapter ; public CDParentHandler ( IIServiceFileSelectAdapter adapter ) { this . adapter = adapter ; } @ Override public void onError ( Throwable th ) { } @ Override public void onComplete ( ) { adapter . exitLoadingState ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onSuccess ( List < ParcelableRemoteFile > files , String parentPath ) { adapter . currentFiles = files ; adapter . currentDir = parentPath ; adapter . notifyDataSetChanged ( ) ; } @ Override public void onPermissionDenied ( ) { Toast", "gt": ". makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String", "gt": "filePath = dis . readUTF ( ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . AlertDialog ; import android . os . DeadObjectException ; import android . os . RemoteException ; import android . view . View ; import android . widget . FrameLayout ; import android . widget . Toast ; import androidx . appcompat . widget . Toolbar ; import androidx . recyclerview . widget . RecyclerView ; import com . l4digital . fastscroll . FastScroller ; import java . util . ArrayList ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . async . CDParentTask ; import top . weixiansen574 . hybridfilexfer . async . CDTask ; import top . weixiansen574 . hybridfilexfer . core . Utils ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public abstract class IIServiceFileSelectAdapter extends FileSelectAdapter < ParcelableRemoteFile > implements FastScroller . SectionIndexer { protected String currentDir ; protected List < ParcelableRemoteFile > currentFiles = new ArrayList < > ( ) ; protected ITransferService service ; public IIServiceFileSelectAdapter ( Activity context , View . OnTouchListener onTouchListener , Toolbar fileSelectToolbar , FrameLayout frameLayout , View listInView , ITransferService service ) { super ( context , onTouchListener , fileSelectToolbar , frameLayout , listInView ) ; this . service = service ; } @ Override protected String getFileName ( ParcelableRemoteFile item ) { return item . getName ( ) ; } @ Override protected String getPath ( ParcelableRemoteFile item ) { return item . getPath ( ) ; } @ Override protected boolean isDir ( ParcelableRemoteFile item ) { return item . isDirectory ( ) ; } @ Override protected ParcelableRemoteFile getItem ( int position ) { return currentFiles . get ( position ) ; } @ Override protected List < ParcelableRemoteFile > getAllItems ( ) { return currentFiles ; } public abstract List < ParcelableRemoteFile > listTargetFiles ( String path ) throws RemoteException ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void cd ( String path ) { System . out . println ( \"<STR_LIT>\" + path ) ; enterLoadingState ( ) ; CDHandler handler = new CDHandler ( this ) ; new CDTask ( handler , this , path ) . execute ( ) ; } private static class CDHandler implements CDTask . EventHandle { private final IIServiceFileSelectAdapter adapter ; public CDHandler ( IIServiceFileSelectAdapter adapter ) { this . adapter = adapter ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onSuccess ( List < ParcelableRemoteFile > files , String path ) { adapter . currentFiles = files ; adapter . currentDir = path ; adapter . notifyDataSetChanged ( ) ; adapter . exitLoadingState ( ) ; } @ Override public void onPermissionDenied ( ) { adapter . exitLoadingState ( ) ; Toast . makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onError ( Throwable th ) { adapter . handleIIServiceExceptions ( th ) ; } } @ Override public String getCurrentDir ( ) { return currentDir ; } @ Override protected long getFileDate ( ParcelableRemoteFile item ) { return item . getLastModified ( ) ; } @ Override protected long getFileSize ( ParcelableRemoteFile item ) { return item . getSize ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void cdParent ( ) { enterLoadingState ( ) ; CDParentHandler handler = new CDParentHandler ( this ) ; new CDParentTask ( handler , this , Utils . replaceBackslashToSlash ( currentDir ) ) . execute ( ) ; } public void handleIIServiceExceptions ( Throwable e ) { e . printStackTrace ( ) ; if ( e instanceof DeadObjectException ) { new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( e . getMessage ( ) ) . setCancelable ( false ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog , which ) -> { context . finish ( ) ; } ) . show ( ) ; } else { Toast . makeText ( context , e . toString ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } private static class CDParentHandler implements CDParentTask . EventHandler { private final IIServiceFileSelectAdapter adapter ; public CDParentHandler ( IIServiceFileSelectAdapter adapter ) { this . adapter = adapter ; } @ Override public void onError ( Throwable th ) { } @ Override public void onComplete ( ) { adapter . exitLoadingState ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onSuccess ( List < ParcelableRemoteFile > files , String parentPath ) { adapter . currentFiles = files ; adapter . currentDir = parentPath ; adapter . notifyDataSetChanged ( ) ; } @ Override public void onPermissionDenied ( ) { Toast . makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onParentDirNotFiles ( ) { Toast . makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onThisIsTheLastPage ( ) { Toast", "gt": ". makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . AlertDialog ; import android . os . DeadObjectException ; import android . os . RemoteException ; import android . view . View ; import android . widget . FrameLayout ; import android . widget . Toast ; import androidx . appcompat . widget . Toolbar ; import androidx . recyclerview . widget . RecyclerView ; import com . l4digital . fastscroll . FastScroller ; import java . util . ArrayList ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . async . CDParentTask ; import top . weixiansen574 . hybridfilexfer . async . CDTask ; import top . weixiansen574 . hybridfilexfer . core . Utils ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public abstract class IIServiceFileSelectAdapter extends FileSelectAdapter < ParcelableRemoteFile > implements FastScroller . SectionIndexer { protected String currentDir ; protected List < ParcelableRemoteFile > currentFiles = new ArrayList < > ( ) ; protected ITransferService service ; public IIServiceFileSelectAdapter ( Activity context , View . OnTouchListener onTouchListener , Toolbar fileSelectToolbar , FrameLayout frameLayout , View listInView , ITransferService service ) { super ( context , onTouchListener , fileSelectToolbar , frameLayout , listInView ) ; this . service = service ; } @ Override protected String getFileName ( ParcelableRemoteFile item ) { return item . getName ( ) ; } @ Override protected String getPath ( ParcelableRemoteFile item ) { return item . getPath ( ) ; } @ Override protected boolean isDir ( ParcelableRemoteFile item ) { return item . isDirectory ( ) ; } @ Override protected ParcelableRemoteFile getItem ( int position ) { return currentFiles . get ( position ) ; } @ Override protected List < ParcelableRemoteFile > getAllItems ( ) { return currentFiles ; } public abstract List < ParcelableRemoteFile > listTargetFiles ( String path ) throws RemoteException ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void cd ( String path ) { System . out . println ( \"<STR_LIT>\" + path ) ; enterLoadingState ( ) ; CDHandler handler = new CDHandler ( this ) ; new CDTask ( handler , this , path ) . execute ( ) ; } private static class CDHandler implements CDTask . EventHandle { private final IIServiceFileSelectAdapter adapter ; public CDHandler ( IIServiceFileSelectAdapter adapter ) { this . adapter = adapter ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onSuccess ( List < ParcelableRemoteFile > files , String path ) { adapter . currentFiles = files ; adapter . currentDir = path ; adapter . notifyDataSetChanged ( ) ; adapter . exitLoadingState ( ) ; } @ Override public void onPermissionDenied ( ) { adapter . exitLoadingState ( ) ; Toast . makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onError ( Throwable th ) { adapter . handleIIServiceExceptions ( th ) ; } } @ Override public String getCurrentDir ( ) { return currentDir ; } @ Override protected long getFileDate ( ParcelableRemoteFile item ) { return item . getLastModified ( ) ; } @ Override protected long getFileSize ( ParcelableRemoteFile item ) { return item . getSize ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void cdParent ( ) { enterLoadingState ( ) ; CDParentHandler handler = new CDParentHandler ( this ) ; new CDParentTask ( handler , this , Utils . replaceBackslashToSlash ( currentDir ) ) . execute ( ) ; } public void handleIIServiceExceptions ( Throwable e ) { e . printStackTrace ( ) ; if ( e instanceof DeadObjectException ) { new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( e . getMessage ( ) ) . setCancelable ( false ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog , which ) -> { context . finish ( ) ; } ) . show ( ) ; } else { Toast . makeText ( context , e . toString ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } private static class CDParentHandler implements CDParentTask . EventHandler { private final IIServiceFileSelectAdapter adapter ; public CDParentHandler ( IIServiceFileSelectAdapter adapter ) { this . adapter = adapter ; } @ Override public void onError ( Throwable th ) { } @ Override public void onComplete ( ) { adapter . exitLoadingState ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onSuccess ( List < ParcelableRemoteFile > files , String parentPath ) { adapter . currentFiles = files ; adapter . currentDir = parentPath ; adapter . notifyDataSetChanged ( ) ; } @ Override public void onPermissionDenied ( ) { Toast . makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onParentDirNotFiles ( ) { Toast . makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onThisIsTheLastPage ( ) { Toast . makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } @ Override public int getItemCount ( ) { return currentFiles . size ( ) ; } @ Override public CharSequence getSectionText ( int position ) { return", "gt": "String . valueOf ( getItem ( position ) . getName ( ) . charAt ( <NUM_LIT> ) ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long totalSize = dis . readLong ( ) ; long startRange = dis . readLong ( ) ; long endRange = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , startRange / <NUM_LIT> / <NUM_LIT> , endRange / <NUM_LIT> / <NUM_LIT> , totalSize / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } RandomAccessFile randomAccessFile = newRAF ( file , totalSize ) ; randomAccessFile . seek ( startRange ) ; int", "gt": "downloadLength = ( int ) ( endRange - startRange ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import androidx . annotation . Nullable ; import java . util . ArrayList ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . bean . BookMark ; @ SuppressLint ( \"<STR_LIT>\" ) public class ConfigDB extends SQLiteOpenHelper { public static final int VERSION = <NUM_LIT> ; public ConfigDB ( @ Nullable Context context ) { super ( context , \"<STR_LIT>\" , null , VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } public long addLocalBookmark ( String path ) { ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , path ) ; return getWritableDatabase ( ) . insert ( \"<STR_LIT>\" , null , cv ) ; } public long addRemoteBookmark ( String path ) { ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , path ) ; return getWritableDatabase ( ) . insert ( \"<STR_LIT>\" , null , cv ) ; } public boolean checkLocalBookmarkExists ( String path ) { Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" , new String [ ] { path } ) ; boolean exists = cursor . moveToFirst ( ) ; cursor . close ( ) ; return exists ; } public boolean checkRemoteBookmarkExists ( String path ) { Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" , new String [ ] { path } ) ; boolean exists = cursor . moveToFirst ( ) ; cursor . close ( ) ; return exists ; } public long removeLocalBookmark ( int id ) { return getWritableDatabase ( ) . delete ( \"<STR_LIT>\" , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } ) ; } public long removeRemoteBookmark ( int id ) { return getWritableDatabase ( ) . delete ( \"<STR_LIT>\" , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } ) ; } public List < BookMark > getAllLocalBookmark ( ) { return getAllBookmarks ( \"<STR_LIT>\" ) ; } public List < BookMark > getAllRemoteBookmark ( ) { return getAllBookmarks ( \"<STR_LIT>\" ) ; } private List < BookMark > getAllBookmarks ( String tableName ) { Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" + tableName , null ) ; List", "gt": "< BookMark > bookmarks = new ArrayList < > ( cursor . getCount ( ) ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long totalSize = dis . readLong ( ) ; long startRange = dis . readLong ( ) ; long endRange = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , startRange / <NUM_LIT> / <NUM_LIT> , endRange / <NUM_LIT> / <NUM_LIT> , totalSize / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent", "gt": "( FileTransferEvent . STATE_DOWNLOAD , desc ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long totalSize = dis . readLong ( ) ; long", "gt": "startRange = dis . readLong ( ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System", "gt": ". out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System", "gt": ". out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE_SLICE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( job . getTotalSize ( ) ) ; dos . writeLong ( job . startRange ) ; dos . writeLong ( job . endRange ) ; RandomAccessFile raf = new RandomAccessFile ( nextFile , \"<STR_LIT>\" ) ; raf . seek ( job . startRange ) ; int outputLength = ( int ) ( job . endRange - job . startRange ) ; byte", "gt": "[ ] buffer = new byte [ <NUM_LIT> ] ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long totalSize = dis . readLong ( ) ; long startRange = dis . readLong ( ) ; long endRange = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , startRange / <NUM_LIT> / <NUM_LIT> , endRange / <NUM_LIT> / <NUM_LIT> , totalSize / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if", "gt": "( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) {", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent", "gt": "( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE_SLICE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos", "gt": ". writeLong ( job . getTotalSize ( ) ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long totalSize = dis . readLong ( ) ; long startRange = dis . readLong ( ) ; long endRange = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , startRange / <NUM_LIT> / <NUM_LIT> , endRange / <NUM_LIT> / <NUM_LIT> , totalSize / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File", "gt": "parentFile = file . getParentFile ( ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE_SLICE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( job . getTotalSize ( ) ) ; dos . writeLong ( job . startRange ) ; dos . writeLong ( job . endRange ) ; RandomAccessFile raf = new RandomAccessFile ( nextFile , \"<STR_LIT>\" ) ; raf", "gt": ". seek ( job . startRange ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long totalSize = dis . readLong ( ) ; long startRange = dis . readLong ( ) ; long endRange = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , startRange / <NUM_LIT> / <NUM_LIT> , endRange / <NUM_LIT> / <NUM_LIT> , totalSize / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } RandomAccessFile randomAccessFile = newRAF ( file , totalSize ) ; randomAccessFile . seek ( startRange ) ; int downloadLength = ( int ) ( endRange - startRange ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; boolean canContinue = true ; while ( canContinue ) { int len ; if ( downloadLength >= <NUM_LIT> ) { len = <NUM_LIT> ; downloadLength -= <NUM_LIT> ; } else { len = downloadLength ; canContinue = false ; } dis . readFully ( buffer , <NUM_LIT> , len ) ; randomAccessFile . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } randomAccessFile . close ( ) ; file . setLastModified ( lastModified ) ; addEvent", "gt": "( FileTransferEvent . STATE_OVER , desc ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . AlertDialog ; import android . os . DeadObjectException ; import android . os . RemoteException ; import android . view . View ; import android . widget . FrameLayout ; import android . widget . Toast ; import androidx . appcompat . widget . Toolbar ; import androidx . recyclerview . widget . RecyclerView ; import com . l4digital . fastscroll . FastScroller ; import java . util . ArrayList ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . async . CDParentTask ; import top . weixiansen574 . hybridfilexfer . async . CDTask ; import top . weixiansen574 . hybridfilexfer . core . Utils ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public abstract class IIServiceFileSelectAdapter extends FileSelectAdapter < ParcelableRemoteFile > implements FastScroller . SectionIndexer { protected String currentDir ; protected List < ParcelableRemoteFile > currentFiles = new ArrayList < > ( ) ; protected ITransferService service ; public IIServiceFileSelectAdapter ( Activity context , View . OnTouchListener onTouchListener , Toolbar fileSelectToolbar , FrameLayout frameLayout , View listInView , ITransferService service ) { super ( context , onTouchListener , fileSelectToolbar , frameLayout , listInView ) ; this . service = service ; } @ Override protected String getFileName ( ParcelableRemoteFile item ) { return item . getName ( ) ; } @ Override protected String getPath ( ParcelableRemoteFile item ) { return item . getPath ( ) ; } @ Override protected boolean isDir ( ParcelableRemoteFile item ) { return item . isDirectory ( ) ; } @ Override protected ParcelableRemoteFile getItem ( int position ) { return currentFiles . get ( position ) ; } @ Override protected List < ParcelableRemoteFile > getAllItems ( ) { return currentFiles ; } public abstract List < ParcelableRemoteFile > listTargetFiles ( String path ) throws RemoteException ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void cd ( String path ) { System . out . println ( \"<STR_LIT>\" + path ) ; enterLoadingState ( ) ; CDHandler handler = new CDHandler ( this ) ; new CDTask ( handler , this , path ) . execute ( ) ; } private static class CDHandler implements CDTask . EventHandle { private final IIServiceFileSelectAdapter adapter ; public CDHandler ( IIServiceFileSelectAdapter adapter ) { this . adapter = adapter ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onSuccess ( List < ParcelableRemoteFile > files , String path ) { adapter . currentFiles = files ; adapter . currentDir = path ; adapter . notifyDataSetChanged ( ) ; adapter . exitLoadingState ( ) ; } @ Override public void onPermissionDenied ( ) { adapter . exitLoadingState ( ) ; Toast . makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onError ( Throwable th ) { adapter . handleIIServiceExceptions ( th ) ; } } @ Override public String getCurrentDir ( ) { return currentDir ; } @ Override protected long getFileDate ( ParcelableRemoteFile item ) { return item . getLastModified ( ) ; } @ Override protected long getFileSize ( ParcelableRemoteFile item ) { return item . getSize ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void cdParent ( ) { enterLoadingState ( ) ; CDParentHandler handler = new CDParentHandler ( this ) ; new CDParentTask ( handler , this , Utils . replaceBackslashToSlash ( currentDir ) ) . execute ( ) ; } public void handleIIServiceExceptions ( Throwable e ) { e . printStackTrace ( ) ; if ( e instanceof DeadObjectException ) { new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( e . getMessage ( ) ) . setCancelable ( false ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog , which ) -> { context . finish ( ) ; } ) . show ( ) ; } else { Toast . makeText ( context , e . toString ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } private static class CDParentHandler implements CDParentTask . EventHandler { private final IIServiceFileSelectAdapter adapter ; public CDParentHandler ( IIServiceFileSelectAdapter adapter ) { this . adapter = adapter ; } @ Override public void onError ( Throwable th ) { } @ Override public void onComplete ( ) { adapter . exitLoadingState ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onSuccess ( List < ParcelableRemoteFile > files , String parentPath ) { adapter . currentFiles = files ; adapter . currentDir = parentPath ; adapter . notifyDataSetChanged ( ) ; } @ Override public void onPermissionDenied ( ) { Toast . makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onParentDirNotFiles ( ) { Toast", "gt": ". makeText ( adapter . context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ReceiveThread extends TransferThread { private final DataInputStream dis ; public ReceiveThread ( BlockingDeque < FileTransferEvent > events , int device , InputStream dis ) { super ( events , device ) ; this . dis = new DataInputStream ( dis ) ; } @ Override public void run ( ) { try { short identifier ; while ( ( identifier = dis . readShort ( ) ) != TransferIdentifiers . END_POINT ) { if ( identifier == TransferIdentifiers . FILE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long remainingLength = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) remainingLength ) / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( remainingLength > <NUM_LIT> ) { int read ; if ( remainingLength >= buffer . length ) { read = dis . read ( buffer ) ; } else { int len = ( int ) remainingLength ; read = dis . read ( buffer , <NUM_LIT> , len ) ; } remainingLength -= read ; fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } fileOutputStream . close ( ) ; file . setLastModified ( lastModified ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; } else if ( identifier == TransferIdentifiers . FOLDER ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } file . setLastModified ( lastModified ) ; System . out . println ( filePath ) ; } else if ( identifier == TransferIdentifiers . FILE_SLICE ) { String filePath = dis . readUTF ( ) ; long lastModified = dis . readLong ( ) ; long totalSize = dis . readLong ( ) ; long startRange = dis . readLong ( ) ; long endRange = dis . readLong ( ) ; String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , startRange / <NUM_LIT> / <NUM_LIT> , endRange / <NUM_LIT> / <NUM_LIT> , totalSize / <NUM_LIT> / <NUM_LIT> , filePath ) ; addEvent ( FileTransferEvent . STATE_DOWNLOAD , desc ) ; File file = new File ( filePath ) ; File parentFile = file . getParentFile ( ) ; if ( parentFile != null && ! file . getParentFile ( ) . exists ( ) ) { parentFile . mkdirs ( ) ; } RandomAccessFile randomAccessFile = newRAF ( file , totalSize ) ; randomAccessFile . seek ( startRange ) ; int downloadLength = ( int ) ( endRange - startRange ) ; System . out . println ( \"<STR_LIT>\" + Thread . currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; boolean canContinue = true ; while ( canContinue ) { int len ; if ( downloadLength >= <NUM_LIT> ) { len = <NUM_LIT> ; downloadLength -= <NUM_LIT> ; } else { len = downloadLength ; canContinue = false ; } dis . readFully ( buffer , <NUM_LIT> , len ) ; randomAccessFile . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } randomAccessFile . close ( ) ; file . setLastModified ( lastModified ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } } System", "gt": ". out . println ( getName ( ) + \"<STR_LIT>\" ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent", "gt": "( FileTransferEvent . STATE_UPLOAD , desc ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos", "gt": ". writeShort ( TransferIdentifiers . FILE_SLICE ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import androidx . annotation . Nullable ; import java . util . ArrayList ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . bean . BookMark ; @ SuppressLint ( \"<STR_LIT>\" ) public class ConfigDB extends SQLiteOpenHelper { public static final int VERSION = <NUM_LIT> ; public ConfigDB ( @ Nullable Context context ) { super ( context , \"<STR_LIT>\" , null , VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } public long addLocalBookmark ( String path ) { ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , path ) ; return getWritableDatabase ( ) . insert ( \"<STR_LIT>\" , null , cv ) ; } public long addRemoteBookmark ( String path ) { ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , path ) ; return getWritableDatabase ( ) . insert ( \"<STR_LIT>\" , null , cv ) ; } public boolean checkLocalBookmarkExists ( String path ) { Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" , new String [ ] { path } ) ; boolean exists = cursor . moveToFirst ( ) ; cursor . close ( ) ; return exists ; } public boolean checkRemoteBookmarkExists ( String path ) { Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" , new String [ ] { path } ) ; boolean exists = cursor . moveToFirst ( ) ; cursor . close ( ) ; return exists ; } public long removeLocalBookmark ( int id ) { return getWritableDatabase ( ) . delete ( \"<STR_LIT>\" , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } ) ; } public long removeRemoteBookmark ( int id ) { return getWritableDatabase ( ) . delete ( \"<STR_LIT>\" , \"<STR_LIT>\" , new String [ ] { String . valueOf ( id ) } ) ; } public List < BookMark > getAllLocalBookmark ( ) { return getAllBookmarks ( \"<STR_LIT>\" ) ; } public List < BookMark > getAllRemoteBookmark ( ) { return getAllBookmarks ( \"<STR_LIT>\" ) ; } private List < BookMark > getAllBookmarks ( String tableName ) { Cursor", "gt": "cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" + tableName , null ) ;", "repo": "HybridFileXfer"}
{"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . util . Locale ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . TransferIdentifiers ; public class SendThread extends TransferThread { JobPublisher jobPublisher ; DataOutputStream dos ; public SendThread ( BlockingDeque < FileTransferEvent > events , int device , JobPublisher jobPublisher , OutputStream os ) { super ( events , device ) ; this . jobPublisher = jobPublisher ; this . dos = new DataOutputStream ( os ) ; } @ Override public void run ( ) { try { while ( true ) { FileTransferJob job ; try { job = jobPublisher . getNextJob ( ) ; } catch ( InterruptedException e ) { dos . writeShort ( TransferIdentifiers . END_POINT ) ; System . out . println ( getName ( ) + \"<STR_LIT>\" ) ; break ; } File nextFile = job . targetFile ; String remotePath = job . toRemotePath ( ) ; if ( ! job . isSlice ) { if ( nextFile . isFile ( ) ) { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) nextFile . length ( ) ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( nextFile . length ( ) ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileInputStream fileInputStream = new FileInputStream ( nextFile ) ; int len ; while ( ( len = fileInputStream . read ( buffer ) ) != - <NUM_LIT> ) { dos . write ( buffer , <NUM_LIT> , len ) ; transferredBytes += len ; } fileInputStream . close ( ) ; addEvent ( FileTransferEvent . STATE_OVER , desc ) ; } else if ( nextFile . isDirectory ( ) ) { System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + nextFile + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , nextFile . getCanonicalPath ( ) ) ; dos . writeShort ( TransferIdentifiers . FOLDER ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; addEvent ( FileTransferEvent . STATE_OVER , nextFile . getCanonicalPath ( ) ) ; } } else { String desc = String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , job . startRange / <NUM_LIT> / <NUM_LIT> , job . endRange / <NUM_LIT> / <NUM_LIT> , job . getTotalSize ( ) / <NUM_LIT> / <NUM_LIT> , nextFile . getCanonicalPath ( ) ) ; System . out . println ( \"<STR_LIT>\" + currentThread ( ) . getName ( ) + \"<STR_LIT>\" + desc + \"<STR_LIT>\" + remotePath ) ; addEvent ( FileTransferEvent . STATE_UPLOAD , desc ) ; dos . writeShort ( TransferIdentifiers . FILE_SLICE ) ; dos . writeUTF ( remotePath ) ; dos . writeLong ( nextFile . lastModified ( ) ) ; dos . writeLong ( job . getTotalSize ( ) ) ; dos . writeLong ( job . startRange ) ; dos . writeLong ( job . endRange ) ; RandomAccessFile raf = new RandomAccessFile ( nextFile , \"<STR_LIT>\" ) ; raf . seek ( job . startRange ) ; int outputLength = ( int ) ( job . endRange - job . startRange ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; boolean canContinue = true ; while ( canContinue ) { int len ; if ( outputLength >= <NUM_LIT> ) { len = <NUM_LIT> ; outputLength -= <NUM_LIT> ; } else { len = outputLength ; canContinue = false ; } int read = raf . read ( buffer , <NUM_LIT> , len ) ; dos . write ( buffer , <NUM_LIT> , read ) ; transferredBytes += read ; } raf . close ( ) ; addEvent", "gt": "( FileTransferEvent . STATE_OVER , desc ) ;", "repo": "HybridFileXfer"}
{"input": "package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . content . SharedPreferences ; import android . security . keystore . KeyGenParameterSpec ; import android . security . keystore . KeyProperties ; import android . util . Log ; import androidx . security . crypto . EncryptedSharedPreferences ; import androidx . security . crypto . MasterKey ; import java . io . File ; import java . security . KeyStore ; public class EncryptedSharedPreferencesHelper { private final static String HARMONIC_ENCRYPTED_PREFS = \"<STR_LIT>\" ; private static final String MASTER_KEY_ALIAS = \"<STR_LIT>\" ; private static final String KEYSTORE_PROVIDER = \"<STR_LIT>\" ; public static SharedPreferences getEncryptedSharedPreferences ( Context ctx ) throws Exception { try { return createSharedPreferences ( ctx ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; try { deleteSharedPreferences ( ctx ) ; return createSharedPreferences ( ctx ) ; } catch ( Exception otherException ) { otherException . printStackTrace ( ) ; throw new Exception ( ) ; } } } private static SharedPreferences createSharedPreferences ( Context ctx ) throws Exception { MasterKey mainKey = getMasterKey ( ctx ) ; if ( mainKey == null ) { Exception e = new Exception ( ) ; throw e ; } return EncryptedSharedPreferences . create ( ctx , HARMONIC_ENCRYPTED_PREFS , getMasterKey ( ctx ) , EncryptedSharedPreferences . PrefKeyEncryptionScheme . AES256_SIV , EncryptedSharedPreferences . PrefValueEncryptionScheme . AES256_GCM ) ; } public static boolean deleteSharedPreferences ( Context ctx ) { try { File sharedPrefsFile = new File ( ctx . getFilesDir ( ) . getParent ( ) + \"<STR_LIT>\" + HARMONIC_ENCRYPTED_PREFS + \"<STR_LIT>\" ) ; clearSharedPreference ( ctx ) ; if ( sharedPrefsFile . exists ( ) ) { boolean deleted = sharedPrefsFile . delete ( ) ; Utils . log ( \"<STR_LIT>\" + deleted + \"<STR_LIT>\" + sharedPrefsFile . getAbsolutePath ( ) ) ; } else { Utils . log ( \"<STR_LIT>\" + sharedPrefsFile . getAbsolutePath ( ) ) ; } KeyStore keyStore = KeyStore . getInstance ( KEYSTORE_PROVIDER ) ; keyStore . load ( null ) ; keyStore . deleteEntry ( MasterKey . DEFAULT_MASTER_KEY_ALIAS ) ; return true ; } catch ( Exception e ) { Utils . log ( \"<STR_LIT>\" + e ) ; return false ; } } private static void clearSharedPreference ( Context ctx ) { ctx . getSharedPreferences ( HARMONIC_ENCRYPTED_PREFS , Context . MODE_PRIVATE ) . edit ( ) . clear ( ) . apply ( ) ; } private static MasterKey getMasterKey ( Context ctx ) { try { KeyGenParameterSpec spec = new KeyGenParameterSpec . Builder ( MASTER_KEY_ALIAS , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_GCM ) . setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_NONE ) . setKeySize ( <NUM_LIT> ) . build ( ) ; return", "gt": "new MasterKey . Builder ( ctx , MASTER_KEY_ALIAS ) . setKeyGenParameterSpec ( spec ) . build ( ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; container . setVisibility ( View . VISIBLE ) ; } catch ( Exception e ) { loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; e . printStackTrace ( ) ; } loadingProgress . setVisibility ( View . GONE ) ; } , error -> { error . printStackTrace ( ) ; loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; } ) ; stringRequest . setRetryPolicy ( new DefaultRetryPolicy ( <NUM_LIT> , DefaultRetryPolicy . DEFAULT_MAX_RETRIES , DefaultRetryPolicy . DEFAULT_BACKOFF_MULT ) ) ; queue . add ( stringRequest ) ; } retryButton . setOnClickListener ( view1 -> { dialog . dismiss ( ) ; showUserDialog ( requireActivity ( ) . getSupportFragmentManager ( ) , userName ) ; } ) ; return dialog ; } public static void showUserDialog ( FragmentManager fm , String name ) { UserDialogFragment userDialogFragment = new UserDialogFragment ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putString ( UserDialogFragment . EXTRA_USER_NAME , name ) ; userDialogFragment . setArguments ( bundle ) ; userDialogFragment . show ( fm , UserDialogFragment . TAG ) ; } public void setLinkifiedText ( String text , TextView textView ) { SpannableString spannableString = new SpannableString ( text ) ; Pattern", "gt": "urlPattern = Pattern . compile ( \"<STR_LIT>\" ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if", "gt": "( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) {", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; container . setVisibility ( View . VISIBLE ) ; } catch ( Exception e ) { loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; e . printStackTrace ( ) ; } loadingProgress . setVisibility ( View . GONE ) ; } , error -> { error . printStackTrace ( ) ; loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; } ) ; stringRequest . setRetryPolicy ( new DefaultRetryPolicy ( <NUM_LIT> , DefaultRetryPolicy . DEFAULT_MAX_RETRIES , DefaultRetryPolicy . DEFAULT_BACKOFF_MULT ) ) ; queue . add ( stringRequest ) ; } retryButton . setOnClickListener ( view1 -> { dialog . dismiss ( ) ; showUserDialog ( requireActivity ( ) . getSupportFragmentManager ( ) , userName ) ; } ) ; return dialog ; } public static void showUserDialog ( FragmentManager fm , String name ) { UserDialogFragment userDialogFragment = new UserDialogFragment ( ) ; Bundle bundle = new Bundle ( ) ; bundle", "gt": ". putString ( UserDialogFragment . EXTRA_USER_NAME , name ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; container . setVisibility ( View . VISIBLE ) ; } catch ( Exception e ) { loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; e . printStackTrace ( ) ; } loadingProgress . setVisibility ( View . GONE ) ; } , error -> { error . printStackTrace ( ) ; loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; } ) ; stringRequest . setRetryPolicy ( new DefaultRetryPolicy ( <NUM_LIT> , DefaultRetryPolicy . DEFAULT_MAX_RETRIES , DefaultRetryPolicy . DEFAULT_BACKOFF_MULT ) ) ; queue . add ( stringRequest ) ; } retryButton . setOnClickListener ( view1 -> { dialog . dismiss ( ) ; showUserDialog ( requireActivity ( ) . getSupportFragmentManager ( ) , userName ) ; } ) ; return dialog ; } public static void showUserDialog ( FragmentManager fm , String name ) { UserDialogFragment userDialogFragment = new UserDialogFragment ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putString ( UserDialogFragment . EXTRA_USER_NAME , name ) ; userDialogFragment . setArguments ( bundle ) ; userDialogFragment . show ( fm , UserDialogFragment . TAG ) ; } public void setLinkifiedText ( String text , TextView textView ) { SpannableString spannableString = new SpannableString ( text ) ; Pattern urlPattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher", "gt": "urlMatcher = urlPattern . matcher ( text ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent", "gt": "intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; startActivityForResult ( intent , READ_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Set < Integer > set = SettingsUtils . readIntSetFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) ; int oldCount = set . size ( ) ; SettingsUtils . saveIntSetToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS , new HashSet < > ( <NUM_LIT> ) ) ; if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } Snackbar snackbar = Snackbar . make ( requireView ( ) , \"<STR_LIT>\" + oldCount + ( oldCount == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) , Snackbar . LENGTH_SHORT ) ; snackbar . show ( ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { startActivity ( new Intent ( getContext ( ) , AboutActivity . class ) ) ; return false ; } } ) ; } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode == Activity . RESULT_OK && getContext ( ) != null && data != null && data . getData ( ) != null ) { if ( requestCode == WRITE_REQUEST_CODE ) { try { Utils . writeInFile ( getContext ( ) , data . getData ( ) , SettingsUtils . readStringFromSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ) ; } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } else if ( requestCode == READ_REQUEST_CODE ) { try { String content = Utils . readFileContent ( getContext ( ) , data . getData ( ) ) ; ArrayList < Bookmark > bookmarks = Utils . loadBookmarks ( true , content ) ; if ( ! bookmarks . isEmpty ( ) ) { SettingsUtils . saveStringToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS , content ) ; Toast . makeText ( getContext ( ) , \"<STR_LIT>\" + bookmarks . size ( ) + \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } } } @ Override public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; setDivider ( null ) ; } @ NonNull @ Override public RecyclerView onCreateRecyclerView ( @ NonNull LayoutInflater inflater , @ NonNull ViewGroup parent , @ Nullable Bundle savedInstanceState ) { RecyclerView recycler = super . onCreateRecyclerView ( inflater , parent , savedInstanceState ) ; recycler . setFitsSystemWindows ( true ) ; return recycler ; } private void updateTimedRangeSummary ( ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; if ( DateFormat . is24HourFormat ( getContext ( ) ) ) { findPreference ( \"<STR_LIT>\" ) . setSummary ( ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] ) ; } else { SimpleDateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; Date dateFrom = new Date ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , nighttimeHours [ <NUM_LIT> ] , nighttimeHours [ <NUM_LIT> ] ) ; Date dateTo = new Date ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , nighttimeHours [ <NUM_LIT> ] , nighttimeHours [ <NUM_LIT> ] ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( df . format ( dateFrom ) + \"<STR_LIT>\" + df . format ( dateTo ) ) ; } } private void changePrefStatus ( Preference pref , boolean newStatus ) { if ( pref != null ) { pref . setEnabled ( newStatus ) ; pref", "gt": ". getIcon ( ) . setAlpha ( newStatus ? <NUM_LIT> : <NUM_LIT> ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent", "gt": "intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; container . setVisibility ( View . VISIBLE ) ; } catch ( Exception e ) { loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container", "gt": ". setVisibility ( View . GONE ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview", "gt": ". setOnClickATagListener ( new OnClickATagListener ( ) {", "repo": "Harmonic-HN"}
{"input": "package org . sufficientlysecure . htmltextview ; import android . text . Html ; import android . text . Html . ImageGetter ; import android . text . SpannableStringBuilder ; import android . text . Spanned ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class HtmlFormatter { private HtmlFormatter ( ) { } public static Spanned formatHtml ( @ NonNull final HtmlFormatterBuilder builder ) { return formatHtml ( builder . getHtml ( ) , builder . getImageGetter ( ) , builder . getClickableTableSpan ( ) , builder . getDrawTableLinkSpan ( ) , new TagClickListenerProvider ( ) { @ Override public OnClickATagListener provideTagClickListener ( ) { return builder . getOnClickATagListener ( ) ; } } , builder . getIndent ( ) , builder . isRemoveTrailingWhiteSpace ( ) ) ; } interface TagClickListenerProvider { OnClickATagListener provideTagClickListener ( ) ; } public static Spanned formatHtml ( @ Nullable String html , ImageGetter imageGetter , ClickableTableSpan clickableTableSpan , DrawTableLinkSpan drawTableLinkSpan , TagClickListenerProvider tagClickListenerProvider , float indent , boolean removeTrailingWhiteSpace ) { final HtmlTagHandler htmlTagHandler = new HtmlTagHandler ( ) ; htmlTagHandler . setClickableTableSpan ( clickableTableSpan ) ; htmlTagHandler . setDrawTableLinkSpan ( drawTableLinkSpan ) ; htmlTagHandler . setOnClickATagListenerProvider ( tagClickListenerProvider ) ; htmlTagHandler . setListIndentPx ( indent ) ; html = htmlTagHandler . overrideTags ( html ) ; Spanned formattedHtml ; if ( removeTrailingWhiteSpace ) { formattedHtml = removeHtmlBottomPadding ( Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ) ; } else { formattedHtml = Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ; } SpannableStringBuilder", "gt": "builder = new SpannableStringBuilder ( formattedHtml ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; container . setVisibility ( View . VISIBLE ) ; } catch ( Exception e ) { loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; e . printStackTrace ( ) ; } loadingProgress . setVisibility ( View . GONE ) ; } , error -> { error . printStackTrace ( ) ; loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; } ) ; stringRequest", "gt": ". setRetryPolicy ( new DefaultRetryPolicy ( <NUM_LIT> , DefaultRetryPolicy . DEFAULT_MAX_RETRIES , DefaultRetryPolicy . DEFAULT_BACKOFF_MULT ) ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; container . setVisibility ( View . VISIBLE ) ; } catch ( Exception e ) { loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; e . printStackTrace ( ) ; } loadingProgress . setVisibility ( View . GONE ) ; } , error -> { error . printStackTrace ( ) ; loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; } ) ; stringRequest . setRetryPolicy ( new DefaultRetryPolicy ( <NUM_LIT> , DefaultRetryPolicy . DEFAULT_MAX_RETRIES , DefaultRetryPolicy . DEFAULT_BACKOFF_MULT ) ) ; queue . add ( stringRequest ) ; } retryButton . setOnClickListener ( view1 -> { dialog . dismiss ( ) ; showUserDialog ( requireActivity ( ) . getSupportFragmentManager ( ) , userName ) ; } ) ; return dialog ; } public static void showUserDialog ( FragmentManager fm , String name ) { UserDialogFragment userDialogFragment = new UserDialogFragment ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putString ( UserDialogFragment . EXTRA_USER_NAME , name ) ; userDialogFragment . setArguments ( bundle ) ; userDialogFragment . show ( fm , UserDialogFragment . TAG ) ; } public void setLinkifiedText ( String text , TextView textView ) { SpannableString spannableString = new SpannableString ( text ) ; Pattern urlPattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher urlMatcher = urlPattern . matcher ( text ) ; while ( urlMatcher . find ( ) ) { String url = urlMatcher . group ( <NUM_LIT> ) ; spannableString", "gt": ". setSpan ( new ClickableSpan ( ) {", "repo": "Harmonic-HN"}
{"input": "package org . sufficientlysecure . htmltextview ; import android . text . Html ; import android . text . Html . ImageGetter ; import android . text . SpannableStringBuilder ; import android . text . Spanned ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class HtmlFormatter { private HtmlFormatter ( ) { } public static Spanned formatHtml ( @ NonNull final HtmlFormatterBuilder builder ) { return formatHtml ( builder . getHtml ( ) , builder . getImageGetter ( ) , builder . getClickableTableSpan ( ) , builder . getDrawTableLinkSpan ( ) , new TagClickListenerProvider ( ) { @ Override public OnClickATagListener provideTagClickListener ( ) { return builder . getOnClickATagListener ( ) ; } } , builder . getIndent ( ) , builder . isRemoveTrailingWhiteSpace ( ) ) ; } interface TagClickListenerProvider { OnClickATagListener provideTagClickListener ( ) ; } public static Spanned formatHtml ( @ Nullable String html , ImageGetter imageGetter , ClickableTableSpan clickableTableSpan , DrawTableLinkSpan drawTableLinkSpan , TagClickListenerProvider tagClickListenerProvider , float indent , boolean removeTrailingWhiteSpace ) { final HtmlTagHandler htmlTagHandler = new HtmlTagHandler ( ) ; htmlTagHandler . setClickableTableSpan ( clickableTableSpan ) ; htmlTagHandler . setDrawTableLinkSpan ( drawTableLinkSpan ) ; htmlTagHandler . setOnClickATagListenerProvider ( tagClickListenerProvider ) ; htmlTagHandler . setListIndentPx ( indent ) ; html = htmlTagHandler . overrideTags ( html ) ; Spanned formattedHtml ; if ( removeTrailingWhiteSpace ) { formattedHtml = removeHtmlBottomPadding ( Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ) ; } else { formattedHtml = Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ; } SpannableStringBuilder builder = new SpannableStringBuilder ( formattedHtml ) ; replaceNonBreakingSpaces ( builder ) ; return ( Spanned ) builder . subSequence ( <NUM_LIT> , builder . length ( ) ) ; } @ Nullable private static Spanned removeHtmlBottomPadding ( @ Nullable Spanned text ) { if ( text == null ) { return null ; } while ( text . length ( ) > <NUM_LIT> && text . charAt ( text . length ( ) - <NUM_LIT> ) == '<STR_LIT>' ) { text = ( Spanned ) text . subSequence ( <NUM_LIT> , text . length ( ) - <NUM_LIT> ) ; } return text ; } private static void replaceNonBreakingSpaces ( SpannableStringBuilder builder ) { int start = <NUM_LIT> ; while", "gt": "( start < builder . length ( ) ) {", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; startActivityForResult ( intent , READ_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Set < Integer > set = SettingsUtils . readIntSetFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) ; int oldCount = set . size ( ) ; SettingsUtils", "gt": ". saveIntSetToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS , new HashSet < > ( <NUM_LIT> ) ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . content . SharedPreferences ; import android . security . keystore . KeyGenParameterSpec ; import android . security . keystore . KeyProperties ; import android . util . Log ; import androidx . security . crypto . EncryptedSharedPreferences ; import androidx . security . crypto . MasterKey ; import java . io . File ; import java . security . KeyStore ; public class EncryptedSharedPreferencesHelper { private final static String HARMONIC_ENCRYPTED_PREFS = \"<STR_LIT>\" ; private static final String MASTER_KEY_ALIAS = \"<STR_LIT>\" ; private static final String KEYSTORE_PROVIDER = \"<STR_LIT>\" ; public static SharedPreferences getEncryptedSharedPreferences ( Context ctx ) throws Exception { try { return createSharedPreferences ( ctx ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; try { deleteSharedPreferences ( ctx ) ; return createSharedPreferences ( ctx ) ; } catch ( Exception otherException ) { otherException . printStackTrace ( ) ; throw new Exception ( ) ; } } } private static SharedPreferences createSharedPreferences ( Context ctx ) throws Exception { MasterKey mainKey = getMasterKey ( ctx ) ; if ( mainKey == null ) { Exception e = new Exception ( ) ; throw e ; } return EncryptedSharedPreferences . create ( ctx , HARMONIC_ENCRYPTED_PREFS , getMasterKey ( ctx ) , EncryptedSharedPreferences . PrefKeyEncryptionScheme . AES256_SIV , EncryptedSharedPreferences . PrefValueEncryptionScheme . AES256_GCM ) ; } public static boolean deleteSharedPreferences ( Context ctx ) { try { File sharedPrefsFile = new File ( ctx . getFilesDir ( ) . getParent ( ) + \"<STR_LIT>\" + HARMONIC_ENCRYPTED_PREFS + \"<STR_LIT>\" ) ; clearSharedPreference ( ctx ) ; if ( sharedPrefsFile . exists ( ) ) { boolean deleted = sharedPrefsFile . delete ( ) ; Utils . log ( \"<STR_LIT>\" + deleted + \"<STR_LIT>\" + sharedPrefsFile . getAbsolutePath ( ) ) ; } else { Utils . log ( \"<STR_LIT>\" + sharedPrefsFile . getAbsolutePath ( ) ) ; } KeyStore keyStore = KeyStore . getInstance ( KEYSTORE_PROVIDER ) ; keyStore . load ( null ) ; keyStore . deleteEntry ( MasterKey . DEFAULT_MASTER_KEY_ALIAS ) ; return true ; } catch ( Exception e ) { Utils . log ( \"<STR_LIT>\" + e ) ; return false ; } } private static void clearSharedPreference ( Context ctx ) { ctx . getSharedPreferences ( HARMONIC_ENCRYPTED_PREFS , Context . MODE_PRIVATE ) . edit ( ) . clear ( ) . apply ( ) ; } private static MasterKey getMasterKey ( Context ctx ) { try { KeyGenParameterSpec spec = new KeyGenParameterSpec . Builder ( MASTER_KEY_ALIAS , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_GCM ) . setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_NONE ) . setKeySize ( <NUM_LIT> ) . build ( ) ; return new MasterKey . Builder ( ctx , MASTER_KEY_ALIAS ) . setKeyGenParameterSpec ( spec ) . build ( ) ; } catch ( Exception e ) { Log", "gt": ". e ( ctx . getClass ( ) . getSimpleName ( ) , \"<STR_LIT>\" , e ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; startActivityForResult ( intent , READ_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Set < Integer > set = SettingsUtils . readIntSetFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) ; int oldCount = set . size ( ) ; SettingsUtils . saveIntSetToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS , new HashSet < > ( <NUM_LIT> ) ) ; if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } Snackbar snackbar = Snackbar . make ( requireView ( ) , \"<STR_LIT>\" + oldCount + ( oldCount == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) , Snackbar . LENGTH_SHORT ) ; snackbar . show ( ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { startActivity ( new Intent ( getContext ( ) , AboutActivity . class ) ) ; return false ; } } ) ; } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode == Activity . RESULT_OK && getContext ( ) != null && data != null && data . getData ( ) != null ) { if ( requestCode == WRITE_REQUEST_CODE ) { try { Utils . writeInFile ( getContext ( ) , data . getData ( ) , SettingsUtils . readStringFromSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ) ; } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } else if ( requestCode == READ_REQUEST_CODE ) { try { String content = Utils . readFileContent ( getContext ( ) , data . getData ( ) ) ; ArrayList < Bookmark > bookmarks = Utils . loadBookmarks ( true , content ) ; if ( ! bookmarks . isEmpty ( ) ) { SettingsUtils . saveStringToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS , content ) ; Toast . makeText ( getContext ( ) , \"<STR_LIT>\" + bookmarks . size ( ) + \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } } } @ Override public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; setDivider ( null ) ; } @ NonNull @ Override public RecyclerView onCreateRecyclerView ( @ NonNull LayoutInflater inflater , @ NonNull ViewGroup parent , @ Nullable Bundle savedInstanceState ) { RecyclerView recycler = super . onCreateRecyclerView ( inflater , parent , savedInstanceState ) ; recycler . setFitsSystemWindows ( true ) ; return recycler ; } private void updateTimedRangeSummary ( ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; if ( DateFormat . is24HourFormat ( getContext ( ) ) ) { findPreference", "gt": "( \"<STR_LIT>\" ) . setSummary ( ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; container . setVisibility ( View . VISIBLE ) ; } catch ( Exception e ) { loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; e . printStackTrace ( ) ; } loadingProgress . setVisibility ( View . GONE ) ; } , error -> { error . printStackTrace ( ) ; loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; } ) ; stringRequest . setRetryPolicy ( new DefaultRetryPolicy ( <NUM_LIT> , DefaultRetryPolicy . DEFAULT_MAX_RETRIES , DefaultRetryPolicy . DEFAULT_BACKOFF_MULT ) ) ; queue . add ( stringRequest ) ; } retryButton . setOnClickListener ( view1 -> { dialog . dismiss ( ) ; showUserDialog ( requireActivity ( ) . getSupportFragmentManager ( ) , userName ) ; } ) ; return dialog ; } public static void showUserDialog ( FragmentManager fm , String name ) { UserDialogFragment userDialogFragment = new UserDialogFragment ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putString ( UserDialogFragment . EXTRA_USER_NAME , name ) ; userDialogFragment . setArguments ( bundle ) ; userDialogFragment . show ( fm , UserDialogFragment . TAG ) ; } public void setLinkifiedText ( String text , TextView textView ) { SpannableString spannableString = new SpannableString ( text ) ; Pattern urlPattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher urlMatcher = urlPattern . matcher ( text ) ; while ( urlMatcher . find ( ) ) { String url = urlMatcher . group ( <NUM_LIT> ) ; spannableString . setSpan ( new ClickableSpan ( ) { @ Override public void onClick ( @ NonNull View widget ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , url ) ; } } , urlMatcher . start ( <NUM_LIT> ) , urlMatcher . end ( <NUM_LIT> ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; } textView", "gt": ". setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; container . setVisibility ( View . VISIBLE ) ; } catch ( Exception e ) { loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; e . printStackTrace ( ) ; } loadingProgress", "gt": ". setVisibility ( View . GONE ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; startActivityForResult ( intent , READ_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Set < Integer > set = SettingsUtils . readIntSetFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) ; int oldCount = set . size ( ) ; SettingsUtils . saveIntSetToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS , new HashSet < > ( <NUM_LIT> ) ) ; if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } Snackbar snackbar = Snackbar . make ( requireView ( ) , \"<STR_LIT>\" + oldCount + ( oldCount == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) , Snackbar . LENGTH_SHORT ) ; snackbar . show ( ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { startActivity ( new Intent ( getContext ( ) , AboutActivity . class ) ) ; return false ; } } ) ; } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode == Activity . RESULT_OK && getContext ( ) != null && data != null && data . getData ( ) != null ) { if ( requestCode == WRITE_REQUEST_CODE ) { try { Utils . writeInFile ( getContext ( ) , data . getData ( ) , SettingsUtils . readStringFromSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ) ; } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } else if ( requestCode == READ_REQUEST_CODE ) { try { String content = Utils . readFileContent ( getContext ( ) , data . getData ( ) ) ; ArrayList < Bookmark > bookmarks = Utils . loadBookmarks ( true , content ) ; if ( ! bookmarks . isEmpty ( ) ) { SettingsUtils . saveStringToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS , content ) ; Toast . makeText ( getContext ( ) , \"<STR_LIT>\" + bookmarks . size ( ) + \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } } } @ Override public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; setDivider ( null ) ; } @ NonNull @ Override public RecyclerView onCreateRecyclerView ( @ NonNull LayoutInflater inflater , @ NonNull ViewGroup parent , @ Nullable Bundle savedInstanceState ) { RecyclerView", "gt": "recycler = super . onCreateRecyclerView ( inflater , parent , savedInstanceState ) ;", "repo": "Harmonic-HN"}
{"input": "package org . sufficientlysecure . htmltextview ; import android . text . Html ; import android . text . Html . ImageGetter ; import android . text . SpannableStringBuilder ; import android . text . Spanned ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class HtmlFormatter { private HtmlFormatter ( ) { } public static Spanned formatHtml ( @ NonNull final HtmlFormatterBuilder builder ) { return formatHtml ( builder . getHtml ( ) , builder . getImageGetter ( ) , builder . getClickableTableSpan ( ) , builder . getDrawTableLinkSpan ( ) , new TagClickListenerProvider ( ) { @ Override public OnClickATagListener provideTagClickListener ( ) { return builder . getOnClickATagListener ( ) ; } } , builder . getIndent ( ) , builder . isRemoveTrailingWhiteSpace ( ) ) ; } interface TagClickListenerProvider { OnClickATagListener provideTagClickListener ( ) ; } public static Spanned formatHtml ( @ Nullable String html , ImageGetter imageGetter , ClickableTableSpan clickableTableSpan , DrawTableLinkSpan drawTableLinkSpan , TagClickListenerProvider tagClickListenerProvider , float indent , boolean removeTrailingWhiteSpace ) { final HtmlTagHandler htmlTagHandler = new HtmlTagHandler ( ) ; htmlTagHandler . setClickableTableSpan ( clickableTableSpan ) ; htmlTagHandler . setDrawTableLinkSpan ( drawTableLinkSpan ) ; htmlTagHandler . setOnClickATagListenerProvider ( tagClickListenerProvider ) ; htmlTagHandler . setListIndentPx ( indent ) ; html = htmlTagHandler . overrideTags ( html ) ; Spanned formattedHtml ; if ( removeTrailingWhiteSpace ) { formattedHtml = removeHtmlBottomPadding ( Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ) ; } else { formattedHtml = Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ; } SpannableStringBuilder builder = new SpannableStringBuilder ( formattedHtml ) ; replaceNonBreakingSpaces ( builder ) ; return ( Spanned ) builder . subSequence ( <NUM_LIT> , builder . length ( ) ) ; } @ Nullable private static Spanned removeHtmlBottomPadding ( @ Nullable Spanned text ) { if ( text == null ) { return null ; } while ( text . length ( ) > <NUM_LIT> && text . charAt ( text . length ( ) - <NUM_LIT> ) == '<STR_LIT>' ) { text = ( Spanned ) text . subSequence ( <NUM_LIT> , text . length ( ) - <NUM_LIT> ) ; } return text ; } private static void replaceNonBreakingSpaces ( SpannableStringBuilder builder ) { int start = <NUM_LIT> ; while ( start < builder . length ( ) ) { int index = builder . toString ( ) . indexOf ( '<STR_LIT>' , start ) ; if", "gt": "( index != - <NUM_LIT> ) {", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; startActivityForResult ( intent , READ_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Set < Integer > set = SettingsUtils . readIntSetFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) ; int oldCount = set . size ( ) ; SettingsUtils . saveIntSetToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS , new HashSet < > ( <NUM_LIT> ) ) ; if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } Snackbar snackbar = Snackbar . make ( requireView ( ) , \"<STR_LIT>\" + oldCount + ( oldCount == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) , Snackbar . LENGTH_SHORT ) ; snackbar . show ( ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { startActivity ( new Intent ( getContext ( ) , AboutActivity . class ) ) ; return false ; } } ) ; } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode == Activity . RESULT_OK && getContext ( ) != null && data != null && data . getData ( ) != null ) { if ( requestCode == WRITE_REQUEST_CODE ) { try { Utils . writeInFile ( getContext ( ) , data . getData ( ) , SettingsUtils . readStringFromSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ) ; } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } else if ( requestCode == READ_REQUEST_CODE ) { try { String content = Utils . readFileContent ( getContext ( ) , data . getData ( ) ) ; ArrayList < Bookmark > bookmarks = Utils . loadBookmarks ( true , content ) ; if ( ! bookmarks . isEmpty ( ) ) { SettingsUtils . saveStringToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS , content ) ; Toast", "gt": ". makeText ( getContext ( ) , \"<STR_LIT>\" + bookmarks . size ( ) + \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview", "gt": ". setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ;", "repo": "Harmonic-HN"}
{"input": "package org . sufficientlysecure . htmltextview ; import android . text . Html ; import android . text . Html . ImageGetter ; import android . text . SpannableStringBuilder ; import android . text . Spanned ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class HtmlFormatter { private HtmlFormatter ( ) { } public static Spanned formatHtml ( @ NonNull final HtmlFormatterBuilder builder ) { return formatHtml ( builder . getHtml ( ) , builder . getImageGetter ( ) , builder . getClickableTableSpan ( ) , builder . getDrawTableLinkSpan ( ) , new TagClickListenerProvider ( ) { @ Override public OnClickATagListener provideTagClickListener ( ) { return builder . getOnClickATagListener ( ) ; } } , builder . getIndent ( ) , builder . isRemoveTrailingWhiteSpace ( ) ) ; } interface TagClickListenerProvider { OnClickATagListener provideTagClickListener ( ) ; } public static Spanned formatHtml ( @ Nullable String html , ImageGetter imageGetter , ClickableTableSpan clickableTableSpan , DrawTableLinkSpan drawTableLinkSpan , TagClickListenerProvider tagClickListenerProvider , float indent , boolean removeTrailingWhiteSpace ) { final HtmlTagHandler htmlTagHandler = new HtmlTagHandler ( ) ; htmlTagHandler . setClickableTableSpan ( clickableTableSpan ) ; htmlTagHandler . setDrawTableLinkSpan ( drawTableLinkSpan ) ; htmlTagHandler . setOnClickATagListenerProvider ( tagClickListenerProvider ) ; htmlTagHandler . setListIndentPx ( indent ) ; html = htmlTagHandler . overrideTags ( html ) ; Spanned formattedHtml ; if ( removeTrailingWhiteSpace ) { formattedHtml = removeHtmlBottomPadding ( Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ) ; } else { formattedHtml = Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ; } SpannableStringBuilder builder = new SpannableStringBuilder ( formattedHtml ) ; replaceNonBreakingSpaces ( builder ) ; return ( Spanned ) builder . subSequence ( <NUM_LIT> , builder . length ( ) ) ; } @ Nullable private static Spanned removeHtmlBottomPadding ( @ Nullable Spanned text ) { if ( text == null ) { return null ; } while ( text . length ( ) > <NUM_LIT> && text . charAt ( text . length ( ) - <NUM_LIT> ) == '<STR_LIT>' ) { text = ( Spanned ) text . subSequence ( <NUM_LIT> , text . length ( ) - <NUM_LIT> ) ; } return text ; } private static void replaceNonBreakingSpaces ( SpannableStringBuilder builder ) { int start = <NUM_LIT> ; while ( start < builder . length ( ) ) { int index = builder . toString ( ) . indexOf ( '<STR_LIT>' , start ) ; if ( index != - <NUM_LIT> ) { builder", "gt": ". replace ( index , index + <NUM_LIT> , \"<STR_LIT>\" ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview", "gt": ". setVisibility ( View . GONE ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; startActivityForResult ( intent , READ_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Set < Integer > set = SettingsUtils . readIntSetFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) ; int oldCount = set . size ( ) ; SettingsUtils . saveIntSetToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS , new HashSet < > ( <NUM_LIT> ) ) ; if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } Snackbar snackbar = Snackbar . make ( requireView ( ) , \"<STR_LIT>\" + oldCount + ( oldCount == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) , Snackbar . LENGTH_SHORT ) ; snackbar . show ( ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { startActivity ( new Intent ( getContext ( ) , AboutActivity . class ) ) ; return false ; } } ) ; } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode == Activity . RESULT_OK && getContext ( ) != null && data != null && data . getData ( ) != null ) { if ( requestCode == WRITE_REQUEST_CODE ) { try { Utils . writeInFile ( getContext ( ) , data . getData ( ) , SettingsUtils . readStringFromSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ) ; } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } else if ( requestCode == READ_REQUEST_CODE ) { try { String content = Utils . readFileContent ( getContext ( ) , data . getData ( ) ) ; ArrayList < Bookmark > bookmarks = Utils . loadBookmarks ( true , content ) ; if ( ! bookmarks . isEmpty ( ) ) { SettingsUtils . saveStringToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS , content ) ; Toast . makeText ( getContext ( ) , \"<STR_LIT>\" + bookmarks . size ( ) + \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } } } @ Override public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super", "gt": ". onViewCreated ( view , savedInstanceState ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent", "gt": ". addCategory ( Intent . CATEGORY_OPENABLE ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . content . SharedPreferences ; import android . security . keystore . KeyGenParameterSpec ; import android . security . keystore . KeyProperties ; import android . util . Log ; import androidx . security . crypto . EncryptedSharedPreferences ; import androidx . security . crypto . MasterKey ; import java . io . File ; import java . security . KeyStore ; public class EncryptedSharedPreferencesHelper { private final static String HARMONIC_ENCRYPTED_PREFS = \"<STR_LIT>\" ; private static final String MASTER_KEY_ALIAS = \"<STR_LIT>\" ; private static final String KEYSTORE_PROVIDER = \"<STR_LIT>\" ; public static SharedPreferences getEncryptedSharedPreferences ( Context ctx ) throws Exception { try { return createSharedPreferences ( ctx ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; try { deleteSharedPreferences ( ctx ) ; return createSharedPreferences ( ctx ) ; } catch ( Exception otherException ) { otherException . printStackTrace ( ) ; throw new Exception ( ) ; } } } private static SharedPreferences createSharedPreferences ( Context ctx ) throws Exception { MasterKey mainKey = getMasterKey ( ctx ) ; if ( mainKey == null ) { Exception e = new Exception ( ) ; throw e ; } return EncryptedSharedPreferences . create ( ctx , HARMONIC_ENCRYPTED_PREFS , getMasterKey ( ctx ) , EncryptedSharedPreferences . PrefKeyEncryptionScheme . AES256_SIV , EncryptedSharedPreferences . PrefValueEncryptionScheme . AES256_GCM ) ; } public static boolean deleteSharedPreferences ( Context ctx ) { try { File sharedPrefsFile = new File ( ctx . getFilesDir ( ) . getParent ( ) + \"<STR_LIT>\" + HARMONIC_ENCRYPTED_PREFS + \"<STR_LIT>\" ) ; clearSharedPreference ( ctx ) ; if ( sharedPrefsFile . exists ( ) ) { boolean", "gt": "deleted = sharedPrefsFile . delete ( ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; startActivityForResult ( intent , READ_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Set < Integer > set = SettingsUtils . readIntSetFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) ; int oldCount = set . size ( ) ; SettingsUtils . saveIntSetToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS , new HashSet < > ( <NUM_LIT> ) ) ; if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } Snackbar snackbar = Snackbar . make ( requireView ( ) , \"<STR_LIT>\" + oldCount + ( oldCount == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) , Snackbar . LENGTH_SHORT ) ; snackbar . show ( ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { startActivity ( new Intent ( getContext ( ) , AboutActivity . class ) ) ; return false ; } } ) ; } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode == Activity . RESULT_OK && getContext ( ) != null && data != null && data . getData ( ) != null ) { if ( requestCode == WRITE_REQUEST_CODE ) { try { Utils . writeInFile ( getContext ( ) , data . getData ( ) , SettingsUtils . readStringFromSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ) ; } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } else if ( requestCode == READ_REQUEST_CODE ) { try { String content = Utils . readFileContent ( getContext ( ) , data . getData ( ) ) ; ArrayList < Bookmark > bookmarks = Utils . loadBookmarks ( true , content ) ; if ( ! bookmarks . isEmpty ( ) ) { SettingsUtils . saveStringToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS , content ) ; Toast . makeText ( getContext ( ) , \"<STR_LIT>\" + bookmarks . size ( ) + \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } } } @ Override public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; setDivider ( null ) ; } @ NonNull @ Override public RecyclerView onCreateRecyclerView ( @ NonNull LayoutInflater inflater , @ NonNull ViewGroup parent , @ Nullable Bundle savedInstanceState ) { RecyclerView recycler = super . onCreateRecyclerView ( inflater , parent , savedInstanceState ) ; recycler . setFitsSystemWindows ( true ) ; return recycler ; } private void updateTimedRangeSummary ( ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; if ( DateFormat . is24HourFormat ( getContext ( ) ) ) { findPreference ( \"<STR_LIT>\" ) . setSummary ( ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] ) ; } else { SimpleDateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; Date dateFrom = new Date ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , nighttimeHours [ <NUM_LIT> ] , nighttimeHours [ <NUM_LIT> ] ) ; Date dateTo = new Date ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , nighttimeHours [ <NUM_LIT> ] , nighttimeHours [ <NUM_LIT> ] ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( df . format ( dateFrom ) + \"<STR_LIT>\" + df . format ( dateTo ) ) ; } } private void changePrefStatus ( Preference pref , boolean newStatus ) { if ( pref != null ) { pref . setEnabled ( newStatus ) ; pref . getIcon ( ) . setAlpha ( newStatus ? <NUM_LIT> : <NUM_LIT> ) ; } } } @ Override public void onConfigurationChanged ( @ NonNull Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; updatePadding ( ) ; } private void updatePadding ( ) { int", "gt": "extraPadding = getResources ( ) . getDimensionPixelSize ( R . dimen . single_view_side_margin ) ;", "repo": "Harmonic-HN"}
{"input": "package org . sufficientlysecure . htmltextview ; import android . text . Html ; import android . text . Html . ImageGetter ; import android . text . SpannableStringBuilder ; import android . text . Spanned ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class HtmlFormatter { private HtmlFormatter ( ) { } public static Spanned formatHtml ( @ NonNull final HtmlFormatterBuilder builder ) { return formatHtml ( builder . getHtml ( ) , builder . getImageGetter ( ) , builder . getClickableTableSpan ( ) , builder . getDrawTableLinkSpan ( ) , new TagClickListenerProvider ( ) { @ Override public OnClickATagListener provideTagClickListener ( ) { return builder . getOnClickATagListener ( ) ; } } , builder . getIndent ( ) , builder . isRemoveTrailingWhiteSpace ( ) ) ; } interface TagClickListenerProvider { OnClickATagListener provideTagClickListener ( ) ; } public static Spanned formatHtml ( @ Nullable String html , ImageGetter imageGetter , ClickableTableSpan clickableTableSpan , DrawTableLinkSpan drawTableLinkSpan , TagClickListenerProvider tagClickListenerProvider , float indent , boolean removeTrailingWhiteSpace ) { final HtmlTagHandler htmlTagHandler = new HtmlTagHandler ( ) ; htmlTagHandler . setClickableTableSpan ( clickableTableSpan ) ; htmlTagHandler . setDrawTableLinkSpan ( drawTableLinkSpan ) ; htmlTagHandler . setOnClickATagListenerProvider ( tagClickListenerProvider ) ; htmlTagHandler . setListIndentPx ( indent ) ; html = htmlTagHandler . overrideTags ( html ) ; Spanned formattedHtml ; if ( removeTrailingWhiteSpace ) { formattedHtml = removeHtmlBottomPadding ( Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ) ; } else { formattedHtml = Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ; } SpannableStringBuilder builder = new SpannableStringBuilder ( formattedHtml ) ; replaceNonBreakingSpaces ( builder ) ; return", "gt": "( Spanned ) builder . subSequence ( <NUM_LIT> , builder . length ( ) ) ;", "repo": "Harmonic-HN"}
{"input": "package org . sufficientlysecure . htmltextview ; import android . text . Html ; import android . text . Html . ImageGetter ; import android . text . SpannableStringBuilder ; import android . text . Spanned ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class HtmlFormatter { private HtmlFormatter ( ) { } public static Spanned formatHtml ( @ NonNull final HtmlFormatterBuilder builder ) { return formatHtml ( builder . getHtml ( ) , builder . getImageGetter ( ) , builder . getClickableTableSpan ( ) , builder . getDrawTableLinkSpan ( ) , new TagClickListenerProvider ( ) { @ Override public OnClickATagListener provideTagClickListener ( ) { return builder . getOnClickATagListener ( ) ; } } , builder . getIndent ( ) , builder . isRemoveTrailingWhiteSpace ( ) ) ; } interface TagClickListenerProvider { OnClickATagListener provideTagClickListener ( ) ; } public static Spanned formatHtml ( @ Nullable String html , ImageGetter imageGetter , ClickableTableSpan clickableTableSpan , DrawTableLinkSpan drawTableLinkSpan , TagClickListenerProvider tagClickListenerProvider , float indent , boolean removeTrailingWhiteSpace ) { final HtmlTagHandler htmlTagHandler = new HtmlTagHandler ( ) ; htmlTagHandler . setClickableTableSpan ( clickableTableSpan ) ; htmlTagHandler . setDrawTableLinkSpan ( drawTableLinkSpan ) ; htmlTagHandler . setOnClickATagListenerProvider ( tagClickListenerProvider ) ; htmlTagHandler . setListIndentPx ( indent ) ; html = htmlTagHandler . overrideTags ( html ) ; Spanned formattedHtml ; if ( removeTrailingWhiteSpace ) { formattedHtml = removeHtmlBottomPadding ( Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ) ; } else { formattedHtml = Html . fromHtml ( html , imageGetter , new WrapperContentHandler ( htmlTagHandler ) ) ; } SpannableStringBuilder builder = new SpannableStringBuilder ( formattedHtml ) ; replaceNonBreakingSpaces ( builder ) ; return ( Spanned ) builder . subSequence ( <NUM_LIT> , builder . length ( ) ) ; } @ Nullable private static Spanned removeHtmlBottomPadding ( @ Nullable Spanned text ) { if ( text == null ) { return null ; } while ( text . length ( ) > <NUM_LIT> && text . charAt ( text . length ( ) - <NUM_LIT> ) == '<STR_LIT>' ) { text = ( Spanned ) text . subSequence ( <NUM_LIT> , text . length ( ) - <NUM_LIT> ) ; } return text ; } private static void replaceNonBreakingSpaces ( SpannableStringBuilder builder ) { int start = <NUM_LIT> ; while ( start < builder . length ( ) ) { int", "gt": "index = builder . toString ( ) . indexOf ( '<STR_LIT>' , start ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; container . setVisibility ( View . VISIBLE ) ; } catch ( Exception e ) { loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; e . printStackTrace ( ) ; } loadingProgress . setVisibility ( View . GONE ) ; } , error -> { error . printStackTrace ( ) ; loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container", "gt": ". setVisibility ( View . GONE ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker", "gt": ". show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; startActivityForResult ( intent , READ_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Set < Integer > set = SettingsUtils . readIntSetFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) ; int oldCount = set . size ( ) ; SettingsUtils . saveIntSetToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS , new HashSet < > ( <NUM_LIT> ) ) ; if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } Snackbar snackbar = Snackbar . make ( requireView ( ) , \"<STR_LIT>\" + oldCount + ( oldCount == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) , Snackbar . LENGTH_SHORT ) ; snackbar . show ( ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { startActivity ( new Intent ( getContext ( ) , AboutActivity . class ) ) ; return false ; } } ) ; } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode == Activity . RESULT_OK && getContext ( ) != null && data != null && data . getData ( ) != null ) { if ( requestCode == WRITE_REQUEST_CODE ) { try { Utils . writeInFile ( getContext ( ) , data . getData ( ) , SettingsUtils . readStringFromSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ) ; } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } else if ( requestCode == READ_REQUEST_CODE ) { try { String content = Utils . readFileContent ( getContext ( ) , data . getData ( ) ) ; ArrayList < Bookmark > bookmarks = Utils . loadBookmarks ( true , content ) ; if ( ! bookmarks . isEmpty ( ) ) { SettingsUtils . saveStringToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS , content ) ; Toast . makeText ( getContext ( ) , \"<STR_LIT>\" + bookmarks . size ( ) + \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } } } @ Override public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; setDivider ( null ) ; } @ NonNull @ Override public RecyclerView onCreateRecyclerView ( @ NonNull LayoutInflater inflater , @ NonNull ViewGroup parent , @ Nullable Bundle savedInstanceState ) { RecyclerView recycler = super . onCreateRecyclerView ( inflater , parent , savedInstanceState ) ; recycler . setFitsSystemWindows ( true ) ; return recycler ; } private void updateTimedRangeSummary ( ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; if ( DateFormat . is24HourFormat ( getContext ( ) ) ) { findPreference ( \"<STR_LIT>\" ) . setSummary ( ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] ) ; } else { SimpleDateFormat", "gt": "df = new SimpleDateFormat ( \"<STR_LIT>\" ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; startActivityForResult ( intent , READ_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Set < Integer > set = SettingsUtils . readIntSetFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) ; int oldCount = set . size ( ) ; SettingsUtils . saveIntSetToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS , new HashSet < > ( <NUM_LIT> ) ) ; if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } Snackbar snackbar = Snackbar . make ( requireView ( ) , \"<STR_LIT>\" + oldCount + ( oldCount == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) , Snackbar . LENGTH_SHORT ) ; snackbar . show ( ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { startActivity ( new Intent ( getContext ( ) , AboutActivity . class ) ) ; return false ; } } ) ; } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode == Activity . RESULT_OK && getContext ( ) != null && data != null && data . getData ( ) != null ) { if ( requestCode == WRITE_REQUEST_CODE ) { try { Utils . writeInFile ( getContext ( ) , data . getData ( ) , SettingsUtils . readStringFromSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ) ; } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } else if ( requestCode == READ_REQUEST_CODE ) { try { String content = Utils . readFileContent ( getContext ( ) , data . getData ( ) ) ; ArrayList < Bookmark > bookmarks = Utils . loadBookmarks ( true , content ) ; if ( ! bookmarks . isEmpty ( ) ) { SettingsUtils . saveStringToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS , content ) ; Toast . makeText ( getContext ( ) , \"<STR_LIT>\" + bookmarks . size ( ) + \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } } } @ Override public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; setDivider ( null ) ; } @ NonNull @ Override public RecyclerView onCreateRecyclerView ( @ NonNull LayoutInflater inflater , @ NonNull ViewGroup parent , @ Nullable Bundle savedInstanceState ) { RecyclerView recycler = super . onCreateRecyclerView ( inflater , parent , savedInstanceState ) ; recycler . setFitsSystemWindows ( true ) ; return recycler ; } private void updateTimedRangeSummary ( ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; if ( DateFormat . is24HourFormat ( getContext ( ) ) ) { findPreference ( \"<STR_LIT>\" ) . setSummary ( ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] ) ; } else { SimpleDateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; Date dateFrom = new Date ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , nighttimeHours [ <NUM_LIT> ] , nighttimeHours [ <NUM_LIT> ] ) ; Date", "gt": "dateTo = new Date ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , nighttimeHours [ <NUM_LIT> ] , nighttimeHours [ <NUM_LIT> ] ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; container . setVisibility ( View . VISIBLE ) ; } catch ( Exception e ) { loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; e . printStackTrace ( ) ; } loadingProgress . setVisibility ( View . GONE ) ; } , error -> { error . printStackTrace ( ) ; loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; } ) ; stringRequest . setRetryPolicy ( new DefaultRetryPolicy ( <NUM_LIT> , DefaultRetryPolicy . DEFAULT_MAX_RETRIES , DefaultRetryPolicy . DEFAULT_BACKOFF_MULT ) ) ; queue . add ( stringRequest ) ; } retryButton . setOnClickListener ( view1 -> { dialog . dismiss ( ) ; showUserDialog ( requireActivity ( ) . getSupportFragmentManager ( ) , userName ) ; } ) ; return dialog ; } public static void showUserDialog ( FragmentManager fm , String name ) { UserDialogFragment", "gt": "userDialogFragment = new UserDialogFragment ( ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . content . SharedPreferences ; import android . security . keystore . KeyGenParameterSpec ; import android . security . keystore . KeyProperties ; import android . util . Log ; import androidx . security . crypto . EncryptedSharedPreferences ; import androidx . security . crypto . MasterKey ; import java . io . File ; import java . security . KeyStore ; public class EncryptedSharedPreferencesHelper { private final static String HARMONIC_ENCRYPTED_PREFS = \"<STR_LIT>\" ; private static final String MASTER_KEY_ALIAS = \"<STR_LIT>\" ; private static final String KEYSTORE_PROVIDER = \"<STR_LIT>\" ; public static SharedPreferences getEncryptedSharedPreferences ( Context ctx ) throws Exception { try { return createSharedPreferences ( ctx ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; try { deleteSharedPreferences ( ctx ) ; return createSharedPreferences ( ctx ) ; } catch ( Exception otherException ) { otherException . printStackTrace ( ) ; throw new Exception ( ) ; } } } private static SharedPreferences createSharedPreferences ( Context ctx ) throws Exception { MasterKey mainKey = getMasterKey ( ctx ) ; if ( mainKey == null ) { Exception e = new Exception ( ) ; throw e ; } return EncryptedSharedPreferences . create ( ctx , HARMONIC_ENCRYPTED_PREFS , getMasterKey ( ctx ) , EncryptedSharedPreferences . PrefKeyEncryptionScheme . AES256_SIV , EncryptedSharedPreferences . PrefValueEncryptionScheme . AES256_GCM ) ; } public static boolean deleteSharedPreferences ( Context ctx ) { try { File sharedPrefsFile = new File ( ctx . getFilesDir ( ) . getParent ( ) + \"<STR_LIT>\" + HARMONIC_ENCRYPTED_PREFS + \"<STR_LIT>\" ) ; clearSharedPreference ( ctx ) ; if ( sharedPrefsFile . exists ( ) ) { boolean deleted = sharedPrefsFile . delete ( ) ; Utils . log ( \"<STR_LIT>\" + deleted + \"<STR_LIT>\" + sharedPrefsFile . getAbsolutePath ( ) ) ; } else { Utils . log ( \"<STR_LIT>\" + sharedPrefsFile . getAbsolutePath ( ) ) ; } KeyStore keyStore = KeyStore . getInstance ( KEYSTORE_PROVIDER ) ; keyStore . load ( null ) ; keyStore . deleteEntry ( MasterKey . DEFAULT_MASTER_KEY_ALIAS ) ; return true ; } catch ( Exception e ) { Utils . log ( \"<STR_LIT>\" + e ) ; return false ; } } private static void clearSharedPreference ( Context ctx ) { ctx . getSharedPreferences ( HARMONIC_ENCRYPTED_PREFS , Context . MODE_PRIVATE ) . edit ( ) . clear ( ) . apply ( ) ; } private static MasterKey getMasterKey ( Context ctx ) { try { KeyGenParameterSpec", "gt": "spec = new KeyGenParameterSpec . Builder ( MASTER_KEY_ALIAS , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_GCM ) . setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_NONE ) . setKeySize ( <NUM_LIT> ) . build ( ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import static com . simon . harmonichackernews . SubmissionsActivity . KEY_USER ; import android . app . Dialog ; import android . content . Intent ; import android . os . Bundle ; import android . text . Html ; import android . text . SpannableString ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . method . LinkMovementMethod ; import android . text . style . ClickableSpan ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import com . android . volley . DefaultRetryPolicy ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . Calendar ; import java . util . Date ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UserDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_USER_NAME = \"<STR_LIT>\" ; private TextView nameTextview ; private TextView metaTextview ; private HtmlTextView aboutTextview ; private Button submissionsButton ; private ProgressBar loadingProgress ; private LinearLayout errorLayout ; private LinearLayout container ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . user_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; nameTextview = rootView . findViewById ( R . id . user_name ) ; metaTextview = rootView . findViewById ( R . id . user_meta ) ; aboutTextview = rootView . findViewById ( R . id . user_about ) ; submissionsButton = rootView . findViewById ( R . id . user_submissions_button ) ; loadingProgress = rootView . findViewById ( R . id . user_loading ) ; errorLayout = rootView . findViewById ( R . id . user_error ) ; Button retryButton = rootView . findViewById ( R . id . user_retry ) ; container = rootView . findViewById ( R . id . user_container ) ; Bundle bundle = getArguments ( ) ; final String userName = ( bundle != null && ! TextUtils . isEmpty ( bundle . getString ( EXTRA_USER_NAME ) ) ) ? bundle . getString ( EXTRA_USER_NAME ) : null ; if ( userName != null ) { String url = \"<STR_LIT>\" + userName + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { JSONObject jsonObject = new JSONObject ( response ) ; nameTextview . setText ( jsonObject . getString ( \"<STR_LIT>\" ) ) ; int karma = jsonObject . getInt ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( jsonObject . getInt ( \"<STR_LIT>\" ) * <NUM_LIT> ) ) ; JSONArray submitted ; if ( jsonObject . has ( \"<STR_LIT>\" ) ) { submitted = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; } else { submitted = new JSONArray ( ) ; jsonObject . put ( \"<STR_LIT>\" , submitted ) ; } if ( submitted . length ( ) == <NUM_LIT> ) { submissionsButton . setVisibility ( View . GONE ) ; } else { submissionsButton . setText ( \"<STR_LIT>\" ) ; submissionsButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent submissionsIntent = new Intent ( view . getContext ( ) , SubmissionsActivity . class ) ; try { submissionsIntent . putExtra ( KEY_USER , jsonObject . getString ( \"<STR_LIT>\" ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } startActivity ( submissionsIntent ) ; } } ) ; } String month = getResources ( ) . getStringArray ( R . array . months ) [ cal . get ( Calendar . MONTH ) ] ; metaTextview . setText ( \"<STR_LIT>\" + Utils . getThousandSeparatedString ( karma ) + \"<STR_LIT>\" + month + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" + ( cal . get ( Calendar . YEAR ) ) ) ; if ( jsonObject . has ( \"<STR_LIT>\" ) && ! TextUtils . isEmpty ( jsonObject . getString ( \"<STR_LIT>\" ) ) ) { setLinkifiedText ( Html . fromHtml ( jsonObject . getString ( \"<STR_LIT>\" ) ) . toString ( ) . trim ( ) , aboutTextview ) ; } else { aboutTextview . setVisibility ( View . GONE ) ; } aboutTextview . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; container . setVisibility ( View . VISIBLE ) ; } catch ( Exception e ) { loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; e . printStackTrace ( ) ; } loadingProgress . setVisibility ( View . GONE ) ; } , error -> { error . printStackTrace ( ) ; loadingProgress . setVisibility ( View . GONE ) ; errorLayout . setVisibility ( View . VISIBLE ) ; container . setVisibility ( View . GONE ) ; } ) ; stringRequest . setRetryPolicy ( new DefaultRetryPolicy ( <NUM_LIT> , DefaultRetryPolicy . DEFAULT_MAX_RETRIES , DefaultRetryPolicy . DEFAULT_BACKOFF_MULT ) ) ; queue . add ( stringRequest ) ; } retryButton . setOnClickListener ( view1 -> { dialog . dismiss ( ) ; showUserDialog ( requireActivity ( ) . getSupportFragmentManager ( ) , userName ) ; } ) ; return dialog ; } public static void showUserDialog ( FragmentManager fm , String name ) { UserDialogFragment userDialogFragment = new UserDialogFragment ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putString ( UserDialogFragment . EXTRA_USER_NAME , name ) ; userDialogFragment . setArguments ( bundle ) ; userDialogFragment . show ( fm , UserDialogFragment . TAG ) ; } public void setLinkifiedText ( String text , TextView textView ) { SpannableString spannableString = new SpannableString ( text ) ; Pattern urlPattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher urlMatcher = urlPattern . matcher ( text ) ; while ( urlMatcher . find ( ) ) { String url = urlMatcher . group ( <NUM_LIT> ) ; spannableString . setSpan ( new ClickableSpan ( ) { @ Override public void onClick ( @ NonNull View widget ) { Utils", "gt": ". openLinkMaybeHN ( widget . getContext ( ) , url ) ;", "repo": "Harmonic-HN"}
{"input": "package com . simon . harmonichackernews ; import android . app . Activity ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . text . format . DateFormat ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . preference . Preference ; import androidx . preference . PreferenceFragmentCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . timepicker . MaterialTimePicker ; import com . google . android . material . timepicker . TimeFormat ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; public class SettingsActivity extends AppCompatActivity { private static boolean requestFullRestart = false ; public final static String EXTRA_REQUEST_RESTART = \"<STR_LIT>\" ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestFullRestart = false ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_settings ) ; updatePadding ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . settings , new SettingsFragment ( ) ) . commit ( ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { handleExit ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; if ( getIntent ( ) != null && getIntent ( ) . getBooleanExtra ( EXTRA_REQUEST_RESTART , false ) ) { backPressedCallback . setEnabled ( true ) ; } } public static class SettingsFragment extends PreferenceFragmentCompat { private static final int WRITE_REQUEST_CODE = <NUM_LIT> ; private static final int READ_REQUEST_CODE = <NUM_LIT> ; public SettingsFragment ( ) { } @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . root_preferences , rootKey ) ; updateTimedRangeSummary ( ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! ( boolean ) newValue ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } requestFullRestart = true ; return true ; } } ) ; boolean compact = SettingsUtils . shouldUseCompactView ( getContext ( ) ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; changePrefStatus ( findPreference ( \"<STR_LIT>\" ) , ! compact ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; final Fragment f = this ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceChangeListener ( new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { Intent intent = new Intent ( getContext ( ) , SettingsActivity . class ) ; intent . putExtra ( EXTRA_REQUEST_RESTART , true ) ; requireContext ( ) . startActivity ( intent ) ; requireActivity ( ) . finish ( ) ; return true ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; MaterialTimePicker fromTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; fromTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MaterialTimePicker toTimePicker = new MaterialTimePicker . Builder ( ) . setTimeFormat ( DateFormat . is24HourFormat ( getContext ( ) ) ? TimeFormat . CLOCK_24H : TimeFormat . CLOCK_12H ) . setHour ( nighttimeHours [ <NUM_LIT> ] ) . setMinute ( nighttimeHours [ <NUM_LIT> ] ) . setTitleText ( \"<STR_LIT>\" ) . build ( ) ; toTimePicker . addOnPositiveButtonClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Utils . setNighttimeHours ( fromTimePicker . getHour ( ) , fromTimePicker . getMinute ( ) , toTimePicker . getHour ( ) , toTimePicker . getMinute ( ) , getContext ( ) ) ; updateTimedRangeSummary ( ) ; } } ) ; toTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; } } ) ; fromTimePicker . show ( getParentFragmentManager ( ) , \"<STR_LIT>\" ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { String textToSave = SettingsUtils . readStringFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ; if ( TextUtils . isEmpty ( textToSave ) ) { Snackbar . make ( getView ( ) , \"<STR_LIT>\" , Snackbar . LENGTH_SHORT ) . show ( ) ; return false ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + cal . get ( Calendar . YEAR ) + \"<STR_LIT>\" + ( cal . get ( Calendar . MONTH ) + <NUM_LIT> ) + \"<STR_LIT>\" + cal . get ( Calendar . DAY_OF_MONTH ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , WRITE_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; startActivityForResult ( intent , READ_REQUEST_CODE ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { Set < Integer > set = SettingsUtils . readIntSetFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) ; int oldCount = set . size ( ) ; SettingsUtils . saveIntSetToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS , new HashSet < > ( <NUM_LIT> ) ) ; if ( getActivity ( ) != null && getActivity ( ) instanceof SettingsActivity ) { ( ( SettingsActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( true ) ; } Snackbar snackbar = Snackbar . make ( requireView ( ) , \"<STR_LIT>\" + oldCount + ( oldCount == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) , Snackbar . LENGTH_SHORT ) ; snackbar . show ( ) ; return false ; } } ) ; findPreference ( \"<STR_LIT>\" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { startActivity ( new Intent ( getContext ( ) , AboutActivity . class ) ) ; return false ; } } ) ; } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode == Activity . RESULT_OK && getContext ( ) != null && data != null && data . getData ( ) != null ) { if ( requestCode == WRITE_REQUEST_CODE ) { try { Utils . writeInFile ( getContext ( ) , data . getData ( ) , SettingsUtils . readStringFromSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS ) ) ; } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } else if ( requestCode == READ_REQUEST_CODE ) { try { String content = Utils . readFileContent ( getContext ( ) , data . getData ( ) ) ; ArrayList < Bookmark > bookmarks = Utils . loadBookmarks ( true , content ) ; if ( ! bookmarks . isEmpty ( ) ) { SettingsUtils . saveStringToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_BOOKMARKS , content ) ; Toast . makeText ( getContext ( ) , \"<STR_LIT>\" + bookmarks . size ( ) + \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } catch ( Exception e ) { Toast . makeText ( getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; e . printStackTrace ( ) ; } } } } @ Override public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; setDivider ( null ) ; } @ NonNull @ Override public RecyclerView onCreateRecyclerView ( @ NonNull LayoutInflater inflater , @ NonNull ViewGroup parent , @ Nullable Bundle savedInstanceState ) { RecyclerView recycler = super . onCreateRecyclerView ( inflater , parent , savedInstanceState ) ; recycler . setFitsSystemWindows ( true ) ; return recycler ; } private void updateTimedRangeSummary ( ) { int [ ] nighttimeHours = Utils . getNighttimeHours ( getContext ( ) ) ; if ( DateFormat . is24HourFormat ( getContext ( ) ) ) { findPreference ( \"<STR_LIT>\" ) . setSummary ( ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] + \"<STR_LIT>\" + ( nighttimeHours [ <NUM_LIT> ] < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + nighttimeHours [ <NUM_LIT> ] ) ; } else { SimpleDateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; Date dateFrom = new Date ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , nighttimeHours [ <NUM_LIT> ] , nighttimeHours [ <NUM_LIT> ] ) ; Date dateTo = new Date ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , nighttimeHours [ <NUM_LIT> ] , nighttimeHours [ <NUM_LIT> ] ) ; findPreference ( \"<STR_LIT>\" ) . setSummary ( df . format ( dateFrom ) + \"<STR_LIT>\" + df . format ( dateTo ) ) ; } } private void changePrefStatus ( Preference pref , boolean newStatus ) { if ( pref != null ) { pref . setEnabled ( newStatus ) ; pref . getIcon ( ) . setAlpha ( newStatus ? <NUM_LIT> : <NUM_LIT> ) ; } } } @ Override public void onConfigurationChanged ( @ NonNull Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; updatePadding ( ) ; } private void updatePadding ( ) { int extraPadding = getResources ( ) . getDimensionPixelSize ( R . dimen . single_view_side_margin ) ; findViewById ( R . id . settings_linear_layout ) . setPadding ( extraPadding , <NUM_LIT> , extraPadding , <NUM_LIT> ) ; } private void handleExit ( ) { Intent intent = getPackageManager ( ) . getLaunchIntentForPackage ( getPackageName ( ) ) ; intent", "gt": ". addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TASK ) ;", "repo": "Harmonic-HN"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ; mPaint . setStrokeWidth ( width ) ; float radius = mSize / <NUM_LIT> ; canvas . rotate ( rotateDegrees , radius , radius ) ; canvas . translate ( radius , radius ) ; for ( int i = <NUM_LIT> ; i < LINE_COUNT ; i ++ ) { canvas . rotate ( DEGREE_PER_LINE ) ; float factor = ( i + <NUM_LIT> ) / LINE_COUNT ; mPaint . setAlpha ( Math . max ( ( int ) ( <NUM_LIT> * ( factor * factor ) ) , <NUM_LIT> ) ) ; canvas . translate ( <NUM_LIT> , - radius + width * <NUM_LIT> ) ; canvas", "gt": ". drawLine ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , height , mPaint ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ; View view = uiManagerModule . resolveView ( viewTag ) ; WritableMap map = Arguments . createMap ( ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map", "gt": ". putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . imagecrop ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReadableArray ; import com . facebook . react . bridge . ReadableMap ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . ViewGroupManager ; import com . facebook . react . uimanager . annotations . ReactProp ; import java . util . Map ; public class RNImageCropViewManager extends ViewGroupManager < RNImageCropView > { private static final String REACT_CLASS = \"<STR_LIT>\" ; private static final int COMMAND_CROP = <NUM_LIT> ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override protected RNImageCropView createViewInstance ( @ NonNull ThemedReactContext reactContext ) { return new RNImageCropView ( reactContext ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setFileUri ( RNImageCropView RNImageCropView , String fileUri ) { RNImageCropView . setFileUri ( fileUri ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setCropStyle ( RNImageCropView RNImageCropView , String cropStyle ) { RNImageCropView . setCropStyle ( cropStyle ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setObjectRect ( RNImageCropView RNImageCropView , ReadableMap objectRect ) { RNImageCropView . setObjectRect ( objectRect ) ; } @ Override protected void onAfterUpdateTransaction ( @ NonNull RNImageCropView RNImageCropView ) { super . onAfterUpdateTransaction ( RNImageCropView ) ; RNImageCropView . initProperties ( ) ; } @ Nullable @ Override public Map < String , Integer > getCommandsMap ( ) { return MapBuilder . of ( \"<STR_LIT>\" , COMMAND_CROP ) ; } @ Override public void receiveCommand ( @ NonNull RNImageCropView root , String commandId , @ Nullable ReadableArray args ) { super . receiveCommand ( root , commandId , args ) ; int commandIdInt = Integer . parseInt ( commandId ) ; switch ( commandIdInt ) { case COMMAND_CROP : root . crop ( ) ; break ; } } public Map < String , Object > getExportedCustomBubblingEventTypeConstants ( ) { String name = \"<STR_LIT>\" ; String bubbled = \"<STR_LIT>\" ; return", "gt": "MapBuilder . < String , Object > builder ( ) . put ( \"<STR_LIT>\" , MapBuilder . of ( name , MapBuilder . of ( bubbled , \"<STR_LIT>\" ) ) ) . build ( ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ; View view = uiManagerModule . resolveView ( viewTag ) ; WritableMap map = Arguments . createMap ( ) ; map", "gt": ". putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ; View view = uiManagerModule . resolveView ( viewTag ) ; WritableMap map = Arguments . createMap ( ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; if ( view != null ) { EdgeInsets", "gt": "insets = SystemUI . getEdgeInsetsForView ( view ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . imagecrop ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReadableArray ; import com . facebook . react . bridge . ReadableMap ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . ViewGroupManager ; import com . facebook . react . uimanager . annotations . ReactProp ; import java . util . Map ; public class RNImageCropViewManager extends ViewGroupManager < RNImageCropView > { private static final String REACT_CLASS = \"<STR_LIT>\" ; private static final int COMMAND_CROP = <NUM_LIT> ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override protected RNImageCropView createViewInstance ( @ NonNull ThemedReactContext reactContext ) { return new RNImageCropView ( reactContext ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setFileUri ( RNImageCropView RNImageCropView , String fileUri ) { RNImageCropView . setFileUri ( fileUri ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setCropStyle ( RNImageCropView RNImageCropView , String cropStyle ) { RNImageCropView . setCropStyle ( cropStyle ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setObjectRect ( RNImageCropView RNImageCropView , ReadableMap objectRect ) { RNImageCropView . setObjectRect ( objectRect ) ; } @ Override protected void onAfterUpdateTransaction ( @ NonNull RNImageCropView RNImageCropView ) { super . onAfterUpdateTransaction ( RNImageCropView ) ; RNImageCropView . initProperties ( ) ; } @ Nullable @ Override public Map < String , Integer > getCommandsMap ( ) { return", "gt": "MapBuilder . of ( \"<STR_LIT>\" , COMMAND_CROP ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . imagecrop ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReadableArray ; import com . facebook . react . bridge . ReadableMap ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . ViewGroupManager ; import com . facebook . react . uimanager . annotations . ReactProp ; import java . util . Map ; public class RNImageCropViewManager extends ViewGroupManager < RNImageCropView > { private static final String REACT_CLASS = \"<STR_LIT>\" ; private static final int COMMAND_CROP = <NUM_LIT> ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override protected RNImageCropView createViewInstance ( @ NonNull ThemedReactContext reactContext ) { return new RNImageCropView ( reactContext ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setFileUri ( RNImageCropView RNImageCropView , String fileUri ) { RNImageCropView . setFileUri ( fileUri ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setCropStyle ( RNImageCropView RNImageCropView , String cropStyle ) { RNImageCropView . setCropStyle ( cropStyle ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setObjectRect ( RNImageCropView RNImageCropView , ReadableMap objectRect ) { RNImageCropView . setObjectRect ( objectRect ) ; } @ Override protected void onAfterUpdateTransaction ( @ NonNull RNImageCropView RNImageCropView ) { super . onAfterUpdateTransaction ( RNImageCropView ) ; RNImageCropView . initProperties ( ) ; } @ Nullable @ Override public Map < String , Integer > getCommandsMap ( ) { return MapBuilder . of ( \"<STR_LIT>\" , COMMAND_CROP ) ; } @ Override public void receiveCommand ( @ NonNull RNImageCropView root , String commandId , @ Nullable ReadableArray args ) { super", "gt": ". receiveCommand ( root , commandId , args ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ; View view = uiManagerModule . resolveView ( viewTag ) ; WritableMap map = Arguments . createMap ( ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; if ( view != null ) { EdgeInsets insets = SystemUI . getEdgeInsetsForView ( view ) ; map . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( insets . top ) ) ; map . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( insets . left ) ) ; map", "gt": ". putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( insets . right ) ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator", "gt": ". setInterpolator ( new LinearInterpolator ( ) ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ; mPaint . setStrokeWidth ( width ) ; float radius = mSize / <NUM_LIT> ; canvas . rotate ( rotateDegrees , radius , radius ) ; canvas . translate ( radius , radius ) ; for ( int i = <NUM_LIT> ; i < LINE_COUNT ; i ++ ) { canvas . rotate ( DEGREE_PER_LINE ) ; float factor = ( i + <NUM_LIT> ) / LINE_COUNT ; mPaint . setAlpha ( Math . max ( ( int ) ( <NUM_LIT> * ( factor * factor ) ) , <NUM_LIT> ) ) ; canvas . translate ( <NUM_LIT> , - radius + width * <NUM_LIT> ) ; canvas . drawLine ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , height , mPaint ) ; canvas", "gt": ". translate ( <NUM_LIT> , radius - width * <NUM_LIT> ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator", "gt": ". setRepeatCount ( ValueAnimator . INFINITE ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ; mPaint . setStrokeWidth ( width ) ; float radius = mSize / <NUM_LIT> ; canvas", "gt": ". rotate ( rotateDegrees , radius , radius ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . content . Context ; import android . view . View ; import com . facebook . react . views . view . ReactViewGroup ; public class KeyboardInsetsView extends ReactViewGroup { private String mode = \"<STR_LIT>\" ; private float extraHeight = <NUM_LIT> ; public KeyboardInsetsView ( Context context ) { super ( context ) ; } public void setMode ( String mode ) { this . mode = mode ; } public boolean isAutoMode ( ) { return", "gt": "this . mode . equals ( \"<STR_LIT>\" ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ; mPaint . setStrokeWidth ( width ) ; float radius = mSize / <NUM_LIT> ; canvas . rotate ( rotateDegrees , radius , radius ) ; canvas", "gt": ". translate ( radius , radius ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator", "gt": ". setRepeatMode ( ValueAnimator . RESTART ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ; View view = uiManagerModule . resolveView ( viewTag ) ; WritableMap map = Arguments . createMap ( ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; if ( view != null ) { EdgeInsets insets = SystemUI . getEdgeInsetsForView ( view ) ; map", "gt": ". putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( insets . top ) ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ; View", "gt": "view = uiManagerModule . resolveView ( viewTag ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int", "gt": "width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . imagecrop ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReadableArray ; import com . facebook . react . bridge . ReadableMap ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . ViewGroupManager ; import com . facebook . react . uimanager . annotations . ReactProp ; import java . util . Map ; public class RNImageCropViewManager extends ViewGroupManager < RNImageCropView > { private static final String REACT_CLASS = \"<STR_LIT>\" ; private static final int COMMAND_CROP = <NUM_LIT> ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override protected RNImageCropView createViewInstance ( @ NonNull ThemedReactContext reactContext ) { return new RNImageCropView ( reactContext ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setFileUri ( RNImageCropView RNImageCropView , String fileUri ) { RNImageCropView . setFileUri ( fileUri ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setCropStyle ( RNImageCropView RNImageCropView , String cropStyle ) { RNImageCropView . setCropStyle ( cropStyle ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setObjectRect ( RNImageCropView RNImageCropView , ReadableMap objectRect ) { RNImageCropView . setObjectRect ( objectRect ) ; } @ Override protected void onAfterUpdateTransaction ( @ NonNull RNImageCropView RNImageCropView ) { super . onAfterUpdateTransaction ( RNImageCropView ) ; RNImageCropView . initProperties ( ) ; } @ Nullable @ Override public Map < String , Integer > getCommandsMap ( ) { return MapBuilder . of ( \"<STR_LIT>\" , COMMAND_CROP ) ; } @ Override public void receiveCommand ( @ NonNull RNImageCropView root , String commandId , @ Nullable ReadableArray args ) { super . receiveCommand ( root , commandId , args ) ; int", "gt": "commandIdInt = Integer . parseInt ( commandId ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ; mPaint . setStrokeWidth ( width ) ; float radius = mSize / <NUM_LIT> ; canvas . rotate ( rotateDegrees , radius , radius ) ; canvas . translate ( radius , radius ) ; for ( int i = <NUM_LIT> ; i < LINE_COUNT ; i ++ ) { canvas . rotate ( DEGREE_PER_LINE ) ; float factor = ( i + <NUM_LIT> ) / LINE_COUNT ; mPaint . setAlpha ( Math . max ( ( int ) ( <NUM_LIT> * ( factor * factor ) ) , <NUM_LIT> ) ) ; canvas . translate ( <NUM_LIT> , - radius + width * <NUM_LIT> ) ; canvas . drawLine ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , height , mPaint ) ; canvas . translate ( <NUM_LIT> , radius - width * <NUM_LIT> ) ; } } @ Override protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { setMeasuredDimension ( mSize , mSize ) ; } @ Override protected void onDraw ( Canvas canvas ) { super . onDraw ( canvas ) ; int saveCount = canvas . saveLayer ( <NUM_LIT> , <NUM_LIT> , getWidth ( ) , getHeight ( ) , null , Canvas . ALL_SAVE_FLAG ) ; drawLoading", "gt": "( canvas , mAnimateValue * DEGREE_PER_LINE ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ; View view = uiManagerModule . resolveView ( viewTag ) ; WritableMap", "gt": "map = Arguments . createMap ( ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ; mPaint . setStrokeWidth ( width ) ; float radius = mSize / <NUM_LIT> ; canvas . rotate ( rotateDegrees , radius , radius ) ; canvas . translate ( radius , radius ) ; for ( int i = <NUM_LIT> ; i < LINE_COUNT ; i ++ ) { canvas . rotate ( DEGREE_PER_LINE ) ; float", "gt": "factor = ( i + <NUM_LIT> ) / LINE_COUNT ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ; mPaint . setStrokeWidth ( width ) ; float radius = mSize / <NUM_LIT> ; canvas . rotate ( rotateDegrees , radius , radius ) ; canvas . translate ( radius , radius ) ; for ( int i = <NUM_LIT> ; i < LINE_COUNT ; i ++ ) { canvas . rotate ( DEGREE_PER_LINE ) ; float factor = ( i + <NUM_LIT> ) / LINE_COUNT ; mPaint . setAlpha ( Math . max ( ( int ) ( <NUM_LIT> * ( factor * factor ) ) , <NUM_LIT> ) ) ; canvas . translate ( <NUM_LIT> , - radius + width * <NUM_LIT> ) ; canvas . drawLine ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , height , mPaint ) ; canvas . translate ( <NUM_LIT> , radius - width * <NUM_LIT> ) ; } } @ Override protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { setMeasuredDimension ( mSize , mSize ) ; } @ Override protected void onDraw ( Canvas canvas ) { super . onDraw ( canvas ) ; int", "gt": "saveCount = canvas . saveLayer ( <NUM_LIT> , <NUM_LIT> , getWidth ( ) , getHeight ( ) , null , Canvas . ALL_SAVE_FLAG ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . imagecrop ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReadableArray ; import com . facebook . react . bridge . ReadableMap ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . ViewGroupManager ; import com . facebook . react . uimanager . annotations . ReactProp ; import java . util . Map ; public class RNImageCropViewManager extends ViewGroupManager < RNImageCropView > { private static final String REACT_CLASS = \"<STR_LIT>\" ; private static final int COMMAND_CROP = <NUM_LIT> ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override protected RNImageCropView createViewInstance ( @ NonNull ThemedReactContext reactContext ) { return new RNImageCropView ( reactContext ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setFileUri ( RNImageCropView RNImageCropView , String fileUri ) { RNImageCropView . setFileUri ( fileUri ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setCropStyle ( RNImageCropView RNImageCropView , String cropStyle ) { RNImageCropView . setCropStyle ( cropStyle ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setObjectRect ( RNImageCropView RNImageCropView , ReadableMap objectRect ) { RNImageCropView . setObjectRect ( objectRect ) ; } @ Override protected void onAfterUpdateTransaction ( @ NonNull RNImageCropView RNImageCropView ) { super . onAfterUpdateTransaction ( RNImageCropView ) ; RNImageCropView . initProperties ( ) ; } @ Nullable @ Override public Map < String , Integer > getCommandsMap ( ) { return MapBuilder . of ( \"<STR_LIT>\" , COMMAND_CROP ) ; } @ Override public void receiveCommand ( @ NonNull RNImageCropView root , String commandId , @ Nullable ReadableArray args ) { super . receiveCommand ( root , commandId , args ) ; int commandIdInt = Integer . parseInt ( commandId ) ; switch ( commandIdInt ) { case", "gt": "COMMAND_CROP : root . crop ( ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . content . Context ; import android . view . View ; import com . facebook . react . views . view . ReactViewGroup ; public class KeyboardInsetsView extends ReactViewGroup { private String mode = \"<STR_LIT>\" ; private float extraHeight = <NUM_LIT> ; public KeyboardInsetsView ( Context context ) { super ( context ) ; } public void setMode ( String mode ) { this . mode = mode ; } public boolean isAutoMode ( ) { return this . mode . equals ( \"<STR_LIT>\" ) ; } public void setExtraHeight ( float extraHeight ) { this . extraHeight = extraHeight ; } public float getExtraHeight ( ) { return this . extraHeight ; } @ Override public void requestChildFocus ( View child , View focused ) { super", "gt": ". requestChildFocus ( child , focused ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ; mPaint . setStrokeWidth ( width ) ; float radius = mSize / <NUM_LIT> ; canvas . rotate ( rotateDegrees , radius , radius ) ; canvas . translate ( radius , radius ) ; for ( int i = <NUM_LIT> ; i < LINE_COUNT ; i ++ ) { canvas . rotate ( DEGREE_PER_LINE ) ; float factor = ( i + <NUM_LIT> ) / LINE_COUNT ; mPaint", "gt": ". setAlpha ( Math . max ( ( int ) ( <NUM_LIT> * ( factor * factor ) ) , <NUM_LIT> ) ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ; View view = uiManagerModule . resolveView ( viewTag ) ; WritableMap map = Arguments . createMap ( ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; if ( view != null ) { EdgeInsets insets = SystemUI . getEdgeInsetsForView ( view ) ; map . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( insets . top ) ) ; map", "gt": ". putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( insets . left ) ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ; mPaint . setStrokeWidth ( width ) ; float radius = mSize / <NUM_LIT> ; canvas . rotate ( rotateDegrees , radius , radius ) ; canvas . translate ( radius , radius ) ; for ( int i = <NUM_LIT> ; i < LINE_COUNT ; i ++ ) { canvas . rotate ( DEGREE_PER_LINE ) ; float factor = ( i + <NUM_LIT> ) / LINE_COUNT ; mPaint . setAlpha ( Math . max ( ( int ) ( <NUM_LIT> * ( factor * factor ) ) , <NUM_LIT> ) ) ; canvas", "gt": ". translate ( <NUM_LIT> , - radius + width * <NUM_LIT> ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ; mPaint . setStrokeWidth ( width ) ; float radius = mSize / <NUM_LIT> ; canvas . rotate ( rotateDegrees , radius , radius ) ; canvas . translate ( radius , radius ) ; for ( int i = <NUM_LIT> ; i < LINE_COUNT ; i ++ ) { canvas . rotate ( DEGREE_PER_LINE ) ; float factor = ( i + <NUM_LIT> ) / LINE_COUNT ; mPaint . setAlpha ( Math . max ( ( int ) ( <NUM_LIT> * ( factor * factor ) ) , <NUM_LIT> ) ) ; canvas . translate ( <NUM_LIT> , - radius + width * <NUM_LIT> ) ; canvas . drawLine ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , height , mPaint ) ; canvas . translate ( <NUM_LIT> , radius - width * <NUM_LIT> ) ; } } @ Override protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { setMeasuredDimension ( mSize , mSize ) ; } @ Override protected void onDraw ( Canvas canvas ) { super . onDraw ( canvas ) ; int saveCount = canvas . saveLayer ( <NUM_LIT> , <NUM_LIT> , getWidth ( ) , getHeight ( ) , null , Canvas . ALL_SAVE_FLAG ) ; drawLoading ( canvas , mAnimateValue * DEGREE_PER_LINE ) ; canvas . restoreToCount ( saveCount ) ; } @ Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; if ( mAnimating ) { start ( ) ; } } @ Override protected void onDetachedFromWindow ( ) { super . onDetachedFromWindow ( ) ; stop ( ) ; } @ Override protected void onVisibilityChanged ( @ NonNull View changedView , int visibility ) { super", "gt": ". onVisibilityChanged ( changedView , visibility ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ; View view = uiManagerModule . resolveView ( viewTag ) ; WritableMap map = Arguments . createMap ( ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map", "gt": ". putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil", "gt": ". runOnUiThread ( ( ) -> {", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ; View view = uiManagerModule . resolveView ( viewTag ) ; WritableMap map = Arguments . createMap ( ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; if ( view != null ) { EdgeInsets insets = SystemUI . getEdgeInsetsForView ( view ) ; map . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( insets . top ) ) ; map . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( insets . left ) ) ; map . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( insets . right ) ) ; map", "gt": ". putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( insets . bottom ) ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule", "gt": "uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else if ( ! mAnimator . isStarted ( ) ) { mAnimator . start ( ) ; } } public void stop ( ) { if ( mAnimator != null ) { mAnimator . removeUpdateListener ( mUpdateListener ) ; mAnimator . removeAllUpdateListeners ( ) ; mAnimator . cancel ( ) ; mAnimator = null ; } } private void drawLoading ( Canvas canvas , int rotateDegrees ) { int width = mSize / <NUM_LIT> , height = mSize / <NUM_LIT> ; mPaint . setStrokeWidth ( width ) ; float radius = mSize / <NUM_LIT> ; canvas . rotate ( rotateDegrees , radius , radius ) ; canvas . translate ( radius , radius ) ; for ( int i = <NUM_LIT> ; i < LINE_COUNT ; i ++ ) { canvas . rotate ( DEGREE_PER_LINE ) ; float factor = ( i + <NUM_LIT> ) / LINE_COUNT ; mPaint . setAlpha ( Math . max ( ( int ) ( <NUM_LIT> * ( factor * factor ) ) , <NUM_LIT> ) ) ; canvas . translate ( <NUM_LIT> , - radius + width * <NUM_LIT> ) ; canvas . drawLine ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , height , mPaint ) ; canvas . translate ( <NUM_LIT> , radius - width * <NUM_LIT> ) ; } } @ Override protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { setMeasuredDimension ( mSize , mSize ) ; } @ Override protected void onDraw ( Canvas canvas ) { super . onDraw ( canvas ) ; int saveCount = canvas . saveLayer ( <NUM_LIT> , <NUM_LIT> , getWidth ( ) , getHeight ( ) , null , Canvas . ALL_SAVE_FLAG ) ; drawLoading ( canvas , mAnimateValue * DEGREE_PER_LINE ) ; canvas . restoreToCount ( saveCount ) ; } @ Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; if ( mAnimating ) { start ( ) ; } } @ Override protected void onDetachedFromWindow ( ) { super . onDetachedFromWindow ( ) ; stop ( ) ; } @ Override protected void onVisibilityChanged ( @ NonNull View changedView , int visibility ) { super . onVisibilityChanged ( changedView , visibility ) ; if", "gt": "( visibility == VISIBLE && mAnimating ) {", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator", "gt": "= ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ;", "repo": "react-native-troika"}
{"input": "package com . reactnative . activityindicator ; import android . animation . ValueAnimator ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . util . AttributeSet ; import android . view . View ; import android . view . animation . LinearInterpolator ; import androidx . annotation . NonNull ; import com . facebook . react . uimanager . PixelUtil ; public class ActivityIndicator extends View { private int mSize ; private int mPaintColor ; private boolean mAnimating ; private int mAnimateValue = <NUM_LIT> ; private ValueAnimator mAnimator ; private Paint mPaint ; private static final int LINE_COUNT = <NUM_LIT> ; private static final int DEGREE_PER_LINE = <NUM_LIT> / LINE_COUNT ; public ActivityIndicator ( Context context ) { this ( context , null ) ; } public ActivityIndicator ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public ActivityIndicator ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initPaint ( ) ; } public ActivityIndicator ( Context context , int size , int color ) { super ( context ) ; mSize = size ; mPaintColor = color ; initPaint ( ) ; } private void initPaint ( ) { mSize = ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ; mPaintColor = Color . parseColor ( \"<STR_LIT>\" ) ; mAnimating = true ; mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; } public void setColor ( int color ) { mPaintColor = color ; mPaint . setColor ( color ) ; invalidate ( ) ; } public void setSize ( int size ) { mSize = size ; requestLayout ( ) ; } public void setAnimating ( boolean animating ) { mAnimating = animating ; if ( mAnimating ) { start ( ) ; } else { stop ( ) ; } } private ValueAnimator . AnimatorUpdateListener mUpdateListener = animation -> { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; } ; public void start ( ) { if ( mAnimator == null ) { mAnimator = ValueAnimator . ofInt ( <NUM_LIT> , LINE_COUNT - <NUM_LIT> ) ; mAnimator . addUpdateListener ( mUpdateListener ) ; mAnimator . setDuration ( <NUM_LIT> ) ; mAnimator . setRepeatMode ( ValueAnimator . RESTART ) ; mAnimator . setRepeatCount ( ValueAnimator . INFINITE ) ; mAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mAnimator . start ( ) ; } else", "gt": "if ( ! mAnimator . isStarted ( ) ) {", "repo": "react-native-troika"}
{"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . Callback ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . UIManagerModule ; public class KeyboardInsetsModule extends ReactContextBaseJavaModule { public KeyboardInsetsModule ( ReactApplicationContext reactContext ) { super ( reactContext ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void getEdgeInsetsForView ( int viewTag , Callback callback ) { UiThreadUtil . runOnUiThread ( ( ) -> { UIManagerModule uiManagerModule = getReactApplicationContext ( ) . getNativeModule ( UIManagerModule . class ) ; View view = uiManagerModule . resolveView ( viewTag ) ; WritableMap map = Arguments . createMap ( ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; map", "gt": ". putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ;", "repo": "react-native-troika"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( this . accept ( field ) ) { try { Object fieldValue = this . getValue ( field ) ; this . append ( fieldName , fieldValue ) ; } catch ( IllegalAccessException ex ) { throw new InternalError ( \"<STR_LIT>\" + ex . getMessage ( ) ) ; } } } } public String [ ] getExcludeFieldNames ( ) { return this . excludeFieldNames . clone ( ) ; } public Class < ? > getUpToClass ( ) { return this . upToClass ; } protected Object getValue ( Field field ) throws IllegalArgumentException , IllegalAccessException { return field . get ( this . getObject ( ) ) ; } public boolean isAppendStatics ( ) { return this . appendStatics ; } public boolean isAppendTransients ( ) { return this . appendTransients ; } public ReflectionToStringBuilder reflectionAppendArray ( Object array ) { this", "gt": ". getStyle ( ) . reflectionAppendArrayDetail ( this . getStringBuffer ( ) , null , array ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this", "gt": ". reflectionAppendArray ( this . getObject ( ) ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( this . accept ( field ) ) { try { Object fieldValue = this . getValue ( field ) ; this . append ( fieldName , fieldValue ) ; } catch ( IllegalAccessException ex ) { throw new InternalError ( \"<STR_LIT>\" + ex . getMessage ( ) ) ; } } } } public String [ ] getExcludeFieldNames ( ) { return this . excludeFieldNames . clone ( ) ; } public Class < ? > getUpToClass ( ) { return this . upToClass ; } protected Object getValue ( Field field ) throws IllegalArgumentException , IllegalAccessException { return field . get ( this . getObject ( ) ) ; } public boolean isAppendStatics ( ) { return this . appendStatics ; } public boolean isAppendTransients ( ) { return this . appendTransients ; } public ReflectionToStringBuilder reflectionAppendArray ( Object array ) { this . getStyle ( ) . reflectionAppendArrayDetail ( this . getStringBuffer ( ) , null , array ) ; return this ; } public void setAppendStatics ( boolean appendStatics ) { this . appendStatics = appendStatics ; } public void setAppendTransients ( boolean appendTransients ) { this . appendTransients = appendTransients ; } public ReflectionToStringBuilder setExcludeFieldNames ( String ... excludeFieldNamesParam ) { if ( excludeFieldNamesParam == null ) { this . excludeFieldNames = null ; } else { this . excludeFieldNames = toNoNullStringArray ( excludeFieldNamesParam ) ; Arrays . sort ( this . excludeFieldNames ) ; } return this ; } public void setUpToClass ( Class < ? > clazz ) { if ( clazz != null ) { Object object = getObject ( ) ; if ( object != null && clazz . isInstance ( object ) == false ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } this . upToClass = clazz ; } @ Override public String toString ( ) { if ( this . getObject ( ) == null ) { return this . getStyle ( ) . getNullText ( ) ; } Class < ? > clazz = this . getObject ( ) . getClass ( ) ; this . appendFieldsIn ( clazz ) ; while ( clazz . getSuperclass ( ) != null && clazz != this . getUpToClass ( ) ) { clazz", "gt": "= clazz . getSuperclass ( ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Set < String > getStringSet ( String key , Set < String > defValues ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Set < String > v = ( Set < String > ) mMap . get ( key ) ; return v != null ? v : defValues ; } } @ Override public int getInt ( String key , int defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Integer v = ( Integer ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public long getLong ( String key , long defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Long v = ( Long ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public float getFloat ( String key , float defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Float v = ( Float ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public boolean getBoolean ( String key , boolean defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Boolean v = ( Boolean ) mMap . get ( key ) ; return", "gt": "v != null ? v : defValue ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( this . accept ( field ) ) { try { Object fieldValue = this . getValue ( field ) ; this . append ( fieldName , fieldValue ) ; } catch ( IllegalAccessException ex ) { throw", "gt": "new InternalError ( \"<STR_LIT>\" + ex . getMessage ( ) ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return", "gt": "new HashMap < > ( mMap ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return", "gt": "v != null ? v : defValue ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . mutable ; public class MutableInt extends Number implements Comparable < MutableInt > , Mutable < Number > { private static final long serialVersionUID = <NUM_LIT> ; private int value ; public MutableInt ( ) { super ( ) ; } public MutableInt ( int value ) { super ( ) ; this . value = value ; } public MutableInt ( Number value ) { super ( ) ; this . value = value . intValue ( ) ; } public MutableInt ( String value ) throws NumberFormatException { super ( ) ; this . value = Integer . parseInt ( value ) ; } public Integer getValue ( ) { return Integer . valueOf ( this . value ) ; } public void setValue ( int value ) { this . value = value ; } public void setValue ( Number value ) { this . value = value . intValue ( ) ; } public void increment ( ) { value ++ ; } public void decrement ( ) { value -- ; } public void add ( int operand ) { this . value += operand ; } public void add ( Number operand ) { this . value += operand . intValue ( ) ; } public void subtract ( int operand ) { this . value -= operand ; } public void subtract ( Number operand ) { this . value -= operand . intValue ( ) ; } @ Override public int intValue ( ) { return value ; } @ Override public long longValue ( ) { return value ; } @ Override public float floatValue ( ) { return value ; } @ Override public double doubleValue ( ) { return value ; } public Integer toInteger ( ) { return", "gt": "Integer . valueOf ( intValue ( ) ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Set < String > getStringSet ( String key , Set < String > defValues ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Set < String > v = ( Set < String > ) mMap . get ( key ) ; return v != null ? v : defValues ; } } @ Override public int getInt ( String key , int defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Integer v = ( Integer ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public long getLong ( String key , long defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Long v = ( Long ) mMap . get ( key ) ; return", "gt": "v != null ? v : defValue ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult", "gt": "result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Set < String > getStringSet ( String key , Set < String > defValues ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Set < String > v = ( Set < String > ) mMap . get ( key ) ; return v != null ? v : defValues ; } } @ Override public int getInt ( String key , int defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Integer v = ( Integer ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public long getLong ( String key , long defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Long v = ( Long ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public float getFloat ( String key , float defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Float v = ( Float ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public boolean getBoolean ( String key , boolean defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Boolean v = ( Boolean ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public boolean contains ( String key ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return", "gt": "mMap . containsKey ( key ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( this . accept ( field ) ) { try { Object fieldValue = this . getValue ( field ) ; this . append ( fieldName , fieldValue ) ; } catch ( IllegalAccessException ex ) { throw new InternalError ( \"<STR_LIT>\" + ex . getMessage ( ) ) ; } } } } public String [ ] getExcludeFieldNames ( ) { return this . excludeFieldNames . clone ( ) ; } public Class < ? > getUpToClass ( ) { return this . upToClass ; } protected Object getValue ( Field field ) throws IllegalArgumentException , IllegalAccessException { return field . get ( this . getObject ( ) ) ; } public boolean isAppendStatics ( ) { return this . appendStatics ; } public boolean isAppendTransients ( ) { return this . appendTransients ; } public ReflectionToStringBuilder reflectionAppendArray ( Object array ) { this . getStyle ( ) . reflectionAppendArrayDetail ( this . getStringBuffer ( ) , null , array ) ; return this ; } public void setAppendStatics ( boolean appendStatics ) { this . appendStatics = appendStatics ; } public void setAppendTransients ( boolean appendTransients ) { this . appendTransients = appendTransients ; } public ReflectionToStringBuilder setExcludeFieldNames ( String ... excludeFieldNamesParam ) { if ( excludeFieldNamesParam == null ) { this . excludeFieldNames = null ; } else { this . excludeFieldNames = toNoNullStringArray ( excludeFieldNamesParam ) ; Arrays", "gt": ". sort ( this . excludeFieldNames ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for", "gt": "( Field field : fields ) {", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject", "gt": ". setAccessible ( fields , true ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . mutable ; public class MutableInt extends Number implements Comparable < MutableInt > , Mutable < Number > { private static final long serialVersionUID = <NUM_LIT> ; private int value ; public MutableInt ( ) { super ( ) ; } public MutableInt ( int value ) { super ( ) ; this . value = value ; } public MutableInt ( Number value ) { super ( ) ; this . value = value . intValue ( ) ; } public MutableInt ( String value ) throws NumberFormatException { super ( ) ; this . value = Integer . parseInt ( value ) ; } public Integer getValue ( ) { return Integer . valueOf ( this . value ) ; } public void setValue ( int value ) { this . value = value ; } public void setValue ( Number value ) { this . value = value . intValue ( ) ; } public void increment ( ) { value ++ ; } public void decrement ( ) { value -- ; } public void add ( int operand ) { this . value += operand ; } public void add ( Number operand ) { this . value += operand . intValue ( ) ; } public void subtract ( int operand ) { this . value -= operand ; } public void subtract ( Number operand ) { this . value -= operand . intValue ( ) ; } @ Override public int intValue ( ) { return value ; } @ Override public long longValue ( ) { return value ; } @ Override public float floatValue ( ) { return value ; } @ Override public double doubleValue ( ) { return value ; } public Integer toInteger ( ) { return Integer . valueOf ( intValue ( ) ) ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof MutableInt ) { return", "gt": "value == ( ( MutableInt ) obj ) . intValue ( ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Set < String > getStringSet ( String key , Set < String > defValues ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Set < String > v = ( Set < String > ) mMap . get ( key ) ; return v != null ? v : defValues ; } } @ Override public int getInt ( String key , int defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Integer v = ( Integer ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public long getLong ( String key , long defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Long v = ( Long ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public float getFloat ( String key , float defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Float", "gt": "v = ( Float ) mMap . get ( key ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . mutable ; public class MutableInt extends Number implements Comparable < MutableInt > , Mutable < Number > { private static final long serialVersionUID = <NUM_LIT> ; private int value ; public MutableInt ( ) { super ( ) ; } public MutableInt ( int value ) { super ( ) ; this . value = value ; } public MutableInt ( Number value ) { super ( ) ; this . value = value . intValue ( ) ; } public MutableInt ( String value ) throws NumberFormatException { super ( ) ; this . value = Integer . parseInt ( value ) ; } public Integer getValue ( ) { return Integer . valueOf ( this . value ) ; } public void setValue ( int value ) { this . value = value ; } public void setValue ( Number value ) { this . value = value . intValue ( ) ; } public void increment ( ) { value ++ ; } public void decrement ( ) { value -- ; } public void add ( int operand ) { this . value += operand ; } public void add ( Number operand ) { this . value += operand . intValue ( ) ; } public void subtract ( int operand ) { this . value -= operand ; } public void subtract ( Number operand ) { this . value -= operand . intValue ( ) ; } @ Override public int intValue ( ) { return value ; } @ Override public long longValue ( ) { return value ; } @ Override public float floatValue ( ) { return value ; } @ Override public double doubleValue ( ) { return value ; } public Integer toInteger ( ) { return Integer . valueOf ( intValue ( ) ) ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof MutableInt ) { return value == ( ( MutableInt ) obj ) . intValue ( ) ; } return false ; } @ Override public int hashCode ( ) { return value ; } public int compareTo ( MutableInt other ) { int anotherVal = other . value ; return value < anotherVal ? - <NUM_LIT> : ( value == anotherVal ? <NUM_LIT> : <NUM_LIT> ) ; } @ Override public String toString ( ) { return", "gt": "String . valueOf ( value ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Set < String > getStringSet ( String key , Set < String > defValues ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Set < String > v = ( Set < String > ) mMap . get ( key ) ; return v != null ? v : defValues ; } } @ Override public int getInt ( String key , int defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Integer v = ( Integer ) mMap . get ( key ) ; return", "gt": "v != null ? v : defValue ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Set < String > getStringSet ( String key , Set < String > defValues ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Set < String > v = ( Set < String > ) mMap . get ( key ) ; return v != null ? v : defValues ; } } @ Override public int getInt ( String key , int defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Integer v = ( Integer ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public long getLong ( String key , long defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Long v = ( Long ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public float getFloat ( String key , float defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Float v = ( Float ) mMap . get ( key ) ; return", "gt": "v != null ? v : defValue ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . mutable ; public class MutableInt extends Number implements Comparable < MutableInt > , Mutable < Number > { private static final long serialVersionUID = <NUM_LIT> ; private int value ; public MutableInt ( ) { super ( ) ; } public MutableInt ( int value ) { super ( ) ; this . value = value ; } public MutableInt ( Number value ) { super ( ) ; this . value = value . intValue ( ) ; } public MutableInt ( String value ) throws NumberFormatException { super ( ) ; this . value = Integer . parseInt ( value ) ; } public Integer getValue ( ) { return Integer . valueOf ( this . value ) ; } public void setValue ( int value ) { this . value = value ; } public void setValue ( Number value ) { this . value = value . intValue ( ) ; } public void increment ( ) { value ++ ; } public void decrement ( ) { value -- ; } public void add ( int operand ) { this . value += operand ; } public void add ( Number operand ) { this . value += operand . intValue ( ) ; } public void subtract ( int operand ) { this . value -= operand ; } public void subtract ( Number operand ) { this", "gt": ". value -= operand . intValue ( ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Set < String > getStringSet ( String key , Set < String > defValues ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Set < String > v = ( Set < String > ) mMap . get ( key ) ; return v != null ? v : defValues ; } } @ Override public int getInt ( String key , int defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Integer", "gt": "v = ( Integer ) mMap . get ( key ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String", "gt": "fieldName = field . getName ( ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( this . accept ( field ) ) { try { Object fieldValue = this . getValue ( field ) ; this . append ( fieldName , fieldValue ) ; } catch ( IllegalAccessException ex ) { throw new InternalError ( \"<STR_LIT>\" + ex . getMessage ( ) ) ; } } } } public String [ ] getExcludeFieldNames ( ) { return this . excludeFieldNames . clone ( ) ; } public Class < ? > getUpToClass ( ) { return this . upToClass ; } protected Object getValue ( Field field ) throws IllegalArgumentException , IllegalAccessException { return field . get ( this . getObject ( ) ) ; } public boolean isAppendStatics ( ) { return this . appendStatics ; } public boolean isAppendTransients ( ) { return this . appendTransients ; } public ReflectionToStringBuilder reflectionAppendArray ( Object array ) { this . getStyle ( ) . reflectionAppendArrayDetail ( this . getStringBuffer ( ) , null , array ) ; return this ; } public void setAppendStatics ( boolean appendStatics ) { this . appendStatics = appendStatics ; } public void setAppendTransients ( boolean appendTransients ) { this . appendTransients = appendTransients ; } public ReflectionToStringBuilder setExcludeFieldNames ( String ... excludeFieldNamesParam ) { if ( excludeFieldNamesParam == null ) { this . excludeFieldNames = null ; } else { this . excludeFieldNames = toNoNullStringArray ( excludeFieldNamesParam ) ; Arrays . sort ( this . excludeFieldNames ) ; } return this ; } public void setUpToClass ( Class < ? > clazz ) { if ( clazz != null ) { Object object = getObject ( ) ; if ( object != null && clazz . isInstance ( object ) == false ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } this . upToClass = clazz ; } @ Override public String toString ( ) { if ( this . getObject ( ) == null ) { return", "gt": "this . getStyle ( ) . getNullText ( ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String", "gt": "v = ( String ) mMap . get ( key ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if", "gt": "( clazz . isArray ( ) ) {", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( this . accept ( field ) ) { try { Object fieldValue = this . getValue ( field ) ; this", "gt": ". append ( fieldName , fieldValue ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( this . accept ( field ) ) { try { Object", "gt": "fieldValue = this . getValue ( field ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field", "gt": "[ ] fields = clazz . getDeclaredFields ( ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Set < String > getStringSet ( String key , Set < String > defValues ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Set", "gt": "< String > v = ( Set < String > ) mMap . get ( key ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( this . accept ( field ) ) { try { Object fieldValue = this . getValue ( field ) ; this . append ( fieldName , fieldValue ) ; } catch ( IllegalAccessException ex ) { throw new InternalError ( \"<STR_LIT>\" + ex . getMessage ( ) ) ; } } } } public String [ ] getExcludeFieldNames ( ) { return this . excludeFieldNames . clone ( ) ; } public Class < ? > getUpToClass ( ) { return this . upToClass ; } protected Object getValue ( Field field ) throws IllegalArgumentException , IllegalAccessException { return field . get ( this . getObject ( ) ) ; } public boolean isAppendStatics ( ) { return this . appendStatics ; } public boolean isAppendTransients ( ) { return this . appendTransients ; } public ReflectionToStringBuilder reflectionAppendArray ( Object array ) { this . getStyle ( ) . reflectionAppendArrayDetail ( this . getStringBuffer ( ) , null , array ) ; return this ; } public void setAppendStatics ( boolean appendStatics ) { this . appendStatics = appendStatics ; } public void setAppendTransients ( boolean appendTransients ) { this . appendTransients = appendTransients ; } public ReflectionToStringBuilder setExcludeFieldNames ( String ... excludeFieldNamesParam ) { if ( excludeFieldNamesParam == null ) { this . excludeFieldNames = null ; } else { this . excludeFieldNames = toNoNullStringArray ( excludeFieldNamesParam ) ; Arrays . sort ( this . excludeFieldNames ) ; } return this ; } public void setUpToClass ( Class < ? > clazz ) { if ( clazz != null ) { Object object = getObject ( ) ; if ( object != null && clazz . isInstance ( object ) == false ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } this . upToClass = clazz ; } @ Override public String toString ( ) { if ( this . getObject ( ) == null ) { return this . getStyle ( ) . getNullText ( ) ; } Class < ? > clazz = this . getObject ( ) . getClass ( ) ; this . appendFieldsIn ( clazz ) ; while", "gt": "( clazz . getSuperclass ( ) != null && clazz != this . getUpToClass ( ) ) {", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( this . accept ( field ) ) { try { Object fieldValue = this . getValue ( field ) ; this . append ( fieldName , fieldValue ) ; } catch ( IllegalAccessException ex ) { throw new InternalError ( \"<STR_LIT>\" + ex . getMessage ( ) ) ; } } } } public String [ ] getExcludeFieldNames ( ) { return this . excludeFieldNames . clone ( ) ; } public Class < ? > getUpToClass ( ) { return this . upToClass ; } protected Object getValue ( Field field ) throws IllegalArgumentException , IllegalAccessException { return", "gt": "field . get ( this . getObject ( ) ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( this . accept ( field ) ) { try { Object fieldValue = this . getValue ( field ) ; this . append ( fieldName , fieldValue ) ; } catch ( IllegalAccessException ex ) { throw new InternalError ( \"<STR_LIT>\" + ex . getMessage ( ) ) ; } } } } public String [ ] getExcludeFieldNames ( ) { return this . excludeFieldNames . clone ( ) ; } public Class < ? > getUpToClass ( ) { return this . upToClass ; } protected Object getValue ( Field field ) throws IllegalArgumentException , IllegalAccessException { return field . get ( this . getObject ( ) ) ; } public boolean isAppendStatics ( ) { return this . appendStatics ; } public boolean isAppendTransients ( ) { return this . appendTransients ; } public ReflectionToStringBuilder reflectionAppendArray ( Object array ) { this . getStyle ( ) . reflectionAppendArrayDetail ( this . getStringBuffer ( ) , null , array ) ; return this ; } public void setAppendStatics ( boolean appendStatics ) { this . appendStatics = appendStatics ; } public void setAppendTransients ( boolean appendTransients ) { this . appendTransients = appendTransients ; } public ReflectionToStringBuilder setExcludeFieldNames ( String ... excludeFieldNamesParam ) { if ( excludeFieldNamesParam == null ) { this . excludeFieldNames = null ; } else { this . excludeFieldNames = toNoNullStringArray ( excludeFieldNamesParam ) ; Arrays . sort ( this . excludeFieldNames ) ; } return this ; } public void setUpToClass ( Class < ? > clazz ) { if ( clazz != null ) { Object object = getObject ( ) ; if", "gt": "( object != null && clazz . isInstance ( object ) == false ) {", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if", "gt": "( this . accept ( field ) ) {", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . mutable ; public class MutableInt extends Number implements Comparable < MutableInt > , Mutable < Number > { private static final long serialVersionUID = <NUM_LIT> ; private int value ; public MutableInt ( ) { super ( ) ; } public MutableInt ( int value ) { super ( ) ; this . value = value ; } public MutableInt ( Number value ) { super ( ) ; this . value = value . intValue ( ) ; } public MutableInt ( String value ) throws NumberFormatException { super ( ) ; this . value = Integer . parseInt ( value ) ; } public Integer getValue ( ) { return Integer . valueOf ( this . value ) ; } public void setValue ( int value ) { this . value = value ; } public void setValue ( Number value ) { this . value = value . intValue ( ) ; } public void increment ( ) { value ++ ; } public void decrement ( ) { value -- ; } public void add ( int operand ) { this . value += operand ; } public void add ( Number operand ) { this", "gt": ". value += operand . intValue ( ) ;", "repo": "XYNXposed"}
{"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class ReflectionToStringBuilder extends ToStringBuilder { public static String toString ( Object object ) { return toString ( object , null , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style ) { return toString ( object , style , false , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients ) { return toString ( object , style , outputTransients , false , null ) ; } public static String toString ( Object object , ToStringStyle style , boolean outputTransients , boolean outputStatics ) { return toString ( object , style , outputTransients , outputStatics , null ) ; } public static < T > String toString ( T object , ToStringStyle style , boolean outputTransients , boolean outputStatics , Class < ? super T > reflectUpToClass ) { return new ReflectionToStringBuilder ( object , style , null , reflectUpToClass , outputTransients , outputStatics ) . toString ( ) ; } public static String toStringExclude ( Object object , Collection < String > excludeFieldNames ) { return toStringExclude ( object , toNoNullStringArray ( excludeFieldNames ) ) ; } static String [ ] toNoNullStringArray ( Collection < String > collection ) { if ( collection == null ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } return toNoNullStringArray ( collection . toArray ( ) ) ; } static String [ ] toNoNullStringArray ( Object [ ] array ) { List < String > list = new ArrayList < String > ( array . length ) ; for ( Object e : array ) { if ( e != null ) { list . add ( e . toString ( ) ) ; } } return list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } public static String toStringExclude ( Object object , String ... excludeFieldNames ) { return new ReflectionToStringBuilder ( object ) . setExcludeFieldNames ( excludeFieldNames ) . toString ( ) ; } private boolean appendStatics = false ; private boolean appendTransients = false ; protected String [ ] excludeFieldNames ; private Class < ? > upToClass = null ; public ReflectionToStringBuilder ( Object object ) { super ( object ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style ) { super ( object , style ) ; } public ReflectionToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { super ( object , style , buffer ) ; } public < T > ReflectionToStringBuilder ( T object , ToStringStyle style , StringBuffer buffer , Class < ? super T > reflectUpToClass , boolean outputTransients , boolean outputStatics ) { super ( object , style , buffer ) ; this . setUpToClass ( reflectUpToClass ) ; this . setAppendTransients ( outputTransients ) ; this . setAppendStatics ( outputStatics ) ; } protected boolean accept ( Field field ) { if ( field . getName ( ) . indexOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return false ; } if ( Modifier . isTransient ( field . getModifiers ( ) ) && ! this . isAppendTransients ( ) ) { return false ; } if ( Modifier . isStatic ( field . getModifiers ( ) ) && ! this . isAppendStatics ( ) ) { return false ; } if ( this . excludeFieldNames != null && Arrays . binarySearch ( this . excludeFieldNames , field . getName ( ) ) >= <NUM_LIT> ) { return false ; } return true ; } protected void appendFieldsIn ( Class < ? > clazz ) { if ( clazz . isArray ( ) ) { this . reflectionAppendArray ( this . getObject ( ) ) ; return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( this . accept ( field ) ) { try { Object fieldValue = this . getValue ( field ) ; this . append ( fieldName , fieldValue ) ; } catch ( IllegalAccessException ex ) { throw new InternalError ( \"<STR_LIT>\" + ex . getMessage ( ) ) ; } } } } public String [ ] getExcludeFieldNames ( ) { return this . excludeFieldNames . clone ( ) ; } public Class < ? > getUpToClass ( ) { return this . upToClass ; } protected Object getValue ( Field field ) throws IllegalArgumentException , IllegalAccessException { return field . get ( this . getObject ( ) ) ; } public boolean isAppendStatics ( ) { return this . appendStatics ; } public boolean isAppendTransients ( ) { return this . appendTransients ; } public ReflectionToStringBuilder reflectionAppendArray ( Object array ) { this . getStyle ( ) . reflectionAppendArrayDetail ( this . getStringBuffer ( ) , null , array ) ; return this ; } public void setAppendStatics ( boolean appendStatics ) { this . appendStatics = appendStatics ; } public void setAppendTransients ( boolean appendTransients ) { this . appendTransients = appendTransients ; } public ReflectionToStringBuilder setExcludeFieldNames ( String ... excludeFieldNamesParam ) { if ( excludeFieldNamesParam == null ) { this . excludeFieldNames = null ; } else { this . excludeFieldNames = toNoNullStringArray ( excludeFieldNamesParam ) ; Arrays . sort ( this . excludeFieldNames ) ; } return this ; } public void setUpToClass ( Class < ? > clazz ) { if ( clazz != null ) { Object object = getObject ( ) ; if ( object != null && clazz . isInstance ( object ) == false ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } this . upToClass = clazz ; } @ Override public String toString ( ) { if ( this . getObject ( ) == null ) { return this . getStyle ( ) . getNullText ( ) ; } Class", "gt": "< ? > clazz = this . getObject ( ) . getClass ( ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if", "gt": "( hasFileChanged ( ) ) startLoadFromDisk ( ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Set < String > getStringSet ( String key , Set < String > defValues ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Set < String > v = ( Set < String > ) mMap . get ( key ) ; return", "gt": "v != null ? v : defValues ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Set < String > getStringSet ( String key , Set < String > defValues ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Set < String > v = ( Set < String > ) mMap . get ( key ) ; return v != null ? v : defValues ; } } @ Override public int getInt ( String key , int defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Integer v = ( Integer ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public long getLong ( String key , long defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Long", "gt": "v = ( Long ) mMap . get ( key ) ;", "repo": "XYNXposed"}
{"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . util . Log ; import com . android . internal . util . XmlUtils ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . services . FileResult ; public final class XSharedPreferences implements SharedPreferences { private static final String TAG = \"<STR_LIT>\" ; private final File mFile ; private final String mFilename ; private Map < String , Object > mMap ; private boolean mLoaded = false ; private long mLastModified ; private long mFileSize ; public XSharedPreferences ( File prefFile ) { mFile = prefFile ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } public XSharedPreferences ( String packageName ) { this ( packageName , packageName + \"<STR_LIT>\" ) ; } public XSharedPreferences ( String packageName , String prefFileName ) { mFile = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + prefFileName + \"<STR_LIT>\" ) ; mFilename = mFile . getAbsolutePath ( ) ; startLoadFromDisk ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean makeWorldReadable ( ) { if ( ! SELinuxHelper . getAppDataFileService ( ) . hasDirectFileAccess ( ) ) return false ; if ( ! mFile . exists ( ) ) return false ; return mFile . setReadable ( true , false ) ; } public File getFile ( ) { return mFile ; } private void startLoadFromDisk ( ) { synchronized ( this ) { mLoaded = false ; } new Thread ( \"<STR_LIT>\" ) { @ Override public void run ( ) { synchronized ( XSharedPreferences . this ) { loadFromDiskLocked ( ) ; } } } . start ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private void loadFromDiskLocked ( ) { if ( mLoaded ) { return ; } Map map = null ; FileResult result = null ; try { result = SELinuxHelper . getAppDataFileService ( ) . getFileInputStream ( mFilename , mFileSize , mLastModified ) ; if ( result . stream != null ) { map = XmlUtils . readMapXml ( result . stream ) ; result . stream . close ( ) ; } else { map = mMap ; } } catch ( XmlPullParserException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } catch ( FileNotFoundException ignored ) { } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; } finally { if ( result != null && result . stream != null ) { try { result . stream . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } mLoaded = true ; if ( map != null ) { mMap = map ; mLastModified = result . mtime ; mFileSize = result . size ; } else { mMap = new HashMap < > ( ) ; } notifyAll ( ) ; } public synchronized void reload ( ) { if ( hasFileChanged ( ) ) startLoadFromDisk ( ) ; } public synchronized boolean hasFileChanged ( ) { try { FileResult result = SELinuxHelper . getAppDataFileService ( ) . statFile ( mFilename ) ; return mLastModified != result . mtime || mFileSize != result . size ; } catch ( FileNotFoundException ignored ) { return true ; } catch ( IOException e ) { Log . w ( TAG , \"<STR_LIT>\" , e ) ; return true ; } } private void awaitLoadedLocked ( ) { while ( ! mLoaded ) { try { wait ( ) ; } catch ( InterruptedException unused ) { } } } @ Override public Map < String , ? > getAll ( ) { synchronized ( this ) { awaitLoadedLocked ( ) ; return new HashMap < > ( mMap ) ; } } @ Override public String getString ( String key , String defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; String v = ( String ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Set < String > getStringSet ( String key , Set < String > defValues ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Set < String > v = ( Set < String > ) mMap . get ( key ) ; return v != null ? v : defValues ; } } @ Override public int getInt ( String key , int defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Integer v = ( Integer ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public long getLong ( String key , long defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Long v = ( Long ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public float getFloat ( String key , float defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Float v = ( Float ) mMap . get ( key ) ; return v != null ? v : defValue ; } } @ Override public boolean getBoolean ( String key , boolean defValue ) { synchronized ( this ) { awaitLoadedLocked ( ) ; Boolean", "gt": "v = ( Boolean ) mMap . get ( key ) ;", "repo": "XYNXposed"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo", "gt": "( me . getX ( ) ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ; if ( Math . abs ( mHorizontalThumbCenterX - x ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mHorizontalDragX , x , scrollbarRange , mRecyclerView . computeHorizontalScrollRange ( ) , mRecyclerView . computeHorizontalScrollOffset ( ) , mRecyclerViewWidth ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( scrollingBy , <NUM_LIT> ) ; } mHorizontalDragX = x ; } private int scrollTo ( float oldDragPos , float newDragPos , int [ ] scrollbarRange , int scrollRange , int scrollOffset , int viewLength ) { int scrollbarLength = scrollbarRange [ <NUM_LIT> ] - scrollbarRange [ <NUM_LIT> ] ; if ( scrollbarLength == <NUM_LIT> ) { return <NUM_LIT> ; } float percentage = ( ( newDragPos - oldDragPos ) / ( float ) scrollbarLength ) ; int totalPossibleOffset = scrollRange - viewLength ; int scrollingBy = ( int ) ( percentage * totalPossibleOffset ) ; int absoluteOffset = scrollOffset + scrollingBy ; if ( absoluteOffset < totalPossibleOffset && absoluteOffset >= <NUM_LIT> ) { return scrollingBy ; } else { return <NUM_LIT> ; } } @ VisibleForTesting boolean isPointInsideVerticalThumb ( float x , float y ) { return ( isLayoutRTL ( ) ? x <= mVerticalThumbWidth : x >= mRecyclerViewWidth - mVerticalThumbWidth ) && y >= mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> && y <= mVerticalThumbCenterY + mVerticalThumbHeight / <NUM_LIT> ; } @ VisibleForTesting boolean isPointInsideHorizontalThumb ( float x , float y ) { return ( y >= mRecyclerViewHeight - mHorizontalThumbHeight ) && x >= mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> && x <= mHorizontalThumbCenterX + mHorizontalThumbWidth / <NUM_LIT> ; } @ VisibleForTesting Drawable getHorizontalTrackDrawable ( ) { return mHorizontalTrackDrawable ; } @ VisibleForTesting Drawable getHorizontalThumbDrawable ( ) { return mHorizontalThumbDrawable ; } @ VisibleForTesting Drawable getVerticalTrackDrawable ( ) { return mVerticalTrackDrawable ; } @ VisibleForTesting Drawable getVerticalThumbDrawable ( ) { return mVerticalThumbDrawable ; } private int [ ] getVerticalRange ( ) { mVerticalRange [ <NUM_LIT> ] = mMargin ; mVerticalRange [ <NUM_LIT> ] = mRecyclerViewHeight - mMargin ; return mVerticalRange ; } private int [ ] getHorizontalRange ( ) { mHorizontalRange [ <NUM_LIT> ] = mMargin ; mHorizontalRange [ <NUM_LIT> ] = mRecyclerViewWidth - mMargin ; return mHorizontalRange ; } private class AnimatorListener extends AnimatorListenerAdapter { private boolean mCanceled = false ; AnimatorListener ( ) { } @ Override public void onAnimationEnd ( Animator animation ) { if ( mCanceled ) { mCanceled = false ; return ; } if", "gt": "( ( float ) mShowHideAnimator . getAnimatedValue ( ) == <NUM_LIT> ) {", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return super . dispatchPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate", "gt": ". onPopulateAccessibilityEvent ( host , event ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return super . dispatchPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onPopulateAccessibilityEvent ( host , event ) ; } else { super", "gt": ". onPopulateAccessibilityEvent ( host , event ) ;", "repo": "Accord"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . appcompat . graphics . drawable . DrawableWrapperCompat ; import androidx . core . graphics . drawable . DrawableCompat ; @ SuppressLint ( \"<STR_LIT>\" ) class AutoMirrorDrawable extends DrawableWrapperCompat { public AutoMirrorDrawable ( @ NonNull Drawable drawable ) { super ( drawable ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { if ( needMirroring ( ) ) { float centerX = getBounds ( ) . exactCenterX ( ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> , centerX , <NUM_LIT> ) ; super . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> , centerX , <NUM_LIT> ) ; } else { super . draw ( canvas ) ; } } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { super . onLayoutDirectionChanged ( layoutDirection ) ; return true ; } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return", "gt": "DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return super . dispatchPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onPopulateAccessibilityEvent ( host , event ) ; } else { super . onPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat", "gt": "originalDelegate = mOriginalItemDelegates . get ( host ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ; if ( Math . abs ( mHorizontalThumbCenterX - x ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mHorizontalDragX , x , scrollbarRange , mRecyclerView . computeHorizontalScrollRange ( ) , mRecyclerView . computeHorizontalScrollOffset ( ) , mRecyclerViewWidth ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( scrollingBy , <NUM_LIT> ) ; } mHorizontalDragX = x ; } private int scrollTo ( float oldDragPos , float newDragPos , int [ ] scrollbarRange , int scrollRange , int scrollOffset , int viewLength ) { int scrollbarLength = scrollbarRange [ <NUM_LIT> ] - scrollbarRange [ <NUM_LIT> ] ; if ( scrollbarLength == <NUM_LIT> ) { return <NUM_LIT> ; } float percentage = ( ( newDragPos - oldDragPos ) / ( float ) scrollbarLength ) ; int totalPossibleOffset = scrollRange - viewLength ; int", "gt": "scrollingBy = ( int ) ( percentage * totalPossibleOffset ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final int end = mCallback . getParentEnd ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ; View acceptableMatch = null ; for ( int i = fromIndex ; i != toIndex ; i += next ) { final View child = mCallback . getChildAt ( i ) ; final", "gt": "int childStart = mCallback . getChildStart ( child ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate", "gt": ". sendAccessibilityEventUnchecked ( host , event ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final int end = mCallback . getParentEnd ( ) ; final", "gt": "int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final", "gt": "int [ ] scrollbarRange = getVerticalRange ( ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ; if ( Math . abs ( mHorizontalThumbCenterX - x ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mHorizontalDragX , x , scrollbarRange , mRecyclerView . computeHorizontalScrollRange ( ) , mRecyclerView . computeHorizontalScrollOffset ( ) , mRecyclerViewWidth ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( scrollingBy , <NUM_LIT> ) ; } mHorizontalDragX = x ; } private int scrollTo ( float oldDragPos , float newDragPos , int [ ] scrollbarRange , int scrollRange , int scrollOffset , int viewLength ) { int", "gt": "scrollbarLength = scrollbarRange [ <NUM_LIT> ] - scrollbarRange [ <NUM_LIT> ] ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas", "gt": ". translate ( left , <NUM_LIT> ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable", "gt": ". setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int", "gt": "left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar", "gt": "= horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat", "gt": "originalDelegate = mOriginalItemDelegates . get ( host ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX", "gt": "= ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else", "gt": "if ( mState == STATE_DRAGGING ) {", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final int end = mCallback . getParentEnd ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ; View acceptableMatch = null ; for ( int i = fromIndex ; i != toIndex ; i += next ) { final", "gt": "View child = mCallback . getChildAt ( i ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final int end = mCallback . getParentEnd ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ; View acceptableMatch = null ; for ( int i = fromIndex ; i != toIndex ; i += next ) { final View child = mCallback . getChildAt ( i ) ; final int childStart = mCallback . getChildStart ( child ) ; final int childEnd = mCallback . getChildEnd ( child ) ; mBoundFlags", "gt": ". setBounds ( start , end , childStart , childEnd ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ; if ( Math . abs ( mHorizontalThumbCenterX - x ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mHorizontalDragX , x , scrollbarRange , mRecyclerView . computeHorizontalScrollRange ( ) , mRecyclerView . computeHorizontalScrollOffset ( ) , mRecyclerViewWidth ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( scrollingBy , <NUM_LIT> ) ; } mHorizontalDragX = x ; } private int scrollTo ( float oldDragPos , float newDragPos , int [ ] scrollbarRange , int scrollRange , int scrollOffset , int viewLength ) { int scrollbarLength = scrollbarRange [ <NUM_LIT> ] - scrollbarRange [ <NUM_LIT> ] ; if ( scrollbarLength == <NUM_LIT> ) { return <NUM_LIT> ; } float percentage = ( ( newDragPos - oldDragPos ) / ( float ) scrollbarLength ) ; int totalPossibleOffset = scrollRange - viewLength ; int scrollingBy = ( int ) ( percentage * totalPossibleOffset ) ; int absoluteOffset = scrollOffset + scrollingBy ; if ( absoluteOffset < totalPossibleOffset && absoluteOffset >= <NUM_LIT> ) { return scrollingBy ; } else { return <NUM_LIT> ; } } @ VisibleForTesting boolean isPointInsideVerticalThumb ( float x , float y ) { return ( isLayoutRTL ( ) ? x <= mVerticalThumbWidth : x >= mRecyclerViewWidth - mVerticalThumbWidth ) && y >= mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> && y <= mVerticalThumbCenterY + mVerticalThumbHeight / <NUM_LIT> ; } @ VisibleForTesting boolean isPointInsideHorizontalThumb ( float x , float y ) { return ( y >= mRecyclerViewHeight - mHorizontalThumbHeight ) && x >= mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> && x <= mHorizontalThumbCenterX + mHorizontalThumbWidth / <NUM_LIT> ; } @ VisibleForTesting Drawable getHorizontalTrackDrawable ( ) { return mHorizontalTrackDrawable ; } @ VisibleForTesting Drawable getHorizontalThumbDrawable ( ) { return mHorizontalThumbDrawable ; } @ VisibleForTesting Drawable getVerticalTrackDrawable ( ) { return mVerticalTrackDrawable ; } @ VisibleForTesting Drawable getVerticalThumbDrawable ( ) { return mVerticalThumbDrawable ; } private int [ ] getVerticalRange ( ) { mVerticalRange [ <NUM_LIT> ] = mMargin ; mVerticalRange [ <NUM_LIT> ] = mRecyclerViewHeight - mMargin ; return mVerticalRange ; } private int [ ] getHorizontalRange ( ) { mHorizontalRange [ <NUM_LIT> ] = mMargin ; mHorizontalRange [ <NUM_LIT> ] = mRecyclerViewWidth - mMargin ; return mHorizontalRange ; } private class AnimatorListener extends AnimatorListenerAdapter { private boolean mCanceled = false ; AnimatorListener ( ) { } @ Override public void onAnimationEnd ( Animator animation ) { if ( mCanceled ) { mCanceled = false ; return ; } if ( ( float ) mShowHideAnimator . getAnimatedValue ( ) == <NUM_LIT> ) { mAnimationState = ANIMATION_STATE_OUT ; setState ( STATE_HIDDEN ) ; } else { mAnimationState = ANIMATION_STATE_IN ; requestRedraw ( ) ; } } @ Override public void onAnimationCancel ( Animator animation ) { mCanceled = true ; } } private class AnimatorUpdater implements AnimatorUpdateListener { AnimatorUpdater ( ) { } @ Override public void onAnimationUpdate ( ValueAnimator valueAnimator ) { int", "gt": "alpha = ( int ) ( SCROLLBAR_FULL_OPAQUE * ( ( float ) valueAnimator . getAnimatedValue ( ) ) ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX", "gt": "= ( int ) me . getX ( ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable", "gt": ". setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int", "gt": "verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ;", "repo": "Accord"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context", "gt": "context = mView . getContext ( ) ;", "repo": "Accord"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . DEFAULT ; return this ; } @ NonNull public FastScrollerBuilder useMd2Style ( ) { Context context = mView . getContext ( ) ; mTrackDrawable", "gt": "= Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_track , android . R . attr . colorControlNormal , context ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super", "gt": ". sendAccessibilityEventUnchecked ( host , event ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat", "gt": "originalDelegate = mOriginalItemDelegates . get ( host ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super", "gt": ". sendAccessibilityEvent ( host , eventType ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; import androidx . annotation . IntDef ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; class ViewBoundsCheck { static final int GT = <NUM_LIT> << <NUM_LIT> ; static final int EQ = <NUM_LIT> << <NUM_LIT> ; static final int LT = <NUM_LIT> << <NUM_LIT> ; static final int CVS_PVS_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVS = GT << CVS_PVS_POS ; static final int FLAG_CVS_EQ_PVS = EQ << CVS_PVS_POS ; static final int FLAG_CVS_LT_PVS = LT << CVS_PVS_POS ; static final int CVS_PVE_POS = <NUM_LIT> ; static final int FLAG_CVS_GT_PVE = GT << CVS_PVE_POS ; static final int FLAG_CVS_EQ_PVE = EQ << CVS_PVE_POS ; static final int FLAG_CVS_LT_PVE = LT << CVS_PVE_POS ; static final int CVE_PVS_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVS = GT << CVE_PVS_POS ; static final int FLAG_CVE_EQ_PVS = EQ << CVE_PVS_POS ; static final int FLAG_CVE_LT_PVS = LT << CVE_PVS_POS ; static final int CVE_PVE_POS = <NUM_LIT> ; static final int FLAG_CVE_GT_PVE = GT << CVE_PVE_POS ; static final int FLAG_CVE_EQ_PVE = EQ << CVE_PVE_POS ; static final int FLAG_CVE_LT_PVE = LT << CVE_PVE_POS ; static final int MASK = GT | EQ | LT ; final Callback mCallback ; BoundFlags mBoundFlags ; @ IntDef ( flag = true , value = { FLAG_CVS_GT_PVS , FLAG_CVS_EQ_PVS , FLAG_CVS_LT_PVS , FLAG_CVS_GT_PVE , FLAG_CVS_EQ_PVE , FLAG_CVS_LT_PVE , FLAG_CVE_GT_PVS , FLAG_CVE_EQ_PVS , FLAG_CVE_LT_PVS , FLAG_CVE_GT_PVE , FLAG_CVE_EQ_PVE , FLAG_CVE_LT_PVE } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface ViewBounds { } ViewBoundsCheck ( Callback callback ) { mCallback = callback ; mBoundFlags = new BoundFlags ( ) ; } static class BoundFlags { int mBoundFlags = <NUM_LIT> ; int mRvStart , mRvEnd , mChildStart , mChildEnd ; void setBounds ( int rvStart , int rvEnd , int childStart , int childEnd ) { mRvStart = rvStart ; mRvEnd = rvEnd ; mChildStart = childStart ; mChildEnd = childEnd ; } void addFlags ( @ ViewBounds int flags ) { mBoundFlags |= flags ; } void resetFlags ( ) { mBoundFlags = <NUM_LIT> ; } int compare ( int x , int y ) { if ( x > y ) { return GT ; } if ( x == y ) { return EQ ; } return LT ; } boolean boundsMatch ( ) { if ( ( mBoundFlags & ( MASK << CVS_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvStart ) << CVS_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVS_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildStart , mRvEnd ) << CVS_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVS_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvStart ) << CVE_PVS_POS ) ) == <NUM_LIT> ) { return false ; } } if ( ( mBoundFlags & ( MASK << CVE_PVE_POS ) ) != <NUM_LIT> ) { if ( ( mBoundFlags & ( compare ( mChildEnd , mRvEnd ) << CVE_PVE_POS ) ) == <NUM_LIT> ) { return false ; } } return true ; } } ; View", "gt": "findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) {", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x", "gt": "= Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return", "gt": "super . dispatchPopulateAccessibilityEvent ( host , event ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth", "gt": "= Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } return mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . performAccessibilityActionForItem ( host , action , args ) ; } else { return super . performAccessibilityAction ( host , action , args ) ; } } @ Override public void sendAccessibilityEvent ( @ NonNull View host , int eventType ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEvent ( host , eventType ) ; } else { super . sendAccessibilityEvent ( host , eventType ) ; } } @ Override public void sendAccessibilityEventUnchecked ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . sendAccessibilityEventUnchecked ( host , event ) ; } else { super . sendAccessibilityEventUnchecked ( host , event ) ; } } @ Override public boolean dispatchPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { return originalDelegate . dispatchPopulateAccessibilityEvent ( host , event ) ; } else { return super . dispatchPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onPopulateAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onPopulateAccessibilityEvent ( host , event ) ; } else { super . onPopulateAccessibilityEvent ( host , event ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ NonNull View host , @ NonNull AccessibilityEvent event ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityEvent ( host , event ) ; } else { super", "gt": ". onInitializeAccessibilityEvent ( host , event ) ;", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if ( originalDelegate . performAccessibilityAction ( host , action , args ) ) { return true ; } } else", "gt": "if ( super . performAccessibilityAction ( host , action , args ) ) {", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . os . Bundle ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeProviderCompat ; import java . util . Map ; import java . util . WeakHashMap ; public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat { final RecyclerView mRecyclerView ; private final ItemDelegate mItemDelegate ; public RecyclerViewAccessibilityDelegate ( @ NonNull RecyclerView recyclerView ) { mRecyclerView = recyclerView ; AccessibilityDelegateCompat itemDelegate = getItemDelegate ( ) ; if ( itemDelegate != null && itemDelegate instanceof ItemDelegate ) { mItemDelegate = ( ItemDelegate ) itemDelegate ; } else { mItemDelegate = new ItemDelegate ( this ) ; } } boolean shouldIgnore ( ) { return mRecyclerView . hasPendingAdapterUpdates ( ) ; } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( super . performAccessibilityAction ( host , action , args ) ) { return true ; } if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { return mRecyclerView . getLayoutManager ( ) . performAccessibilityAction ( action , args ) ; } return false ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( host , info ) ; if ( ! shouldIgnore ( ) && mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfo ( info ) ; } } @ Override public void onInitializeAccessibilityEvent ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( host , event ) ; if ( host instanceof RecyclerView && ! shouldIgnore ( ) ) { RecyclerView rv = ( RecyclerView ) host ; if ( rv . getLayoutManager ( ) != null ) { rv . getLayoutManager ( ) . onInitializeAccessibilityEvent ( event ) ; } } } @ NonNull public AccessibilityDelegateCompat getItemDelegate ( ) { return mItemDelegate ; } public static class ItemDelegate extends AccessibilityDelegateCompat { final RecyclerViewAccessibilityDelegate mRecyclerViewDelegate ; private Map < View , AccessibilityDelegateCompat > mOriginalItemDelegates = new WeakHashMap < > ( ) ; public ItemDelegate ( @ NonNull RecyclerViewAccessibilityDelegate recyclerViewDelegate ) { mRecyclerViewDelegate = recyclerViewDelegate ; } void saveOriginalDelegate ( View itemView ) { AccessibilityDelegateCompat delegate = ViewCompat . getAccessibilityDelegate ( itemView ) ; if ( delegate != null && delegate != this ) { mOriginalItemDelegates . put ( itemView , delegate ) ; } } AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem ( View itemView ) { return mOriginalItemDelegates . remove ( itemView ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { originalDelegate . onInitializeAccessibilityNodeInfo ( host , info ) ; } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } else { super . onInitializeAccessibilityNodeInfo ( host , info ) ; } } @ Override public boolean performAccessibilityAction ( @ SuppressLint ( \"<STR_LIT>\" ) @ NonNull View host , int action , @ SuppressLint ( \"<STR_LIT>\" ) @ Nullable Bundle args ) { if ( ! mRecyclerViewDelegate . shouldIgnore ( ) && mRecyclerViewDelegate . mRecyclerView . getLayoutManager ( ) != null ) { AccessibilityDelegateCompat originalDelegate = mOriginalItemDelegates . get ( host ) ; if ( originalDelegate != null ) { if", "gt": "( originalDelegate . performAccessibilityAction ( host , action , args ) ) {", "repo": "Accord"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . ScrollView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Consumer ; import androidx . core . widget . NestedScrollView ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FastScrollerBuilder { @ NonNull private final ViewGroup mView ; @ Nullable private FastScroller . ViewHelper mViewHelper ; @ Nullable private PopupTextProvider mPopupTextProvider ; @ Nullable private Rect mPadding ; @ NonNull private Drawable mTrackDrawable ; @ NonNull private Drawable mThumbDrawable ; @ NonNull private Consumer < TextView > mPopupStyle ; @ Nullable private FastScroller . AnimationHelper mAnimationHelper ; public FastScrollerBuilder ( @ NonNull ViewGroup view ) { mView = view ; useDefaultStyle ( ) ; } @ NonNull public FastScrollerBuilder setViewHelper ( @ Nullable FastScroller . ViewHelper viewHelper ) { mViewHelper = viewHelper ; return this ; } @ NonNull public FastScrollerBuilder setPopupTextProvider ( @ Nullable PopupTextProvider popupTextProvider ) { mPopupTextProvider = popupTextProvider ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( int left , int top , int right , int bottom ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( left , top , right , bottom ) ; return this ; } @ NonNull public FastScrollerBuilder setPadding ( @ Nullable Rect padding ) { if ( padding != null ) { if ( mPadding == null ) { mPadding = new Rect ( ) ; } mPadding . set ( padding ) ; } else { mPadding = null ; } return this ; } @ NonNull public FastScrollerBuilder setTrackDrawable ( @ NonNull Drawable trackDrawable ) { mTrackDrawable = trackDrawable ; return this ; } @ NonNull public FastScrollerBuilder setThumbDrawable ( @ NonNull Drawable thumbDrawable ) { mThumbDrawable = thumbDrawable ; return this ; } @ NonNull public FastScrollerBuilder setPopupStyle ( @ NonNull Consumer < TextView > popupStyle ) { mPopupStyle = popupStyle ; return this ; } @ NonNull public FastScrollerBuilder useDefaultStyle ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . DEFAULT ; return this ; } @ NonNull public FastScrollerBuilder useMd2Style ( ) { Context context = mView . getContext ( ) ; mTrackDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_track , android . R . attr . colorControlNormal , context ) ; mThumbDrawable = Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_md2_thumb , android . R . attr . colorControlActivated , context ) ; mPopupStyle = PopupStyles . MD2 ; return this ; } public void setAnimationHelper ( @ Nullable FastScroller . AnimationHelper animationHelper ) { mAnimationHelper = animationHelper ; } public void disableScrollbarAutoHide ( ) { DefaultAnimationHelper animationHelper = new DefaultAnimationHelper ( mView ) ; animationHelper . setScrollbarAutoHideEnabled ( false ) ; mAnimationHelper = animationHelper ; } @ NonNull public FastScroller build ( ) { return new FastScroller ( mView , getOrCreateViewHelper ( ) , mPadding , mTrackDrawable , mThumbDrawable , mPopupStyle , getOrCreateAnimationHelper ( ) ) ; } @ NonNull private FastScroller . ViewHelper getOrCreateViewHelper ( ) { if ( mViewHelper != null ) { return mViewHelper ; } if ( mView instanceof ViewHelperProvider ) { return ( ( ViewHelperProvider ) mView ) . getViewHelper ( ) ; } else if ( mView instanceof RecyclerView ) { return new RecyclerViewHelper ( ( RecyclerView ) mView , mPopupTextProvider ) ; } else", "gt": "if ( mView instanceof NestedScrollView ) {", "repo": "Accord"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . view . MotionEvent ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . ViewCompat ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; @ VisibleForTesting class FastScroller extends RecyclerView . ItemDecoration implements RecyclerView . OnItemTouchListener { @ IntDef ( { STATE_HIDDEN , STATE_VISIBLE , STATE_DRAGGING } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface State { } private static final int STATE_HIDDEN = <NUM_LIT> ; private static final int STATE_VISIBLE = <NUM_LIT> ; private static final int STATE_DRAGGING = <NUM_LIT> ; @ IntDef ( { DRAG_X , DRAG_Y , DRAG_NONE } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface DragState { } private static final int DRAG_NONE = <NUM_LIT> ; private static final int DRAG_X = <NUM_LIT> ; private static final int DRAG_Y = <NUM_LIT> ; @ IntDef ( { ANIMATION_STATE_OUT , ANIMATION_STATE_FADING_IN , ANIMATION_STATE_IN , ANIMATION_STATE_FADING_OUT } ) @ Retention ( RetentionPolicy . SOURCE ) private @ interface AnimationState { } private static final int ANIMATION_STATE_OUT = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_IN = <NUM_LIT> ; private static final int ANIMATION_STATE_FADING_OUT = <NUM_LIT> ; private static final int SHOW_DURATION_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_VISIBLE_MS = <NUM_LIT> ; private static final int HIDE_DELAY_AFTER_DRAGGING_MS = <NUM_LIT> ; private static final int HIDE_DURATION_MS = <NUM_LIT> ; private static final int SCROLLBAR_FULL_OPAQUE = <NUM_LIT> ; private static final int [ ] PRESSED_STATE_SET = new int [ ] { android . R . attr . state_pressed } ; private static final int [ ] EMPTY_STATE_SET = new int [ ] { } ; private final int mScrollbarMinimumRange ; private final int mMargin ; @ SuppressWarnings ( \"<STR_LIT>\" ) final StateListDrawable mVerticalThumbDrawable ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Drawable mVerticalTrackDrawable ; private final int mVerticalThumbWidth ; private final int mVerticalTrackWidth ; private final StateListDrawable mHorizontalThumbDrawable ; private final Drawable mHorizontalTrackDrawable ; private final int mHorizontalThumbHeight ; private final int mHorizontalTrackHeight ; @ VisibleForTesting int mVerticalThumbHeight ; @ VisibleForTesting int mVerticalThumbCenterY ; @ VisibleForTesting float mVerticalDragY ; @ VisibleForTesting int mHorizontalThumbWidth ; @ VisibleForTesting int mHorizontalThumbCenterX ; @ VisibleForTesting float mHorizontalDragX ; private int mRecyclerViewWidth = <NUM_LIT> ; private int mRecyclerViewHeight = <NUM_LIT> ; private RecyclerView mRecyclerView ; private boolean mNeedVerticalScrollbar = false ; private boolean mNeedHorizontalScrollbar = false ; @ State private int mState = STATE_HIDDEN ; @ DragState private int mDragState = DRAG_NONE ; private final int [ ] mVerticalRange = new int [ <NUM_LIT> ] ; private final int [ ] mHorizontalRange = new int [ <NUM_LIT> ] ; @ SuppressWarnings ( \"<STR_LIT>\" ) final ValueAnimator mShowHideAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ AnimationState int mAnimationState = ANIMATION_STATE_OUT ; private final Runnable mHideRunnable = new Runnable ( ) { @ Override public void run ( ) { hide ( HIDE_DURATION_MS ) ; } } ; private final RecyclerView . OnScrollListener mOnScrollListener = new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { updateScrollPosition ( recyclerView . computeHorizontalScrollOffset ( ) , recyclerView . computeVerticalScrollOffset ( ) ) ; } } ; FastScroller ( RecyclerView recyclerView , StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable , int defaultWidth , int scrollbarMinimumRange , int margin ) { mVerticalThumbDrawable = verticalThumbDrawable ; mVerticalTrackDrawable = verticalTrackDrawable ; mHorizontalThumbDrawable = horizontalThumbDrawable ; mHorizontalTrackDrawable = horizontalTrackDrawable ; mVerticalThumbWidth = Math . max ( defaultWidth , verticalThumbDrawable . getIntrinsicWidth ( ) ) ; mVerticalTrackWidth = Math . max ( defaultWidth , verticalTrackDrawable . getIntrinsicWidth ( ) ) ; mHorizontalThumbHeight = Math . max ( defaultWidth , horizontalThumbDrawable . getIntrinsicWidth ( ) ) ; mHorizontalTrackHeight = Math . max ( defaultWidth , horizontalTrackDrawable . getIntrinsicWidth ( ) ) ; mScrollbarMinimumRange = scrollbarMinimumRange ; mMargin = margin ; mVerticalThumbDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mVerticalTrackDrawable . setAlpha ( SCROLLBAR_FULL_OPAQUE ) ; mShowHideAnimator . addListener ( new AnimatorListener ( ) ) ; mShowHideAnimator . addUpdateListener ( new AnimatorUpdater ( ) ) ; attachToRecyclerView ( recyclerView ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; } } private void setupCallbacks ( ) { mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( this ) ; mRecyclerView . addOnScrollListener ( mOnScrollListener ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( this ) ; mRecyclerView . removeOnScrollListener ( mOnScrollListener ) ; cancelHide ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void requestRedraw ( ) { mRecyclerView . invalidate ( ) ; } void setState ( @ State int state ) { if ( state == STATE_DRAGGING && mState != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( PRESSED_STATE_SET ) ; cancelHide ( ) ; } if ( state == STATE_HIDDEN ) { requestRedraw ( ) ; } else { show ( ) ; } if ( mState == STATE_DRAGGING && state != STATE_DRAGGING ) { mVerticalThumbDrawable . setState ( EMPTY_STATE_SET ) ; resetHideDelay ( HIDE_DELAY_AFTER_DRAGGING_MS ) ; } else if ( state == STATE_VISIBLE ) { resetHideDelay ( HIDE_DELAY_AFTER_VISIBLE_MS ) ; } mState = state ; } private boolean isLayoutRTL ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean isDragging ( ) { return mState == STATE_DRAGGING ; } @ VisibleForTesting boolean isVisible ( ) { return mState == STATE_VISIBLE ; } public void show ( ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_OUT : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_OUT : mAnimationState = ANIMATION_STATE_FADING_IN ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( SHOW_DURATION_MS ) ; mShowHideAnimator . setStartDelay ( <NUM_LIT> ) ; mShowHideAnimator . start ( ) ; break ; } } @ VisibleForTesting void hide ( int duration ) { switch ( mAnimationState ) { case ANIMATION_STATE_FADING_IN : mShowHideAnimator . cancel ( ) ; case ANIMATION_STATE_IN : mAnimationState = ANIMATION_STATE_FADING_OUT ; mShowHideAnimator . setFloatValues ( ( float ) mShowHideAnimator . getAnimatedValue ( ) , <NUM_LIT> ) ; mShowHideAnimator . setDuration ( duration ) ; mShowHideAnimator . start ( ) ; break ; } } private void cancelHide ( ) { mRecyclerView . removeCallbacks ( mHideRunnable ) ; } private void resetHideDelay ( int delay ) { cancelHide ( ) ; mRecyclerView . postDelayed ( mHideRunnable , delay ) ; } @ Override public void onDrawOver ( Canvas canvas , RecyclerView parent , RecyclerView . State state ) { if ( mRecyclerViewWidth != mRecyclerView . getWidth ( ) || mRecyclerViewHeight != mRecyclerView . getHeight ( ) ) { mRecyclerViewWidth = mRecyclerView . getWidth ( ) ; mRecyclerViewHeight = mRecyclerView . getHeight ( ) ; setState ( STATE_HIDDEN ) ; return ; } if ( mAnimationState != ANIMATION_STATE_OUT ) { if ( mNeedVerticalScrollbar ) { drawVerticalScrollbar ( canvas ) ; } if ( mNeedHorizontalScrollbar ) { drawHorizontalScrollbar ( canvas ) ; } } } private void drawVerticalScrollbar ( Canvas canvas ) { int viewWidth = mRecyclerViewWidth ; int left = viewWidth - mVerticalThumbWidth ; int top = mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> ; mVerticalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalThumbWidth , mVerticalThumbHeight ) ; mVerticalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mVerticalTrackWidth , mRecyclerViewHeight ) ; if ( isLayoutRTL ( ) ) { mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( mVerticalThumbWidth , top ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . scale ( - <NUM_LIT> , <NUM_LIT> ) ; canvas . translate ( - mVerticalThumbWidth , - top ) ; } else { canvas . translate ( left , <NUM_LIT> ) ; mVerticalTrackDrawable . draw ( canvas ) ; canvas . translate ( <NUM_LIT> , top ) ; mVerticalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } } private void drawHorizontalScrollbar ( Canvas canvas ) { int viewHeight = mRecyclerViewHeight ; int top = viewHeight - mHorizontalThumbHeight ; int left = mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> ; mHorizontalThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mHorizontalThumbWidth , mHorizontalThumbHeight ) ; mHorizontalTrackDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , mRecyclerViewWidth , mHorizontalTrackHeight ) ; canvas . translate ( <NUM_LIT> , top ) ; mHorizontalTrackDrawable . draw ( canvas ) ; canvas . translate ( left , <NUM_LIT> ) ; mHorizontalThumbDrawable . draw ( canvas ) ; canvas . translate ( - left , - top ) ; } void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > <NUM_LIT> && mRecyclerViewHeight >= mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > <NUM_LIT> && mRecyclerViewWidth >= mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar && ! mNeedHorizontalScrollbar ) { if ( mState != STATE_HIDDEN ) { setState ( STATE_HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / <NUM_LIT> ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / <NUM_LIT> ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState == STATE_HIDDEN || mState == STATE_VISIBLE ) { setState ( STATE_VISIBLE ) ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent ev ) { final boolean handled ; if ( mState == STATE_VISIBLE ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( ev . getX ( ) , ev . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( ev . getX ( ) , ev . getY ( ) ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN && ( insideVerticalThumb || insideHorizontalThumb ) ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) ev . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) ev . getY ( ) ; } setState ( STATE_DRAGGING ) ; handled = true ; } else { handled = false ; } } else if ( mState == STATE_DRAGGING ) { handled = true ; } else { handled = false ; } return handled ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent me ) { if ( mState == STATE_HIDDEN ) { return ; } if ( me . getAction ( ) == MotionEvent . ACTION_DOWN ) { boolean insideVerticalThumb = isPointInsideVerticalThumb ( me . getX ( ) , me . getY ( ) ) ; boolean insideHorizontalThumb = isPointInsideHorizontalThumb ( me . getX ( ) , me . getY ( ) ) ; if ( insideVerticalThumb || insideHorizontalThumb ) { if ( insideHorizontalThumb ) { mDragState = DRAG_X ; mHorizontalDragX = ( int ) me . getX ( ) ; } else if ( insideVerticalThumb ) { mDragState = DRAG_Y ; mVerticalDragY = ( int ) me . getY ( ) ; } setState ( STATE_DRAGGING ) ; } } else if ( me . getAction ( ) == MotionEvent . ACTION_UP && mState == STATE_DRAGGING ) { mVerticalDragY = <NUM_LIT> ; mHorizontalDragX = <NUM_LIT> ; setState ( STATE_VISIBLE ) ; mDragState = DRAG_NONE ; } else if ( me . getAction ( ) == MotionEvent . ACTION_MOVE && mState == STATE_DRAGGING ) { show ( ) ; if ( mDragState == DRAG_X ) { horizontalScrollTo ( me . getX ( ) ) ; } if ( mDragState == DRAG_Y ) { verticalScrollTo ( me . getY ( ) ) ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private void verticalScrollTo ( float y ) { final int [ ] scrollbarRange = getVerticalRange ( ) ; y = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , y ) ) ; if ( Math . abs ( mVerticalThumbCenterY - y ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mVerticalDragY , y , scrollbarRange , mRecyclerView . computeVerticalScrollRange ( ) , mRecyclerView . computeVerticalScrollOffset ( ) , mRecyclerViewHeight ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( <NUM_LIT> , scrollingBy ) ; } mVerticalDragY = y ; } private void horizontalScrollTo ( float x ) { final int [ ] scrollbarRange = getHorizontalRange ( ) ; x = Math . max ( scrollbarRange [ <NUM_LIT> ] , Math . min ( scrollbarRange [ <NUM_LIT> ] , x ) ) ; if ( Math . abs ( mHorizontalThumbCenterX - x ) < <NUM_LIT> ) { return ; } int scrollingBy = scrollTo ( mHorizontalDragX , x , scrollbarRange , mRecyclerView . computeHorizontalScrollRange ( ) , mRecyclerView . computeHorizontalScrollOffset ( ) , mRecyclerViewWidth ) ; if ( scrollingBy != <NUM_LIT> ) { mRecyclerView . scrollBy ( scrollingBy , <NUM_LIT> ) ; } mHorizontalDragX = x ; } private int scrollTo ( float oldDragPos , float newDragPos , int [ ] scrollbarRange , int scrollRange , int scrollOffset , int viewLength ) { int scrollbarLength = scrollbarRange [ <NUM_LIT> ] - scrollbarRange [ <NUM_LIT> ] ; if ( scrollbarLength == <NUM_LIT> ) { return <NUM_LIT> ; } float percentage = ( ( newDragPos - oldDragPos ) / ( float ) scrollbarLength ) ; int totalPossibleOffset = scrollRange - viewLength ; int scrollingBy = ( int ) ( percentage * totalPossibleOffset ) ; int absoluteOffset = scrollOffset + scrollingBy ; if ( absoluteOffset < totalPossibleOffset && absoluteOffset >= <NUM_LIT> ) { return scrollingBy ; } else { return <NUM_LIT> ; } } @ VisibleForTesting boolean isPointInsideVerticalThumb ( float x , float y ) { return ( isLayoutRTL ( ) ? x <= mVerticalThumbWidth : x >= mRecyclerViewWidth - mVerticalThumbWidth ) && y >= mVerticalThumbCenterY - mVerticalThumbHeight / <NUM_LIT> && y <= mVerticalThumbCenterY + mVerticalThumbHeight / <NUM_LIT> ; } @ VisibleForTesting boolean isPointInsideHorizontalThumb ( float x , float y ) { return ( y >= mRecyclerViewHeight - mHorizontalThumbHeight ) && x >= mHorizontalThumbCenterX - mHorizontalThumbWidth / <NUM_LIT> && x <= mHorizontalThumbCenterX + mHorizontalThumbWidth / <NUM_LIT> ; } @ VisibleForTesting Drawable getHorizontalTrackDrawable ( ) { return mHorizontalTrackDrawable ; } @ VisibleForTesting Drawable getHorizontalThumbDrawable ( ) { return mHorizontalThumbDrawable ; } @ VisibleForTesting Drawable getVerticalTrackDrawable ( ) { return mVerticalTrackDrawable ; } @ VisibleForTesting Drawable getVerticalThumbDrawable ( ) { return mVerticalThumbDrawable ; } private int [ ] getVerticalRange ( ) { mVerticalRange [ <NUM_LIT> ] = mMargin ; mVerticalRange", "gt": "[ <NUM_LIT> ] = mRecyclerViewHeight - mMargin ;", "repo": "Accord"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . badge ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = @ Permission ( strings = { } , alias = \"<STR_LIT>\" ) ) public class BadgePlugin extends Plugin { private Badge implementation ; @ Override public void load ( ) { BadgeConfig config = getBadgeConfig ( ) ; implementation = new Badge ( getContext ( ) , config ) ; } @ Override public void handleOnResume ( ) { super . handleOnResume ( ) ; implementation . handleOnResume ( ) ; } @ PluginMethod public void get ( PluginCall call ) { try { int count = implementation . get ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , count ) ; call . resolve ( ret ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void set ( PluginCall call ) { try { int count = call . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; implementation . set ( count ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void increase ( PluginCall call ) { try { implementation . increase ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void decrease ( PluginCall call ) { try { implementation . decrease ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void clear ( PluginCall call ) { try { implementation . clear ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { boolean isSupported = implementation . isSupported ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , isSupported ) ; call . resolve ( ret ) ; } catch ( Exception ex ) { call", "gt": ". reject ( ex . getLocalizedMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setChannel ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setCustomId ( PluginCall call ) { try { String customId = call . getString ( \"<STR_LIT>\" ) ; if ( customId == null ) { call . reject ( ERROR_CUSTOM_ID_MISSING ) ; return ; } SetCustomIdOptions options = new SetCustomIdOptions ( customId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setCustomId ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void sync ( PluginCall call ) { try { String appId = config . getAppId ( ) ; if ( appId == null ) { call . reject ( ERROR_APP_ID_MISSING ) ; return ; } NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . sync ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } private LiveUpdateConfig getLiveUpdateConfig ( ) { LiveUpdateConfig config = new LiveUpdateConfig ( ) ; String", "gt": "appId = getConfig ( ) . getString ( \"<STR_LIT>\" , config . getAppId ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation", "gt": ". setChannel ( options , callback ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions", "gt": "options = new SetBundleOptions ( bundleId ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . cloudinary ; import androidx . annotation . NonNull ; import com . getcapacitor . Bridge ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginHandle ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import java . util . HashMap ; import java . util . Map ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class CloudinaryPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String ERROR_NOT_INITIALIZED = \"<STR_LIT>\" ; public static final String ERROR_CLOUD_NAME_MISSING = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_RESOURCE_TYPE_MISSING = \"<STR_LIT>\" ; public static final String ERROR_UPLOAD_PRESET_MISSING = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static Bridge staticBridge = null ; private Cloudinary implementation ; private boolean initialized = false ; public void load ( ) { staticBridge = this . bridge ; implementation = new Cloudinary ( this ) ; } @ PluginMethod public void initialize ( PluginCall call ) { try { if ( initialized ) { return ; } String cloudName = call . getString ( \"<STR_LIT>\" ) ; if ( cloudName == null ) { call . reject ( ERROR_CLOUD_NAME_MISSING ) ; return ; } implementation . initialize ( cloudName ) ; initialized = true ; call . resolve ( ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void uploadResource ( PluginCall call ) { try { if ( ! initialized ) { call . reject ( ERROR_NOT_INITIALIZED ) ; return ; } String resourceType = call . getString ( \"<STR_LIT>\" ) ; if ( resourceType == null ) { call . reject ( ERROR_RESOURCE_TYPE_MISSING ) ; return ; } String uploadPreset = call . getString ( \"<STR_LIT>\" ) ; if ( uploadPreset == null ) { call . reject ( ERROR_UPLOAD_PRESET_MISSING ) ; return ; } String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } String publicId = call . getString ( \"<STR_LIT>\" ) ; implementation . uploadResource ( resourceType , path , uploadPreset , publicId , new UploadResourceResultCallback ( ) { @ Override public void success ( Map resultData ) { JSObject result = CloudinaryHelper . createUploadResourceResult ( resultData ) ; call . resolve ( result ) ; } @ Override public void error ( String message ) { call . reject ( message ) ; } } ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void downloadResource ( PluginCall call ) { try { if ( ! initialized ) { call . reject ( ERROR_NOT_INITIALIZED ) ; return ; } String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } implementation", "gt": ". downloadResource ( url , new DownloadResourceResultCallback ( ) {", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call", "gt": ". resolve ( result . toJSObject ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setChannel ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setCustomId ( PluginCall call ) { try { String customId = call . getString ( \"<STR_LIT>\" ) ; if ( customId == null ) { call . reject ( ERROR_CUSTOM_ID_MISSING ) ; return ; } SetCustomIdOptions options = new SetCustomIdOptions ( customId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call", "gt": ". resolve ( result . toJSObject ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . cloudinary ; import androidx . annotation . NonNull ; import com . getcapacitor . Bridge ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginHandle ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import java . util . HashMap ; import java . util . Map ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class CloudinaryPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String ERROR_NOT_INITIALIZED = \"<STR_LIT>\" ; public static final String ERROR_CLOUD_NAME_MISSING = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_RESOURCE_TYPE_MISSING = \"<STR_LIT>\" ; public static final String ERROR_UPLOAD_PRESET_MISSING = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static Bridge staticBridge = null ; private Cloudinary implementation ; private boolean initialized = false ; public void load ( ) { staticBridge = this . bridge ; implementation = new Cloudinary ( this ) ; } @ PluginMethod public void initialize ( PluginCall call ) { try { if ( initialized ) { return ; } String cloudName = call . getString ( \"<STR_LIT>\" ) ; if ( cloudName == null ) { call . reject ( ERROR_CLOUD_NAME_MISSING ) ; return ; } implementation . initialize ( cloudName ) ; initialized = true ; call . resolve ( ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void uploadResource ( PluginCall call ) { try { if ( ! initialized ) { call . reject ( ERROR_NOT_INITIALIZED ) ; return ; } String resourceType = call . getString ( \"<STR_LIT>\" ) ; if ( resourceType == null ) { call . reject ( ERROR_RESOURCE_TYPE_MISSING ) ; return ; } String uploadPreset = call . getString ( \"<STR_LIT>\" ) ; if ( uploadPreset == null ) { call . reject ( ERROR_UPLOAD_PRESET_MISSING ) ; return ; } String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } String publicId = call . getString ( \"<STR_LIT>\" ) ; implementation . uploadResource ( resourceType , path , uploadPreset , publicId , new UploadResourceResultCallback ( ) { @ Override public void success ( Map resultData ) { JSObject result = CloudinaryHelper . createUploadResourceResult ( resultData ) ; call . resolve ( result ) ; } @ Override public void error ( String message ) { call . reject ( message ) ; } } ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void downloadResource ( PluginCall call ) { try { if ( ! initialized ) { call . reject ( ERROR_NOT_INITIALIZED ) ; return ; } String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } implementation . downloadResource ( url , new DownloadResourceResultCallback ( ) { @ Override public void success ( String path ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , path ) ; call . resolve ( result ) ; } @ Override public void error ( String message ) { call . reject ( message ) ; } } ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } public Cloudinary getImplementation ( ) { return implementation ; } public static void onDownloadCompleted ( long downloadId ) { CloudinaryPlugin plugin = CloudinaryPlugin . getCloudinaryPluginInstance ( ) ; if ( plugin != null ) { plugin . getImplementation ( ) . handleDownloadCompleted ( downloadId ) ; } } private static CloudinaryPlugin getCloudinaryPluginInstance ( ) { if ( staticBridge == null || staticBridge . getWebView ( ) == null ) { return null ; } PluginHandle", "gt": "handle = staticBridge . getPlugin ( \"<STR_LIT>\" ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setChannel ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setCustomId ( PluginCall call ) { try { String customId = call . getString ( \"<STR_LIT>\" ) ; if ( customId == null ) { call . reject ( ERROR_CUSTOM_ID_MISSING ) ; return ; } SetCustomIdOptions options = new SetCustomIdOptions ( customId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setCustomId ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void sync ( PluginCall call ) { try { String", "gt": "appId = config . getAppId ( ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . badge ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = @ Permission ( strings = { } , alias = \"<STR_LIT>\" ) ) public class BadgePlugin extends Plugin { private Badge implementation ; @ Override public void load ( ) { BadgeConfig config = getBadgeConfig ( ) ; implementation = new Badge ( getContext ( ) , config ) ; } @ Override public void handleOnResume ( ) { super . handleOnResume ( ) ; implementation . handleOnResume ( ) ; } @ PluginMethod public void get ( PluginCall call ) { try { int count = implementation . get ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , count ) ; call . resolve ( ret ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void set ( PluginCall call ) { try { int count = call . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; implementation . set ( count ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void increase ( PluginCall call ) { try { implementation . increase ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call", "gt": ". reject ( ex . getLocalizedMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setChannel ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setCustomId ( PluginCall call ) { try { String customId = call . getString ( \"<STR_LIT>\" ) ; if ( customId == null ) { call . reject ( ERROR_CUSTOM_ID_MISSING ) ; return ; } SetCustomIdOptions options = new SetCustomIdOptions ( customId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setCustomId ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void sync ( PluginCall call ) { try { String appId = config . getAppId ( ) ; if ( appId == null ) { call . reject ( ERROR_APP_ID_MISSING ) ; return ; } NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call", "gt": ". resolve ( result . toJSObject ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback", "gt": "< Result > callback = new NonEmptyCallback < > ( ) {", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setChannel ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setCustomId ( PluginCall call ) { try { String customId = call . getString ( \"<STR_LIT>\" ) ; if ( customId == null ) { call . reject ( ERROR_CUSTOM_ID_MISSING ) ; return ; } SetCustomIdOptions options = new SetCustomIdOptions ( customId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setCustomId ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void sync ( PluginCall call ) { try { String appId = config . getAppId ( ) ; if ( appId == null ) { call . reject ( ERROR_APP_ID_MISSING ) ; return ; } NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . sync ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } private LiveUpdateConfig getLiveUpdateConfig ( ) { LiveUpdateConfig config = new LiveUpdateConfig ( ) ; String appId = getConfig ( ) . getString ( \"<STR_LIT>\" , config . getAppId ( ) ) ; config . setAppId ( appId ) ; boolean autoDeleteBundles = getConfig ( ) . getBoolean ( \"<STR_LIT>\" , config . getAutoDeleteBundles ( ) ) ; config . setAutoDeleteBundles ( autoDeleteBundles ) ; boolean enabled = getConfig ( ) . getBoolean ( \"<STR_LIT>\" , config . getEnabled ( ) ) ; config . setEnabled ( enabled ) ; String location = getConfig ( ) . getString ( \"<STR_LIT>\" , config . getLocation ( ) ) ; config . setLocation ( location ) ; String", "gt": "publicKey = getConfig ( ) . getString ( \"<STR_LIT>\" , config . getPublicKey ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . datetimepicker ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; public class DatetimePickerHelper { public static Date convertStringToDate ( String format , String value ) throws ParseException { SimpleDateFormat dateFormat = new SimpleDateFormat ( format ) ; return dateFormat . parse ( value ) ; } public static String convertDateToString ( String format , Date date ) { SimpleDateFormat dateFormat = new SimpleDateFormat ( format ) ; return dateFormat . format ( date ) ; } @ Nullable public static Theme convertStringToTheme ( @ Nullable String value ) { if ( value == null ) { return null ; } switch ( value ) { case \"<STR_LIT>\" : return Theme . LIGHT ; case \"<STR_LIT>\" : return Theme . DARK ; case \"<STR_LIT>\" : return Theme . AUTO ; default : return null ; } } @ Nullable public static AndroidTimePickerMode convertStringToTimePickerMode ( @ Nullable String value ) { if ( value == null ) { return null ; } switch ( value ) { case \"<STR_LIT>\" : return AndroidTimePickerMode . CLOCK ; case \"<STR_LIT>\" : return AndroidTimePickerMode . SPINNER ; default : return null ; } } @ Nullable public static AndroidDatePickerMode convertStringToDatePickerMode ( @ Nullable String value ) { if ( value == null ) { return null ; } switch ( value ) { case \"<STR_LIT>\" : return AndroidDatePickerMode . CALENDAR ; case \"<STR_LIT>\" : return AndroidDatePickerMode . SPINNER ; default : return null ; } } public static Locale convertStringToLocale ( String value ) { return Locale . forLanguageTag ( value ) ; } public static boolean is24HourLocale ( @ NonNull Locale locale ) { String timeString = DateFormat . getTimeInstance ( DateFormat . LONG , locale ) . format ( new Date ( ) ) . toUpperCase ( ) ; if", "gt": "( timeString . contains ( \"<STR_LIT>\" ) || timeString . contains ( \"<STR_LIT>\" ) ) {", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setChannel ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setCustomId ( PluginCall call ) { try { String customId = call . getString ( \"<STR_LIT>\" ) ; if ( customId == null ) { call . reject ( ERROR_CUSTOM_ID_MISSING ) ; return ; } SetCustomIdOptions options = new SetCustomIdOptions ( customId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setCustomId ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String", "gt": "channel = call . getString ( \"<STR_LIT>\" ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . badge ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = @ Permission ( strings = { } , alias = \"<STR_LIT>\" ) ) public class BadgePlugin extends Plugin { private Badge implementation ; @ Override public void load ( ) { BadgeConfig config = getBadgeConfig ( ) ; implementation = new Badge ( getContext ( ) , config ) ; } @ Override public void handleOnResume ( ) { super . handleOnResume ( ) ; implementation . handleOnResume ( ) ; } @ PluginMethod public void get ( PluginCall call ) { try { int count = implementation . get ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , count ) ; call . resolve ( ret ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void set ( PluginCall call ) { try { int count = call . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; implementation . set ( count ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void increase ( PluginCall call ) { try { implementation . increase ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void decrease ( PluginCall call ) { try { implementation . decrease ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void clear ( PluginCall call ) { try { implementation . clear ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { boolean isSupported = implementation . isSupported ( ) ; JSObject ret = new JSObject ( ) ; ret", "gt": ". put ( \"<STR_LIT>\" , isSupported ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setChannel ( options , callback ) ; } catch ( Exception exception ) { Logger", "gt": ". error ( TAG , exception . getMessage ( ) , exception ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setChannel ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setCustomId ( PluginCall call ) { try { String customId = call . getString ( \"<STR_LIT>\" ) ; if ( customId == null ) { call . reject ( ERROR_CUSTOM_ID_MISSING ) ; return ; } SetCustomIdOptions options = new SetCustomIdOptions ( customId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation", "gt": ". setCustomId ( options , callback ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . badge ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = @ Permission ( strings = { } , alias = \"<STR_LIT>\" ) ) public class BadgePlugin extends Plugin { private Badge implementation ; @ Override public void load ( ) { BadgeConfig config = getBadgeConfig ( ) ; implementation = new Badge ( getContext ( ) , config ) ; } @ Override public void handleOnResume ( ) { super . handleOnResume ( ) ; implementation . handleOnResume ( ) ; } @ PluginMethod public void get ( PluginCall call ) { try { int count = implementation . get ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , count ) ; call . resolve ( ret ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void set ( PluginCall call ) { try { int count = call . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; implementation . set ( count ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void increase ( PluginCall call ) { try { implementation . increase ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void decrease ( PluginCall call ) { try { implementation . decrease ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void clear ( PluginCall call ) { try { implementation . clear ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { boolean isSupported = implementation . isSupported ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , isSupported ) ; call . resolve ( ret ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } private BadgeConfig getBadgeConfig ( ) { BadgeConfig config = new BadgeConfig ( ) ; Boolean persist = getConfig ( ) . getBoolean ( \"<STR_LIT>\" , config . getPersist ( ) ) ; config . setPersist ( persist ) ; Boolean", "gt": "autoClear = getConfig ( ) . getBoolean ( \"<STR_LIT>\" , config . getAutoClear ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . badge ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = @ Permission ( strings = { } , alias = \"<STR_LIT>\" ) ) public class BadgePlugin extends Plugin { private Badge implementation ; @ Override public void load ( ) { BadgeConfig config = getBadgeConfig ( ) ; implementation = new Badge ( getContext ( ) , config ) ; } @ Override public void handleOnResume ( ) { super . handleOnResume ( ) ; implementation . handleOnResume ( ) ; } @ PluginMethod public void get ( PluginCall call ) { try { int count = implementation . get ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , count ) ; call . resolve ( ret ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void set ( PluginCall call ) { try { int count = call . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; implementation . set ( count ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void increase ( PluginCall call ) { try { implementation . increase ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void decrease ( PluginCall call ) { try { implementation . decrease ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void clear ( PluginCall call ) { try { implementation . clear ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void isSupported ( PluginCall call ) { try { boolean isSupported = implementation . isSupported ( ) ; JSObject", "gt": "ret = new JSObject ( ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . cloudinary ; import com . getcapacitor . JSObject ; import java . util . Map ; public class CloudinaryHelper { public static JSObject createUploadResourceResult ( Map resultData ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result", "gt": ". put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setChannel ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setCustomId ( PluginCall call ) { try { String", "gt": "customId = call . getString ( \"<STR_LIT>\" ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setChannel ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setCustomId ( PluginCall call ) { try { String customId = call . getString ( \"<STR_LIT>\" ) ; if ( customId == null ) { call . reject ( ERROR_CUSTOM_ID_MISSING ) ; return ; } SetCustomIdOptions options = new SetCustomIdOptions ( customId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setCustomId ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void sync ( PluginCall call ) { try { String appId = config . getAppId ( ) ; if ( appId == null ) { call . reject ( ERROR_APP_ID_MISSING ) ; return ; } NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . sync ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } private LiveUpdateConfig getLiveUpdateConfig ( ) { LiveUpdateConfig config = new LiveUpdateConfig ( ) ; String appId = getConfig ( ) . getString ( \"<STR_LIT>\" , config . getAppId ( ) ) ; config . setAppId ( appId ) ; boolean autoDeleteBundles = getConfig ( ) . getBoolean ( \"<STR_LIT>\" , config . getAutoDeleteBundles ( ) ) ; config . setAutoDeleteBundles ( autoDeleteBundles ) ; boolean enabled = getConfig ( ) . getBoolean ( \"<STR_LIT>\" , config . getEnabled ( ) ) ; config . setEnabled ( enabled ) ; String location = getConfig ( ) . getString ( \"<STR_LIT>\" , config . getLocation ( ) ) ; config . setLocation ( location ) ; String publicKey = getConfig ( ) . getString ( \"<STR_LIT>\" , config . getPublicKey ( ) ) ; config . setPublicKey ( publicKey ) ; int", "gt": "readyTimeout = getConfig ( ) . getInt ( \"<STR_LIT>\" , config . getReadyTimeout ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . cloudinary ; import com . getcapacitor . JSObject ; import java . util . Map ; public class CloudinaryHelper { public static JSObject createUploadResourceResult ( Map resultData ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result . put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ; result", "gt": ". put ( \"<STR_LIT>\" , resultData . get ( \"<STR_LIT>\" ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } SetBundleOptions options = new SetBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setChannel ( PluginCall call ) { try { String channel = call . getString ( \"<STR_LIT>\" ) ; SetChannelOptions options = new SetChannelOptions ( channel ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setChannel ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void setCustomId ( PluginCall call ) { try { String customId = call . getString ( \"<STR_LIT>\" ) ; if ( customId == null ) { call . reject ( ERROR_CUSTOM_ID_MISSING ) ; return ; } SetCustomIdOptions options = new SetCustomIdOptions ( customId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . setCustomId ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void sync ( PluginCall call ) { try { String appId = config . getAppId ( ) ; if ( appId == null ) { call . reject ( ERROR_APP_ID_MISSING ) ; return ; } NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . datetimepicker ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; public class DatetimePickerHelper { public static Date convertStringToDate ( String format , String value ) throws ParseException { SimpleDateFormat dateFormat = new SimpleDateFormat ( format ) ; return dateFormat . parse ( value ) ; } public static String convertDateToString ( String format , Date date ) { SimpleDateFormat dateFormat = new SimpleDateFormat ( format ) ; return dateFormat . format ( date ) ; } @ Nullable public static Theme convertStringToTheme ( @ Nullable String value ) { if ( value == null ) { return null ; } switch ( value ) { case \"<STR_LIT>\" : return Theme . LIGHT ; case \"<STR_LIT>\" : return Theme . DARK ; case \"<STR_LIT>\" : return Theme . AUTO ; default : return null ; } } @ Nullable public static AndroidTimePickerMode convertStringToTimePickerMode ( @ Nullable String value ) { if ( value == null ) { return null ; } switch ( value ) { case \"<STR_LIT>\" : return AndroidTimePickerMode . CLOCK ; case \"<STR_LIT>\" : return AndroidTimePickerMode . SPINNER ; default : return null ; } } @ Nullable public static AndroidDatePickerMode convertStringToDatePickerMode ( @ Nullable String value ) { if ( value == null ) { return null ; } switch ( value ) { case \"<STR_LIT>\" : return AndroidDatePickerMode . CALENDAR ; case", "gt": "\"<STR_LIT>\" : return AndroidDatePickerMode . SPINNER ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . badge ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = @ Permission ( strings = { } , alias = \"<STR_LIT>\" ) ) public class BadgePlugin extends Plugin { private Badge implementation ; @ Override public void load ( ) { BadgeConfig config = getBadgeConfig ( ) ; implementation = new Badge ( getContext ( ) , config ) ; } @ Override public void handleOnResume ( ) { super . handleOnResume ( ) ; implementation . handleOnResume ( ) ; } @ PluginMethod public void get ( PluginCall call ) { try { int count = implementation . get ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , count ) ; call . resolve ( ret ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void set ( PluginCall call ) { try { int count = call . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; implementation . set ( count ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void increase ( PluginCall call ) { try { implementation . increase ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void decrease ( PluginCall call ) { try { implementation . decrease ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call . reject ( ex . getLocalizedMessage ( ) ) ; } } @ PluginMethod public void clear ( PluginCall call ) { try { implementation . clear ( ) ; call . resolve ( ) ; } catch ( Exception ex ) { call", "gt": ". reject ( ex . getLocalizedMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class LiveUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String VERSION = \"<STR_LIT>\" ; public static final String SHARED_PREFERENCES_NAME = \"<STR_LIT>\" ; public static final String ERROR_APP_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_EXISTS = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_INDEX_HTML_MISSING = \"<STR_LIT>\" ; public static final String ERROR_BUNDLE_NOT_FOUND = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_CALCULATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_CHECKSUM_MISMATCH = \"<STR_LIT>\" ; public static final String ERROR_CUSTOM_ID_MISSING = \"<STR_LIT>\" ; public static final String ERROR_DOWNLOAD_FAILED = \"<STR_LIT>\" ; public static final String ERROR_URL_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_VERIFICATION_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PUBLIC_KEY_INVALID = \"<STR_LIT>\" ; public static final String ERROR_SIGNATURE_MISSING = \"<STR_LIT>\" ; @ Nullable private LiveUpdateConfig config ; @ Nullable private LiveUpdate implementation ; public void load ( ) { try { config = getLiveUpdateConfig ( ) ; implementation = new LiveUpdate ( config , this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void deleteBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } DeleteBundleOptions options = new DeleteBundleOptions ( bundleId ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . deleteBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void downloadBundle ( PluginCall call ) { try { String bundleId = call . getString ( \"<STR_LIT>\" ) ; if ( bundleId == null ) { call . reject ( ERROR_BUNDLE_ID_MISSING ) ; return ; } String checksum = call . getString ( \"<STR_LIT>\" ) ; String url = call . getString ( \"<STR_LIT>\" ) ; if ( url == null ) { call . reject ( ERROR_URL_MISSING ) ; return ; } DownloadBundleOptions options = new DownloadBundleOptions ( bundleId , checksum , url ) ; EmptyCallback callback = new EmptyCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . downloadBundle ( options , callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundle ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundle ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getBundles ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getBundles ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getChannel ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getChannel ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getCustomId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getCustomId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getDeviceId ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getDeviceId ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionCode ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionCode ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void getVersionName ( PluginCall call ) { try { NonEmptyCallback < Result > callback = new NonEmptyCallback < > ( ) { @ Override public void success ( Result result ) { call . resolve ( result . toJSObject ( ) ) ; } @ Override public void error ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } ; implementation . getVersionName ( callback ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void ready ( PluginCall call ) { try { implementation . ready ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reload ( PluginCall call ) { try { implementation . reload ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void reset ( PluginCall call ) { try { implementation . reset ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call", "gt": ". reject ( exception . getMessage ( ) ) ;", "repo": "capacitor-plugins"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async ; import android . content . DialogInterface ; import java . io . IOException ; import icu . freedomIntrovert . async . EventHandler ; public abstract class BiliBiliApiRequestHandler extends EventHandler { ErrorHandle errorHandle ; public BiliBiliApiRequestHandler ( ErrorHandle errorHandle ) { this . errorHandle = errorHandle ; } public void setErrorHandle ( ErrorHandle errorHandle ) { this . errorHandle = errorHandle ; } @ Override public void handleError ( Throwable th ) { th . printStackTrace ( ) ; if ( errorHandle != null ) { if ( th instanceof CookieFailedException ) { errorHandle . handleCookieFiledException ( ( CookieFailedException ) th ) ; } else if ( th instanceof BiliBiliApiException ) { errorHandle . handleBiliBiliApiException ( ( BiliBiliApiException ) th ) ; } else if ( th instanceof IOException ) { errorHandle . handleNetIOException ( ( IOException ) th ) ; } else { errorHandle . handleOtherExceptions ( th ) ; } } } public interface ErrorHandle { void handleNetIOException ( IOException e ) ; void handleCookieFiledException ( CookieFailedException e ) ; void handleBiliBiliApiException ( BiliBiliApiException e ) ; void handleOtherExceptions ( Throwable th ) ; } public static class DialogErrorHandle implements ErrorHandle { DialogInterface toDismissDialog ; public interface OnDialogMessageListener { void dialogMessage ( String title , String message ) ; } public OnDialogMessageListener listener ; public DialogErrorHandle ( DialogInterface toDismissDialog , OnDialogMessageListener listener ) { this . toDismissDialog = toDismissDialog ; this . listener = listener ; } @ Override public void handleNetIOException ( IOException e ) { toDismissDialog . dismiss ( ) ; listener . dialogMessage ( \"<STR_LIT>\" , e . getMessage ( ) ) ; } @ Override public void handleCookieFiledException ( CookieFailedException e ) { toDismissDialog . dismiss ( ) ; listener . dialogMessage ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } @ Override public void handleBiliBiliApiException ( BiliBiliApiException e ) { toDismissDialog . dismiss ( ) ; String msg ; if", "gt": "( e . tipsMessage != null ) {", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class ReviewCommentStatusTask extends BackstageTask < ReviewCommentStatusTask . EventHandler > { private CommentManipulator commentManipulator ; private StatisticsDBOpenHelper statisticsDB ; private HistoryComment historyComment ; public ReviewCommentStatusTask ( EventHandler handle , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_UNDER_REVIEW , rootComment ) ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , rootComment ) ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_OK , rootComment ) ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , rootComment ) ; } } else { GeneralResponse < CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , false ) ; if ( foundReply != null ) { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_INVISIBLE , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , foundReply ) ; } else { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_NORMAL , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_REPLY_OK , foundReply ) ; } } else { BiliComment foundReplyHasAcc = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , true ) ; if ( foundReplyHasAcc != null ) { statisticsDB . updateHistoryCommentStates ( foundReplyHasAcc . rpid , HistoryComment . STATE_SHADOW_BAN , foundReplyHasAcc . like , foundReplyHasAcc . rcount , new Date ( ) ) ; eventHandler", "gt": ". sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , foundReplyHasAcc ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . danmaku ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . zip . Inflater ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; public class DanmakuManipulator { OkHttpClient httpClient ; public DanmakuManipulator ( ) { this . httpClient = OkHttpUtil . getHttpClient ( ) ; } public boolean findDanmaku ( long oid , long dmid , String accessKey ) throws IOException , ParserConfigurationException , SAXException { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Request request ; byte [ ] decompress ; if ( accessKey == null ) { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid ) . build ( ) ; } else { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid + \"<STR_LIT>\" + accessKey ) . build ( ) ; } decompress = decompress ( httpClient . newCall ( request ) . execute ( ) . body ( ) . bytes ( ) ) ; Document document = builder . parse ( new ByteArrayInputStream ( decompress ) ) ; NodeList nodeList = document . getDocumentElement ( ) . getElementsByTagName ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < nodeList . getLength ( ) ; i ++ ) { Element element = ( Element ) nodeList . item ( i ) ; String p = element . getAttribute ( \"<STR_LIT>\" ) ; String thisDmid = p . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; System", "gt": ". out . println ( thisDmid ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class ReviewCommentStatusTask extends BackstageTask < ReviewCommentStatusTask . EventHandler > { private CommentManipulator commentManipulator ; private StatisticsDBOpenHelper statisticsDB ; private HistoryComment historyComment ; public ReviewCommentStatusTask ( EventHandler handle , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_UNDER_REVIEW , rootComment ) ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , rootComment ) ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_OK , rootComment ) ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , rootComment ) ; } } else { GeneralResponse < CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , false ) ; if ( foundReply != null ) { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_INVISIBLE , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , foundReply ) ; } else { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_NORMAL , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_REPLY_OK , foundReply ) ; } } else { BiliComment foundReplyHasAcc = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , true ) ; if ( foundReplyHasAcc != null ) { statisticsDB . updateHistoryCommentStates ( foundReplyHasAcc . rpid , HistoryComment . STATE_SHADOW_BAN , foundReplyHasAcc . like , foundReplyHasAcc . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , foundReplyHasAcc ) ; } else { statisticsDB", "gt": ". updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_DELETED , historyComment . like , historyComment . replyCount , new Date ( ) ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentLocator { public static void lunch ( Context context , int areaType , long oid , long rpid , long root , String sourceId ) { Intent intent = new Intent ( ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_DOCUMENT ) ; Bundle extras = new Bundle ( ) ; if ( areaType == CommentArea . AREA_TYPE_VIDEO ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; } else if ( areaType == CommentArea . AREA_TYPE_DYNAMIC11 || areaType == CommentArea . AREA_TYPE_DYNAMIC17 ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras", "gt": ". putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class ReviewCommentStatusTask extends BackstageTask < ReviewCommentStatusTask . EventHandler > { private CommentManipulator commentManipulator ; private StatisticsDBOpenHelper statisticsDB ; private HistoryComment historyComment ; public ReviewCommentStatusTask ( EventHandler handle , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_UNDER_REVIEW , rootComment ) ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , rootComment ) ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_OK , rootComment ) ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , rootComment ) ; } } else { GeneralResponse < CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , false ) ; if ( foundReply != null ) { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_INVISIBLE , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , foundReply ) ; } else { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_NORMAL , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_REPLY_OK , foundReply ) ; } } else { BiliComment foundReplyHasAcc = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , true ) ; if ( foundReplyHasAcc != null ) { statisticsDB . updateHistoryCommentStates ( foundReplyHasAcc . rpid , HistoryComment . STATE_SHADOW_BAN , foundReplyHasAcc . like , foundReplyHasAcc . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , foundReplyHasAcc ) ; } else { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_DELETED , historyComment . like , historyComment . replyCount , new Date ( ) ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_DELETED ) ; } } } else { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_SHADOW_BAN , historyComment . like , historyComment . replyCount , new Date ( ) ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ROOT_COMMENT_IS_SHADOW_BAN ) ; } } } else", "gt": "if ( resp . code == CommentAddResult . CODE_DELETED ) {", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentLocator { public static void lunch ( Context context , int areaType , long oid , long rpid , long root , String sourceId ) { Intent intent = new Intent ( ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_DOCUMENT ) ; Bundle extras = new Bundle ( ) ; if ( areaType == CommentArea . AREA_TYPE_VIDEO ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; } else if ( areaType == CommentArea . AREA_TYPE_DYNAMIC11 || areaType == CommentArea . AREA_TYPE_DYNAMIC17 ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( areaType ) ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" + sourceId ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( areaType == CommentArea . AREA_TYPE_ARTICLE ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( areaType ) ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; extras", "gt": ". putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . danmaku ; import android . os . Handler ; import org . xml . sax . SAXException ; import java . io . IOException ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; import javax . xml . parsers . ParserConfigurationException ; import icu . freedomIntrovert . biliSendCommAntifraud . NetworkCallBack ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class DanmakuPresenter { private Handler handler ; public DanmakuManipulator danmakuManipulator ; public StatisticsDBOpenHelper statisticsDBOpenHelper ; private boolean enableStatistics ; public long waitTime ; private Executor executor ; public DanmakuPresenter ( Handler handler , DanmakuManipulator danmakuManipulator , StatisticsDBOpenHelper statisticsDBOpenHelper , long waitTime , boolean enableStatistics ) { this . handler = handler ; this . danmakuManipulator = danmakuManipulator ; this . statisticsDBOpenHelper = statisticsDBOpenHelper ; this . enableStatistics = enableStatistics ; this . waitTime = waitTime ; executor = Executors . newSingleThreadExecutor ( ) ; } public void checkDanmaku ( long oid , long dmid , String content , String accessKey , long avid , CheckDanmakuCallBack callBack ) { executor . execute ( ( ) -> { try { handler . post ( ( ) -> callBack . onSleeping ( waitTime ) ) ; try { Thread . sleep ( waitTime ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } handler . post ( callBack :: onGettingNoAccountDMList ) ; if ( danmakuManipulator . findDanmaku ( oid , dmid , null ) ) { handler . post ( callBack :: thenOk ) ; } else { handler . post ( callBack :: onGettingHasAccountDMList ) ; if ( danmakuManipulator . findDanmaku ( oid , dmid , accessKey ) ) { handler . post ( callBack :: thenShadowBan ) ; } else { handler", "gt": ". post ( callBack :: thenDeleted ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . ImageView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . viewpager . widget . ViewPager ; import com . wgw . photo . preview . IndicatorType ; import com . wgw . photo . preview . PhotoPreview ; import com . wgw . photo . preview . interfaces . IFindThumbnailView ; import com . wgw . photo . preview . interfaces . ImageLoader ; import com . wgw . photo . preview . interfaces . OnLongClickListener ; import java . io . File ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureLoader ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; public class PicturesAdapter extends RecyclerView . Adapter < PicturesAdapter . ViewHolder > { HistoryCommentActivity context ; List < Comment . PictureInfo > pictureInfos ; LinearLayoutManager linearLayoutManager ; public PicturesAdapter ( HistoryCommentActivity context , List < Comment . PictureInfo > pictureInfos , LinearLayoutManager linearLayoutManager ) { this . context = context ; this . pictureInfos = pictureInfos ; this . linearLayoutManager = linearLayoutManager ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new ViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_pictrues , parent , false ) ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { ImageView imageView = holder . imageView ; PictureLoader . with ( context ) . load ( pictureInfos . get ( position ) . img_src ) . into ( imageView ) ; holder . itemView . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { PhotoPreview . with ( context ) . sources ( pictureInfos ) . indicatorType ( IndicatorType . TEXT ) . showThumbnailViewMask ( true ) . fullScreen ( true ) . animDuration ( <NUM_LIT> ) . defaultShowPosition ( holder . getLayoutPosition ( ) ) . imageLoader ( new ImageLoader ( ) { @ Override public void onLoadImage ( int position , @ Nullable Object source , @ NonNull ImageView imageView ) { PictureLoader . with ( context ) . load ( pictureInfos . get ( position ) . img_src ) . into ( imageView ) ; } } ) . onPageChangeListener ( new ViewPager . OnPageChangeListener ( ) { @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { } @ Override public void onPageSelected ( int position ) { linearLayoutManager . scrollToPosition ( position ) ; } @ Override public void onPageScrollStateChanged ( int state ) { } } ) . onLongClickListener ( new OnLongClickListener ( ) { @ Override public boolean onLongClick ( int position , FrameLayout customViewRoot , ImageView imageView ) { String imgSrc = pictureInfos . get ( position ) . img_src ; File", "gt": "pictureFile = PictureStorage . getPictureFile ( context , imgSrc ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . danmaku ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . zip . Inflater ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; public class DanmakuManipulator { OkHttpClient httpClient ; public DanmakuManipulator ( ) { this . httpClient = OkHttpUtil . getHttpClient ( ) ; } public boolean findDanmaku ( long oid , long dmid , String accessKey ) throws IOException , ParserConfigurationException , SAXException { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Request request ; byte [ ] decompress ; if ( accessKey == null ) { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid ) . build ( ) ; } else { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid + \"<STR_LIT>\" + accessKey ) . build ( ) ; } decompress = decompress ( httpClient . newCall ( request ) . execute ( ) . body ( ) . bytes ( ) ) ; Document document = builder . parse ( new ByteArrayInputStream ( decompress ) ) ; NodeList nodeList = document . getDocumentElement ( ) . getElementsByTagName ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < nodeList . getLength ( ) ; i ++ ) { Element element = ( Element ) nodeList . item ( i ) ; String p = element . getAttribute ( \"<STR_LIT>\" ) ; String thisDmid = p . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; System . out . println ( thisDmid ) ; if ( Long . parseLong ( thisDmid ) == dmid ) { return true ; } } return false ; } public static byte [ ] decompress ( byte [ ] data ) throws IOException { byte [ ] decompressData = null ; Inflater decompressor = new Inflater ( true ) ; decompressor . reset ( ) ; decompressor . setInput ( data ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( data . length ) ; try { byte [ ] buf = new byte [ <NUM_LIT> ] ; while", "gt": "( ! decompressor . finished ( ) ) {", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class ReviewCommentStatusTask extends BackstageTask < ReviewCommentStatusTask . EventHandler > { private CommentManipulator commentManipulator ; private StatisticsDBOpenHelper statisticsDB ; private HistoryComment historyComment ; public ReviewCommentStatusTask ( EventHandler handle , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_UNDER_REVIEW , rootComment ) ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , rootComment ) ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_OK , rootComment ) ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , rootComment ) ; } } else { GeneralResponse", "gt": "< CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentLocator { public static void lunch ( Context context , int areaType , long oid , long rpid , long root , String sourceId ) { Intent intent = new Intent ( ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_DOCUMENT ) ; Bundle extras = new Bundle ( ) ; if ( areaType == CommentArea . AREA_TYPE_VIDEO ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; } else if ( areaType == CommentArea . AREA_TYPE_DYNAMIC11 || areaType == CommentArea . AREA_TYPE_DYNAMIC17 ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( areaType ) ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" + sourceId ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( areaType == CommentArea . AREA_TYPE_ARTICLE ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras", "gt": ". putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . ImageView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . viewpager . widget . ViewPager ; import com . wgw . photo . preview . IndicatorType ; import com . wgw . photo . preview . PhotoPreview ; import com . wgw . photo . preview . interfaces . IFindThumbnailView ; import com . wgw . photo . preview . interfaces . ImageLoader ; import com . wgw . photo . preview . interfaces . OnLongClickListener ; import java . io . File ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureLoader ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; public class PicturesAdapter extends RecyclerView . Adapter < PicturesAdapter . ViewHolder > { HistoryCommentActivity context ; List < Comment . PictureInfo > pictureInfos ; LinearLayoutManager linearLayoutManager ; public PicturesAdapter ( HistoryCommentActivity context , List < Comment . PictureInfo > pictureInfos , LinearLayoutManager linearLayoutManager ) { this . context = context ; this . pictureInfos = pictureInfos ; this . linearLayoutManager = linearLayoutManager ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new ViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_pictrues , parent , false ) ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { ImageView imageView = holder . imageView ; PictureLoader . with ( context ) . load ( pictureInfos . get ( position ) . img_src ) . into ( imageView ) ; holder . itemView . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { PhotoPreview . with ( context ) . sources ( pictureInfos ) . indicatorType ( IndicatorType . TEXT ) . showThumbnailViewMask ( true ) . fullScreen ( true ) . animDuration ( <NUM_LIT> ) . defaultShowPosition ( holder . getLayoutPosition ( ) ) . imageLoader ( new ImageLoader ( ) { @ Override public void onLoadImage ( int position , @ Nullable Object source , @ NonNull ImageView imageView ) { PictureLoader . with ( context ) . load ( pictureInfos . get ( position ) . img_src ) . into ( imageView ) ; } } ) . onPageChangeListener ( new ViewPager . OnPageChangeListener ( ) { @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { } @ Override public void onPageSelected ( int position ) { linearLayoutManager . scrollToPosition ( position ) ; } @ Override public void onPageScrollStateChanged ( int state ) { } } ) . onLongClickListener ( new OnLongClickListener ( ) { @ Override public boolean onLongClick ( int position , FrameLayout customViewRoot , ImageView imageView ) { String imgSrc = pictureInfos . get ( position ) . img_src ; File pictureFile = PictureStorage . getPictureFile ( context , imgSrc ) ; context . savePicFileLauncher . launch ( pictureFile ) ; return false ; } } )", "gt": ". build ( ) . show ( new IFindThumbnailView ( ) {", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentLocator { public static void lunch ( Context context , int areaType , long oid , long rpid , long root , String sourceId ) { Intent intent = new Intent ( ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_DOCUMENT ) ; Bundle extras = new Bundle ( ) ; if ( areaType == CommentArea . AREA_TYPE_VIDEO ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; } else if ( areaType == CommentArea . AREA_TYPE_DYNAMIC11 || areaType == CommentArea . AREA_TYPE_DYNAMIC17 ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; extras", "gt": ". putString ( \"<STR_LIT>\" , String . valueOf ( areaType ) ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentLocator { public static void lunch ( Context context , int areaType , long oid , long rpid , long root , String sourceId ) { Intent intent = new Intent ( ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_DOCUMENT ) ; Bundle extras = new Bundle ( ) ; if ( areaType == CommentArea . AREA_TYPE_VIDEO ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; } else if ( areaType == CommentArea . AREA_TYPE_DYNAMIC11 || areaType == CommentArea . AREA_TYPE_DYNAMIC17 ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( areaType ) ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" + sourceId ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( areaType == CommentArea . AREA_TYPE_ARTICLE ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( areaType ) ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras", "gt": ". putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentLocator { public static void lunch ( Context context , int areaType , long oid , long rpid , long root , String sourceId ) { Intent intent = new Intent ( ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_DOCUMENT ) ; Bundle extras = new Bundle ( ) ; if ( areaType == CommentArea . AREA_TYPE_VIDEO ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; } else if ( areaType == CommentArea . AREA_TYPE_DYNAMIC11 || areaType == CommentArea . AREA_TYPE_DYNAMIC17 ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras", "gt": ". putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class ReviewCommentStatusTask extends BackstageTask < ReviewCommentStatusTask . EventHandler > { private CommentManipulator commentManipulator ; private StatisticsDBOpenHelper statisticsDB ; private HistoryComment historyComment ; public ReviewCommentStatusTask ( EventHandler handle , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_UNDER_REVIEW , rootComment ) ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , rootComment ) ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_OK , rootComment ) ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , rootComment ) ; } } else { GeneralResponse < CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , false ) ; if ( foundReply != null ) { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_INVISIBLE , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , foundReply ) ; } else { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_NORMAL , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler", "gt": ". sendEventMessage ( EventHandler . WHAT_REPLY_OK , foundReply ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . danmaku ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . zip . Inflater ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; public class DanmakuManipulator { OkHttpClient httpClient ; public DanmakuManipulator ( ) { this . httpClient = OkHttpUtil . getHttpClient ( ) ; } public boolean findDanmaku ( long oid , long dmid , String accessKey ) throws IOException , ParserConfigurationException , SAXException { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Request request ; byte [ ] decompress ; if ( accessKey == null ) { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid ) . build ( ) ; } else { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid + \"<STR_LIT>\" + accessKey ) . build ( ) ; } decompress = decompress ( httpClient . newCall ( request ) . execute ( ) . body ( ) . bytes ( ) ) ; Document document = builder . parse ( new ByteArrayInputStream ( decompress ) ) ; NodeList nodeList = document . getDocumentElement ( ) . getElementsByTagName ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i", "gt": "< nodeList . getLength ( ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class ReviewCommentStatusTask extends BackstageTask < ReviewCommentStatusTask . EventHandler > { private CommentManipulator commentManipulator ; private StatisticsDBOpenHelper statisticsDB ; private HistoryComment historyComment ; public ReviewCommentStatusTask ( EventHandler handle , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_UNDER_REVIEW , rootComment ) ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , rootComment ) ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_OK , rootComment ) ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , rootComment ) ; } } else { GeneralResponse < CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , false ) ; if ( foundReply != null ) { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_INVISIBLE , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , foundReply ) ; } else { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_NORMAL , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_REPLY_OK , foundReply ) ; } } else { BiliComment foundReplyHasAcc = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , true ) ; if ( foundReplyHasAcc != null ) { statisticsDB", "gt": ". updateHistoryCommentStates ( foundReplyHasAcc . rpid , HistoryComment . STATE_SHADOW_BAN , foundReplyHasAcc . like , foundReplyHasAcc . rcount , new Date ( ) ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentLocator { public static void lunch ( Context context , int areaType , long oid , long rpid , long root , String sourceId ) { Intent intent = new Intent ( ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_DOCUMENT ) ; Bundle extras = new Bundle ( ) ; if ( areaType == CommentArea . AREA_TYPE_VIDEO ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; } else if ( areaType == CommentArea . AREA_TYPE_DYNAMIC11 || areaType == CommentArea . AREA_TYPE_DYNAMIC17 ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( areaType ) ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" + sourceId ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( areaType == CommentArea . AREA_TYPE_ARTICLE ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( areaType ) ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras", "gt": ". putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import android . util . Log ; import androidx . annotation . Nullable ; import retrofit2 . Call ; import retrofit2 . Callback ; import retrofit2 . HttpException ; import retrofit2 . Response ; public abstract class BiliApiCallback < T > implements Callback < T > { public boolean isCancel ( ) { return false ; } public abstract void onError ( Throwable th ) ; @ Override public void onFailure ( @ Nullable Call < T > call , Throwable th ) { if ( isCancel ( ) ) { return ; } if ( call != null ) { Log . e ( \"<STR_LIT>\" , call . request ( ) . url ( ) + \"<STR_LIT>\" + th . getMessage ( ) ) ; } else { Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" , th ) ; } onError ( th ) ; } @ Override public void onResponse ( @ Nullable Call < T > call , Response < T > response ) { if ( isCancel ( ) ) { return ; } if ( ! response . isSuccessful ( ) ) { onFailure ( call , new HttpException ( response ) ) ; return ; } onSuccess", "gt": "( response . body ( ) ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . danmaku ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . zip . Inflater ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; public class DanmakuManipulator { OkHttpClient httpClient ; public DanmakuManipulator ( ) { this . httpClient = OkHttpUtil . getHttpClient ( ) ; } public boolean findDanmaku ( long oid , long dmid , String accessKey ) throws IOException , ParserConfigurationException , SAXException { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Request request ; byte [ ] decompress ; if ( accessKey == null ) { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid ) . build ( ) ; } else { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid + \"<STR_LIT>\" + accessKey ) . build ( ) ; } decompress = decompress ( httpClient . newCall ( request ) . execute ( ) . body ( ) . bytes ( ) ) ; Document document = builder . parse ( new ByteArrayInputStream ( decompress ) ) ; NodeList nodeList = document . getDocumentElement ( ) . getElementsByTagName ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < nodeList . getLength ( ) ; i ++ ) { Element element = ( Element ) nodeList . item ( i ) ; String p = element . getAttribute ( \"<STR_LIT>\" ) ; String thisDmid = p . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; System . out . println ( thisDmid ) ; if ( Long . parseLong ( thisDmid ) == dmid ) { return true ; } } return false ; } public static byte [ ] decompress ( byte [ ] data ) throws IOException { byte [ ] decompressData = null ; Inflater decompressor = new Inflater ( true ) ; decompressor . reset ( ) ; decompressor . setInput ( data ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( data . length ) ; try { byte", "gt": "[ ] buf = new byte [ <NUM_LIT> ] ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . ImageView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . viewpager . widget . ViewPager ; import com . wgw . photo . preview . IndicatorType ; import com . wgw . photo . preview . PhotoPreview ; import com . wgw . photo . preview . interfaces . IFindThumbnailView ; import com . wgw . photo . preview . interfaces . ImageLoader ; import com . wgw . photo . preview . interfaces . OnLongClickListener ; import java . io . File ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureLoader ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; public class PicturesAdapter extends RecyclerView . Adapter < PicturesAdapter . ViewHolder > { HistoryCommentActivity context ; List < Comment . PictureInfo > pictureInfos ; LinearLayoutManager linearLayoutManager ; public PicturesAdapter ( HistoryCommentActivity context , List < Comment . PictureInfo > pictureInfos , LinearLayoutManager linearLayoutManager ) { this . context = context ; this . pictureInfos = pictureInfos ; this . linearLayoutManager = linearLayoutManager ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new ViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_pictrues , parent , false ) ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { ImageView imageView = holder . imageView ; PictureLoader . with ( context ) . load ( pictureInfos . get ( position ) . img_src ) . into ( imageView ) ; holder . itemView . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { PhotoPreview . with ( context ) . sources ( pictureInfos ) . indicatorType ( IndicatorType . TEXT ) . showThumbnailViewMask ( true ) . fullScreen ( true ) . animDuration ( <NUM_LIT> ) . defaultShowPosition ( holder . getLayoutPosition ( ) ) . imageLoader ( new ImageLoader ( ) { @ Override public void onLoadImage ( int position , @ Nullable Object source , @ NonNull ImageView imageView ) { PictureLoader . with ( context ) . load ( pictureInfos . get ( position ) . img_src ) . into ( imageView ) ; } } ) . onPageChangeListener ( new ViewPager . OnPageChangeListener ( ) { @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { } @ Override public void onPageSelected ( int position ) { linearLayoutManager . scrollToPosition ( position ) ; } @ Override public void onPageScrollStateChanged ( int state ) { } } ) . onLongClickListener ( new OnLongClickListener ( ) { @ Override public boolean onLongClick ( int position , FrameLayout customViewRoot , ImageView imageView ) { String imgSrc = pictureInfos . get ( position ) . img_src ; File pictureFile = PictureStorage . getPictureFile ( context , imgSrc ) ; context", "gt": ". savePicFileLauncher . launch ( pictureFile ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import android . util . Log ; import androidx . annotation . Nullable ; import retrofit2 . Call ; import retrofit2 . Callback ; import retrofit2 . HttpException ; import retrofit2 . Response ; public abstract class BiliApiCallback < T > implements Callback < T > { public boolean isCancel ( ) { return false ; } public abstract void onError ( Throwable th ) ; @ Override public void onFailure ( @ Nullable Call < T > call , Throwable th ) { if ( isCancel ( ) ) { return ; } if ( call != null ) { Log . e ( \"<STR_LIT>\" , call . request ( ) . url ( ) + \"<STR_LIT>\" + th . getMessage ( ) ) ; } else { Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" , th ) ; } onError ( th ) ; } @ Override public void onResponse ( @ Nullable Call < T > call , Response < T > response ) { if ( isCancel ( ) ) { return ; } if", "gt": "( ! response . isSuccessful ( ) ) {", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . ImageView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . viewpager . widget . ViewPager ; import com . wgw . photo . preview . IndicatorType ; import com . wgw . photo . preview . PhotoPreview ; import com . wgw . photo . preview . interfaces . IFindThumbnailView ; import com . wgw . photo . preview . interfaces . ImageLoader ; import com . wgw . photo . preview . interfaces . OnLongClickListener ; import java . io . File ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureLoader ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; public class PicturesAdapter extends RecyclerView . Adapter < PicturesAdapter . ViewHolder > { HistoryCommentActivity context ; List < Comment . PictureInfo > pictureInfos ; LinearLayoutManager linearLayoutManager ; public PicturesAdapter ( HistoryCommentActivity context , List < Comment . PictureInfo > pictureInfos , LinearLayoutManager linearLayoutManager ) { this . context = context ; this . pictureInfos = pictureInfos ; this . linearLayoutManager = linearLayoutManager ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new ViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_pictrues , parent , false ) ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { ImageView imageView = holder . imageView ; PictureLoader . with ( context ) . load ( pictureInfos . get ( position ) . img_src ) . into ( imageView ) ; holder . itemView . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { PhotoPreview . with ( context ) . sources ( pictureInfos ) . indicatorType ( IndicatorType . TEXT ) . showThumbnailViewMask ( true ) . fullScreen ( true ) . animDuration ( <NUM_LIT> ) . defaultShowPosition ( holder . getLayoutPosition ( ) ) . imageLoader ( new ImageLoader ( ) { @ Override public void onLoadImage ( int position , @ Nullable Object source , @ NonNull ImageView imageView ) { PictureLoader . with ( context ) . load ( pictureInfos . get ( position ) . img_src ) . into ( imageView ) ; } } ) . onPageChangeListener ( new ViewPager . OnPageChangeListener ( ) { @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { } @ Override public void onPageSelected ( int position ) { linearLayoutManager . scrollToPosition ( position ) ; } @ Override public void onPageScrollStateChanged ( int state ) { } } ) . onLongClickListener ( new OnLongClickListener ( ) { @ Override public boolean onLongClick ( int position , FrameLayout customViewRoot , ImageView imageView ) { String imgSrc = pictureInfos . get ( position ) . img_src ; File pictureFile = PictureStorage . getPictureFile ( context , imgSrc ) ; context . savePicFileLauncher . launch ( pictureFile ) ; return false ; } } ) . build ( ) . show ( new IFindThumbnailView ( ) { @ Override public View findView ( int position ) { return", "gt": "linearLayoutManager . findViewByPosition ( position ) . findViewById ( R . id . picture ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . danmaku ; import android . os . Handler ; import org . xml . sax . SAXException ; import java . io . IOException ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; import javax . xml . parsers . ParserConfigurationException ; import icu . freedomIntrovert . biliSendCommAntifraud . NetworkCallBack ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class DanmakuPresenter { private Handler handler ; public DanmakuManipulator danmakuManipulator ; public StatisticsDBOpenHelper statisticsDBOpenHelper ; private boolean enableStatistics ; public long waitTime ; private Executor executor ; public DanmakuPresenter ( Handler handler , DanmakuManipulator danmakuManipulator , StatisticsDBOpenHelper statisticsDBOpenHelper , long waitTime , boolean enableStatistics ) { this . handler = handler ; this . danmakuManipulator = danmakuManipulator ; this . statisticsDBOpenHelper = statisticsDBOpenHelper ; this . enableStatistics = enableStatistics ; this . waitTime = waitTime ; executor = Executors . newSingleThreadExecutor ( ) ; } public void checkDanmaku ( long oid , long dmid , String content , String accessKey , long avid , CheckDanmakuCallBack callBack ) { executor . execute ( ( ) -> { try { handler . post ( ( ) -> callBack . onSleeping ( waitTime ) ) ; try { Thread . sleep ( waitTime ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } handler . post ( callBack :: onGettingNoAccountDMList ) ; if ( danmakuManipulator . findDanmaku ( oid , dmid , null ) ) { handler . post ( callBack :: thenOk ) ; } else { handler . post ( callBack :: onGettingHasAccountDMList ) ; if ( danmakuManipulator . findDanmaku ( oid , dmid , accessKey ) ) { handler . post ( callBack :: thenShadowBan ) ; } else { handler . post ( callBack :: thenDeleted ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; handler", "gt": ". post ( ( ) -> callBack . onNetworkError ( e ) ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentLocator { public static void lunch ( Context context , int areaType , long oid , long rpid , long root , String sourceId ) { Intent intent = new Intent ( ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_DOCUMENT ) ; Bundle extras = new Bundle ( ) ; if ( areaType == CommentArea . AREA_TYPE_VIDEO ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; } else if ( areaType == CommentArea . AREA_TYPE_DYNAMIC11 || areaType == CommentArea . AREA_TYPE_DYNAMIC17 ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( areaType ) ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" + sourceId ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras", "gt": ". putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class ReviewCommentStatusTask extends BackstageTask < ReviewCommentStatusTask . EventHandler > { private CommentManipulator commentManipulator ; private StatisticsDBOpenHelper statisticsDB ; private HistoryComment historyComment ; public ReviewCommentStatusTask ( EventHandler handle , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_UNDER_REVIEW , rootComment ) ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , rootComment ) ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_OK , rootComment ) ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , rootComment ) ; } } else { GeneralResponse < CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , false ) ; if ( foundReply != null ) { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_INVISIBLE , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler", "gt": ". sendEventMessage ( EventHandler . WHAT_INVISIBLE , foundReply ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . danmaku ; import android . os . Handler ; import org . xml . sax . SAXException ; import java . io . IOException ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; import javax . xml . parsers . ParserConfigurationException ; import icu . freedomIntrovert . biliSendCommAntifraud . NetworkCallBack ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class DanmakuPresenter { private Handler handler ; public DanmakuManipulator danmakuManipulator ; public StatisticsDBOpenHelper statisticsDBOpenHelper ; private boolean enableStatistics ; public long waitTime ; private Executor executor ; public DanmakuPresenter ( Handler handler , DanmakuManipulator danmakuManipulator , StatisticsDBOpenHelper statisticsDBOpenHelper , long waitTime , boolean enableStatistics ) { this . handler = handler ; this . danmakuManipulator = danmakuManipulator ; this . statisticsDBOpenHelper = statisticsDBOpenHelper ; this . enableStatistics = enableStatistics ; this . waitTime = waitTime ; executor = Executors . newSingleThreadExecutor ( ) ; } public void checkDanmaku ( long oid , long dmid , String content , String accessKey , long avid , CheckDanmakuCallBack callBack ) { executor . execute ( ( ) -> { try { handler . post ( ( ) -> callBack . onSleeping ( waitTime ) ) ; try { Thread . sleep ( waitTime ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } handler . post ( callBack :: onGettingNoAccountDMList ) ; if ( danmakuManipulator . findDanmaku ( oid , dmid , null ) ) { handler . post ( callBack :: thenOk ) ; } else { handler", "gt": ". post ( callBack :: onGettingHasAccountDMList ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class ReviewCommentStatusTask extends BackstageTask < ReviewCommentStatusTask . EventHandler > { private CommentManipulator commentManipulator ; private StatisticsDBOpenHelper statisticsDB ; private HistoryComment historyComment ; public ReviewCommentStatusTask ( EventHandler handle , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_UNDER_REVIEW , rootComment ) ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , rootComment ) ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_OK , rootComment ) ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , rootComment ) ; } } else { GeneralResponse < CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , false ) ; if ( foundReply != null ) { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_INVISIBLE , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , foundReply ) ; } else { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_NORMAL , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_REPLY_OK , foundReply ) ; } } else { BiliComment", "gt": "foundReplyHasAcc = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , true ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentLocator { public static void lunch ( Context context , int areaType , long oid , long rpid , long root , String sourceId ) { Intent intent = new Intent ( ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_DOCUMENT ) ; Bundle extras = new Bundle ( ) ; if ( areaType == CommentArea . AREA_TYPE_VIDEO ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; } else if ( areaType == CommentArea . AREA_TYPE_DYNAMIC11 || areaType == CommentArea . AREA_TYPE_DYNAMIC17 ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( areaType ) ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" + sourceId ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( areaType == CommentArea . AREA_TYPE_ARTICLE ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( areaType ) ) ; extras", "gt": ". putString ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import android . util . Log ; import androidx . annotation . Nullable ; import retrofit2 . Call ; import retrofit2 . Callback ; import retrofit2 . HttpException ; import retrofit2 . Response ; public abstract class BiliApiCallback < T > implements Callback < T > { public boolean isCancel ( ) { return false ; } public abstract void onError ( Throwable th ) ; @ Override public void onFailure ( @ Nullable Call < T > call , Throwable th ) { if ( isCancel ( ) ) { return ; } if ( call != null ) { Log . e ( \"<STR_LIT>\" , call . request ( ) . url ( ) + \"<STR_LIT>\" + th . getMessage ( ) ) ; } else { Log", "gt": ". e ( \"<STR_LIT>\" , \"<STR_LIT>\" , th ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentLocator { public static void lunch ( Context context , int areaType , long oid , long rpid , long root , String sourceId ) { Intent intent = new Intent ( ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_DOCUMENT ) ; Bundle extras = new Bundle ( ) ; if ( areaType == CommentArea . AREA_TYPE_VIDEO ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } else { extras . putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ; } extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; extras . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" + oid ) ; } else if ( areaType == CommentArea . AREA_TYPE_DYNAMIC11 || areaType == CommentArea . AREA_TYPE_DYNAMIC17 ) { intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( root != <NUM_LIT> ) { extras . putString ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; } else { extras", "gt": ". putString ( \"<STR_LIT>\" , String . valueOf ( rpid ) ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . danmaku ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . zip . Inflater ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; public class DanmakuManipulator { OkHttpClient httpClient ; public DanmakuManipulator ( ) { this . httpClient = OkHttpUtil . getHttpClient ( ) ; } public boolean findDanmaku ( long oid , long dmid , String accessKey ) throws IOException , ParserConfigurationException , SAXException { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Request request ; byte [ ] decompress ; if ( accessKey == null ) { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid ) . build ( ) ; } else { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid + \"<STR_LIT>\" + accessKey ) . build ( ) ; } decompress = decompress ( httpClient . newCall ( request ) . execute ( ) . body ( ) . bytes ( ) ) ; Document document = builder . parse ( new ByteArrayInputStream ( decompress ) ) ; NodeList nodeList = document . getDocumentElement ( ) . getElementsByTagName ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < nodeList . getLength ( ) ; i ++ ) { Element", "gt": "element = ( Element ) nodeList . item ( i ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . ImageView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . viewpager . widget . ViewPager ; import com . wgw . photo . preview . IndicatorType ; import com . wgw . photo . preview . PhotoPreview ; import com . wgw . photo . preview . interfaces . IFindThumbnailView ; import com . wgw . photo . preview . interfaces . ImageLoader ; import com . wgw . photo . preview . interfaces . OnLongClickListener ; import java . io . File ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureLoader ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; public class PicturesAdapter extends RecyclerView . Adapter < PicturesAdapter . ViewHolder > { HistoryCommentActivity context ; List < Comment . PictureInfo > pictureInfos ; LinearLayoutManager linearLayoutManager ; public PicturesAdapter ( HistoryCommentActivity context , List < Comment . PictureInfo > pictureInfos , LinearLayoutManager linearLayoutManager ) { this . context = context ; this . pictureInfos = pictureInfos ; this . linearLayoutManager = linearLayoutManager ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new ViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_pictrues , parent , false ) ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { ImageView imageView = holder . imageView ; PictureLoader . with ( context ) . load ( pictureInfos . get ( position ) . img_src ) . into ( imageView ) ; holder . itemView . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { PhotoPreview . with ( context ) . sources ( pictureInfos ) . indicatorType ( IndicatorType . TEXT ) . showThumbnailViewMask ( true ) . fullScreen ( true ) . animDuration ( <NUM_LIT> ) . defaultShowPosition ( holder . getLayoutPosition ( ) ) . imageLoader ( new ImageLoader ( ) { @ Override public void onLoadImage ( int position , @ Nullable Object source , @ NonNull ImageView imageView ) { PictureLoader", "gt": ". with ( context ) . load ( pictureInfos . get ( position ) . img_src ) . into ( imageView ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async ; import android . content . DialogInterface ; import java . io . IOException ; import icu . freedomIntrovert . async . EventHandler ; public abstract class BiliBiliApiRequestHandler extends EventHandler { ErrorHandle errorHandle ; public BiliBiliApiRequestHandler ( ErrorHandle errorHandle ) { this . errorHandle = errorHandle ; } public void setErrorHandle ( ErrorHandle errorHandle ) { this . errorHandle = errorHandle ; } @ Override public void handleError ( Throwable th ) { th . printStackTrace ( ) ; if ( errorHandle != null ) { if ( th instanceof CookieFailedException ) { errorHandle . handleCookieFiledException ( ( CookieFailedException ) th ) ; } else if ( th instanceof BiliBiliApiException ) { errorHandle . handleBiliBiliApiException ( ( BiliBiliApiException ) th ) ; } else if ( th instanceof IOException ) { errorHandle . handleNetIOException ( ( IOException ) th ) ; } else { errorHandle . handleOtherExceptions ( th ) ; } } } public interface ErrorHandle { void handleNetIOException ( IOException e ) ; void handleCookieFiledException ( CookieFailedException e ) ; void handleBiliBiliApiException ( BiliBiliApiException e ) ; void handleOtherExceptions ( Throwable th ) ; } public static class DialogErrorHandle implements ErrorHandle { DialogInterface toDismissDialog ; public interface OnDialogMessageListener { void dialogMessage ( String title , String message ) ; } public OnDialogMessageListener listener ; public DialogErrorHandle ( DialogInterface toDismissDialog , OnDialogMessageListener listener ) { this . toDismissDialog = toDismissDialog ; this . listener = listener ; } @ Override public void handleNetIOException ( IOException e ) { toDismissDialog . dismiss ( ) ; listener . dialogMessage ( \"<STR_LIT>\" , e . getMessage ( ) ) ; } @ Override public void handleCookieFiledException ( CookieFailedException e ) { toDismissDialog . dismiss ( ) ; listener", "gt": ". dialogMessage ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . danmaku ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . zip . Inflater ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; public class DanmakuManipulator { OkHttpClient httpClient ; public DanmakuManipulator ( ) { this . httpClient = OkHttpUtil . getHttpClient ( ) ; } public boolean findDanmaku ( long oid , long dmid , String accessKey ) throws IOException , ParserConfigurationException , SAXException { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Request request ; byte [ ] decompress ; if ( accessKey == null ) { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid ) . build ( ) ; } else { request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + oid + \"<STR_LIT>\" + accessKey ) . build ( ) ; } decompress = decompress ( httpClient . newCall ( request ) . execute ( ) . body ( ) . bytes ( ) ) ; Document document = builder . parse ( new ByteArrayInputStream ( decompress ) ) ; NodeList nodeList = document . getDocumentElement ( ) . getElementsByTagName ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < nodeList . getLength ( ) ; i ++ ) { Element element = ( Element ) nodeList . item ( i ) ; String p = element . getAttribute ( \"<STR_LIT>\" ) ; String thisDmid = p . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; System . out . println ( thisDmid ) ; if ( Long . parseLong ( thisDmid ) == dmid ) { return true ; } } return false ; } public static byte [ ] decompress ( byte [ ] data ) throws IOException { byte [ ] decompressData = null ; Inflater decompressor = new Inflater ( true ) ; decompressor . reset ( ) ; decompressor . setInput ( data ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( data . length ) ; try { byte [ ] buf = new byte [ <NUM_LIT> ] ; while ( ! decompressor . finished ( ) ) { int i = decompressor . inflate ( buf ) ; outputStream . write ( buf , <NUM_LIT> , i ) ; } decompressData", "gt": "= outputStream . toByteArray ( ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class ReviewCommentStatusTask extends BackstageTask < ReviewCommentStatusTask . EventHandler > { private CommentManipulator commentManipulator ; private StatisticsDBOpenHelper statisticsDB ; private HistoryComment historyComment ; public ReviewCommentStatusTask ( EventHandler handle , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_UNDER_REVIEW , rootComment ) ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , rootComment ) ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_OK , rootComment ) ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler", "gt": ". sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , rootComment ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class ReviewCommentStatusTask extends BackstageTask < ReviewCommentStatusTask . EventHandler > { private CommentManipulator commentManipulator ; private StatisticsDBOpenHelper statisticsDB ; private HistoryComment historyComment ; public ReviewCommentStatusTask ( EventHandler handle , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_UNDER_REVIEW , rootComment ) ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , rootComment ) ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_OK , rootComment ) ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , rootComment ) ; } } else { GeneralResponse < CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , false ) ; if ( foundReply != null ) { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_INVISIBLE , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_INVISIBLE , foundReply ) ; } else { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_NORMAL , foundReply . like , foundReply . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_REPLY_OK , foundReply ) ; } } else { BiliComment foundReplyHasAcc = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , true ) ; if ( foundReplyHasAcc != null ) { statisticsDB . updateHistoryCommentStates ( foundReplyHasAcc . rpid , HistoryComment . STATE_SHADOW_BAN , foundReplyHasAcc . like , foundReplyHasAcc . rcount , new Date ( ) ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_SHADOW_BANNED , foundReplyHasAcc ) ; } else { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_DELETED , historyComment . like , historyComment . replyCount , new Date ( ) ) ; eventHandler", "gt": ". sendEmptyEventMessage ( EventHandler . WHAT_DELETED ) ;", "repo": "biliSendCommAntifraud"}
{"input": "package com . wmods . wppenhacer . xposed . features . customization ; import android . graphics . Color ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . NinePatchDrawable ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . List ; import java . util . Objects ; import java . util . Properties ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class BubbleColors extends Feature { public BubbleColors ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } private static void replaceColor ( String drawableName , int color ) { try { var drawable = DesignUtils . getDrawableByName ( drawableName ) ; if ( drawable == null ) return ; drawable . setTint ( color ) ; drawable . setColorFilter ( new PorterDuffColorFilter ( color , PorterDuff . Mode . SRC_IN ) ) ; DesignUtils . setReplacementDrawable ( drawableName , drawable ) ; } catch ( Exception ignored ) { } } @ Override public void doHook ( ) throws Exception { Properties properties = Utils . extractProperties ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) && ! Objects . equals ( properties . getProperty ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ) return ; boolean bubbleColor = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; int bubbleLeftColor = bubbleColor ? prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) : Color . parseColor ( DesignUtils . checkSystemColor ( properties . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; int bubbleRightColor = bubbleColor ? prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) : Color . parseColor ( DesignUtils . checkSystemColor ( properties . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; if ( bubbleRightColor != <NUM_LIT> ) { var ballons = List . of ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; for ( var balloon : ballons ) { replaceColor ( balloon , bubbleRightColor ) ; } } if ( bubbleLeftColor != <NUM_LIT> ) { var", "gt": "ballons = List . of ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . adapter . IGStatusAdapter ; public class IGStatusView extends FrameLayout { public HorizontalListView mStatusListView ; public IGStatusAdapter mStatusAdapter ; public IGStatusView ( @ NonNull Context context ) { super ( context ) ; init ( context ) ; } private void init ( Context context ) { mStatusListView = new HorizontalListView ( context ) ; var layoutParams = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ; mStatusListView . setLayoutParams ( layoutParams ) ; addView ( mStatusListView ) ; } @ Override public void setTranslationY ( float f ) { if ( this . getHeight ( ) > <NUM_LIT> ) { int", "gt": "v = f > ( ( float ) this . getHeight ( ) ) ? GONE : VISIBLE ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int", "gt": "top = child . getTop ( ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . core . components ; import android . app . AlertDialog ; import android . app . Dialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . View ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . Method ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class AlertDialogWpp { private static Method getAlertDialog ; private static Class < ? > alertDialogClass ; private static Method setItemsMethod ; private static boolean isAvailable ; private static Method setMessageMethod ; private static Method setNegativeButtonMethod ; private static Method setPositiveButtonMethod ; private final Context mContext ; private AlertDialog . Builder mAlertDialog ; private Object mAlertDialogWpp ; private Dialog mCreate ; public static void initDialog ( ClassLoader loader ) { try { getAlertDialog = Unobfuscator . loadMaterialAlertDialog ( loader ) ; alertDialogClass = getAlertDialog . getReturnType ( ) ; setItemsMethod = ReflectionUtils . findMethodUsingFilter ( alertDialogClass , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( DialogInterface . OnClickListener . class ) && method . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( CharSequence [ ] . class ) ) ; setMessageMethod = ReflectionUtils . findMethodUsingFilter ( alertDialogClass , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( CharSequence . class ) ) ; var buttons = ReflectionUtils . findAllMethodsUsingFilter ( alertDialogClass , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( DialogInterface . OnClickListener . class ) && method . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( CharSequence . class ) ) ; setNegativeButtonMethod = buttons [ <NUM_LIT> ] ; setPositiveButtonMethod = buttons [ <NUM_LIT> ] ; isAvailable = true ; } catch ( Throwable e ) { isAvailable = false ; XposedBridge . log ( e ) ; } } public AlertDialogWpp ( Context context ) { mContext = context ; if ( isSystemDialog ( ) ) { mAlertDialog = new AlertDialog . Builder ( context ) ; return ; } try { mAlertDialogWpp = getAlertDialog . invoke ( null , context ) ; setMessage ( null ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } } public Context getContext ( ) { return mContext ; } public static boolean isSystemDialog ( ) { return ! isAvailable ; } public AlertDialogWpp setTitle ( String title ) { if ( isSystemDialog ( ) ) { mAlertDialog . setTitle ( title ) ; return this ; } XposedHelpers . callMethod ( mAlertDialogWpp , \"<STR_LIT>\" , title ) ; return this ; } public AlertDialogWpp setMessage ( String message ) { if ( isSystemDialog ( ) ) { mAlertDialog . setMessage ( message ) ; return this ; } try { setMessageMethod . invoke ( mAlertDialogWpp , message ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return this ; } public AlertDialogWpp setItems ( CharSequence [ ] items , DialogInterface . OnClickListener listener ) { if ( isSystemDialog ( ) ) { mAlertDialog . setItems ( items , listener ) ; return this ; } try { setItemsMethod . invoke ( mAlertDialogWpp , listener , items ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return this ; } public AlertDialogWpp setNegativeButton ( CharSequence text , DialogInterface . OnClickListener listener ) { if ( isSystemDialog ( ) ) { mAlertDialog . setNegativeButton ( text , listener ) ; return this ; } try { setNegativeButtonMethod . invoke ( mAlertDialogWpp , listener , text ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return this ; } public AlertDialogWpp setPositiveButton ( CharSequence text , DialogInterface . OnClickListener listener ) { if ( isSystemDialog ( ) ) { mAlertDialog . setPositiveButton ( text , listener ) ; return this ; } try { setPositiveButtonMethod . invoke ( mAlertDialogWpp , listener , text ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return this ; } public AlertDialogWpp setView ( View view ) { if ( isSystemDialog ( ) ) { mAlertDialog . setView ( view ) ; return this ; } XposedHelpers . callMethod ( mAlertDialogWpp , \"<STR_LIT>\" , view ) ; return this ; } public Dialog create ( ) { if", "gt": "( mCreate != null ) return mCreate ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . features . customization ; import android . graphics . Color ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . NinePatchDrawable ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . List ; import java . util . Objects ; import java . util . Properties ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class BubbleColors extends Feature { public BubbleColors ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } private static void replaceColor ( String drawableName , int color ) { try { var drawable = DesignUtils . getDrawableByName ( drawableName ) ; if ( drawable == null ) return ; drawable . setTint ( color ) ; drawable . setColorFilter ( new PorterDuffColorFilter ( color , PorterDuff . Mode . SRC_IN ) ) ; DesignUtils . setReplacementDrawable ( drawableName , drawable ) ; } catch ( Exception ignored ) { } } @ Override public void doHook ( ) throws Exception { Properties properties = Utils . extractProperties ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) && ! Objects . equals ( properties . getProperty ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ) return ; boolean bubbleColor = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; int bubbleLeftColor = bubbleColor ? prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) : Color . parseColor ( DesignUtils . checkSystemColor ( properties . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; int bubbleRightColor = bubbleColor ? prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) : Color . parseColor ( DesignUtils . checkSystemColor ( properties . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; if ( bubbleRightColor != <NUM_LIT> ) { var ballons = List . of ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; for ( var balloon : ballons ) { replaceColor ( balloon , bubbleRightColor ) ; } } if ( bubbleLeftColor != <NUM_LIT> ) { var ballons = List . of ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; for ( var balloon : ballons ) { replaceColor ( balloon , bubbleLeftColor ) ; } } var methods = Unobfuscator . loadNineDrawableMethods ( classLoader ) ; for ( var method : methods ) { XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var draw = ( NinePatchDrawable ) param . getResult ( ) ; var", "gt": "right = ( boolean ) param . args [ <NUM_LIT> ] ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . view . Menu ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . Field ; import java . util . HashSet ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class MenuStatus extends Feature { public static HashSet < MenuItemStatus > menuStatuses = new HashSet < > ( ) ; public MenuStatus ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var mediaClass = Unobfuscator . loadStatusDownloadMediaClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + mediaClass . getName ( ) ) ; var menuStatusMethod = Unobfuscator . loadMenuStatusMethod ( classLoader ) ; logDebug ( \"<STR_LIT>\" + menuStatusMethod . getName ( ) ) ; var fieldFile = Unobfuscator . loadStatusDownloadFileField ( classLoader ) ; logDebug ( \"<STR_LIT>\" + fieldFile . getName ( ) ) ; var clazzSubMenu = Unobfuscator . loadStatusDownloadSubMenuClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + clazzSubMenu . getName ( ) ) ; var clazzMenu = Unobfuscator . loadStatusDownloadMenuClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + clazzMenu . getName ( ) ) ; var menuField = Unobfuscator . getFieldByType ( clazzSubMenu , clazzMenu ) ; logDebug ( \"<STR_LIT>\" + menuField . getName ( ) ) ; Class < ? > StatusPlaybackBaseFragmentClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; Class < ? > StatusPlaybackContactFragmentClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; var listStatusField = ReflectionUtils . getFieldsByExtendType ( StatusPlaybackContactFragmentClass , List . class ) . get ( <NUM_LIT> ) ; XposedBridge . hookMethod ( menuStatusMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { Object fragmentInstance ; Menu menu ; if ( param . args [ <NUM_LIT> ] instanceof Menu ) { menu = ( Menu ) param . args [ <NUM_LIT> ] ; fragmentInstance = param . thisObject ; } else { var clazz = param . thisObject . getClass ( ) ; Field subMenuField = ReflectionUtils . findFieldUsingFilter ( clazz , f -> f . getType ( ) == Object . class && clazzSubMenu . isInstance ( ReflectionUtils . getField ( f , param . thisObject ) ) ) ; Object", "gt": "subMenu = ReflectionUtils . getField ( subMenuField , param . thisObject ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . utils ; import android . util . Pair ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . function . Predicate ; import java . util . stream . Collectors ; import de . robv . android . xposed . XposedHelpers ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtils { public static Method findMethodUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Method [ ] findAllMethodsUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Method [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field findFieldUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Constructor [ ] findAllConstructorsUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Constructor [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Constructor [ <NUM_LIT> ] ; } public static Constructor findConstructorUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field [ ] findAllFieldsUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Field [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Field [ <NUM_LIT> ] ; } public static Method findMethodUsingFilterIfExists ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static Field findFieldUsingFilterIfExists ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static boolean isOverridden ( Method method ) { try { Class < ? > superclass = method . getDeclaringClass ( ) . getSuperclass ( ) ; if ( superclass == null ) return false ; Method parentMethod = superclass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; return ! parentMethod . equals ( method ) ; } catch ( NoSuchMethodException e ) { return false ; } } public static List < Field > getFieldsByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . collect ( Collectors . toList ( ) ) ; } public static List < Field > getFieldsByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . collect ( Collectors . toList ( ) ) ; } public static Field getFieldByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . findFirst ( ) . orElse ( null ) ; } public static Field getFieldByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . findFirst ( ) . orElse ( null ) ; } public static Object callMethod ( Method method , Object instance , Object ... args ) { try { return method . invoke ( instance , args ) ; } catch ( Exception e ) { return null ; } } public static Object getField ( Field loadProfileInfoField , Object thisObject ) { try { return loadProfileInfoField . get ( thisObject ) ; } catch ( Exception e ) { return null ; } } public static int findIndexOfType ( Object [ ] args , Class < ? > type ) { for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { if ( args [ i ] == null ) continue ; if ( args [ i ] instanceof Class ) { if ( type . isAssignableFrom ( ( Class ) args [ i ] ) ) return i ; continue ; } if ( type . isAssignableFrom ( args [ i ] . getClass ( ) ) ) return i ; } return - <NUM_LIT> ; } public static List < Pair < Integer , Object > > findArrayOfType ( Object [ ] args , Class < ? > type ) { var result = new ArrayList < Pair < Integer , Object > > ( ) ; for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { var arg = args [ i ] ; if ( arg == null ) continue ; if ( arg instanceof Class ) { if ( type . isAssignableFrom ( ( Class ) arg ) ) { result . add ( new Pair < > ( i , arg ) ) ; } continue ; } if ( type . isAssignableFrom ( arg . getClass ( ) ) || type . isInstance ( arg ) ) { result . add ( new Pair < > ( i , arg ) ) ; } } return result ; } public static boolean isCalledFromString ( String contains ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; var text = Arrays . toString ( trace ) ; return text . contains ( contains ) ; } public static boolean isCalledFromStrings ( String ... contains ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; var text = Arrays . toString ( trace ) ; for ( String s : contains ) { if ( text . contains ( s ) ) return true ; } return false ; } public static boolean isClassSimpleNameString ( Class < ? > aClass , String s ) { try { Class < ? > search = XposedHelpers . findClassIfExists ( \"<STR_LIT>\" + s , aClass . getClassLoader ( ) ) ; if", "gt": "( search != null ) search = XposedHelpers . findClassIfExists ( \"<STR_LIT>\" + s , aClass . getClassLoader ( ) ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . view . Menu ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . Field ; import java . util . HashSet ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class MenuStatus extends Feature { public static HashSet < MenuItemStatus > menuStatuses = new HashSet < > ( ) ; public MenuStatus ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var mediaClass = Unobfuscator . loadStatusDownloadMediaClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + mediaClass . getName ( ) ) ; var menuStatusMethod = Unobfuscator . loadMenuStatusMethod ( classLoader ) ; logDebug ( \"<STR_LIT>\" + menuStatusMethod . getName ( ) ) ; var fieldFile = Unobfuscator . loadStatusDownloadFileField ( classLoader ) ; logDebug ( \"<STR_LIT>\" + fieldFile . getName ( ) ) ; var clazzSubMenu = Unobfuscator . loadStatusDownloadSubMenuClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + clazzSubMenu . getName ( ) ) ; var clazzMenu = Unobfuscator . loadStatusDownloadMenuClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + clazzMenu . getName ( ) ) ; var menuField = Unobfuscator . getFieldByType ( clazzSubMenu , clazzMenu ) ; logDebug ( \"<STR_LIT>\" + menuField . getName ( ) ) ; Class < ? > StatusPlaybackBaseFragmentClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; Class < ? > StatusPlaybackContactFragmentClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; var listStatusField = ReflectionUtils . getFieldsByExtendType ( StatusPlaybackContactFragmentClass , List . class ) . get ( <NUM_LIT> ) ; XposedBridge . hookMethod ( menuStatusMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { Object fragmentInstance ; Menu menu ; if ( param . args [ <NUM_LIT> ] instanceof Menu ) { menu", "gt": "= ( Menu ) param . args [ <NUM_LIT> ] ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . ui . fragments ; import static com . wmods . wppenhacer . preference . ContactPickerPreference . REQUEST_CONTACT_PICKER ; import android . app . Activity ; import android . content . Intent ; import android . os . Bundle ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . preference . ContactPickerPreference ; import com . wmods . wppenhacer . ui . fragments . base . BasePreferenceFragment ; public class PrivacyFragment extends BasePreferenceFragment { @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { super . onCreatePreferences ( savedInstanceState , rootKey ) ; setPreferencesFromResource ( R . xml . fragment_privacy , rootKey ) ; } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super", "gt": ". onActivityResult ( requestCode , resultCode , data ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemLongClicked != null ) { mOnItemLongClicked . onItemLongClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } break ; } } } } ; private void fillList ( final int dx ) { int edge = <NUM_LIT> ; View child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; if ( child != null ) { edge = child . getRight ( ) ; } fillListRight ( edge , dx ) ; edge = <NUM_LIT> ; child = getChildAt ( <NUM_LIT> ) ; if ( child != null ) { edge = child . getLeft ( ) ; } fillListLeft ( edge , dx ) ; } private void fillListRight ( int rightEdge , final int dx ) { while ( rightEdge + dx < getWidth ( ) && mRightViewIndex < mAdapter . getCount ( ) ) { View child = mAdapter . getView ( mRightViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , - <NUM_LIT> ) ; rightEdge += child . getMeasuredWidth ( ) ; if ( mRightViewIndex == mAdapter . getCount ( ) - <NUM_LIT> ) { mMaxX = mCurrentX + rightEdge - getWidth ( ) ; } if ( mMaxX < <NUM_LIT> ) { mMaxX = <NUM_LIT> ; } mRightViewIndex ++ ; } } private void fillListLeft ( int leftEdge , final int dx ) { while", "gt": "( leftEdge + dx > <NUM_LIT> && mLeftViewIndex >= <NUM_LIT> ) {", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . view . Menu ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . Field ; import java . util . HashSet ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class MenuStatus extends Feature { public static HashSet < MenuItemStatus > menuStatuses = new HashSet < > ( ) ; public MenuStatus ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var mediaClass = Unobfuscator . loadStatusDownloadMediaClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + mediaClass . getName ( ) ) ; var menuStatusMethod = Unobfuscator . loadMenuStatusMethod ( classLoader ) ; logDebug ( \"<STR_LIT>\" + menuStatusMethod . getName ( ) ) ; var fieldFile = Unobfuscator . loadStatusDownloadFileField ( classLoader ) ; logDebug ( \"<STR_LIT>\" + fieldFile . getName ( ) ) ; var clazzSubMenu = Unobfuscator . loadStatusDownloadSubMenuClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + clazzSubMenu . getName ( ) ) ; var clazzMenu = Unobfuscator . loadStatusDownloadMenuClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + clazzMenu . getName ( ) ) ; var menuField = Unobfuscator . getFieldByType ( clazzSubMenu , clazzMenu ) ; logDebug ( \"<STR_LIT>\" + menuField . getName ( ) ) ; Class < ? > StatusPlaybackBaseFragmentClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; Class < ? > StatusPlaybackContactFragmentClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; var listStatusField = ReflectionUtils . getFieldsByExtendType ( StatusPlaybackContactFragmentClass , List . class ) . get ( <NUM_LIT> ) ; XposedBridge . hookMethod ( menuStatusMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { Object fragmentInstance ; Menu menu ; if ( param . args [ <NUM_LIT> ] instanceof Menu ) { menu = ( Menu ) param . args [ <NUM_LIT> ] ; fragmentInstance = param . thisObject ; } else { var clazz = param . thisObject . getClass ( ) ; Field subMenuField = ReflectionUtils . findFieldUsingFilter ( clazz , f -> f . getType ( ) == Object . class && clazzSubMenu . isInstance ( ReflectionUtils . getField ( f , param . thisObject ) ) ) ; Object subMenu = ReflectionUtils . getField ( subMenuField , param . thisObject ) ; menu", "gt": "= ( Menu ) ReflectionUtils . getField ( menuField , subMenu ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if", "gt": "( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) {", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . core ; import android . util . Log ; import androidx . annotation . NonNull ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public abstract class Feature { public final ClassLoader classLoader ; public final XSharedPreferences prefs ; public static boolean DEBUG = false ; public Feature ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { this . classLoader = classLoader ; this . prefs = preferences ; } public abstract void doHook ( ) throws Throwable ; @ NonNull public abstract String getPluginName ( ) ; public void logDebug ( Object object ) { if ( ! DEBUG ) return ; log ( object ) ; if ( object instanceof Throwable th ) { Log", "gt": ". i ( this . getPluginName ( ) , th . getMessage ( ) , th ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . utils ; import android . view . animation . AccelerateDecelerateInterpolator ; import android . view . animation . AccelerateInterpolator ; import android . view . animation . AlphaAnimation ; import android . view . animation . Animation ; import android . view . animation . AnimationSet ; import android . view . animation . BounceInterpolator ; import android . view . animation . RotateAnimation ; import android . view . animation . ScaleAnimation ; import android . view . animation . TranslateAnimation ; public class AnimationUtil { public static Animation getAnimation ( String animationName ) { return switch ( animationName . toLowerCase ( ) ) { case \"<STR_LIT>\" -> createFadeInAnimation ( ) ; case \"<STR_LIT>\" -> createFadeOutAnimation ( ) ; case \"<STR_LIT>\" -> createScaleUpAnimation ( ) ; case \"<STR_LIT>\" -> createSlideUpAnimation ( ) ; case \"<STR_LIT>\" -> createSlideRightToLeftAnimation ( ) ; case \"<STR_LIT>\" -> createRotateAnimation ( ) ; case \"<STR_LIT>\" -> createBounceAnimation ( ) ; case \"<STR_LIT>\" -> createShrinkAnimation ( ) ; case \"<STR_LIT>\" -> createFlipAnimation ( ) ; case \"<STR_LIT>\" -> createHyperspaceOutAnimation ( ) ; default -> null ; } ; } private static Animation createFadeInAnimation ( ) { AlphaAnimation anim = new AlphaAnimation ( <NUM_LIT> , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createFadeOutAnimation ( ) { AlphaAnimation anim = new AlphaAnimation ( <NUM_LIT> , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createScaleUpAnimation ( ) { ScaleAnimation anim = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createSlideUpAnimation ( ) { TranslateAnimation anim = new TranslateAnimation ( Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createSlideRightToLeftAnimation ( ) { TranslateAnimation anim = new TranslateAnimation ( Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createRotateAnimation ( ) { RotateAnimation anim = new RotateAnimation ( <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } public static Animation createBounceAnimation ( ) { ScaleAnimation scaleAnimation = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; scaleAnimation . setDuration ( <NUM_LIT> ) ; scaleAnimation . setInterpolator ( new BounceInterpolator ( ) ) ; AnimationSet animationSet = new AnimationSet ( true ) ; animationSet . addAnimation ( scaleAnimation ) ; animationSet . setFillAfter ( true ) ; return animationSet ; } private static Animation createShrinkAnimation ( ) { ScaleAnimation anim = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createFlipAnimation ( ) { ScaleAnimation anim = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , - <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; anim . setRepeatCount ( <NUM_LIT> ) ; anim . setRepeatMode ( Animation . REVERSE ) ; return anim ; } public static Animation createHyperspaceOutAnimation ( ) { ScaleAnimation firstScaleAnimation = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; firstScaleAnimation . setDuration ( <NUM_LIT> ) ; firstScaleAnimation . setInterpolator ( new AccelerateDecelerateInterpolator ( ) ) ; firstScaleAnimation . setFillAfter ( false ) ; ScaleAnimation secondScaleAnimation = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; secondScaleAnimation . setDuration ( <NUM_LIT> ) ; RotateAnimation rotateAnimation = new RotateAnimation ( <NUM_LIT> , - <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; rotateAnimation . setDuration ( <NUM_LIT> ) ; AnimationSet innerSet = new AnimationSet ( true ) ; innerSet . setInterpolator ( new AccelerateInterpolator ( ) ) ; innerSet . setStartOffset ( <NUM_LIT> ) ; innerSet . addAnimation ( secondScaleAnimation ) ; innerSet . addAnimation ( rotateAnimation ) ; AnimationSet", "gt": "outerSet = new AnimationSet ( false ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemLongClicked != null ) { mOnItemLongClicked . onItemLongClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } break ; } } } } ; private void fillList ( final int dx ) { int edge = <NUM_LIT> ; View child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; if ( child != null ) { edge = child . getRight ( ) ; } fillListRight ( edge , dx ) ; edge = <NUM_LIT> ; child = getChildAt ( <NUM_LIT> ) ; if ( child != null ) { edge = child . getLeft ( ) ; } fillListLeft ( edge , dx ) ; } private void fillListRight ( int rightEdge , final int dx ) { while", "gt": "( rightEdge + dx < getWidth ( ) && mRightViewIndex < mAdapter . getCount ( ) ) {", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . features . customization ; import android . graphics . Color ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . NinePatchDrawable ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . List ; import java . util . Objects ; import java . util . Properties ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class BubbleColors extends Feature { public BubbleColors ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } private static void replaceColor ( String drawableName , int color ) { try { var drawable = DesignUtils . getDrawableByName ( drawableName ) ; if ( drawable == null ) return ; drawable . setTint ( color ) ; drawable . setColorFilter ( new PorterDuffColorFilter ( color , PorterDuff . Mode . SRC_IN ) ) ; DesignUtils . setReplacementDrawable ( drawableName , drawable ) ; } catch ( Exception ignored ) { } } @ Override public void doHook ( ) throws Exception { Properties properties = Utils . extractProperties ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) && ! Objects . equals ( properties . getProperty ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ) return ; boolean bubbleColor = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; int bubbleLeftColor = bubbleColor ? prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) : Color . parseColor ( DesignUtils . checkSystemColor ( properties . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; int bubbleRightColor = bubbleColor ? prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) : Color . parseColor ( DesignUtils . checkSystemColor ( properties . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; if ( bubbleRightColor != <NUM_LIT> ) { var ballons = List . of ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; for ( var balloon : ballons ) { replaceColor ( balloon , bubbleRightColor ) ; } } if ( bubbleLeftColor != <NUM_LIT> ) { var ballons = List . of ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; for ( var balloon : ballons ) { replaceColor ( balloon , bubbleLeftColor ) ; } } var methods = Unobfuscator . loadNineDrawableMethods ( classLoader ) ; for ( var method : methods ) { XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var draw = ( NinePatchDrawable ) param . getResult ( ) ; var right = ( boolean ) param . args [ <NUM_LIT> ] ; if ( right ) { if ( bubbleRightColor == <NUM_LIT> ) return ; draw . setColorFilter ( new PorterDuffColorFilter ( bubbleRightColor , PorterDuff . Mode . SRC_IN ) ) ; } else { if ( bubbleLeftColor == <NUM_LIT> ) return ; draw", "gt": ". setColorFilter ( new PorterDuffColorFilter ( bubbleLeftColor , PorterDuff . Mode . SRC_IN ) ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemLongClicked != null ) { mOnItemLongClicked . onItemLongClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } break ; } } } } ; private void fillList ( final int dx ) { int edge = <NUM_LIT> ; View child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; if ( child != null ) { edge = child . getRight ( ) ; } fillListRight ( edge , dx ) ; edge = <NUM_LIT> ; child = getChildAt ( <NUM_LIT> ) ; if ( child != null ) { edge = child . getLeft ( ) ; } fillListLeft ( edge , dx ) ; } private void fillListRight ( int rightEdge , final int dx ) { while ( rightEdge + dx < getWidth ( ) && mRightViewIndex < mAdapter . getCount ( ) ) { View child = mAdapter . getView ( mRightViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , - <NUM_LIT> ) ; rightEdge += child . getMeasuredWidth ( ) ; if ( mRightViewIndex == mAdapter . getCount ( ) - <NUM_LIT> ) { mMaxX = mCurrentX + rightEdge - getWidth ( ) ; } if ( mMaxX < <NUM_LIT> ) { mMaxX = <NUM_LIT> ; } mRightViewIndex ++ ; } } private void fillListLeft ( int leftEdge , final int dx ) { while ( leftEdge + dx > <NUM_LIT> && mLeftViewIndex >= <NUM_LIT> ) { View child = mAdapter . getView ( mLeftViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , <NUM_LIT> ) ; leftEdge -= child . getMeasuredWidth ( ) ; mLeftViewIndex -- ; mDisplayOffset -= child . getMeasuredWidth ( ) ; } } private void removeNonVisibleItems ( final int dx ) { View child = getChildAt ( <NUM_LIT> ) ; while ( child != null && child . getRight ( ) + dx <= <NUM_LIT> ) { mDisplayOffset += child . getMeasuredWidth ( ) ; mRemovedViewQueue . offer ( child ) ; removeViewInLayout ( child ) ; mLeftViewIndex ++ ; child = getChildAt ( <NUM_LIT> ) ; } child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; while ( child != null && child . getLeft ( ) + dx >= getWidth ( ) ) { mRemovedViewQueue . offer ( child ) ; removeViewInLayout ( child ) ; mRightViewIndex -- ; child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; } } private void positionItems ( final int dx ) { if ( getChildCount ( ) > <NUM_LIT> ) { mDisplayOffset += dx ; int left = mDisplayOffset ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int childWidth = child . getMeasuredWidth ( ) ; child . layout ( left , <NUM_LIT> , left + childWidth , child . getMeasuredHeight ( ) ) ; left += childWidth ; } } } public synchronized void scrollTo ( int x ) { mScroller . startScroll ( mNextX , <NUM_LIT> , x - mNextX , <NUM_LIT> ) ; requestLayout ( ) ; } @ Override public boolean dispatchTouchEvent ( MotionEvent ev ) { boolean handled = mGesture . onTouchEvent ( ev ) ; return handled ; } protected boolean onFling ( MotionEvent e1 , MotionEvent e2 , float velocityX , float velocityY ) { synchronized ( HorizontalListView . this ) { mScroller . fling ( mNextX , <NUM_LIT> , ( int ) - velocityX , <NUM_LIT> , <NUM_LIT> , mMaxX , <NUM_LIT> , <NUM_LIT> ) ; } requestLayout ( ) ; return true ; } protected boolean onDown ( MotionEvent e ) { mScroller . forceFinished ( true ) ; return true ; } @ Override protected synchronized void onLayout ( boolean changed , int left , int top , int right , int bottom ) { super . onLayout ( changed , left , top , right , bottom ) ; if ( mAdapter == null ) { return ; } if ( mDataChanged ) { int oldCurrentX = mCurrentX ; initView ( ) ; removeAllViewsInLayout ( ) ; mNextX = oldCurrentX ; mDataChanged = false ; } if ( mScroller . computeScrollOffset ( ) ) { mNextX", "gt": "= mScroller . getCurrX ( ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . utils ; import android . util . Pair ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . function . Predicate ; import java . util . stream . Collectors ; import de . robv . android . xposed . XposedHelpers ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtils { public static Method findMethodUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Method [ ] findAllMethodsUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Method [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field findFieldUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Constructor [ ] findAllConstructorsUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Constructor [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Constructor [ <NUM_LIT> ] ; } public static Constructor findConstructorUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field [ ] findAllFieldsUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Field [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Field [ <NUM_LIT> ] ; } public static Method findMethodUsingFilterIfExists ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static Field findFieldUsingFilterIfExists ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static boolean isOverridden ( Method method ) { try { Class < ? > superclass = method . getDeclaringClass ( ) . getSuperclass ( ) ; if ( superclass == null ) return false ; Method parentMethod = superclass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; return ! parentMethod . equals ( method ) ; } catch ( NoSuchMethodException e ) { return false ; } } public static List < Field > getFieldsByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . collect ( Collectors . toList ( ) ) ; } public static List < Field > getFieldsByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . collect ( Collectors . toList ( ) ) ; } public static Field getFieldByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . findFirst ( ) . orElse ( null ) ; } public static Field getFieldByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . findFirst ( ) . orElse ( null ) ; } public static Object callMethod ( Method method , Object instance , Object ... args ) { try { return method . invoke ( instance , args ) ; } catch ( Exception e ) { return null ; } } public static Object getField ( Field loadProfileInfoField , Object thisObject ) { try { return loadProfileInfoField . get ( thisObject ) ; } catch ( Exception e ) { return null ; } } public static int findIndexOfType ( Object [ ] args , Class < ? > type ) { for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { if ( args [ i ] == null ) continue ; if ( args [ i ] instanceof Class ) { if ( type . isAssignableFrom ( ( Class ) args [ i ] ) ) return i ; continue ; } if ( type . isAssignableFrom ( args [ i ] . getClass ( ) ) ) return i ; } return - <NUM_LIT> ; } public static List < Pair < Integer , Object > > findArrayOfType ( Object [ ] args , Class < ? > type ) { var result = new ArrayList < Pair < Integer , Object > > ( ) ; for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { var arg = args [ i ] ; if ( arg == null ) continue ; if ( arg instanceof Class ) { if ( type . isAssignableFrom ( ( Class ) arg ) ) { result . add ( new Pair < > ( i , arg ) ) ; } continue ; } if ( type . isAssignableFrom ( arg . getClass ( ) ) || type . isInstance ( arg ) ) { result . add ( new Pair < > ( i , arg ) ) ; } } return result ; } public static boolean isCalledFromString ( String contains ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; var text = Arrays . toString ( trace ) ; return text . contains ( contains ) ; } public static boolean isCalledFromStrings ( String ... contains ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; var text = Arrays . toString ( trace ) ; for ( String s : contains ) { if ( text . contains ( s ) ) return true ; } return false ; } public static boolean isClassSimpleNameString ( Class < ? > aClass , String s ) { try { Class < ? > search = XposedHelpers . findClassIfExists ( \"<STR_LIT>\" + s , aClass . getClassLoader ( ) ) ; if ( search != null ) search = XposedHelpers . findClassIfExists ( \"<STR_LIT>\" + s , aClass . getClassLoader ( ) ) ; Class < ? > cls = aClass ; do { if ( search != null ) { if ( cls . getName ( ) . equals ( search . getName ( ) ) ) return true ; if ( cls . getName ( ) . startsWith ( \"<STR_LIT>\" ) || cls . getName ( ) . startsWith ( \"<STR_LIT>\" ) ) return false ; } else { if", "gt": "( cls . getSimpleName ( ) . contains ( s ) ) return true ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . utils ; import android . util . Pair ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . function . Predicate ; import java . util . stream . Collectors ; import de . robv . android . xposed . XposedHelpers ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtils { public static Method findMethodUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Method [ ] findAllMethodsUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Method [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field findFieldUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Constructor [ ] findAllConstructorsUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Constructor [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Constructor [ <NUM_LIT> ] ; } public static Constructor findConstructorUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field [ ] findAllFieldsUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Field [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Field [ <NUM_LIT> ] ; } public static Method findMethodUsingFilterIfExists ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static Field findFieldUsingFilterIfExists ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static boolean isOverridden ( Method method ) { try { Class < ? > superclass = method . getDeclaringClass ( ) . getSuperclass ( ) ; if ( superclass == null ) return false ; Method parentMethod = superclass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; return ! parentMethod . equals ( method ) ; } catch ( NoSuchMethodException e ) { return false ; } } public static List < Field > getFieldsByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . collect ( Collectors . toList ( ) ) ; } public static List < Field > getFieldsByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . collect ( Collectors . toList ( ) ) ; } public static Field getFieldByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . findFirst ( ) . orElse ( null ) ; } public static Field getFieldByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . findFirst ( ) . orElse ( null ) ; } public static Object callMethod ( Method method , Object instance , Object ... args ) { try { return method . invoke ( instance , args ) ; } catch ( Exception e ) { return null ; } } public static Object getField ( Field loadProfileInfoField , Object thisObject ) { try { return loadProfileInfoField . get ( thisObject ) ; } catch ( Exception e ) { return null ; } } public static int findIndexOfType ( Object [ ] args , Class < ? > type ) { for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { if ( args [ i ] == null ) continue ; if ( args [ i ] instanceof Class ) { if ( type . isAssignableFrom ( ( Class ) args [ i ] ) ) return i ; continue ; } if ( type . isAssignableFrom ( args [ i ] . getClass ( ) ) ) return i ; } return - <NUM_LIT> ; } public static List < Pair < Integer , Object > > findArrayOfType ( Object [ ] args , Class < ? > type ) { var result = new ArrayList < Pair < Integer , Object > > ( ) ; for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { var arg = args [ i ] ; if ( arg == null ) continue ; if ( arg instanceof Class ) { if ( type . isAssignableFrom ( ( Class ) arg ) ) { result . add ( new Pair < > ( i , arg ) ) ; } continue ; } if ( type . isAssignableFrom ( arg . getClass ( ) ) || type . isInstance ( arg ) ) { result . add ( new Pair < > ( i , arg ) ) ; } } return result ; } public static boolean isCalledFromString ( String contains ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; var", "gt": "text = Arrays . toString ( trace ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemLongClicked != null ) { mOnItemLongClicked . onItemLongClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } break ; } } } } ; private void fillList ( final int dx ) { int edge = <NUM_LIT> ; View child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; if ( child != null ) { edge = child . getRight ( ) ; } fillListRight ( edge , dx ) ; edge = <NUM_LIT> ; child = getChildAt ( <NUM_LIT> ) ; if ( child != null ) { edge = child . getLeft ( ) ; } fillListLeft ( edge , dx ) ; } private void fillListRight ( int rightEdge , final int dx ) { while ( rightEdge + dx < getWidth ( ) && mRightViewIndex < mAdapter . getCount ( ) ) { View child = mAdapter . getView ( mRightViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , - <NUM_LIT> ) ; rightEdge += child . getMeasuredWidth ( ) ; if ( mRightViewIndex == mAdapter . getCount ( ) - <NUM_LIT> ) { mMaxX = mCurrentX + rightEdge - getWidth ( ) ; } if ( mMaxX < <NUM_LIT> ) { mMaxX = <NUM_LIT> ; } mRightViewIndex ++ ; } } private void fillListLeft ( int leftEdge , final int dx ) { while ( leftEdge + dx > <NUM_LIT> && mLeftViewIndex >= <NUM_LIT> ) { View child = mAdapter . getView ( mLeftViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , <NUM_LIT> ) ; leftEdge -= child . getMeasuredWidth ( ) ; mLeftViewIndex -- ; mDisplayOffset -= child . getMeasuredWidth ( ) ; } } private void removeNonVisibleItems ( final int dx ) { View", "gt": "child = getChildAt ( <NUM_LIT> ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View", "gt": "child = getChildAt ( i ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . utils ; import android . view . animation . AccelerateDecelerateInterpolator ; import android . view . animation . AccelerateInterpolator ; import android . view . animation . AlphaAnimation ; import android . view . animation . Animation ; import android . view . animation . AnimationSet ; import android . view . animation . BounceInterpolator ; import android . view . animation . RotateAnimation ; import android . view . animation . ScaleAnimation ; import android . view . animation . TranslateAnimation ; public class AnimationUtil { public static Animation getAnimation ( String animationName ) { return switch ( animationName . toLowerCase ( ) ) { case \"<STR_LIT>\" -> createFadeInAnimation ( ) ; case \"<STR_LIT>\" -> createFadeOutAnimation ( ) ; case \"<STR_LIT>\" -> createScaleUpAnimation ( ) ; case \"<STR_LIT>\" -> createSlideUpAnimation ( ) ; case \"<STR_LIT>\" -> createSlideRightToLeftAnimation ( ) ; case \"<STR_LIT>\" -> createRotateAnimation ( ) ; case \"<STR_LIT>\" -> createBounceAnimation ( ) ; case \"<STR_LIT>\" -> createShrinkAnimation ( ) ; case \"<STR_LIT>\" -> createFlipAnimation ( ) ; case \"<STR_LIT>\" -> createHyperspaceOutAnimation ( ) ; default -> null ; } ; } private static Animation createFadeInAnimation ( ) { AlphaAnimation anim = new AlphaAnimation ( <NUM_LIT> , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createFadeOutAnimation ( ) { AlphaAnimation anim = new AlphaAnimation ( <NUM_LIT> , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createScaleUpAnimation ( ) { ScaleAnimation anim = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createSlideUpAnimation ( ) { TranslateAnimation anim = new TranslateAnimation ( Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createSlideRightToLeftAnimation ( ) { TranslateAnimation anim = new TranslateAnimation ( Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createRotateAnimation ( ) { RotateAnimation anim = new RotateAnimation ( <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } public static Animation createBounceAnimation ( ) { ScaleAnimation scaleAnimation = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; scaleAnimation . setDuration ( <NUM_LIT> ) ; scaleAnimation . setInterpolator ( new BounceInterpolator ( ) ) ; AnimationSet animationSet = new AnimationSet ( true ) ; animationSet . addAnimation ( scaleAnimation ) ; animationSet . setFillAfter ( true ) ; return animationSet ; } private static Animation createShrinkAnimation ( ) { ScaleAnimation anim = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createFlipAnimation ( ) { ScaleAnimation anim = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , - <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; anim . setRepeatCount ( <NUM_LIT> ) ; anim . setRepeatMode ( Animation . REVERSE ) ; return anim ; } public static Animation createHyperspaceOutAnimation ( ) { ScaleAnimation firstScaleAnimation = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; firstScaleAnimation . setDuration ( <NUM_LIT> ) ; firstScaleAnimation . setInterpolator ( new AccelerateDecelerateInterpolator ( ) ) ; firstScaleAnimation . setFillAfter ( false ) ; ScaleAnimation", "gt": "secondScaleAnimation = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . utils ; import android . util . Pair ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . function . Predicate ; import java . util . stream . Collectors ; import de . robv . android . xposed . XposedHelpers ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtils { public static Method findMethodUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Method [ ] findAllMethodsUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Method [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field findFieldUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Constructor [ ] findAllConstructorsUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Constructor [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Constructor [ <NUM_LIT> ] ; } public static Constructor findConstructorUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field [ ] findAllFieldsUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Field [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Field [ <NUM_LIT> ] ; } public static Method findMethodUsingFilterIfExists ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static Field findFieldUsingFilterIfExists ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static boolean isOverridden ( Method method ) { try { Class < ? > superclass = method . getDeclaringClass ( ) . getSuperclass ( ) ; if ( superclass == null ) return false ; Method parentMethod = superclass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; return ! parentMethod . equals ( method ) ; } catch ( NoSuchMethodException e ) { return false ; } } public static List < Field > getFieldsByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . collect ( Collectors . toList ( ) ) ; } public static List < Field > getFieldsByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . collect ( Collectors . toList ( ) ) ; } public static Field getFieldByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . findFirst ( ) . orElse ( null ) ; } public static Field getFieldByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . findFirst ( ) . orElse ( null ) ; } public static Object callMethod ( Method method , Object instance , Object ... args ) { try { return method . invoke ( instance , args ) ; } catch ( Exception e ) { return null ; } } public static Object getField ( Field loadProfileInfoField , Object thisObject ) { try { return loadProfileInfoField . get ( thisObject ) ; } catch ( Exception e ) { return null ; } } public static int findIndexOfType ( Object [ ] args , Class < ? > type ) { for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { if ( args [ i ] == null ) continue ; if ( args [ i ] instanceof Class ) { if ( type . isAssignableFrom ( ( Class ) args [ i ] ) ) return i ; continue ; } if ( type . isAssignableFrom ( args [ i ] . getClass ( ) ) ) return i ; } return - <NUM_LIT> ; } public static List < Pair < Integer , Object > > findArrayOfType ( Object [ ] args , Class < ? > type ) { var", "gt": "result = new ArrayList < Pair < Integer , Object > > ( ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . utils ; import android . util . Pair ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . function . Predicate ; import java . util . stream . Collectors ; import de . robv . android . xposed . XposedHelpers ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtils { public static Method findMethodUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Method [ ] findAllMethodsUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Method [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field findFieldUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Constructor [ ] findAllConstructorsUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Constructor [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Constructor [ <NUM_LIT> ] ; } public static Constructor findConstructorUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field [ ] findAllFieldsUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Field [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Field [ <NUM_LIT> ] ; } public static Method findMethodUsingFilterIfExists ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static Field findFieldUsingFilterIfExists ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static boolean isOverridden ( Method method ) { try { Class < ? > superclass = method . getDeclaringClass ( ) . getSuperclass ( ) ; if ( superclass == null ) return false ; Method parentMethod = superclass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; return ! parentMethod . equals ( method ) ; } catch ( NoSuchMethodException e ) { return false ; } } public static List < Field > getFieldsByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . collect ( Collectors . toList ( ) ) ; } public static List < Field > getFieldsByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . collect ( Collectors . toList ( ) ) ; } public static Field getFieldByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . findFirst ( ) . orElse ( null ) ; } public static Field getFieldByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . findFirst ( ) . orElse ( null ) ; } public static Object callMethod ( Method method , Object instance , Object ... args ) { try { return method . invoke ( instance , args ) ; } catch ( Exception e ) { return null ; } } public static Object getField ( Field loadProfileInfoField , Object thisObject ) { try { return loadProfileInfoField . get ( thisObject ) ; } catch ( Exception e ) { return null ; } } public static int findIndexOfType ( Object [ ] args , Class < ? > type ) { for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { if ( args [ i ] == null ) continue ; if ( args [ i ] instanceof Class ) { if ( type . isAssignableFrom ( ( Class ) args [ i ] ) ) return i ; continue ; } if ( type . isAssignableFrom ( args [ i ] . getClass ( ) ) ) return i ; } return - <NUM_LIT> ; } public static List < Pair < Integer , Object > > findArrayOfType ( Object [ ] args , Class < ? > type ) { var result = new ArrayList < Pair < Integer , Object > > ( ) ; for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { var arg = args [ i ] ; if ( arg == null ) continue ; if ( arg instanceof Class ) { if ( type . isAssignableFrom ( ( Class ) arg ) ) { result . add ( new Pair < > ( i , arg ) ) ; } continue ; } if ( type . isAssignableFrom ( arg . getClass ( ) ) || type . isInstance ( arg ) ) { result . add ( new Pair < > ( i , arg ) ) ; } } return result ; } public static boolean isCalledFromString ( String contains ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; var text = Arrays . toString ( trace ) ; return text . contains ( contains ) ; } public static boolean isCalledFromStrings ( String ... contains ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; var", "gt": "text = Arrays . toString ( trace ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemLongClicked != null ) { mOnItemLongClicked . onItemLongClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } break ; } } } } ; private void fillList ( final int dx ) { int edge = <NUM_LIT> ; View child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; if ( child != null ) { edge = child . getRight ( ) ; } fillListRight ( edge , dx ) ; edge = <NUM_LIT> ; child = getChildAt ( <NUM_LIT> ) ; if ( child != null ) { edge = child . getLeft ( ) ; } fillListLeft ( edge , dx ) ; } private void fillListRight ( int rightEdge , final int dx ) { while ( rightEdge + dx < getWidth ( ) && mRightViewIndex < mAdapter . getCount ( ) ) { View child = mAdapter . getView ( mRightViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , - <NUM_LIT> ) ; rightEdge += child . getMeasuredWidth ( ) ; if ( mRightViewIndex == mAdapter . getCount ( ) - <NUM_LIT> ) { mMaxX = mCurrentX + rightEdge - getWidth ( ) ; } if ( mMaxX < <NUM_LIT> ) { mMaxX = <NUM_LIT> ; } mRightViewIndex ++ ; } } private void fillListLeft ( int leftEdge , final int dx ) { while ( leftEdge + dx > <NUM_LIT> && mLeftViewIndex >= <NUM_LIT> ) { View", "gt": "child = mAdapter . getView ( mLeftViewIndex , mRemovedViewQueue . poll ( ) , this ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . features . customization ; import android . graphics . Color ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . NinePatchDrawable ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . List ; import java . util . Objects ; import java . util . Properties ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class BubbleColors extends Feature { public BubbleColors ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } private static void replaceColor ( String drawableName , int color ) { try { var drawable = DesignUtils . getDrawableByName ( drawableName ) ; if ( drawable == null ) return ; drawable . setTint ( color ) ; drawable . setColorFilter ( new PorterDuffColorFilter ( color , PorterDuff . Mode . SRC_IN ) ) ; DesignUtils . setReplacementDrawable ( drawableName , drawable ) ; } catch ( Exception ignored ) { } } @ Override public void doHook ( ) throws Exception { Properties properties = Utils . extractProperties ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) && ! Objects . equals ( properties . getProperty ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ) return ; boolean bubbleColor = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; int bubbleLeftColor = bubbleColor ? prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) : Color . parseColor ( DesignUtils . checkSystemColor ( properties . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; int bubbleRightColor = bubbleColor ? prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) : Color . parseColor ( DesignUtils . checkSystemColor ( properties . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; if ( bubbleRightColor != <NUM_LIT> ) { var ballons = List . of ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; for ( var balloon : ballons ) { replaceColor ( balloon , bubbleRightColor ) ; } } if ( bubbleLeftColor != <NUM_LIT> ) { var ballons = List . of ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; for ( var balloon : ballons ) { replaceColor ( balloon , bubbleLeftColor ) ; } } var methods = Unobfuscator . loadNineDrawableMethods ( classLoader ) ; for ( var method : methods ) { XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var draw = ( NinePatchDrawable ) param . getResult ( ) ; var right = ( boolean ) param . args [ <NUM_LIT> ] ; if ( right ) { if ( bubbleRightColor == <NUM_LIT> ) return ; draw", "gt": ". setColorFilter ( new PorterDuffColorFilter ( bubbleRightColor , PorterDuff . Mode . SRC_IN ) ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect", "gt": "viewRect = new Rect ( ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemLongClicked != null ) { mOnItemLongClicked . onItemLongClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } break ; } } } } ; private void fillList ( final int dx ) { int edge = <NUM_LIT> ; View child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; if ( child != null ) { edge = child . getRight ( ) ; } fillListRight ( edge , dx ) ; edge = <NUM_LIT> ; child = getChildAt ( <NUM_LIT> ) ; if ( child != null ) { edge = child . getLeft ( ) ; } fillListLeft ( edge , dx ) ; } private void fillListRight ( int rightEdge , final int dx ) { while ( rightEdge + dx < getWidth ( ) && mRightViewIndex < mAdapter . getCount ( ) ) { View child = mAdapter . getView ( mRightViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , - <NUM_LIT> ) ; rightEdge += child . getMeasuredWidth ( ) ; if ( mRightViewIndex == mAdapter . getCount ( ) - <NUM_LIT> ) { mMaxX = mCurrentX + rightEdge - getWidth ( ) ; } if ( mMaxX < <NUM_LIT> ) { mMaxX = <NUM_LIT> ; } mRightViewIndex ++ ; } } private void fillListLeft ( int leftEdge , final int dx ) { while ( leftEdge + dx > <NUM_LIT> && mLeftViewIndex >= <NUM_LIT> ) { View child = mAdapter . getView ( mLeftViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , <NUM_LIT> ) ; leftEdge -= child . getMeasuredWidth ( ) ; mLeftViewIndex -- ; mDisplayOffset -= child . getMeasuredWidth ( ) ; } } private void removeNonVisibleItems ( final int dx ) { View child = getChildAt ( <NUM_LIT> ) ; while", "gt": "( child != null && child . getRight ( ) + dx <= <NUM_LIT> ) {", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . adapter . IGStatusAdapter ; public class IGStatusView extends FrameLayout { public HorizontalListView mStatusListView ; public IGStatusAdapter mStatusAdapter ; public IGStatusView ( @ NonNull Context context ) { super ( context ) ; init ( context ) ; } private void init ( Context context ) { mStatusListView = new HorizontalListView ( context ) ; var layoutParams = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ; mStatusListView . setLayoutParams ( layoutParams ) ; addView ( mStatusListView ) ; } @ Override public void setTranslationY ( float f ) { if", "gt": "( this . getHeight ( ) > <NUM_LIT> ) {", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . ui . fragments ; import static com . wmods . wppenhacer . preference . ContactPickerPreference . REQUEST_CONTACT_PICKER ; import android . app . Activity ; import android . content . Intent ; import android . os . Bundle ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . preference . ContactPickerPreference ; import com . wmods . wppenhacer . ui . fragments . base . BasePreferenceFragment ; public class PrivacyFragment extends BasePreferenceFragment { @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { super", "gt": ". onCreatePreferences ( savedInstanceState , rootKey ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . utils ; import android . util . Pair ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . function . Predicate ; import java . util . stream . Collectors ; import de . robv . android . xposed . XposedHelpers ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtils { public static Method findMethodUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Method [ ] findAllMethodsUsingFilter ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Method [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field findFieldUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Constructor [ ] findAllConstructorsUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Constructor [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Constructor [ <NUM_LIT> ] ; } public static Constructor findConstructorUsingFilter ( Class < ? > clazz , Predicate < Constructor > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredConstructors ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } public static Field [ ] findAllFieldsUsingFilter ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . collect ( Collectors . toList ( ) ) ; if ( ! results . isEmpty ( ) ) return results . toArray ( new Field [ <NUM_LIT> ] ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return new Field [ <NUM_LIT> ] ; } public static Method findMethodUsingFilterIfExists ( Class < ? > clazz , Predicate < Method > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static Field findFieldUsingFilterIfExists ( Class < ? > clazz , Predicate < Field > predicate ) { do { var results = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( predicate ) . findFirst ( ) ; if ( results . isPresent ( ) ) return results . get ( ) ; } while ( ( clazz = clazz . getSuperclass ( ) ) != null ) ; return null ; } public static boolean isOverridden ( Method method ) { try { Class < ? > superclass = method . getDeclaringClass ( ) . getSuperclass ( ) ; if ( superclass == null ) return false ; Method parentMethod = superclass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; return ! parentMethod . equals ( method ) ; } catch ( NoSuchMethodException e ) { return false ; } } public static List < Field > getFieldsByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . collect ( Collectors . toList ( ) ) ; } public static List < Field > getFieldsByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . collect ( Collectors . toList ( ) ) ; } public static Field getFieldByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . findFirst ( ) . orElse ( null ) ; } public static Field getFieldByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type == f . getType ( ) ) . findFirst ( ) . orElse ( null ) ; } public static Object callMethod ( Method method , Object instance , Object ... args ) { try { return method . invoke ( instance , args ) ; } catch ( Exception e ) { return null ; } } public static Object getField ( Field loadProfileInfoField , Object thisObject ) { try { return loadProfileInfoField . get ( thisObject ) ; } catch ( Exception e ) { return null ; } } public static int findIndexOfType ( Object [ ] args , Class < ? > type ) { for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { if ( args [ i ] == null ) continue ; if ( args [ i ] instanceof Class ) { if ( type . isAssignableFrom ( ( Class ) args [ i ] ) ) return i ; continue ; } if ( type . isAssignableFrom ( args [ i ] . getClass ( ) ) ) return i ; } return - <NUM_LIT> ; } public static List < Pair < Integer , Object > > findArrayOfType ( Object [ ] args , Class < ? > type ) { var result = new ArrayList < Pair < Integer , Object > > ( ) ; for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { var arg = args [ i ] ; if ( arg == null ) continue ; if ( arg instanceof Class ) { if ( type . isAssignableFrom ( ( Class ) arg ) ) { result . add ( new Pair < > ( i , arg ) ) ; } continue ; } if ( type . isAssignableFrom ( arg . getClass ( ) ) || type . isInstance ( arg ) ) { result . add ( new Pair < > ( i , arg ) ) ; } } return result ; } public static boolean isCalledFromString ( String contains ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; var text = Arrays . toString ( trace ) ; return text . contains ( contains ) ; } public static boolean isCalledFromStrings ( String ... contains ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; var text = Arrays . toString ( trace ) ; for ( String s : contains ) { if ( text . contains ( s ) ) return true ; } return false ; } public static boolean isClassSimpleNameString ( Class < ? > aClass , String s ) { try { Class < ? > search = XposedHelpers . findClassIfExists ( \"<STR_LIT>\" + s , aClass . getClassLoader ( ) ) ; if ( search != null ) search = XposedHelpers . findClassIfExists ( \"<STR_LIT>\" + s , aClass . getClassLoader ( ) ) ; Class", "gt": "< ? > cls = aClass ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemLongClicked != null ) { mOnItemLongClicked . onItemLongClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } break ; } } } } ; private void fillList ( final int dx ) { int edge = <NUM_LIT> ; View", "gt": "child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . core . components ; import android . app . AlertDialog ; import android . app . Dialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . View ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . Method ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class AlertDialogWpp { private static Method getAlertDialog ; private static Class < ? > alertDialogClass ; private static Method setItemsMethod ; private static boolean isAvailable ; private static Method setMessageMethod ; private static Method setNegativeButtonMethod ; private static Method setPositiveButtonMethod ; private final Context mContext ; private AlertDialog . Builder mAlertDialog ; private Object mAlertDialogWpp ; private Dialog mCreate ; public static void initDialog ( ClassLoader loader ) { try { getAlertDialog = Unobfuscator . loadMaterialAlertDialog ( loader ) ; alertDialogClass = getAlertDialog . getReturnType ( ) ; setItemsMethod = ReflectionUtils . findMethodUsingFilter ( alertDialogClass , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( DialogInterface . OnClickListener . class ) && method . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( CharSequence [ ] . class ) ) ; setMessageMethod = ReflectionUtils . findMethodUsingFilter ( alertDialogClass , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( CharSequence . class ) ) ; var buttons = ReflectionUtils . findAllMethodsUsingFilter ( alertDialogClass , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( DialogInterface . OnClickListener . class ) && method . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( CharSequence . class ) ) ; setNegativeButtonMethod = buttons [ <NUM_LIT> ] ; setPositiveButtonMethod = buttons [ <NUM_LIT> ] ; isAvailable = true ; } catch ( Throwable e ) { isAvailable = false ; XposedBridge . log ( e ) ; } } public AlertDialogWpp ( Context context ) { mContext = context ; if ( isSystemDialog ( ) ) { mAlertDialog = new AlertDialog . Builder ( context ) ; return ; } try { mAlertDialogWpp = getAlertDialog . invoke ( null , context ) ; setMessage ( null ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } } public Context getContext ( ) { return mContext ; } public static boolean isSystemDialog ( ) { return ! isAvailable ; } public AlertDialogWpp setTitle ( String title ) { if ( isSystemDialog ( ) ) { mAlertDialog . setTitle ( title ) ; return this ; } XposedHelpers . callMethod ( mAlertDialogWpp , \"<STR_LIT>\" , title ) ; return this ; } public AlertDialogWpp setMessage ( String message ) { if ( isSystemDialog ( ) ) { mAlertDialog . setMessage ( message ) ; return this ; } try { setMessageMethod . invoke ( mAlertDialogWpp , message ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return this ; } public AlertDialogWpp setItems ( CharSequence [ ] items , DialogInterface . OnClickListener listener ) { if ( isSystemDialog ( ) ) { mAlertDialog . setItems ( items , listener ) ; return this ; } try { setItemsMethod . invoke ( mAlertDialogWpp , listener , items ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return this ; } public AlertDialogWpp setNegativeButton ( CharSequence text , DialogInterface . OnClickListener listener ) { if ( isSystemDialog ( ) ) { mAlertDialog . setNegativeButton ( text , listener ) ; return this ; } try { setNegativeButtonMethod . invoke ( mAlertDialogWpp , listener , text ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return this ; } public AlertDialogWpp setPositiveButton ( CharSequence text , DialogInterface . OnClickListener listener ) { if ( isSystemDialog ( ) ) { mAlertDialog . setPositiveButton ( text , listener ) ; return this ; } try { setPositiveButtonMethod . invoke ( mAlertDialogWpp , listener , text ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return this ; } public AlertDialogWpp setView ( View view ) { if ( isSystemDialog ( ) ) { mAlertDialog . setView ( view ) ; return this ; } XposedHelpers . callMethod ( mAlertDialogWpp , \"<STR_LIT>\" , view ) ; return this ; } public Dialog create ( ) { if ( mCreate != null ) return mCreate ; if ( isSystemDialog ( ) ) { mCreate = mAlertDialog . create ( ) ; } else { mCreate", "gt": "= ( Dialog ) XposedHelpers . callMethod ( mAlertDialogWpp , \"<STR_LIT>\" ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . view . Menu ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . Field ; import java . util . HashSet ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class MenuStatus extends Feature { public static HashSet < MenuItemStatus > menuStatuses = new HashSet < > ( ) ; public MenuStatus ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var mediaClass = Unobfuscator . loadStatusDownloadMediaClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + mediaClass . getName ( ) ) ; var menuStatusMethod = Unobfuscator . loadMenuStatusMethod ( classLoader ) ; logDebug ( \"<STR_LIT>\" + menuStatusMethod . getName ( ) ) ; var fieldFile = Unobfuscator . loadStatusDownloadFileField ( classLoader ) ; logDebug ( \"<STR_LIT>\" + fieldFile . getName ( ) ) ; var clazzSubMenu = Unobfuscator . loadStatusDownloadSubMenuClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + clazzSubMenu . getName ( ) ) ; var clazzMenu = Unobfuscator . loadStatusDownloadMenuClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + clazzMenu . getName ( ) ) ; var menuField = Unobfuscator . getFieldByType ( clazzSubMenu , clazzMenu ) ; logDebug ( \"<STR_LIT>\" + menuField . getName ( ) ) ; Class < ? > StatusPlaybackBaseFragmentClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; Class < ? > StatusPlaybackContactFragmentClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; var listStatusField = ReflectionUtils . getFieldsByExtendType ( StatusPlaybackContactFragmentClass , List . class ) . get ( <NUM_LIT> ) ; XposedBridge . hookMethod ( menuStatusMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { Object fragmentInstance ; Menu menu ; if ( param . args [ <NUM_LIT> ] instanceof Menu ) { menu = ( Menu ) param . args [ <NUM_LIT> ] ; fragmentInstance = param . thisObject ; } else { var clazz = param . thisObject . getClass ( ) ; Field subMenuField = ReflectionUtils . findFieldUsingFilter ( clazz , f -> f . getType ( ) == Object . class && clazzSubMenu . isInstance ( ReflectionUtils . getField ( f , param . thisObject ) ) ) ; Object subMenu = ReflectionUtils . getField ( subMenuField , param . thisObject ) ; menu = ( Menu ) ReflectionUtils . getField ( menuField , subMenu ) ; var fragment = ReflectionUtils . findFieldUsingFilter ( clazz , f -> StatusPlaybackBaseFragmentClass . isInstance ( ReflectionUtils . getField ( f , param . thisObject ) ) ) ; if ( fragment == null ) { logDebug ( \"<STR_LIT>\" ) ; return ; } fragmentInstance = fragment . get ( param . thisObject ) ; } var index = ( int ) XposedHelpers . getObjectField ( fragmentInstance , \"<STR_LIT>\" ) ; var listStatus = ( List ) listStatusField . get ( fragmentInstance ) ; var", "gt": "fMessage = new FMessageWpp ( listStatus . get ( index ) ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemLongClicked != null ) { mOnItemLongClicked . onItemLongClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } break ; } } } } ; private void fillList ( final int dx ) { int edge = <NUM_LIT> ; View child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; if ( child != null ) { edge = child . getRight ( ) ; } fillListRight ( edge , dx ) ; edge = <NUM_LIT> ; child = getChildAt ( <NUM_LIT> ) ; if ( child != null ) { edge = child . getLeft ( ) ; } fillListLeft ( edge , dx ) ; } private void fillListRight ( int rightEdge , final int dx ) { while ( rightEdge + dx < getWidth ( ) && mRightViewIndex < mAdapter . getCount ( ) ) { View child = mAdapter . getView ( mRightViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , - <NUM_LIT> ) ; rightEdge += child . getMeasuredWidth ( ) ; if ( mRightViewIndex == mAdapter . getCount ( ) - <NUM_LIT> ) { mMaxX = mCurrentX + rightEdge - getWidth ( ) ; } if ( mMaxX < <NUM_LIT> ) { mMaxX = <NUM_LIT> ; } mRightViewIndex ++ ; } } private void fillListLeft ( int leftEdge , final int dx ) { while ( leftEdge + dx > <NUM_LIT> && mLeftViewIndex >= <NUM_LIT> ) { View child = mAdapter . getView ( mLeftViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , <NUM_LIT> ) ; leftEdge -= child . getMeasuredWidth ( ) ; mLeftViewIndex -- ; mDisplayOffset -= child . getMeasuredWidth ( ) ; } } private void removeNonVisibleItems ( final int dx ) { View child = getChildAt ( <NUM_LIT> ) ; while ( child != null && child . getRight ( ) + dx <= <NUM_LIT> ) { mDisplayOffset += child . getMeasuredWidth ( ) ; mRemovedViewQueue . offer ( child ) ; removeViewInLayout ( child ) ; mLeftViewIndex ++ ; child = getChildAt ( <NUM_LIT> ) ; } child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; while ( child != null && child . getLeft ( ) + dx >= getWidth ( ) ) { mRemovedViewQueue . offer ( child ) ; removeViewInLayout ( child ) ; mRightViewIndex -- ; child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; } } private void positionItems ( final int dx ) { if ( getChildCount ( ) > <NUM_LIT> ) { mDisplayOffset += dx ; int left = mDisplayOffset ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View", "gt": "child = getChildAt ( i ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemLongClicked != null ) { mOnItemLongClicked . onItemLongClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } break ; } } } } ; private void fillList ( final int dx ) { int edge = <NUM_LIT> ; View child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; if ( child != null ) { edge = child . getRight ( ) ; } fillListRight ( edge , dx ) ; edge = <NUM_LIT> ; child = getChildAt ( <NUM_LIT> ) ; if ( child != null ) { edge = child . getLeft ( ) ; } fillListLeft ( edge , dx ) ; } private void fillListRight ( int rightEdge , final int dx ) { while ( rightEdge + dx < getWidth ( ) && mRightViewIndex < mAdapter . getCount ( ) ) { View child = mAdapter . getView ( mRightViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , - <NUM_LIT> ) ; rightEdge += child . getMeasuredWidth ( ) ; if ( mRightViewIndex == mAdapter . getCount ( ) - <NUM_LIT> ) { mMaxX = mCurrentX + rightEdge - getWidth ( ) ; } if ( mMaxX < <NUM_LIT> ) { mMaxX = <NUM_LIT> ; } mRightViewIndex ++ ; } } private void fillListLeft ( int leftEdge , final int dx ) { while ( leftEdge + dx > <NUM_LIT> && mLeftViewIndex >= <NUM_LIT> ) { View child = mAdapter . getView ( mLeftViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , <NUM_LIT> ) ; leftEdge -= child . getMeasuredWidth ( ) ; mLeftViewIndex -- ; mDisplayOffset -= child . getMeasuredWidth ( ) ; } } private void removeNonVisibleItems ( final int dx ) { View child = getChildAt ( <NUM_LIT> ) ; while ( child != null && child . getRight ( ) + dx <= <NUM_LIT> ) { mDisplayOffset += child . getMeasuredWidth ( ) ; mRemovedViewQueue . offer ( child ) ; removeViewInLayout ( child ) ; mLeftViewIndex ++ ; child = getChildAt ( <NUM_LIT> ) ; } child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; while ( child != null && child . getLeft ( ) + dx >= getWidth ( ) ) { mRemovedViewQueue . offer ( child ) ; removeViewInLayout ( child ) ; mRightViewIndex -- ; child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; } } private void positionItems ( final int dx ) { if ( getChildCount ( ) > <NUM_LIT> ) { mDisplayOffset += dx ; int left = mDisplayOffset ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int childWidth = child . getMeasuredWidth ( ) ; child . layout ( left , <NUM_LIT> , left + childWidth , child . getMeasuredHeight ( ) ) ; left += childWidth ; } } } public synchronized void scrollTo ( int x ) { mScroller . startScroll ( mNextX , <NUM_LIT> , x - mNextX , <NUM_LIT> ) ; requestLayout ( ) ; } @ Override public boolean dispatchTouchEvent ( MotionEvent ev ) { boolean handled = mGesture . onTouchEvent ( ev ) ; return handled ; } protected boolean onFling ( MotionEvent e1 , MotionEvent e2 , float velocityX , float velocityY ) { synchronized ( HorizontalListView . this ) { mScroller . fling ( mNextX , <NUM_LIT> , ( int ) - velocityX , <NUM_LIT> , <NUM_LIT> , mMaxX , <NUM_LIT> , <NUM_LIT> ) ; } requestLayout ( ) ; return true ; } protected boolean onDown ( MotionEvent e ) { mScroller . forceFinished ( true ) ; return true ; } @ Override protected synchronized void onLayout ( boolean changed , int left , int top , int right , int bottom ) { super", "gt": ". onLayout ( changed , left , top , right , bottom ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . xposed . utils ; import android . view . animation . AccelerateDecelerateInterpolator ; import android . view . animation . AccelerateInterpolator ; import android . view . animation . AlphaAnimation ; import android . view . animation . Animation ; import android . view . animation . AnimationSet ; import android . view . animation . BounceInterpolator ; import android . view . animation . RotateAnimation ; import android . view . animation . ScaleAnimation ; import android . view . animation . TranslateAnimation ; public class AnimationUtil { public static Animation getAnimation ( String animationName ) { return switch ( animationName . toLowerCase ( ) ) { case \"<STR_LIT>\" -> createFadeInAnimation ( ) ; case \"<STR_LIT>\" -> createFadeOutAnimation ( ) ; case \"<STR_LIT>\" -> createScaleUpAnimation ( ) ; case \"<STR_LIT>\" -> createSlideUpAnimation ( ) ; case \"<STR_LIT>\" -> createSlideRightToLeftAnimation ( ) ; case \"<STR_LIT>\" -> createRotateAnimation ( ) ; case \"<STR_LIT>\" -> createBounceAnimation ( ) ; case \"<STR_LIT>\" -> createShrinkAnimation ( ) ; case \"<STR_LIT>\" -> createFlipAnimation ( ) ; case \"<STR_LIT>\" -> createHyperspaceOutAnimation ( ) ; default -> null ; } ; } private static Animation createFadeInAnimation ( ) { AlphaAnimation anim = new AlphaAnimation ( <NUM_LIT> , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createFadeOutAnimation ( ) { AlphaAnimation anim = new AlphaAnimation ( <NUM_LIT> , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createScaleUpAnimation ( ) { ScaleAnimation anim = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createSlideUpAnimation ( ) { TranslateAnimation anim = new TranslateAnimation ( Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createSlideRightToLeftAnimation ( ) { TranslateAnimation anim = new TranslateAnimation ( Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> , Animation . RELATIVE_TO_PARENT , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createRotateAnimation ( ) { RotateAnimation anim = new RotateAnimation ( <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } public static Animation createBounceAnimation ( ) { ScaleAnimation scaleAnimation = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; scaleAnimation . setDuration ( <NUM_LIT> ) ; scaleAnimation . setInterpolator ( new BounceInterpolator ( ) ) ; AnimationSet animationSet = new AnimationSet ( true ) ; animationSet . addAnimation ( scaleAnimation ) ; animationSet . setFillAfter ( true ) ; return animationSet ; } private static Animation createShrinkAnimation ( ) { ScaleAnimation anim = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; return anim ; } private static Animation createFlipAnimation ( ) { ScaleAnimation", "gt": "anim = new ScaleAnimation ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , - <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemLongClicked != null ) { mOnItemLongClicked", "gt": ". onItemLongClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ;", "repo": "WaEnhancer"}
{"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . database . DataSetObserver ; import android . graphics . Rect ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListAdapter ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import java . util . LinkedList ; import java . util . Queue ; public class HorizontalListView extends AdapterView < ListAdapter > { protected ListAdapter mAdapter ; private int mLeftViewIndex = - <NUM_LIT> ; private int mRightViewIndex = <NUM_LIT> ; protected int mCurrentX ; protected int mNextX ; private int mMaxX = Integer . MAX_VALUE ; private int mDisplayOffset = <NUM_LIT> ; protected Scroller mScroller ; private GestureDetector mGesture ; private final Queue < View > mRemovedViewQueue = new LinkedList < View > ( ) ; private OnItemSelectedListener mOnItemSelected ; private OnItemClickListener mOnItemClicked ; private OnItemLongClickListener mOnItemLongClicked ; private boolean mDataChanged = false ; public HorizontalListView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initView ( ) ; } public HorizontalListView ( Context context ) { super ( context ) ; initView ( ) ; } private synchronized void initView ( ) { mLeftViewIndex = - <NUM_LIT> ; mRightViewIndex = <NUM_LIT> ; mDisplayOffset = <NUM_LIT> ; mCurrentX = <NUM_LIT> ; mNextX = <NUM_LIT> ; mMaxX = Integer . MAX_VALUE ; mScroller = new Scroller ( getContext ( ) ) ; mGesture = new GestureDetector ( getContext ( ) , mOnGesture ) ; } @ Override public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelected = listener ; } @ Override public void setOnItemClickListener ( OnItemClickListener listener ) { mOnItemClicked = listener ; } @ Override public void setOnItemLongClickListener ( OnItemLongClickListener listener ) { mOnItemLongClicked = listener ; } private final DataSetObserver mDataObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { synchronized ( HorizontalListView . this ) { mDataChanged = true ; } setEmptyView ( getEmptyView ( ) ) ; invalidate ( ) ; requestLayout ( ) ; } @ Override public void onInvalidated ( ) { reset ( ) ; invalidate ( ) ; requestLayout ( ) ; } } ; @ Override public ListAdapter getAdapter ( ) { return mAdapter ; } @ Override public View getSelectedView ( ) { return null ; } @ Override public void setAdapter ( ListAdapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mDataObserver ) ; } mAdapter = adapter ; mAdapter . registerDataSetObserver ( mDataObserver ) ; reset ( ) ; } private synchronized void reset ( ) { initView ( ) ; removeAllViewsInLayout ( ) ; requestLayout ( ) ; } @ Override public void setSelection ( int position ) { } private void addAndMeasureChild ( final View child , int viewPos ) { LayoutParams params = child . getLayoutParams ( ) ; if ( params == null ) { params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; } addViewInLayout ( child , viewPos , params , true ) ; child . measure ( MeasureSpec . makeMeasureSpec ( getWidth ( ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getHeight ( ) , MeasureSpec . AT_MOST ) ) ; } private final GestureDetector . OnGestureListener mOnGesture = new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onDown ( @ NonNull MotionEvent e ) { return HorizontalListView . this . onDown ( e ) ; } @ Override public boolean onFling ( MotionEvent e1 , @ NonNull MotionEvent e2 , float velocityX , float velocityY ) { return HorizontalListView . this . onFling ( e1 , e2 , velocityX , velocityY ) ; } @ Override public boolean onScroll ( MotionEvent e1 , @ NonNull MotionEvent e2 , float distanceX , float distanceY ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; synchronized ( HorizontalListView . this ) { mNextX += ( int ) distanceX ; } requestLayout ( ) ; return true ; } @ Override public boolean onSingleTapConfirmed ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemClicked != null ) { mOnItemClicked . onItemClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } if ( mOnItemSelected != null ) { mOnItemSelected . onItemSelected ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } int x = ( int ) e . getX ( ) - left ; int y = ( int ) e . getY ( ) - top ; MotionEvent motionEvent = MotionEvent . obtain ( SystemClock . uptimeMillis ( ) , SystemClock . uptimeMillis ( ) , MotionEvent . ACTION_DOWN , x , y , <NUM_LIT> ) ; child . dispatchTouchEvent ( motionEvent ) ; motionEvent . recycle ( ) ; child . performClick ( ) ; break ; } } return true ; } @ Override public void onLongPress ( @ NonNull MotionEvent e ) { Rect viewRect = new Rect ( ) ; int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; int left = child . getLeft ( ) ; int right = child . getRight ( ) ; int top = child . getTop ( ) ; int bottom = child . getBottom ( ) ; viewRect . set ( left , top , right , bottom ) ; if ( viewRect . contains ( ( int ) e . getX ( ) , ( int ) e . getY ( ) ) ) { if ( mOnItemLongClicked != null ) { mOnItemLongClicked . onItemLongClick ( HorizontalListView . this , child , mLeftViewIndex + <NUM_LIT> + i , mAdapter . getItemId ( mLeftViewIndex + <NUM_LIT> + i ) ) ; } break ; } } } } ; private void fillList ( final int dx ) { int edge = <NUM_LIT> ; View child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; if ( child != null ) { edge = child . getRight ( ) ; } fillListRight ( edge , dx ) ; edge = <NUM_LIT> ; child = getChildAt ( <NUM_LIT> ) ; if ( child != null ) { edge = child . getLeft ( ) ; } fillListLeft ( edge , dx ) ; } private void fillListRight ( int rightEdge , final int dx ) { while ( rightEdge + dx < getWidth ( ) && mRightViewIndex < mAdapter . getCount ( ) ) { View child = mAdapter . getView ( mRightViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , - <NUM_LIT> ) ; rightEdge += child . getMeasuredWidth ( ) ; if ( mRightViewIndex == mAdapter . getCount ( ) - <NUM_LIT> ) { mMaxX = mCurrentX + rightEdge - getWidth ( ) ; } if ( mMaxX < <NUM_LIT> ) { mMaxX = <NUM_LIT> ; } mRightViewIndex ++ ; } } private void fillListLeft ( int leftEdge , final int dx ) { while ( leftEdge + dx > <NUM_LIT> && mLeftViewIndex >= <NUM_LIT> ) { View child = mAdapter . getView ( mLeftViewIndex , mRemovedViewQueue . poll ( ) , this ) ; addAndMeasureChild ( child , <NUM_LIT> ) ; leftEdge -= child . getMeasuredWidth ( ) ; mLeftViewIndex -- ; mDisplayOffset -= child . getMeasuredWidth ( ) ; } } private void removeNonVisibleItems ( final int dx ) { View child = getChildAt ( <NUM_LIT> ) ; while ( child != null && child . getRight ( ) + dx <= <NUM_LIT> ) { mDisplayOffset += child . getMeasuredWidth ( ) ; mRemovedViewQueue . offer ( child ) ; removeViewInLayout ( child ) ; mLeftViewIndex ++ ; child = getChildAt ( <NUM_LIT> ) ; } child = getChildAt ( getChildCount ( ) - <NUM_LIT> ) ; while ( child != null && child . getLeft ( ) + dx >= getWidth ( ) ) { mRemovedViewQueue . offer ( child ) ; removeViewInLayout ( child ) ; mRightViewIndex -- ; child", "gt": "= getChildAt ( getChildCount ( ) - <NUM_LIT> ) ;", "repo": "WaEnhancer"}
