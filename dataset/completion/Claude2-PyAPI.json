{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session", "gt": "= dict ( )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def", "gt": "__init__ ( self ) :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id", "gt": "= context [ '<STR_LIT>' ]"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if", "gt": "query == '<STR_LIT>' :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session", "gt": ". clear_session ( from_user_id )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query", "gt": "= Session . build_session_query ( query , from_user_id )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger", "gt": ". debug ( \"<STR_LIT>\" . format ( new_query ) )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if", "gt": "reply_content and query :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif", "gt": "context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def", "gt": "reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content", "gt": "= response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time", "gt": ". sleep ( <NUM_LIT> )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger", "gt": ". warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return", "gt": "self . reply_text ( query , user_id , retry_count + <NUM_LIT> )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except", "gt": "Exception as e :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger", "gt": ". exception ( e )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session", "gt": ". clear_session ( user_id )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger", "gt": ". warn ( e )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if", "gt": "retry_count < <NUM_LIT> :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger", "gt": ". warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return", "gt": "self . reply_text ( query , retry_count + <NUM_LIT> )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except", "gt": "Exception as e :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger", "gt": ". exception ( e )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt", "gt": "= conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session", "gt": "= user_session . get ( user_id , None )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for", "gt": "conversation in session :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt", "gt": "+= \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\""}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return", "gt": "prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\""}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def", "gt": "save_session ( query , answer , user_id ) :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens", "gt": "= conf ( ) . get ( \"<STR_LIT>\" )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation", "gt": "= dict ( )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation", "gt": "[ \"<STR_LIT>\" ] = query"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session", "gt": "= user_session . get ( user_id )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger", "gt": ". debug ( conversation )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger . debug ( conversation ) <EOL> logger", "gt": ". debug ( session )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger . debug ( conversation ) <EOL> logger . debug ( session ) <EOL> if session : <EOL> session", "gt": ". append ( conversation )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger . debug ( conversation ) <EOL> logger . debug ( session ) <EOL> if session : <EOL> session . append ( conversation ) <EOL> else : <EOL> queue", "gt": "= list ( )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger . debug ( conversation ) <EOL> logger . debug ( session ) <EOL> if session : <EOL> session . append ( conversation ) <EOL> else : <EOL> queue = list ( ) <EOL> queue . append ( conversation ) <EOL> user_session", "gt": "[ user_id ] = queue"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger . debug ( conversation ) <EOL> logger . debug ( session ) <EOL> if session : <EOL> session . append ( conversation ) <EOL> else : <EOL> queue = list ( ) <EOL> queue . append ( conversation ) <EOL> user_session [ user_id ] = queue <EOL> Session", "gt": ". discard_exceed_conversation ( user_session [ user_id ] , max_tokens )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger . debug ( conversation ) <EOL> logger . debug ( session ) <EOL> if session : <EOL> session . append ( conversation ) <EOL> else : <EOL> queue = list ( ) <EOL> queue . append ( conversation ) <EOL> user_session [ user_id ] = queue <EOL> Session . discard_exceed_conversation ( user_session [ user_id ] , max_tokens ) <EOL> @ staticmethod <EOL> def discard_exceed_conversation ( session , max_tokens ) : <EOL> count = <NUM_LIT> <EOL> count_list", "gt": "= list ( )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger . debug ( conversation ) <EOL> logger . debug ( session ) <EOL> if session : <EOL> session . append ( conversation ) <EOL> else : <EOL> queue = list ( ) <EOL> queue . append ( conversation ) <EOL> user_session [ user_id ] = queue <EOL> Session . discard_exceed_conversation ( user_session [ user_id ] , max_tokens ) <EOL> @ staticmethod <EOL> def discard_exceed_conversation ( session , max_tokens ) : <EOL> count = <NUM_LIT> <EOL> count_list = list ( ) <EOL> for i in range ( len ( session ) - <NUM_LIT> , - <NUM_LIT> , - <NUM_LIT> ) : <EOL> history_conv", "gt": "= session [ i ]"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger . debug ( conversation ) <EOL> logger . debug ( session ) <EOL> if session : <EOL> session . append ( conversation ) <EOL> else : <EOL> queue = list ( ) <EOL> queue . append ( conversation ) <EOL> user_session [ user_id ] = queue <EOL> Session . discard_exceed_conversation ( user_session [ user_id ] , max_tokens ) <EOL> @ staticmethod <EOL> def discard_exceed_conversation ( session , max_tokens ) : <EOL> count = <NUM_LIT> <EOL> count_list = list ( ) <EOL> for i in range ( len ( session ) - <NUM_LIT> , - <NUM_LIT> , - <NUM_LIT> ) : <EOL> history_conv = session [ i ] <EOL> count", "gt": "+= len ( history_conv [ \"<STR_LIT>\" ] ) + len ( history_conv [ \"<STR_LIT>\" ] )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger . debug ( conversation ) <EOL> logger . debug ( session ) <EOL> if session : <EOL> session . append ( conversation ) <EOL> else : <EOL> queue = list ( ) <EOL> queue . append ( conversation ) <EOL> user_session [ user_id ] = queue <EOL> Session . discard_exceed_conversation ( user_session [ user_id ] , max_tokens ) <EOL> @ staticmethod <EOL> def discard_exceed_conversation ( session , max_tokens ) : <EOL> count = <NUM_LIT> <EOL> count_list = list ( ) <EOL> for i in range ( len ( session ) - <NUM_LIT> , - <NUM_LIT> , - <NUM_LIT> ) : <EOL> history_conv = session [ i ] <EOL> count += len ( history_conv [ \"<STR_LIT>\" ] ) + len ( history_conv [ \"<STR_LIT>\" ] ) <EOL> count_list", "gt": ". append ( count )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger . debug ( conversation ) <EOL> logger . debug ( session ) <EOL> if session : <EOL> session . append ( conversation ) <EOL> else : <EOL> queue = list ( ) <EOL> queue . append ( conversation ) <EOL> user_session [ user_id ] = queue <EOL> Session . discard_exceed_conversation ( user_session [ user_id ] , max_tokens ) <EOL> @ staticmethod <EOL> def discard_exceed_conversation ( session , max_tokens ) : <EOL> count = <NUM_LIT> <EOL> count_list = list ( ) <EOL> for i in range ( len ( session ) - <NUM_LIT> , - <NUM_LIT> , - <NUM_LIT> ) : <EOL> history_conv = session [ i ] <EOL> count += len ( history_conv [ \"<STR_LIT>\" ] ) + len ( history_conv [ \"<STR_LIT>\" ] ) <EOL> count_list . append ( count ) <EOL> for", "gt": "c in count_list :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class OpenAIBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> elif query == '<STR_LIT>' : <EOL> Session . clear_all_session ( ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content and query : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . Completion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> prompt = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> stop = [ \"<STR_LIT>\" ] <EOL> ) <EOL> res_content = response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( res_content ) ) <EOL> return res_content <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prompt : <EOL> prompt += \"<STR_LIT>\" <EOL> session = user_session . get ( user_id , None ) <EOL> if session : <EOL> for conversation in session : <EOL> prompt += \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" + conversation [ \"<STR_LIT>\" ] + \"<STR_LIT>\" <EOL> prompt += \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> return prompt <EOL> else : <EOL> return prompt + \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> max_tokens = conf ( ) . get ( \"<STR_LIT>\" ) <EOL> if not max_tokens : <EOL> max_tokens = <NUM_LIT> <EOL> conversation = dict ( ) <EOL> conversation [ \"<STR_LIT>\" ] = query <EOL> conversation [ \"<STR_LIT>\" ] = answer <EOL> session = user_session . get ( user_id ) <EOL> logger . debug ( conversation ) <EOL> logger . debug ( session ) <EOL> if session : <EOL> session . append ( conversation ) <EOL> else : <EOL> queue = list ( ) <EOL> queue . append ( conversation ) <EOL> user_session [ user_id ] = queue <EOL> Session . discard_exceed_conversation ( user_session [ user_id ] , max_tokens ) <EOL> @ staticmethod <EOL> def discard_exceed_conversation ( session , max_tokens ) : <EOL> count = <NUM_LIT> <EOL> count_list = list ( ) <EOL> for i in range ( len ( session ) - <NUM_LIT> , - <NUM_LIT> , - <NUM_LIT> ) : <EOL> history_conv = session [ i ] <EOL> count += len ( history_conv [ \"<STR_LIT>\" ] ) + len ( history_conv [ \"<STR_LIT>\" ] ) <EOL> count_list . append ( count ) <EOL> for c in count_list : <EOL> if c > max_tokens : <EOL> session . pop ( <NUM_LIT> ) <EOL> @ staticmethod <EOL> def", "gt": "clear_session ( user_id ) :"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class", "gt": "ClaudeAiBot ( Bot ) :"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class ClaudeAiBot ( Bot ) : <EOL> def", "gt": "reply ( self , query , context = None ) :"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class ClaudeAiBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> storage = idStore ( ) <EOL> Conversation_id", "gt": "= storage . get_id ( )"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class ClaudeAiBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> storage = idStore ( ) <EOL> Conversation_id = storage . get_id ( ) <EOL> if", "gt": "Conversation_id is not None :"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class ClaudeAiBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> storage = idStore ( ) <EOL> Conversation_id = storage . get_id ( ) <EOL> if Conversation_id is not None : <EOL> return self . send_message ( query , Conversation_id ) <EOL> else : <EOL> result", "gt": "= self . create_chat ( query , Conversation_id )"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class ClaudeAiBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> storage = idStore ( ) <EOL> Conversation_id = storage . get_id ( ) <EOL> if Conversation_id is not None : <EOL> return self . send_message ( query , Conversation_id ) <EOL> else : <EOL> result = self . create_chat ( query , Conversation_id ) <EOL> storage", "gt": ". set_id ( result [ '<STR_LIT>' ] )"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class ClaudeAiBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> storage = idStore ( ) <EOL> Conversation_id = storage . get_id ( ) <EOL> if Conversation_id is not None : <EOL> return self . send_message ( query , Conversation_id ) <EOL> else : <EOL> result = self . create_chat ( query , Conversation_id ) <EOL> storage . set_id ( result [ '<STR_LIT>' ] ) <EOL> return result [ '<STR_LIT>' ] <EOL> def create_chat ( self , msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> self . cookie = conf ( ) . get ( '<STR_LIT>' ) <EOL> self", "gt": ". isproxy = conf ( ) . get ( '<STR_LIT>' )"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class ClaudeAiBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> storage = idStore ( ) <EOL> Conversation_id = storage . get_id ( ) <EOL> if Conversation_id is not None : <EOL> return self . send_message ( query , Conversation_id ) <EOL> else : <EOL> result = self . create_chat ( query , Conversation_id ) <EOL> storage . set_id ( result [ '<STR_LIT>' ] ) <EOL> return result [ '<STR_LIT>' ] <EOL> def create_chat ( self , msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> self . cookie = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . isproxy = conf ( ) . get ( '<STR_LIT>' ) <EOL> client", "gt": "= Client ( self . cookie , self . isproxy )"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class ClaudeAiBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> storage = idStore ( ) <EOL> Conversation_id = storage . get_id ( ) <EOL> if Conversation_id is not None : <EOL> return self . send_message ( query , Conversation_id ) <EOL> else : <EOL> result = self . create_chat ( query , Conversation_id ) <EOL> storage . set_id ( result [ '<STR_LIT>' ] ) <EOL> return result [ '<STR_LIT>' ] <EOL> def create_chat ( self , msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> self . cookie = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . isproxy = conf ( ) . get ( '<STR_LIT>' ) <EOL> client = Client ( self . cookie , self . isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger", "gt": ". info ( \"<STR_LIT>\" + str ( response ) )"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class ClaudeAiBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> storage = idStore ( ) <EOL> Conversation_id = storage . get_id ( ) <EOL> if Conversation_id is not None : <EOL> return self . send_message ( query , Conversation_id ) <EOL> else : <EOL> result = self . create_chat ( query , Conversation_id ) <EOL> storage . set_id ( result [ '<STR_LIT>' ] ) <EOL> return result [ '<STR_LIT>' ] <EOL> def create_chat ( self , msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> self . cookie = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . isproxy = conf ( ) . get ( '<STR_LIT>' ) <EOL> client = Client ( self . cookie , self . isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def", "gt": "send_message ( self , msg , conversation_id ) :"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class ClaudeAiBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> storage = idStore ( ) <EOL> Conversation_id = storage . get_id ( ) <EOL> if Conversation_id is not None : <EOL> return self . send_message ( query , Conversation_id ) <EOL> else : <EOL> result = self . create_chat ( query , Conversation_id ) <EOL> storage . set_id ( result [ '<STR_LIT>' ] ) <EOL> return result [ '<STR_LIT>' ] <EOL> def create_chat ( self , msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> self . cookie = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . isproxy = conf ( ) . get ( '<STR_LIT>' ) <EOL> client = Client ( self . cookie , self . isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( self , msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> self . cookie = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . isproxy = conf ( ) . get ( '<STR_LIT>' ) <EOL> client = Client ( self . cookie , self . isproxy ) <EOL> response", "gt": "= client . send_message ( prompt , conversation_id )"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> from config import conf <EOL> from claude_api import Client <EOL> from common . log import logger <EOL> from bot . claude . idStore import idStore <EOL> class ClaudeAiBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> storage = idStore ( ) <EOL> Conversation_id = storage . get_id ( ) <EOL> if Conversation_id is not None : <EOL> return self . send_message ( query , Conversation_id ) <EOL> else : <EOL> result = self . create_chat ( query , Conversation_id ) <EOL> storage . set_id ( result [ '<STR_LIT>' ] ) <EOL> return result [ '<STR_LIT>' ] <EOL> def create_chat ( self , msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> self . cookie = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . isproxy = conf ( ) . get ( '<STR_LIT>' ) <EOL> client = Client ( self . cookie , self . isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( self , msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> self . cookie = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . isproxy = conf ( ) . get ( '<STR_LIT>' ) <EOL> client = Client ( self . cookie , self . isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger", "gt": ". info ( \"<STR_LIT>\" . format ( answer ) )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url", "gt": "= apiurl + \"<STR_LIT>\" + conversation_id"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print", "gt": "( response . text )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer", "gt": "= data [ '<STR_LIT>' ]"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def", "gt": "sendMessage ( conversation_id , msg ) :"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url", "gt": "= apiurl + \"<STR_LIT>\""}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload", "gt": "= json . dumps ( {"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response", "gt": "= requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data", "gt": "= json . loads ( response . text )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer", "gt": "= data [ '<STR_LIT>' ]"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def", "gt": "sendattachment ( msg ) :"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url", "gt": "= apiurl + \"<STR_LIT>\""}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> (", "gt": "'<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response", "gt": "= requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client", "gt": "= Client ( cookie , isproxy )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts", "gt": ". append ( message [ '<STR_LIT>' ] )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger", "gt": ". info ( \"<STR_LIT>\" . format ( texts ) )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data", "gt": "= { '<STR_LIT>' : msg }"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie", "gt": "= get_cookie ( )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy", "gt": "= get_proxy ( )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client", "gt": "= Client ( cookie , isproxy )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation", "gt": "= client . create_new_chat ( )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger", "gt": ". info ( \"<STR_LIT>\" . format ( answer ) )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata", "gt": "= { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer }"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def", "gt": "send_message ( msg , conversation_id ) :"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data", "gt": "= { '<STR_LIT>' : msg }"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt", "gt": "= data [ '<STR_LIT>' ]"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy", "gt": "= get_proxy ( )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger", "gt": ". info ( \"<STR_LIT>\" + str ( response ) )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger", "gt": ". info ( \"<STR_LIT>\" . format ( answer ) )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def", "gt": "send_message_judge ( msg ) :"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result", "gt": "= create_chat ( msg )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie", "gt": "= get_cookie ( )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def", "gt": "text_reply ( msg ) :"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def", "gt": "download_files ( msg ) :"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg", "gt": "[ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return", "gt": "'<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def", "gt": "group_text_reply ( msg ) :"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def group_text_reply ( msg ) : <EOL> item = group_id ( u'<STR_LIT>' ) <EOL> if", "gt": "msg [ '<STR_LIT>' ] == item :"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def group_text_reply ( msg ) : <EOL> item = group_id ( u'<STR_LIT>' ) <EOL> if msg [ '<STR_LIT>' ] == item : <EOL> itchat", "gt": ". send ( u'<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , item )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def group_text_reply ( msg ) : <EOL> item = group_id ( u'<STR_LIT>' ) <EOL> if msg [ '<STR_LIT>' ] == item : <EOL> itchat . send ( u'<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , item ) <EOL> def qrCallback ( uuid , status , qrcode ) : <EOL> if status == \"<STR_LIT>\" : <EOL> try : <EOL> from PIL import Image <EOL> img", "gt": "= Image . open ( io . BytesIO ( qrcode ) )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def group_text_reply ( msg ) : <EOL> item = group_id ( u'<STR_LIT>' ) <EOL> if msg [ '<STR_LIT>' ] == item : <EOL> itchat . send ( u'<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , item ) <EOL> def qrCallback ( uuid , status , qrcode ) : <EOL> if status == \"<STR_LIT>\" : <EOL> try : <EOL> from PIL import Image <EOL> img = Image . open ( io . BytesIO ( qrcode ) ) <EOL> _thread", "gt": "= threading . Thread ( target = img . show , args = ( \"<STR_LIT>\" , ) )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def group_text_reply ( msg ) : <EOL> item = group_id ( u'<STR_LIT>' ) <EOL> if msg [ '<STR_LIT>' ] == item : <EOL> itchat . send ( u'<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , item ) <EOL> def qrCallback ( uuid , status , qrcode ) : <EOL> if status == \"<STR_LIT>\" : <EOL> try : <EOL> from PIL import Image <EOL> img = Image . open ( io . BytesIO ( qrcode ) ) <EOL> _thread = threading . Thread ( target = img . show , args = ( \"<STR_LIT>\" , ) ) <EOL> _thread . setDaemon ( True ) <EOL> _thread . start ( ) <EOL> except", "gt": "Exception as e :"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def group_text_reply ( msg ) : <EOL> item = group_id ( u'<STR_LIT>' ) <EOL> if msg [ '<STR_LIT>' ] == item : <EOL> itchat . send ( u'<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , item ) <EOL> def qrCallback ( uuid , status , qrcode ) : <EOL> if status == \"<STR_LIT>\" : <EOL> try : <EOL> from PIL import Image <EOL> img = Image . open ( io . BytesIO ( qrcode ) ) <EOL> _thread = threading . Thread ( target = img . show , args = ( \"<STR_LIT>\" , ) ) <EOL> _thread . setDaemon ( True ) <EOL> _thread . start ( ) <EOL> except Exception as e : <EOL> pass <EOL> import qrcode <EOL> url = f\"<STR_LIT>\" <EOL> qr_api1 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api2 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api3 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api4", "gt": "= \"<STR_LIT>\" . format ( url )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def group_text_reply ( msg ) : <EOL> item = group_id ( u'<STR_LIT>' ) <EOL> if msg [ '<STR_LIT>' ] == item : <EOL> itchat . send ( u'<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , item ) <EOL> def qrCallback ( uuid , status , qrcode ) : <EOL> if status == \"<STR_LIT>\" : <EOL> try : <EOL> from PIL import Image <EOL> img = Image . open ( io . BytesIO ( qrcode ) ) <EOL> _thread = threading . Thread ( target = img . show , args = ( \"<STR_LIT>\" , ) ) <EOL> _thread . setDaemon ( True ) <EOL> _thread . start ( ) <EOL> except Exception as e : <EOL> pass <EOL> import qrcode <EOL> url = f\"<STR_LIT>\" <EOL> qr_api1 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api2 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api3 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api4 = \"<STR_LIT>\" . format ( url ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( qr_api3 ) <EOL> print ( qr_api4 ) <EOL> print ( qr_api2 ) <EOL> print ( qr_api1 ) <EOL> qr", "gt": "= qrcode . QRCode ( border = <NUM_LIT> )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def group_text_reply ( msg ) : <EOL> item = group_id ( u'<STR_LIT>' ) <EOL> if msg [ '<STR_LIT>' ] == item : <EOL> itchat . send ( u'<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , item ) <EOL> def qrCallback ( uuid , status , qrcode ) : <EOL> if status == \"<STR_LIT>\" : <EOL> try : <EOL> from PIL import Image <EOL> img = Image . open ( io . BytesIO ( qrcode ) ) <EOL> _thread = threading . Thread ( target = img . show , args = ( \"<STR_LIT>\" , ) ) <EOL> _thread . setDaemon ( True ) <EOL> _thread . start ( ) <EOL> except Exception as e : <EOL> pass <EOL> import qrcode <EOL> url = f\"<STR_LIT>\" <EOL> qr_api1 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api2 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api3 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api4 = \"<STR_LIT>\" . format ( url ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( qr_api3 ) <EOL> print ( qr_api4 ) <EOL> print ( qr_api2 ) <EOL> print ( qr_api1 ) <EOL> qr = qrcode . QRCode ( border = <NUM_LIT> ) <EOL> qr", "gt": ". add_data ( url )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def group_text_reply ( msg ) : <EOL> item = group_id ( u'<STR_LIT>' ) <EOL> if msg [ '<STR_LIT>' ] == item : <EOL> itchat . send ( u'<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , item ) <EOL> def qrCallback ( uuid , status , qrcode ) : <EOL> if status == \"<STR_LIT>\" : <EOL> try : <EOL> from PIL import Image <EOL> img = Image . open ( io . BytesIO ( qrcode ) ) <EOL> _thread = threading . Thread ( target = img . show , args = ( \"<STR_LIT>\" , ) ) <EOL> _thread . setDaemon ( True ) <EOL> _thread . start ( ) <EOL> except Exception as e : <EOL> pass <EOL> import qrcode <EOL> url = f\"<STR_LIT>\" <EOL> qr_api1 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api2 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api3 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api4 = \"<STR_LIT>\" . format ( url ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( qr_api3 ) <EOL> print ( qr_api4 ) <EOL> print ( qr_api2 ) <EOL> print ( qr_api1 ) <EOL> qr = qrcode . QRCode ( border = <NUM_LIT> ) <EOL> qr . add_data ( url ) <EOL> qr", "gt": ". make ( fit = True )"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def group_text_reply ( msg ) : <EOL> item = group_id ( u'<STR_LIT>' ) <EOL> if msg [ '<STR_LIT>' ] == item : <EOL> itchat . send ( u'<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , item ) <EOL> def qrCallback ( uuid , status , qrcode ) : <EOL> if status == \"<STR_LIT>\" : <EOL> try : <EOL> from PIL import Image <EOL> img = Image . open ( io . BytesIO ( qrcode ) ) <EOL> _thread = threading . Thread ( target = img . show , args = ( \"<STR_LIT>\" , ) ) <EOL> _thread . setDaemon ( True ) <EOL> _thread . start ( ) <EOL> except Exception as e : <EOL> pass <EOL> import qrcode <EOL> url = f\"<STR_LIT>\" <EOL> qr_api1 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api2 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api3 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api4 = \"<STR_LIT>\" . format ( url ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( qr_api3 ) <EOL> print ( qr_api4 ) <EOL> print ( qr_api2 ) <EOL> print ( qr_api1 ) <EOL> qr = qrcode . QRCode ( border = <NUM_LIT> ) <EOL> qr . add_data ( url ) <EOL> qr . make ( fit = True ) <EOL> qr . print_ascii ( invert = True ) <EOL> itchat . instance . receivingRetryCount = <NUM_LIT> <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> , hotReload = False , qrCallback = qrCallback ) <EOL> user_id = itchat . instance . storageClass . userName <EOL> name", "gt": "= itchat . instance . storageClass . nickName"}
{"input": "import requests <EOL> import json <EOL> import threading <EOL> import io <EOL> from lib import itchat <EOL> from lib . itchat . content import * <EOL> from common . log import logger <EOL> from common . utils import * <EOL> from claude_api import Client <EOL> apiurl = \"<STR_LIT>\" <EOL> def get_chat ( conversation_id ) : <EOL> url = apiurl + \"<STR_LIT>\" + conversation_id <EOL> payload = \"<STR_LIT>\" <EOL> headers = { } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendMessage ( conversation_id , msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def createMessage ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : msg <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def sendattachment ( msg ) : <EOL> url = apiurl + \"<STR_LIT>\" <EOL> payload = { } <EOL> files = [ <EOL> ( '<STR_LIT>' , ( '<STR_LIT>' , open ( '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' ) ) <EOL> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = requests . request ( \"<STR_LIT>\" , url , headers = headers , data = payload , files = files ) <EOL> print ( response . text ) <EOL> data = json . loads ( response . text ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> return answer <EOL> def get_chat_history ( msg ) : <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation_id = \"<STR_LIT>\" <EOL> data = client . chat_conversation_history ( conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( data ) ) <EOL> answer = data [ '<STR_LIT>' ] <EOL> texts = [ ] <EOL> for message in answer : <EOL> texts . append ( message [ '<STR_LIT>' ] ) <EOL> logger . info ( \"<STR_LIT>\" . format ( texts ) ) <EOL> return texts <EOL> def create_chat ( msg ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> resultdata = { '<STR_LIT>' : conversation_id , '<STR_LIT>' : answer } <EOL> return resultdata <EOL> def send_message ( msg , conversation_id ) : <EOL> data = { '<STR_LIT>' : msg } <EOL> prompt = data [ '<STR_LIT>' ] <EOL> cookie = get_cookie ( ) <EOL> isproxy = get_proxy ( ) <EOL> client = Client ( cookie , isproxy ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> logger . info ( \"<STR_LIT>\" + str ( response ) ) <EOL> answer = response <EOL> logger . info ( \"<STR_LIT>\" . format ( answer ) ) <EOL> return answer <EOL> Conversation_id = \"<STR_LIT>\" <EOL> def send_message_judge ( msg ) : <EOL> global Conversation_id <EOL> if Conversation_id != \"<STR_LIT>\" : <EOL> return send_message ( msg , Conversation_id ) <EOL> else : <EOL> result = create_chat ( msg ) <EOL> Conversation_id = result [ '<STR_LIT>' ] <EOL> return result [ '<STR_LIT>' ] <EOL> def get_group_info ( ) : <EOL> cookie = get_cookie ( ) <EOL> def group_id ( name ) : <EOL> df = itchat . search_chatrooms ( name = name ) <EOL> return df [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> @ itchat . msg_register ( [ TEXT , MAP , CARD , NOTE , SHARING ] ) <EOL> def text_reply ( msg ) : <EOL> itchat . send ( '<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( [ PICTURE , RECORDING , ATTACHMENT , VIDEO ] ) <EOL> def download_files ( msg ) : <EOL> msg [ '<STR_LIT>' ] ( msg [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT>' % ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } . get ( msg [ '<STR_LIT>' ] , '<STR_LIT>' ) , msg [ '<STR_LIT>' ] ) <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def group_text_reply ( msg ) : <EOL> item = group_id ( u'<STR_LIT>' ) <EOL> if msg [ '<STR_LIT>' ] == item : <EOL> itchat . send ( u'<STR_LIT>' % send_message_judge ( msg [ '<STR_LIT>' ] ) , item ) <EOL> def qrCallback ( uuid , status , qrcode ) : <EOL> if status == \"<STR_LIT>\" : <EOL> try : <EOL> from PIL import Image <EOL> img = Image . open ( io . BytesIO ( qrcode ) ) <EOL> _thread = threading . Thread ( target = img . show , args = ( \"<STR_LIT>\" , ) ) <EOL> _thread . setDaemon ( True ) <EOL> _thread . start ( ) <EOL> except Exception as e : <EOL> pass <EOL> import qrcode <EOL> url = f\"<STR_LIT>\" <EOL> qr_api1 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api2 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api3 = \"<STR_LIT>\" . format ( url ) <EOL> qr_api4 = \"<STR_LIT>\" . format ( url ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( qr_api3 ) <EOL> print ( qr_api4 ) <EOL> print ( qr_api2 ) <EOL> print ( qr_api1 ) <EOL> qr = qrcode . QRCode ( border = <NUM_LIT> ) <EOL> qr . add_data ( url ) <EOL> qr . make ( fit = True ) <EOL> qr . print_ascii ( invert = True ) <EOL> itchat . instance . receivingRetryCount = <NUM_LIT> <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> , hotReload = False , qrCallback = qrCallback ) <EOL> user_id = itchat . instance . storageClass . userName <EOL> name = itchat . instance . storageClass . nickName <EOL> logger", "gt": ". info ( \"<STR_LIT>\" . format ( user_id , name ) )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai", "gt": ". api_key = conf ( ) . get ( '<STR_LIT>' )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def", "gt": "reply ( self , query , context = None ) :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger", "gt": ". info ( \"<STR_LIT>\" . format ( query ) )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id", "gt": "= context [ '<STR_LIT>' ]"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if", "gt": "query == '<STR_LIT>' :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content", "gt": "= self . reply_text ( new_query , from_user_id , <NUM_LIT> )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger", "gt": ". debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def", "gt": "reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger", "gt": ". info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger", "gt": ". warn ( e )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if", "gt": "retry_count < <NUM_LIT> :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time", "gt": ". sleep ( <NUM_LIT> )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except", "gt": "Exception as e :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger", "gt": ". exception ( e )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session", "gt": ". clear_session ( user_id )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger", "gt": ". warn ( e )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if", "gt": "retry_count < <NUM_LIT> :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time", "gt": ". sleep ( <NUM_LIT> )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger", "gt": ". warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger", "gt": ". exception ( e )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> session", "gt": "= user_session . get ( user_id , [ ] )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> session = user_session . get ( user_id , [ ] ) <EOL> if", "gt": "len ( session ) == <NUM_LIT> :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> session = user_session . get ( user_id , [ ] ) <EOL> if len ( session ) == <NUM_LIT> : <EOL> system_prompt", "gt": "= conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> session = user_session . get ( user_id , [ ] ) <EOL> if len ( session ) == <NUM_LIT> : <EOL> system_prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> system_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : system_prompt } <EOL> session", "gt": ". append ( system_item )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> session = user_session . get ( user_id , [ ] ) <EOL> if len ( session ) == <NUM_LIT> : <EOL> system_prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> system_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : system_prompt } <EOL> session . append ( system_item ) <EOL> user_session", "gt": "[ user_id ] = session"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> session = user_session . get ( user_id , [ ] ) <EOL> if len ( session ) == <NUM_LIT> : <EOL> system_prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> system_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : system_prompt } <EOL> session . append ( system_item ) <EOL> user_session [ user_id ] = session <EOL> user_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : query } <EOL> session", "gt": ". append ( user_item )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> session = user_session . get ( user_id , [ ] ) <EOL> if len ( session ) == <NUM_LIT> : <EOL> system_prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> system_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : system_prompt } <EOL> session . append ( system_item ) <EOL> user_session [ user_id ] = session <EOL> user_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : query } <EOL> session . append ( user_item ) <EOL> return session <EOL> @ staticmethod <EOL> def", "gt": "save_session ( query , answer , user_id ) :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> session = user_session . get ( user_id , [ ] ) <EOL> if len ( session ) == <NUM_LIT> : <EOL> system_prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> system_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : system_prompt } <EOL> session . append ( system_item ) <EOL> user_session [ user_id ] = session <EOL> user_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : query } <EOL> session . append ( user_item ) <EOL> return session <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> session = user_session . get ( user_id ) <EOL> if session : <EOL> gpt_item", "gt": "= { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : answer }"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> session = user_session . get ( user_id , [ ] ) <EOL> if len ( session ) == <NUM_LIT> : <EOL> system_prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> system_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : system_prompt } <EOL> session . append ( system_item ) <EOL> user_session [ user_id ] = session <EOL> user_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : query } <EOL> session . append ( user_item ) <EOL> return session <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> session = user_session . get ( user_id ) <EOL> if session : <EOL> gpt_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : answer } <EOL> session", "gt": ". append ( gpt_item )"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> session = user_session . get ( user_id , [ ] ) <EOL> if len ( session ) == <NUM_LIT> : <EOL> system_prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> system_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : system_prompt } <EOL> session . append ( system_item ) <EOL> user_session [ user_id ] = session <EOL> user_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : query } <EOL> session . append ( user_item ) <EOL> return session <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> session = user_session . get ( user_id ) <EOL> if session : <EOL> gpt_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : answer } <EOL> session . append ( gpt_item ) <EOL> @ staticmethod <EOL> def", "gt": "clear_session ( user_id ) :"}
{"input": "from bot . bot import Bot <EOL> from config import conf <EOL> from common . log import logger <EOL> import openai <EOL> import time <EOL> user_session = dict ( ) <EOL> class ChatGPTBot ( Bot ) : <EOL> def __init__ ( self ) : <EOL> openai . api_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> def reply ( self , query , context = None ) : <EOL> if not context or not context . get ( '<STR_LIT>' ) or context . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> from_user_id = context [ '<STR_LIT>' ] <EOL> if query == '<STR_LIT>' : <EOL> Session . clear_session ( from_user_id ) <EOL> return '<STR_LIT>' <EOL> new_query = Session . build_session_query ( query , from_user_id ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query ) ) <EOL> reply_content = self . reply_text ( new_query , from_user_id , <NUM_LIT> ) <EOL> logger . debug ( \"<STR_LIT>\" . format ( new_query , from_user_id , reply_content ) ) <EOL> if reply_content : <EOL> Session . save_session ( query , reply_content , from_user_id ) <EOL> return reply_content <EOL> elif context . get ( '<STR_LIT>' , None ) == '<STR_LIT>' : <EOL> return self . create_img ( query , <NUM_LIT> ) <EOL> def reply_text ( self , query , user_id , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> response = openai . ChatCompletion . create ( <EOL> model = \"<STR_LIT>\" , <EOL> messages = query , <EOL> temperature = <NUM_LIT> , <EOL> max_tokens = <NUM_LIT> , <EOL> top_p = <NUM_LIT> , <EOL> frequency_penalty = <NUM_LIT> , <EOL> presence_penalty = <NUM_LIT> , <EOL> ) <EOL> logger . info ( response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> return response . choices [ <NUM_LIT> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , user_id , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> Session . clear_session ( user_id ) <EOL> return \"<STR_LIT>\" <EOL> def create_img ( self , query , retry_count = <NUM_LIT> ) : <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( query ) ) <EOL> response = openai . Image . create ( <EOL> prompt = query , <EOL> n = <NUM_LIT> , <EOL> size = \"<STR_LIT>\" <EOL> ) <EOL> image_url = response [ '<STR_LIT>' ] [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . info ( \"<STR_LIT>\" . format ( image_url ) ) <EOL> return image_url <EOL> except openai . error . RateLimitError as e : <EOL> logger . warn ( e ) <EOL> if retry_count < <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . warn ( \"<STR_LIT>\" . format ( retry_count + <NUM_LIT> ) ) <EOL> return self . reply_text ( query , retry_count + <NUM_LIT> ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> return None <EOL> class Session ( object ) : <EOL> @ staticmethod <EOL> def build_session_query ( query , user_id ) : <EOL> session = user_session . get ( user_id , [ ] ) <EOL> if len ( session ) == <NUM_LIT> : <EOL> system_prompt = conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> system_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : system_prompt } <EOL> session . append ( system_item ) <EOL> user_session [ user_id ] = session <EOL> user_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : query } <EOL> session . append ( user_item ) <EOL> return session <EOL> @ staticmethod <EOL> def save_session ( query , answer , user_id ) : <EOL> session = user_session . get ( user_id ) <EOL> if session : <EOL> gpt_item = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : answer } <EOL> session . append ( gpt_item ) <EOL> @ staticmethod <EOL> def clear_session ( user_id ) : <EOL> user_session", "gt": "[ user_id ] = [ ]"}
