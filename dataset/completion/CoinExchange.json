{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if", "gt": "( Func . equals ( type , \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result", "gt": "= MarketUtils . indexDataMap . get ( type ) ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else", "gt": "if ( type . startsWith ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else", "gt": "if ( type . startsWith ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { CircularFifoQueue", "gt": "< ContractTrade > contractTradeQueue = ( CircularFifoQueue < ContractTrade > ) MarketUtils . tradeHDataMap . get ( type ) ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { CircularFifoQueue < ContractTrade > contractTradeQueue = ( CircularFifoQueue < ContractTrade > ) MarketUtils . tradeHDataMap . get ( type ) ; List", "gt": "< ContractTrade > list = null ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { CircularFifoQueue < ContractTrade > contractTradeQueue = ( CircularFifoQueue < ContractTrade > ) MarketUtils . tradeHDataMap . get ( type ) ; List < ContractTrade > list = null ; if", "gt": "( Func . isNotEmpty ( contractTradeQueue ) ) {"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { CircularFifoQueue < ContractTrade > contractTradeQueue = ( CircularFifoQueue < ContractTrade > ) MarketUtils . tradeHDataMap . get ( type ) ; List < ContractTrade > list = null ; if ( Func . isNotEmpty ( contractTradeQueue ) ) { list = contractTradeQueue . stream ( ) . collect ( Collectors . toList ( ) ) ; Collections . reverse ( list ) ; } if ( type . startsWith ( \"<STR_LIT>\" ) ) { if ( Func . isEmpty ( list ) ) { if ( Func . isEmpty ( list ) ) { list", "gt": "= new ArrayList < > ( ) ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { CircularFifoQueue < ContractTrade > contractTradeQueue = ( CircularFifoQueue < ContractTrade > ) MarketUtils . tradeHDataMap . get ( type ) ; List < ContractTrade > list = null ; if ( Func . isNotEmpty ( contractTradeQueue ) ) { list = contractTradeQueue . stream ( ) . collect ( Collectors . toList ( ) ) ; Collections . reverse ( list ) ; } if ( type . startsWith ( \"<STR_LIT>\" ) ) { if ( Func . isEmpty ( list ) ) { if ( Func . isEmpty ( list ) ) { list = new ArrayList < > ( ) ; } String symbolName = type . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; QueryWrapper", "gt": "< Object > wrapper = new QueryWrapper < > ( ) ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { CircularFifoQueue < ContractTrade > contractTradeQueue = ( CircularFifoQueue < ContractTrade > ) MarketUtils . tradeHDataMap . get ( type ) ; List < ContractTrade > list = null ; if ( Func . isNotEmpty ( contractTradeQueue ) ) { list = contractTradeQueue . stream ( ) . collect ( Collectors . toList ( ) ) ; Collections . reverse ( list ) ; } if ( type . startsWith ( \"<STR_LIT>\" ) ) { if ( Func . isEmpty ( list ) ) { if ( Func . isEmpty ( list ) ) { list = new ArrayList < > ( ) ; } String symbolName = type . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper", "gt": ". eq ( \"<STR_LIT>\" , <NUM_LIT> ) ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { CircularFifoQueue < ContractTrade > contractTradeQueue = ( CircularFifoQueue < ContractTrade > ) MarketUtils . tradeHDataMap . get ( type ) ; List < ContractTrade > list = null ; if ( Func . isNotEmpty ( contractTradeQueue ) ) { list = contractTradeQueue . stream ( ) . collect ( Collectors . toList ( ) ) ; Collections . reverse ( list ) ; } if ( type . startsWith ( \"<STR_LIT>\" ) ) { if ( Func . isEmpty ( list ) ) { if ( Func . isEmpty ( list ) ) { list = new ArrayList < > ( ) ; } String symbolName = type . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . select ( \"<STR_LIT>\" ) ; Map", "gt": "< String , Object > coinExchangeMap = baseSqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , wrapper ) ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { CircularFifoQueue < ContractTrade > contractTradeQueue = ( CircularFifoQueue < ContractTrade > ) MarketUtils . tradeHDataMap . get ( type ) ; List < ContractTrade > list = null ; if ( Func . isNotEmpty ( contractTradeQueue ) ) { list = contractTradeQueue . stream ( ) . collect ( Collectors . toList ( ) ) ; Collections . reverse ( list ) ; } if ( type . startsWith ( \"<STR_LIT>\" ) ) { if ( Func . isEmpty ( list ) ) { if ( Func . isEmpty ( list ) ) { list = new ArrayList < > ( ) ; } String symbolName = type . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . select ( \"<STR_LIT>\" ) ; Map < String , Object > coinExchangeMap = baseSqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isNotEmpty ( coinExchangeMap ) ) { String", "gt": "exchangeType = MjkjUtils . getMap2Str ( coinExchangeMap , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { CircularFifoQueue < ContractTrade > contractTradeQueue = ( CircularFifoQueue < ContractTrade > ) MarketUtils . tradeHDataMap . get ( type ) ; List < ContractTrade > list = null ; if ( Func . isNotEmpty ( contractTradeQueue ) ) { list = contractTradeQueue . stream ( ) . collect ( Collectors . toList ( ) ) ; Collections . reverse ( list ) ; } if ( type . startsWith ( \"<STR_LIT>\" ) ) { if ( Func . isEmpty ( list ) ) { if ( Func . isEmpty ( list ) ) { list = new ArrayList < > ( ) ; } String symbolName = type . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . select ( \"<STR_LIT>\" ) ; Map < String , Object > coinExchangeMap = baseSqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isNotEmpty ( coinExchangeMap ) ) { String exchangeType = MjkjUtils . getMap2Str ( coinExchangeMap , \"<STR_LIT>\" ) ; if", "gt": "( Func . equals ( exchangeType , \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { CircularFifoQueue < ContractTrade > contractTradeQueue = ( CircularFifoQueue < ContractTrade > ) MarketUtils . tradeHDataMap . get ( type ) ; List < ContractTrade > list = null ; if ( Func . isNotEmpty ( contractTradeQueue ) ) { list = contractTradeQueue . stream ( ) . collect ( Collectors . toList ( ) ) ; Collections . reverse ( list ) ; } if ( type . startsWith ( \"<STR_LIT>\" ) ) { if ( Func . isEmpty ( list ) ) { if ( Func . isEmpty ( list ) ) { list = new ArrayList < > ( ) ; } String symbolName = type . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . select ( \"<STR_LIT>\" ) ; Map < String , Object > coinExchangeMap = baseSqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isNotEmpty ( coinExchangeMap ) ) { String exchangeType = MjkjUtils . getMap2Str ( coinExchangeMap , \"<STR_LIT>\" ) ; if ( Func . equals ( exchangeType , \"<STR_LIT>\" ) ) { List < ContractTrade > detailList = marketMapper . getExchangeDetailList ( symbolName ) ; if", "gt": "( Func . isNotEmpty ( detailList ) ) {"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . AddWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . entity . SubWalletParam ; import org . springblade . model . DeptHModel ; import org . springblade . web . mapper . MarketMapper ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . InviteRewardModel ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import org . springblade . web . service . IMarketService ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springblade . web . utils . MarketUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Propagation ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Service public class MarketServiceImpl implements IMarketService { @ Autowired private IMjkjBaseSqlService baseSqlService ; @ Autowired private MarketMapper marketMapper ; @ Override public Object messageInitdata ( String type ) { Object result = null ; if ( Func . equals ( type , \"<STR_LIT>\" ) ) { result = MarketUtils . indexDataMap . get ( type ) ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { DeptHModel deptHModel = MarketUtils . dhcpHDataMap . get ( type ) ; result = deptHModel ; } else if ( type . startsWith ( \"<STR_LIT>\" ) ) { CircularFifoQueue < ContractTrade > contractTradeQueue = ( CircularFifoQueue < ContractTrade > ) MarketUtils . tradeHDataMap . get ( type ) ; List < ContractTrade > list = null ; if ( Func . isNotEmpty ( contractTradeQueue ) ) { list = contractTradeQueue . stream ( ) . collect ( Collectors . toList ( ) ) ; Collections . reverse ( list ) ; } if ( type . startsWith ( \"<STR_LIT>\" ) ) { if ( Func . isEmpty ( list ) ) { if ( Func . isEmpty ( list ) ) { list = new ArrayList < > ( ) ; } String symbolName = type . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . select ( \"<STR_LIT>\" ) ; Map < String , Object > coinExchangeMap = baseSqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isNotEmpty ( coinExchangeMap ) ) { String exchangeType = MjkjUtils . getMap2Str ( coinExchangeMap , \"<STR_LIT>\" ) ; if ( Func . equals ( exchangeType , \"<STR_LIT>\" ) ) { List < ContractTrade > detailList = marketMapper . getExchangeDetailList ( symbolName ) ; if ( Func . isNotEmpty ( detailList ) ) { list . addAll ( detailList ) ; } list = list . stream ( ) . sorted ( Comparator . comparing ( ContractTrade :: getTime ) ) . collect ( Collectors . toList ( ) ) ; Collections", "gt": ". reverse ( list ) ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import java . math . BigDecimal ; import java . util . Map ; @ Data public class ForceModelAll { private String memberId ; private boolean resetFlag = false ; private Long lastCheckTime = <NUM_LIT> ; private BigDecimal lastFxl = BigDecimal . ZERO ; private BigDecimal totalBjUsdt ; private BigDecimal totalYjUsdt ; private BigDecimal totalLxUsdt ; Map < String , BalanceModel > bjMap ; Map", "gt": "< String , BorrowModel > yjMap ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import java . math . BigDecimal ; import java . util . Map ; @ Data public class ForceModelAll { private String memberId ; private boolean resetFlag = false ; private Long lastCheckTime = <NUM_LIT> ; private BigDecimal lastFxl = BigDecimal . ZERO ; private BigDecimal totalBjUsdt ; private BigDecimal totalYjUsdt ; private BigDecimal totalLxUsdt ; Map < String , BalanceModel > bjMap ; Map < String , BorrowModel > yjMap ; Map", "gt": "< String , InterestModel > lxMap ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import java . math . BigDecimal ; import java . util . Map ; @ Data public class ForceModelAll { private String memberId ; private boolean resetFlag = false ; private Long lastCheckTime = <NUM_LIT> ; private BigDecimal lastFxl = BigDecimal . ZERO ; private BigDecimal totalBjUsdt ; private BigDecimal totalYjUsdt ; private BigDecimal totalLxUsdt ; Map < String , BalanceModel > bjMap ; Map < String , BorrowModel > yjMap ; Map < String , InterestModel > lxMap ; @ Data public static class BalanceModel { BigDecimal", "gt": "balance = BigDecimal . ZERO ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import java . math . BigDecimal ; import java . util . Map ; @ Data public class ForceModelAll { private String memberId ; private boolean resetFlag = false ; private Long lastCheckTime = <NUM_LIT> ; private BigDecimal lastFxl = BigDecimal . ZERO ; private BigDecimal totalBjUsdt ; private BigDecimal totalYjUsdt ; private BigDecimal totalLxUsdt ; Map < String , BalanceModel > bjMap ; Map < String , BorrowModel > yjMap ; Map < String , InterestModel > lxMap ; @ Data public static class BalanceModel { BigDecimal balance = BigDecimal . ZERO ; BigDecimal", "gt": "balanceUsdt = BigDecimal . ZERO ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import java . math . BigDecimal ; import java . util . Map ; @ Data public class ForceModelAll { private String memberId ; private boolean resetFlag = false ; private Long lastCheckTime = <NUM_LIT> ; private BigDecimal lastFxl = BigDecimal . ZERO ; private BigDecimal totalBjUsdt ; private BigDecimal totalYjUsdt ; private BigDecimal totalLxUsdt ; Map < String , BalanceModel > bjMap ; Map < String , BorrowModel > yjMap ; Map < String , InterestModel > lxMap ; @ Data public static class BalanceModel { BigDecimal balance = BigDecimal . ZERO ; BigDecimal balanceUsdt = BigDecimal . ZERO ; } @ Data public static class BorrowModel { BigDecimal", "gt": "balance = BigDecimal . ZERO ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb", "gt": "= WorkbookFactory . create ( new File ( path ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result", "gt": "= readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch", "gt": "( InvalidFormatException e ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet", "gt": "sheet = wb . getSheetAt ( sheetIndex ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList", "gt": "< Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for", "gt": "( int i = startReadLine ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i", "gt": "< sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row", "gt": "= sheet . getRow ( i ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map", "gt": "< String , String > map = new HashMap < String , String > ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String", "gt": "returnStr = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean", "gt": "isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if", "gt": "( isMerge ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String", "gt": "rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else", "gt": "if ( c . getColumnIndex ( ) == <NUM_LIT> ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map", "gt": ". put ( \"<STR_LIT>\" , returnStr ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map", "gt": ". put ( \"<STR_LIT>\" , returnStr ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map", "gt": ". put ( \"<STR_LIT>\" , returnStr ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else", "gt": "if ( c . getColumnIndex ( ) == <NUM_LIT> ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else", "gt": "if ( c . getColumnIndex ( ) == <NUM_LIT> ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else", "gt": "if ( c . getColumnIndex ( ) == <NUM_LIT> ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map", "gt": ". put ( \"<STR_LIT>\" , returnStr ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else", "gt": "if ( c . getColumnIndex ( ) == <NUM_LIT> ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map", "gt": ". put ( \"<STR_LIT>\" , returnStr ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result", "gt": ". add ( map ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int", "gt": "sheetMergeCount = sheet . getNumMergedRegions ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int", "gt": "lastColumn = ca . getLastColumn ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if", "gt": "( row >= firstRow && row <= lastRow ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if", "gt": "( column >= firstColumn && column <= lastColumn ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row", "gt": "fRow = sheet . getRow ( firstRow ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell", "gt": "fCell = fRow . getCell ( firstColumn ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for", "gt": "( int i = <NUM_LIT> ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int", "gt": "lastColumn = range . getLastColumn ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int", "gt": "firstRow = range . getFirstRow ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int", "gt": "lastRow = range . getLastRow ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if", "gt": "( row == firstRow && row == lastRow ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for", "gt": "( int i = <NUM_LIT> ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int", "gt": "firstColumn = range . getFirstColumn ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int", "gt": "lastRow = range . getLastRow ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if", "gt": "( column >= firstColumn && column <= lastColumn ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return", "gt": "sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet", "gt": ". addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e", "gt": ". fillInStackTrace ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if", "gt": "( cell . getCellTypeEnum ( ) == CellType . STRING ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return", "gt": "cell . getStringCellValue ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else", "gt": "if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else", "gt": "if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return", "gt": "String . valueOf ( cell . getNumericCellValue ( ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String", "gt": "val = value . toString ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if", "gt": "( val . endsWith ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if", "gt": "( isE2007 ) wb = new XSSFWorkbook ( input ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if ( isE2007 ) wb = new XSSFWorkbook ( input ) ; else", "gt": "wb = new HSSFWorkbook ( input ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if ( isE2007 ) wb = new XSSFWorkbook ( input ) ; else wb = new HSSFWorkbook ( input ) ; Sheet sheet = wb . getSheetAt ( <NUM_LIT> ) ; Iterator < Row > rows = sheet . rowIterator ( ) ; while", "gt": "( rows . hasNext ( ) ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if ( isE2007 ) wb = new XSSFWorkbook ( input ) ; else wb = new HSSFWorkbook ( input ) ; Sheet sheet = wb . getSheetAt ( <NUM_LIT> ) ; Iterator < Row > rows = sheet . rowIterator ( ) ; while ( rows . hasNext ( ) ) { Row row = rows . next ( ) ; System . out . println ( \"<STR_LIT>\" + row . getRowNum ( ) ) ; Iterator", "gt": "< Cell > cells = row . cellIterator ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if ( isE2007 ) wb = new XSSFWorkbook ( input ) ; else wb = new HSSFWorkbook ( input ) ; Sheet sheet = wb . getSheetAt ( <NUM_LIT> ) ; Iterator < Row > rows = sheet . rowIterator ( ) ; while ( rows . hasNext ( ) ) { Row row = rows . next ( ) ; System . out . println ( \"<STR_LIT>\" + row . getRowNum ( ) ) ; Iterator < Cell > cells = row . cellIterator ( ) ; while ( cells . hasNext ( ) ) { Cell", "gt": "cell = cells . next ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if ( isE2007 ) wb = new XSSFWorkbook ( input ) ; else wb = new HSSFWorkbook ( input ) ; Sheet sheet = wb . getSheetAt ( <NUM_LIT> ) ; Iterator < Row > rows = sheet . rowIterator ( ) ; while ( rows . hasNext ( ) ) { Row row = rows . next ( ) ; System . out . println ( \"<STR_LIT>\" + row . getRowNum ( ) ) ; Iterator < Cell > cells = row . cellIterator ( ) ; while ( cells . hasNext ( ) ) { Cell cell = cells . next ( ) ; System", "gt": ". out . println ( \"<STR_LIT>\" + cell . getColumnIndex ( ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if ( isE2007 ) wb = new XSSFWorkbook ( input ) ; else wb = new HSSFWorkbook ( input ) ; Sheet sheet = wb . getSheetAt ( <NUM_LIT> ) ; Iterator < Row > rows = sheet . rowIterator ( ) ; while ( rows . hasNext ( ) ) { Row row = rows . next ( ) ; System . out . println ( \"<STR_LIT>\" + row . getRowNum ( ) ) ; Iterator < Cell > cells = row . cellIterator ( ) ; while ( cells . hasNext ( ) ) { Cell cell = cells . next ( ) ; System . out . println ( \"<STR_LIT>\" + cell . getColumnIndex ( ) ) ; switch ( cell . getCellTypeEnum ( ) ) { case", "gt": "NUMERIC : System . out . println ( cell . getNumericCellValue ( ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if ( isE2007 ) wb = new XSSFWorkbook ( input ) ; else wb = new HSSFWorkbook ( input ) ; Sheet sheet = wb . getSheetAt ( <NUM_LIT> ) ; Iterator < Row > rows = sheet . rowIterator ( ) ; while ( rows . hasNext ( ) ) { Row row = rows . next ( ) ; System . out . println ( \"<STR_LIT>\" + row . getRowNum ( ) ) ; Iterator < Cell > cells = row . cellIterator ( ) ; while ( cells . hasNext ( ) ) { Cell cell = cells . next ( ) ; System . out . println ( \"<STR_LIT>\" + cell . getColumnIndex ( ) ) ; switch ( cell . getCellTypeEnum ( ) ) { case NUMERIC : System . out . println ( cell . getNumericCellValue ( ) ) ; break ; case", "gt": "STRING : System . out . println ( cell . getStringCellValue ( ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if ( isE2007 ) wb = new XSSFWorkbook ( input ) ; else wb = new HSSFWorkbook ( input ) ; Sheet sheet = wb . getSheetAt ( <NUM_LIT> ) ; Iterator < Row > rows = sheet . rowIterator ( ) ; while ( rows . hasNext ( ) ) { Row row = rows . next ( ) ; System . out . println ( \"<STR_LIT>\" + row . getRowNum ( ) ) ; Iterator < Cell > cells = row . cellIterator ( ) ; while ( cells . hasNext ( ) ) { Cell cell = cells . next ( ) ; System . out . println ( \"<STR_LIT>\" + cell . getColumnIndex ( ) ) ; switch ( cell . getCellTypeEnum ( ) ) { case NUMERIC : System . out . println ( cell . getNumericCellValue ( ) ) ; break ; case STRING : System . out . println ( cell . getStringCellValue ( ) ) ; break ; case", "gt": "BOOLEAN : System . out . println ( cell . getBooleanCellValue ( ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if ( isE2007 ) wb = new XSSFWorkbook ( input ) ; else wb = new HSSFWorkbook ( input ) ; Sheet sheet = wb . getSheetAt ( <NUM_LIT> ) ; Iterator < Row > rows = sheet . rowIterator ( ) ; while ( rows . hasNext ( ) ) { Row row = rows . next ( ) ; System . out . println ( \"<STR_LIT>\" + row . getRowNum ( ) ) ; Iterator < Cell > cells = row . cellIterator ( ) ; while ( cells . hasNext ( ) ) { Cell cell = cells . next ( ) ; System . out . println ( \"<STR_LIT>\" + cell . getColumnIndex ( ) ) ; switch ( cell . getCellTypeEnum ( ) ) { case NUMERIC : System . out . println ( cell . getNumericCellValue ( ) ) ; break ; case STRING : System . out . println ( cell . getStringCellValue ( ) ) ; break ; case BOOLEAN : System . out . println ( cell . getBooleanCellValue ( ) ) ; break ; case", "gt": "FORMULA : System . out . println ( cell . getCellFormula ( ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if ( isE2007 ) wb = new XSSFWorkbook ( input ) ; else wb = new HSSFWorkbook ( input ) ; Sheet sheet = wb . getSheetAt ( <NUM_LIT> ) ; Iterator < Row > rows = sheet . rowIterator ( ) ; while ( rows . hasNext ( ) ) { Row row = rows . next ( ) ; System . out . println ( \"<STR_LIT>\" + row . getRowNum ( ) ) ; Iterator < Cell > cells = row . cellIterator ( ) ; while ( cells . hasNext ( ) ) { Cell cell = cells . next ( ) ; System . out . println ( \"<STR_LIT>\" + cell . getColumnIndex ( ) ) ; switch ( cell . getCellTypeEnum ( ) ) { case NUMERIC : System . out . println ( cell . getNumericCellValue ( ) ) ; break ; case STRING : System . out . println ( cell . getStringCellValue ( ) ) ; break ; case BOOLEAN : System . out . println ( cell . getBooleanCellValue ( ) ) ; break ; case FORMULA : System . out . println ( cell . getCellFormula ( ) ) ; break ; default", "gt": ": System . out . println ( \"<STR_LIT>\" + cell . getCellTypeEnum ( ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . ss . util . CellRangeAddress ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class ExcelUtil { public static ArrayList < Map < String , String > > readExcelToObj ( String path ) { Workbook wb = null ; ArrayList < Map < String , String > > result = null ; try { wb = WorkbookFactory . create ( new File ( path ) ) ; result = readExcel ( wb , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } catch ( InvalidFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static ArrayList < Map < String , String > > readExcel ( Workbook wb , int sheetIndex , int startReadLine , int tailLine ) { Sheet sheet = wb . getSheetAt ( sheetIndex ) ; Row row = null ; ArrayList < Map < String , String > > result = new ArrayList < Map < String , String > > ( ) ; for ( int i = startReadLine ; i < sheet . getLastRowNum ( ) - tailLine + <NUM_LIT> ; i ++ ) { row = sheet . getRow ( i ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( Cell c : row ) { String returnStr = \"<STR_LIT>\" ; boolean isMerge = isMergedRegion ( sheet , i , c . getColumnIndex ( ) ) ; if ( isMerge ) { String rs = getMergedRegionValue ( sheet , row . getRowNum ( ) , c . getColumnIndex ( ) ) ; returnStr = rs ; } else { returnStr = c . getRichStringCellValue ( ) . getString ( ) ; } if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } else if ( c . getColumnIndex ( ) == <NUM_LIT> ) { map . put ( \"<STR_LIT>\" , returnStr ) ; } } result . add ( map ) ; } return result ; } public static String getMergedRegionValue ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress ca = sheet . getMergedRegion ( i ) ; int firstColumn = ca . getFirstColumn ( ) ; int lastColumn = ca . getLastColumn ( ) ; int firstRow = ca . getFirstRow ( ) ; int lastRow = ca . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { Row fRow = sheet . getRow ( firstRow ) ; Cell fCell = fRow . getCell ( firstColumn ) ; return getCellValue ( fCell ) ; } } } return null ; } public static boolean isMergedRow ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row == firstRow && row == lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean isMergedRegion ( Sheet sheet , int row , int column ) { int sheetMergeCount = sheet . getNumMergedRegions ( ) ; for ( int i = <NUM_LIT> ; i < sheetMergeCount ; i ++ ) { CellRangeAddress range = sheet . getMergedRegion ( i ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; if ( row >= firstRow && row <= lastRow ) { if ( column >= firstColumn && column <= lastColumn ) { return true ; } } } return false ; } public static boolean hasMerged ( Sheet sheet ) { return sheet . getNumMergedRegions ( ) > <NUM_LIT> ? true : false ; } public static void mergeRegion ( Sheet sheet , int firstRow , int lastRow , int firstCol , int lastCol ) { try { sheet . addMergedRegion ( new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ) ; } catch ( IllegalArgumentException e ) { e . fillInStackTrace ( ) ; } } public static String getCellValue ( Cell cell ) { if ( cell == null ) return \"<STR_LIT>\" ; if ( cell . getCellTypeEnum ( ) == CellType . STRING ) { return cell . getStringCellValue ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . BOOLEAN ) { return String . valueOf ( cell . getBooleanCellValue ( ) ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { return cell . getCellFormula ( ) ; } else if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { return String . valueOf ( cell . getNumericCellValue ( ) ) ; } return \"<STR_LIT>\" ; } public static String remove0Suffix ( Object value ) { if ( value != null ) { String val = value . toString ( ) ; if ( val . endsWith ( \"<STR_LIT>\" ) ) { val = val . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return val ; } return null ; } public static void readContent ( String fileName ) { boolean isE2007 = false ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) isE2007 = true ; try { InputStream input = new FileInputStream ( fileName ) ; Workbook wb = null ; if ( isE2007 ) wb = new XSSFWorkbook ( input ) ; else wb = new HSSFWorkbook ( input ) ; Sheet sheet = wb . getSheetAt ( <NUM_LIT> ) ; Iterator < Row > rows = sheet . rowIterator ( ) ; while ( rows . hasNext ( ) ) { Row row = rows . next ( ) ; System . out . println ( \"<STR_LIT>\" + row . getRowNum ( ) ) ; Iterator < Cell > cells = row . cellIterator ( ) ; while ( cells . hasNext ( ) ) { Cell cell = cells . next ( ) ; System . out . println ( \"<STR_LIT>\" + cell . getColumnIndex ( ) ) ; switch ( cell . getCellTypeEnum ( ) ) { case NUMERIC : System . out . println ( cell . getNumericCellValue ( ) ) ; break ; case STRING : System . out . println ( cell . getStringCellValue ( ) ) ; break ; case BOOLEAN : System . out . println ( cell . getBooleanCellValue ( ) ) ; break ; case FORMULA : System . out . println ( cell . getCellFormula ( ) ) ; break ; default : System . out . println ( \"<STR_LIT>\" + cell . getCellTypeEnum ( ) ) ; break ; } } } } catch ( IOException ex ) { ex", "gt": ". printStackTrace ( ) ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . apache . ibatis . annotations . Param ; import org . springblade . cgform . entity . Category ; import java . util . List ; public interface CategoryMapper extends BaseMapper < Category > { String", "gt": "queryCategoryIdByCode ( @ Param ( \"<STR_LIT>\" ) String code ) ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . apache . ibatis . annotations . Param ; import org . springblade . cgform . entity . Category ; import java . util . List ; public interface CategoryMapper extends BaseMapper < Category > { String queryCategoryIdByCode ( @ Param ( \"<STR_LIT>\" ) String code ) ; List", "gt": "< Category > getAllSubList ( Long id ) ;"}
{"input": "package org . springblade . config . autopoi . poi . cache . manager ; import com . google . common . cache . CacheBuilder ; import com . google . common . cache . CacheLoader ; import com . google . common . cache . LoadingCache ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . util . Arrays ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; public final class POICacheManager { private static final Logger LOGGER = LoggerFactory . getLogger ( POICacheManager . class ) ; private static LoadingCache < String , byte [ ] > loadingCache ; static { loadingCache", "gt": "= CacheBuilder . newBuilder ( ) . expireAfterWrite ( <NUM_LIT> , TimeUnit . DAYS ) . maximumSize ( <NUM_LIT> ) . build ( new CacheLoader < String , byte [ ] > ( ) {"}
{"input": "package org . springblade . config . autopoi . poi . cache . manager ; import com . google . common . cache . CacheBuilder ; import com . google . common . cache . CacheLoader ; import com . google . common . cache . LoadingCache ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . util . Arrays ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; public final class POICacheManager { private static final Logger LOGGER = LoggerFactory . getLogger ( POICacheManager . class ) ; private static LoadingCache < String , byte [ ] > loadingCache ; static { loadingCache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <NUM_LIT> , TimeUnit . DAYS ) . maximumSize ( <NUM_LIT> ) . build ( new CacheLoader < String , byte [ ] > ( ) { @ Override public byte [ ] load ( String url ) throws Exception { return null ; } } ) ; } public static InputStream getFile ( String id ) { try { byte [ ] result = Arrays . copyOf ( loadingCache . get ( id ) , loadingCache . get ( id ) . length ) ; return", "gt": "new ByteArrayInputStream ( result ) ;"}
{"input": "package org . springblade . config . autopoi . poi . cache . manager ; import com . google . common . cache . CacheBuilder ; import com . google . common . cache . CacheLoader ; import com . google . common . cache . LoadingCache ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . util . Arrays ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; public final class POICacheManager { private static final Logger LOGGER = LoggerFactory . getLogger ( POICacheManager . class ) ; private static LoadingCache < String , byte [ ] > loadingCache ; static { loadingCache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <NUM_LIT> , TimeUnit . DAYS ) . maximumSize ( <NUM_LIT> ) . build ( new CacheLoader < String , byte [ ] > ( ) { @ Override public byte [ ] load ( String url ) throws Exception { return null ; } } ) ; } public static InputStream getFile ( String id ) { try { byte [ ] result = Arrays . copyOf ( loadingCache . get ( id ) , loadingCache . get ( id ) . length ) ; return new ByteArrayInputStream ( result ) ; } catch ( ExecutionException e ) { LOGGER", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package org . springblade . web . config . engine ; import lombok . extern . slf4j . Slf4j ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ Slf4j public class CoinMatchFactoryConfig { @ Bean public CoinMatchFactoryExchange getExchangeMatchFactory ( ) { CoinMatchFactoryExchange factory = new CoinMatchFactoryExchange ( ) ; return factory ; } @ Bean public CoinMatchFactoryExchangeAll getExchangeAllMatchFactory ( ) { CoinMatchFactoryExchangeAll factory = new CoinMatchFactoryExchangeAll ( ) ; return factory ; } @ Bean public CoinMatchContractFactory getCoinMatchContractFactory ( ) { CoinMatchContractFactory", "gt": "factory = new CoinMatchContractFactory ( ) ;"}
{"input": "package org . springblade . web . config . engine ; import lombok . extern . slf4j . Slf4j ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ Slf4j public class CoinMatchFactoryConfig { @ Bean public CoinMatchFactoryExchange getExchangeMatchFactory ( ) { CoinMatchFactoryExchange factory = new CoinMatchFactoryExchange ( ) ; return factory ; } @ Bean public CoinMatchFactoryExchangeAll getExchangeAllMatchFactory ( ) { CoinMatchFactoryExchangeAll factory = new CoinMatchFactoryExchangeAll ( ) ; return factory ; } @ Bean public CoinMatchContractFactory getCoinMatchContractFactory ( ) { CoinMatchContractFactory factory = new CoinMatchContractFactory ( ) ; return factory ; } @ Bean public CoinMatchContractFactoryAll getCoinMatchContractFactoryAll ( ) { CoinMatchContractFactoryAll", "gt": "factory = new CoinMatchContractFactoryAll ( ) ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; public class SelTreeFieldCommentConverter extends TableFieldCommentConverter { public SelTreeFieldCommentConverter ( CgformField onlCgformField ) { String", "gt": "dictText = onlCgformField . getDictText ( ) ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; public class SelTreeFieldCommentConverter extends TableFieldCommentConverter { public SelTreeFieldCommentConverter ( CgformField onlCgformField ) { String dictText = onlCgformField . getDictText ( ) ; String [ ] strings = dictText . split ( \"<STR_LIT>\" ) ; this", "gt": ". setTable ( onlCgformField . getDictTable ( ) ) ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . DeptHModel ; import org . springblade . model . DetailMessageModel ; import org . springblade . model . KlineMessageModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMarketClient { String API_PREFIX = \"<STR_LIT>\" ; String HANDLE_XXL_JOB = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "HANDLE_XXL_JOB_PING = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . DeptHModel ; import org . springblade . model . DetailMessageModel ; import org . springblade . model . KlineMessageModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMarketClient { String API_PREFIX = \"<STR_LIT>\" ; String HANDLE_XXL_JOB = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_PING = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_CONNECTSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "HANDLE_XXL_JOB_REQKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . DeptHModel ; import org . springblade . model . DetailMessageModel ; import org . springblade . model . KlineMessageModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMarketClient { String API_PREFIX = \"<STR_LIT>\" ; String HANDLE_XXL_JOB = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_PING = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_CONNECTSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET_NUM = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_OKX_QUOTEDPRICE = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "HANDLE_XXL_JOB_BORROW_INTEREST = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . DeptHModel ; import org . springblade . model . DetailMessageModel ; import org . springblade . model . KlineMessageModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMarketClient { String API_PREFIX = \"<STR_LIT>\" ; String HANDLE_XXL_JOB = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_PING = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_CONNECTSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET_NUM = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_OKX_QUOTEDPRICE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_BORROW_INTEREST = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "MESSAGE_INITDATA = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . DeptHModel ; import org . springblade . model . DetailMessageModel ; import org . springblade . model . KlineMessageModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMarketClient { String API_PREFIX = \"<STR_LIT>\" ; String HANDLE_XXL_JOB = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_PING = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_CONNECTSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET_NUM = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_OKX_QUOTEDPRICE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_BORROW_INTEREST = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_INITDATA = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "MESSAGE_CONTRACT_DETAIL = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . DeptHModel ; import org . springblade . model . DetailMessageModel ; import org . springblade . model . KlineMessageModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMarketClient { String API_PREFIX = \"<STR_LIT>\" ; String HANDLE_XXL_JOB = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_PING = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_CONNECTSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET_NUM = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_OKX_QUOTEDPRICE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_BORROW_INTEREST = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_INITDATA = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_CONTRACT_DETAIL = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_WEB_DETAIL = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "MESSAGE_WEB_KLINE = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . DeptHModel ; import org . springblade . model . DetailMessageModel ; import org . springblade . model . KlineMessageModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMarketClient { String API_PREFIX = \"<STR_LIT>\" ; String HANDLE_XXL_JOB = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_PING = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_CONNECTSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET_NUM = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_OKX_QUOTEDPRICE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_BORROW_INTEREST = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_INITDATA = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_CONTRACT_DETAIL = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_WEB_DETAIL = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_WEB_KLINE = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_WEB_DEPTH = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_COINHOUSE_XH_ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "MESSAGE_COINHOUSE_XH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . DeptHModel ; import org . springblade . model . DetailMessageModel ; import org . springblade . model . KlineMessageModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMarketClient { String API_PREFIX = \"<STR_LIT>\" ; String HANDLE_XXL_JOB = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_PING = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_CONNECTSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBSOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_SUBKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_REQKLINESOCKET_NUM = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_OKX_QUOTEDPRICE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_BORROW_INTEREST = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_INITDATA = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_CONTRACT_DETAIL = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_WEB_DETAIL = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_WEB_KLINE = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_WEB_DEPTH = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_COINHOUSE_XH_ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_COINHOUSE_XH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MESSAGE_COINHOUSE_XH_KLINE_GENERATE = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "GET_NOW_XH_PRICE = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String", "gt": "APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String", "gt": "NACOS_DEV_ADDR = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String", "gt": "NACOS_TEST_ADDR = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String", "gt": "SENTINEL_PROD_ADDR = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String", "gt": "ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String", "gt": "ELK_DEV_ADDR = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String", "gt": "ELK_TEST_ADDR = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String", "gt": "FILE_MODE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String", "gt": "DEFAULT_MODE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String", "gt": "GROUP_NAME = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static", "gt": "String seataServiceGroup ( String appName ) {"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return", "gt": "appName . concat ( GROUP_NAME ) ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static", "gt": "String nacosAddr ( String profile ) {"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case", "gt": "( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case", "gt": "( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default", "gt": ": return NACOS_DEV_ADDR ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default : return NACOS_DEV_ADDR ; } } static", "gt": "String sentinelAddr ( String profile ) {"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default : return NACOS_DEV_ADDR ; } } static String sentinelAddr ( String profile ) { switch", "gt": "( profile ) {"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default : return NACOS_DEV_ADDR ; } } static String sentinelAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SENTINEL_PROD_ADDR ; case", "gt": "( AppConstant . TEST_CODE ) : return SENTINEL_TEST_ADDR ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default : return NACOS_DEV_ADDR ; } } static String sentinelAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SENTINEL_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SENTINEL_TEST_ADDR ; default", "gt": ": return SENTINEL_DEV_ADDR ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default : return NACOS_DEV_ADDR ; } } static String sentinelAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SENTINEL_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SENTINEL_TEST_ADDR ; default : return SENTINEL_DEV_ADDR ; } } static String seataAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SEATA_PROD_ADDR ; case", "gt": "( AppConstant . TEST_CODE ) : return SEATA_TEST_ADDR ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default : return NACOS_DEV_ADDR ; } } static String sentinelAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SENTINEL_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SENTINEL_TEST_ADDR ; default : return SENTINEL_DEV_ADDR ; } } static String seataAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SEATA_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SEATA_TEST_ADDR ; default", "gt": ": return SEATA_DEV_ADDR ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default : return NACOS_DEV_ADDR ; } } static String sentinelAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SENTINEL_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SENTINEL_TEST_ADDR ; default : return SENTINEL_DEV_ADDR ; } } static String seataAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SEATA_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SEATA_TEST_ADDR ; default : return SEATA_DEV_ADDR ; } } static", "gt": "String zipkinAddr ( String profile ) {"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default : return NACOS_DEV_ADDR ; } } static String sentinelAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SENTINEL_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SENTINEL_TEST_ADDR ; default : return SENTINEL_DEV_ADDR ; } } static String seataAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SEATA_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SEATA_TEST_ADDR ; default : return SEATA_DEV_ADDR ; } } static String zipkinAddr ( String profile ) { switch ( profile ) { case", "gt": "( AppConstant . PROD_CODE ) : return ZIPKIN_PROD_ADDR ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default : return NACOS_DEV_ADDR ; } } static String sentinelAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SENTINEL_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SENTINEL_TEST_ADDR ; default : return SENTINEL_DEV_ADDR ; } } static String seataAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SEATA_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SEATA_TEST_ADDR ; default : return SEATA_DEV_ADDR ; } } static String zipkinAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return ZIPKIN_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return ZIPKIN_TEST_ADDR ; default : return ZIPKIN_DEV_ADDR ; } } static String elkAddr ( String profile ) { switch", "gt": "( profile ) {"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default : return NACOS_DEV_ADDR ; } } static String sentinelAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SENTINEL_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SENTINEL_TEST_ADDR ; default : return SENTINEL_DEV_ADDR ; } } static String seataAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SEATA_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SEATA_TEST_ADDR ; default : return SEATA_DEV_ADDR ; } } static String zipkinAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return ZIPKIN_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return ZIPKIN_TEST_ADDR ; default : return ZIPKIN_DEV_ADDR ; } } static String elkAddr ( String profile ) { switch ( profile ) { case", "gt": "( AppConstant . PROD_CODE ) : return ELK_PROD_ADDR ;"}
{"input": "package org . springblade . common . constant ; import org . springblade . core . launch . constant . AppConstant ; import static org . springblade . core . launch . constant . AppConstant . APPLICATION_NAME_PREFIX ; public interface LauncherConstant { String APPLICATION_XXLJOB_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String APPLICATION_XXLJOB_ADMIN_NAME = APPLICATION_NAME_PREFIX + \"<STR_LIT>\" ; String NACOS_DEV_ADDR = \"<STR_LIT>\" ; String NACOS_PROD_ADDR = \"<STR_LIT>\" ; String NACOS_TEST_ADDR = \"<STR_LIT>\" ; String SENTINEL_DEV_ADDR = \"<STR_LIT>\" ; String SENTINEL_PROD_ADDR = \"<STR_LIT>\" ; String SENTINEL_TEST_ADDR = \"<STR_LIT>\" ; String SEATA_DEV_ADDR = \"<STR_LIT>\" ; String SEATA_PROD_ADDR = \"<STR_LIT>\" ; String SEATA_TEST_ADDR = \"<STR_LIT>\" ; String ZIPKIN_DEV_ADDR = \"<STR_LIT>\" ; String ZIPKIN_PROD_ADDR = \"<STR_LIT>\" ; String ZIPKIN_TEST_ADDR = \"<STR_LIT>\" ; String ELK_DEV_ADDR = \"<STR_LIT>\" ; String ELK_PROD_ADDR = \"<STR_LIT>\" ; String ELK_TEST_ADDR = \"<STR_LIT>\" ; String FILE_MODE = \"<STR_LIT>\" ; String NACOS_MODE = \"<STR_LIT>\" ; String DEFAULT_MODE = \"<STR_LIT>\" ; String GROUP_NAME = \"<STR_LIT>\" ; static String seataServiceGroup ( String appName ) { return appName . concat ( GROUP_NAME ) ; } static String nacosAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return NACOS_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return NACOS_TEST_ADDR ; default : return NACOS_DEV_ADDR ; } } static String sentinelAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SENTINEL_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SENTINEL_TEST_ADDR ; default : return SENTINEL_DEV_ADDR ; } } static String seataAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return SEATA_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return SEATA_TEST_ADDR ; default : return SEATA_DEV_ADDR ; } } static String zipkinAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return ZIPKIN_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return ZIPKIN_TEST_ADDR ; default : return ZIPKIN_DEV_ADDR ; } } static String elkAddr ( String profile ) { switch ( profile ) { case ( AppConstant . PROD_CODE ) : return ELK_PROD_ADDR ; case ( AppConstant . TEST_CODE ) : return ELK_TEST_ADDR ; default", "gt": ": return ELK_DEV_ADDR ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel ; import org . springblade . config . autopoi . poi . exception . excel . enums . ExcelImportEnum ; public class ExcelImportException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private ExcelImportEnum type ; public ExcelImportException ( ) { super ( ) ; } public ExcelImportException ( ExcelImportEnum type ) { super ( type . getMsg ( ) ) ; this", "gt": ". type = type ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel ; import org . springblade . config . autopoi . poi . exception . excel . enums . ExcelImportEnum ; public class ExcelImportException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private ExcelImportEnum type ; public ExcelImportException ( ) { super ( ) ; } public ExcelImportException ( ExcelImportEnum type ) { super ( type . getMsg ( ) ) ; this . type = type ; } public ExcelImportException ( ExcelImportEnum type , Throwable cause ) { super ( type . getMsg ( ) , cause ) ; } public ExcelImportException ( String message ) { super ( message ) ; } public ExcelImportException ( String message , ExcelImportEnum type ) { super ( message ) ; this . type = type ; } public ExcelImportEnum getType ( ) { return type ; } public void setType ( ExcelImportEnum type ) { this", "gt": ". type = type ;"}
{"input": "package org . springblade . web . service ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MongoDetail ; import java . math . BigDecimal ; import java . util . List ; public interface IMongoService { List", "gt": "< KLine > findAllKLine ( String type , String symbolName , long fromTime , long toTime , String period ) ;"}
{"input": "package org . springblade . web . service ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MongoDetail ; import java . math . BigDecimal ; import java . util . List ; public interface IMongoService { List < KLine > findAllKLine ( String type , String symbolName , long fromTime , long toTime , String period ) ; BigDecimal", "gt": "getPriceBySymbol ( String type , String symbolName ) ;"}
{"input": "package org . springblade . web . service ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MongoDetail ; import java . math . BigDecimal ; import java . util . List ; public interface IMongoService { List < KLine > findAllKLine ( String type , String symbolName , long fromTime , long toTime , String period ) ; BigDecimal getPriceBySymbol ( String type , String symbolName ) ; Long", "gt": "getUpdateTimeBySymbol ( String type , String symbolName ) ;"}
{"input": "package org . springblade . web . service ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MongoDetail ; import java . math . BigDecimal ; import java . util . List ; public interface IMongoService { List < KLine > findAllKLine ( String type , String symbolName , long fromTime , long toTime , String period ) ; BigDecimal getPriceBySymbol ( String type , String symbolName ) ; Long getUpdateTimeBySymbol ( String type , String symbolName ) ; BigDecimal", "gt": "getPriceBySymbol ( String symbolName ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e", "gt": ". printStackTrace ( ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw", "gt": "new RuntimeException ( className + \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String", "gt": "clsName = object . getClass ( ) . getName ( ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if", "gt": "( cls == null ) {"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw", "gt": "new IllegalArgumentException ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package", "gt": "pack = cls . getPackage ( ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if", "gt": "( pack != null ) {"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if", "gt": "( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw", "gt": "new IllegalArgumentException ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } clsName", "gt": "= clsName . substring ( packName . length ( ) + <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } clsName = clsName . substring ( packName . length ( ) + <NUM_LIT> ) ; if", "gt": "( packName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) {"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } clsName = clsName . substring ( packName . length ( ) + <NUM_LIT> ) ; if ( packName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { path = packName + \"<STR_LIT>\" ; } else { int start = <NUM_LIT> , end = <NUM_LIT> ; end", "gt": "= packName . indexOf ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } clsName = clsName . substring ( packName . length ( ) + <NUM_LIT> ) ; if ( packName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { path = packName + \"<STR_LIT>\" ; } else { int start = <NUM_LIT> , end = <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" ) ; while ( end != - <NUM_LIT> ) { path", "gt": "= path + packName . substring ( start , end ) + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } clsName = clsName . substring ( packName . length ( ) + <NUM_LIT> ) ; if ( packName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { path = packName + \"<STR_LIT>\" ; } else { int start = <NUM_LIT> , end = <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" ) ; while ( end != - <NUM_LIT> ) { path = path + packName . substring ( start , end ) + \"<STR_LIT>\" ; start = end + <NUM_LIT> ; end", "gt": "= packName . indexOf ( \"<STR_LIT>\" , start ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } clsName = clsName . substring ( packName . length ( ) + <NUM_LIT> ) ; if ( packName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { path = packName + \"<STR_LIT>\" ; } else { int start = <NUM_LIT> , end = <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" ) ; while ( end != - <NUM_LIT> ) { path = path + packName . substring ( start , end ) + \"<STR_LIT>\" ; start = end + <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" , start ) ; } path = path + packName . substring ( start ) + \"<STR_LIT>\" ; } } java . net . URL url = loader . getResource ( path + clsName ) ; String realPath = url . getPath ( ) ; int pos = realPath . indexOf ( \"<STR_LIT>\" ) ; if", "gt": "( pos > - <NUM_LIT> ) {"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } clsName = clsName . substring ( packName . length ( ) + <NUM_LIT> ) ; if ( packName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { path = packName + \"<STR_LIT>\" ; } else { int start = <NUM_LIT> , end = <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" ) ; while ( end != - <NUM_LIT> ) { path = path + packName . substring ( start , end ) + \"<STR_LIT>\" ; start = end + <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" , start ) ; } path = path + packName . substring ( start ) + \"<STR_LIT>\" ; } } java . net . URL url = loader . getResource ( path + clsName ) ; String realPath = url . getPath ( ) ; int pos = realPath . indexOf ( \"<STR_LIT>\" ) ; if ( pos > - <NUM_LIT> ) { realPath", "gt": "= realPath . substring ( pos + <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } clsName = clsName . substring ( packName . length ( ) + <NUM_LIT> ) ; if ( packName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { path = packName + \"<STR_LIT>\" ; } else { int start = <NUM_LIT> , end = <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" ) ; while ( end != - <NUM_LIT> ) { path = path + packName . substring ( start , end ) + \"<STR_LIT>\" ; start = end + <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" , start ) ; } path = path + packName . substring ( start ) + \"<STR_LIT>\" ; } } java . net . URL url = loader . getResource ( path + clsName ) ; String realPath = url . getPath ( ) ; int pos = realPath . indexOf ( \"<STR_LIT>\" ) ; if ( pos > - <NUM_LIT> ) { realPath = realPath . substring ( pos + <NUM_LIT> ) ; } pos = realPath . indexOf ( path + clsName ) ; realPath", "gt": "= realPath . substring ( <NUM_LIT> , pos - <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } clsName = clsName . substring ( packName . length ( ) + <NUM_LIT> ) ; if ( packName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { path = packName + \"<STR_LIT>\" ; } else { int start = <NUM_LIT> , end = <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" ) ; while ( end != - <NUM_LIT> ) { path = path + packName . substring ( start , end ) + \"<STR_LIT>\" ; start = end + <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" , start ) ; } path = path + packName . substring ( start ) + \"<STR_LIT>\" ; } } java . net . URL url = loader . getResource ( path + clsName ) ; String realPath = url . getPath ( ) ; int pos = realPath . indexOf ( \"<STR_LIT>\" ) ; if ( pos > - <NUM_LIT> ) { realPath = realPath . substring ( pos + <NUM_LIT> ) ; } pos = realPath . indexOf ( path + clsName ) ; realPath = realPath . substring ( <NUM_LIT> , pos - <NUM_LIT> ) ; if", "gt": "( realPath . endsWith ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } clsName = clsName . substring ( packName . length ( ) + <NUM_LIT> ) ; if ( packName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { path = packName + \"<STR_LIT>\" ; } else { int start = <NUM_LIT> , end = <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" ) ; while ( end != - <NUM_LIT> ) { path = path + packName . substring ( start , end ) + \"<STR_LIT>\" ; start = end + <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" , start ) ; } path = path + packName . substring ( start ) + \"<STR_LIT>\" ; } } java . net . URL url = loader . getResource ( path + clsName ) ; String realPath = url . getPath ( ) ; int pos = realPath . indexOf ( \"<STR_LIT>\" ) ; if ( pos > - <NUM_LIT> ) { realPath = realPath . substring ( pos + <NUM_LIT> ) ; } pos = realPath . indexOf ( path + clsName ) ; realPath = realPath . substring ( <NUM_LIT> , pos - <NUM_LIT> ) ; if ( realPath . endsWith ( \"<STR_LIT>\" ) ) { realPath = realPath . substring ( <NUM_LIT> , realPath . lastIndexOf ( \"<STR_LIT>\" ) ) ; } try { realPath", "gt": "= java . net . URLDecoder . decode ( realPath , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util ; public class MyClassLoader extends ClassLoader { public static Class getClassByScn ( String className ) { Class myclass = null ; try { myclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( className + \"<STR_LIT>\" ) ; } return myclass ; } public static String getPackPath ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String clsName = object . getClass ( ) . getName ( ) ; return clsName ; } public static String getAppPath ( Class cls ) { if ( cls == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassLoader loader = cls . getClassLoader ( ) ; String clsName = cls . getName ( ) + \"<STR_LIT>\" ; Package pack = cls . getPackage ( ) ; String path = \"<STR_LIT>\" ; if ( pack != null ) { String packName = pack . getName ( ) ; if ( packName . startsWith ( \"<STR_LIT>\" ) || packName . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } clsName = clsName . substring ( packName . length ( ) + <NUM_LIT> ) ; if ( packName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { path = packName + \"<STR_LIT>\" ; } else { int start = <NUM_LIT> , end = <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" ) ; while ( end != - <NUM_LIT> ) { path = path + packName . substring ( start , end ) + \"<STR_LIT>\" ; start = end + <NUM_LIT> ; end = packName . indexOf ( \"<STR_LIT>\" , start ) ; } path = path + packName . substring ( start ) + \"<STR_LIT>\" ; } } java . net . URL url = loader . getResource ( path + clsName ) ; String realPath = url . getPath ( ) ; int pos = realPath . indexOf ( \"<STR_LIT>\" ) ; if ( pos > - <NUM_LIT> ) { realPath = realPath . substring ( pos + <NUM_LIT> ) ; } pos = realPath . indexOf ( path + clsName ) ; realPath = realPath . substring ( <NUM_LIT> , pos - <NUM_LIT> ) ; if ( realPath . endsWith ( \"<STR_LIT>\" ) ) { realPath = realPath . substring ( <NUM_LIT> , realPath . lastIndexOf ( \"<STR_LIT>\" ) ) ; } try { realPath = java . net . URLDecoder . decode ( realPath , \"<STR_LIT>\" ) ; } catch ( Exception e ) { throw", "gt": "new RuntimeException ( e ) ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformEnhanceSql ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . model . CgformEnhanceJavaBatchInter ; import org . springblade . config . exception . BusinessException ; import org . springblade . core . mp . base . BaseService ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . List ; import java . util . Map ; public interface ICgformEnhanceSqlService extends BaseService < CgformEnhanceSql > { void", "gt": "executeEnhanceSqlList ( CgformHead head , String buttonCode , Map < String , Object > params ) ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformEnhanceSql ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . model . CgformEnhanceJavaBatchInter ; import org . springblade . config . exception . BusinessException ; import org . springblade . core . mp . base . BaseService ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . List ; import java . util . Map ; public interface ICgformEnhanceSqlService extends BaseService < CgformEnhanceSql > { void executeEnhanceSqlList ( CgformHead head , String buttonCode , Map < String , Object > params ) ; void", "gt": "saveBatchCodeOnlineTable ( CgformHead onlcgformhead , List < CgformField > fieldList , List < Map < String , Object > > dataList , String batchCode ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle", "gt": "resourceBundle = null ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final", "gt": "String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log", "gt": ". debug ( \"<STR_LIT>\" + string ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch", "gt": "( IOException e ) {"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if", "gt": "( inputStream != null ) {"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch", "gt": "( IOException ex ) {"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch", "gt": "( IOException ex2 ) {"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return", "gt": "DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return", "gt": "DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return", "gt": "CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return", "gt": "CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return", "gt": "CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return", "gt": "CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final", "gt": "String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if", "gt": "( string != null && ! \"<STR_LIT>\" . equals ( string ) ) {"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig", "gt": ". projectPath = string ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return", "gt": "DbConfig . projectPath ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE", "gt": "= getResourceBundleInConfig ( DATABASE_CONFIG ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE", "gt": "= ResourceBundle . getBundle ( DATABASE_CONFIG ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE", "gt": "= getResourceBundleInConfig ( CODE_CONFIG ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if", "gt": "( CODE_RESOURCE_BUNDLE == null ) {"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig", "gt": ". dbType = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig", "gt": ". driver = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig", "gt": ". dbName = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig . dbName = \"<STR_LIT>\" ; DbConfig", "gt": ". projectPath = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig . dbName = \"<STR_LIT>\" ; DbConfig . projectPath = \"<STR_LIT>\" ; DbConfig . bussiPackage = \"<STR_LIT>\" ; DbConfig . sourceRoot = \"<STR_LIT>\" ; DbConfig", "gt": ". webRoot = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig . dbName = \"<STR_LIT>\" ; DbConfig . projectPath = \"<STR_LIT>\" ; DbConfig . bussiPackage = \"<STR_LIT>\" ; DbConfig . sourceRoot = \"<STR_LIT>\" ; DbConfig . webRoot = \"<STR_LIT>\" ; DbConfig . templatepath = \"<STR_LIT>\" ; DbConfig", "gt": ". dbFiledConvert = true ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig . dbName = \"<STR_LIT>\" ; DbConfig . projectPath = \"<STR_LIT>\" ; DbConfig . bussiPackage = \"<STR_LIT>\" ; DbConfig . sourceRoot = \"<STR_LIT>\" ; DbConfig . webRoot = \"<STR_LIT>\" ; DbConfig . templatepath = \"<STR_LIT>\" ; DbConfig . dbFiledConvert = true ; DbConfig", "gt": ". pageFieldRequiredNum = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig . dbName = \"<STR_LIT>\" ; DbConfig . projectPath = \"<STR_LIT>\" ; DbConfig . bussiPackage = \"<STR_LIT>\" ; DbConfig . sourceRoot = \"<STR_LIT>\" ; DbConfig . webRoot = \"<STR_LIT>\" ; DbConfig . templatepath = \"<STR_LIT>\" ; DbConfig . dbFiledConvert = true ; DbConfig . pageFieldRequiredNum = \"<STR_LIT>\" ; DbConfig . pageSearchFiledNum = \"<STR_LIT>\" ; DbConfig", "gt": ". pageFieldRowNum = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig . dbName = \"<STR_LIT>\" ; DbConfig . projectPath = \"<STR_LIT>\" ; DbConfig . bussiPackage = \"<STR_LIT>\" ; DbConfig . sourceRoot = \"<STR_LIT>\" ; DbConfig . webRoot = \"<STR_LIT>\" ; DbConfig . templatepath = \"<STR_LIT>\" ; DbConfig . dbFiledConvert = true ; DbConfig . pageFieldRequiredNum = \"<STR_LIT>\" ; DbConfig . pageSearchFiledNum = \"<STR_LIT>\" ; DbConfig . pageFieldRowNum = \"<STR_LIT>\" ; DbConfig . driver = getDriver ( ) ; DbConfig . url = getUrl ( ) ; DbConfig . username = getUsername ( ) ; DbConfig . password = getPassword ( ) ; DbConfig . dbName = getDbName ( ) ; DbConfig", "gt": ". sourceRoot = getSourceRoot ( ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig . dbName = \"<STR_LIT>\" ; DbConfig . projectPath = \"<STR_LIT>\" ; DbConfig . bussiPackage = \"<STR_LIT>\" ; DbConfig . sourceRoot = \"<STR_LIT>\" ; DbConfig . webRoot = \"<STR_LIT>\" ; DbConfig . templatepath = \"<STR_LIT>\" ; DbConfig . dbFiledConvert = true ; DbConfig . pageFieldRequiredNum = \"<STR_LIT>\" ; DbConfig . pageSearchFiledNum = \"<STR_LIT>\" ; DbConfig . pageFieldRowNum = \"<STR_LIT>\" ; DbConfig . driver = getDriver ( ) ; DbConfig . url = getUrl ( ) ; DbConfig . username = getUsername ( ) ; DbConfig . password = getPassword ( ) ; DbConfig . dbName = getDbName ( ) ; DbConfig . sourceRoot = getSourceRoot ( ) ; DbConfig . webRoot = getWebRoot ( ) ; DbConfig . bussiPackage = getBussiPackage ( ) ; DbConfig . templatepath = getTemplatepath ( ) ; DbConfig . projectPath = getProjectPath ( ) ; DbConfig . dbTableId = getDbTableId ( ) ; DbConfig", "gt": ". dbFiledConvert = getDbFiledConvert ( ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig . dbName = \"<STR_LIT>\" ; DbConfig . projectPath = \"<STR_LIT>\" ; DbConfig . bussiPackage = \"<STR_LIT>\" ; DbConfig . sourceRoot = \"<STR_LIT>\" ; DbConfig . webRoot = \"<STR_LIT>\" ; DbConfig . templatepath = \"<STR_LIT>\" ; DbConfig . dbFiledConvert = true ; DbConfig . pageFieldRequiredNum = \"<STR_LIT>\" ; DbConfig . pageSearchFiledNum = \"<STR_LIT>\" ; DbConfig . pageFieldRowNum = \"<STR_LIT>\" ; DbConfig . driver = getDriver ( ) ; DbConfig . url = getUrl ( ) ; DbConfig . username = getUsername ( ) ; DbConfig . password = getPassword ( ) ; DbConfig . dbName = getDbName ( ) ; DbConfig . sourceRoot = getSourceRoot ( ) ; DbConfig . webRoot = getWebRoot ( ) ; DbConfig . bussiPackage = getBussiPackage ( ) ; DbConfig . templatepath = getTemplatepath ( ) ; DbConfig . projectPath = getProjectPath ( ) ; DbConfig . dbTableId = getDbTableId ( ) ; DbConfig . dbFiledConvert = getDbFiledConvert ( ) ; DbConfig . pageFilterFields = getPageFilterFields ( ) ; DbConfig", "gt": ". pageSearchFiledNum = getPageSearchFiledNum ( ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig . dbName = \"<STR_LIT>\" ; DbConfig . projectPath = \"<STR_LIT>\" ; DbConfig . bussiPackage = \"<STR_LIT>\" ; DbConfig . sourceRoot = \"<STR_LIT>\" ; DbConfig . webRoot = \"<STR_LIT>\" ; DbConfig . templatepath = \"<STR_LIT>\" ; DbConfig . dbFiledConvert = true ; DbConfig . pageFieldRequiredNum = \"<STR_LIT>\" ; DbConfig . pageSearchFiledNum = \"<STR_LIT>\" ; DbConfig . pageFieldRowNum = \"<STR_LIT>\" ; DbConfig . driver = getDriver ( ) ; DbConfig . url = getUrl ( ) ; DbConfig . username = getUsername ( ) ; DbConfig . password = getPassword ( ) ; DbConfig . dbName = getDbName ( ) ; DbConfig . sourceRoot = getSourceRoot ( ) ; DbConfig . webRoot = getWebRoot ( ) ; DbConfig . bussiPackage = getBussiPackage ( ) ; DbConfig . templatepath = getTemplatepath ( ) ; DbConfig . projectPath = getProjectPath ( ) ; DbConfig . dbTableId = getDbTableId ( ) ; DbConfig . dbFiledConvert = getDbFiledConvert ( ) ; DbConfig . pageFilterFields = getPageFilterFields ( ) ; DbConfig . pageSearchFiledNum = getPageSearchFiledNum ( ) ; DbConfig . pageFieldRequiredNum = getPageFieldRequiredNum ( ) ; DbConfig . pageFieldRowNum = getPageFieldRowNum ( ) ; if ( url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> || url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DbConfig . dbType = DbConvertDef . MYSQL ; } else", "gt": "if ( url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> || url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) {"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig . dbName = \"<STR_LIT>\" ; DbConfig . projectPath = \"<STR_LIT>\" ; DbConfig . bussiPackage = \"<STR_LIT>\" ; DbConfig . sourceRoot = \"<STR_LIT>\" ; DbConfig . webRoot = \"<STR_LIT>\" ; DbConfig . templatepath = \"<STR_LIT>\" ; DbConfig . dbFiledConvert = true ; DbConfig . pageFieldRequiredNum = \"<STR_LIT>\" ; DbConfig . pageSearchFiledNum = \"<STR_LIT>\" ; DbConfig . pageFieldRowNum = \"<STR_LIT>\" ; DbConfig . driver = getDriver ( ) ; DbConfig . url = getUrl ( ) ; DbConfig . username = getUsername ( ) ; DbConfig . password = getPassword ( ) ; DbConfig . dbName = getDbName ( ) ; DbConfig . sourceRoot = getSourceRoot ( ) ; DbConfig . webRoot = getWebRoot ( ) ; DbConfig . bussiPackage = getBussiPackage ( ) ; DbConfig . templatepath = getTemplatepath ( ) ; DbConfig . projectPath = getProjectPath ( ) ; DbConfig . dbTableId = getDbTableId ( ) ; DbConfig . dbFiledConvert = getDbFiledConvert ( ) ; DbConfig . pageFilterFields = getPageFilterFields ( ) ; DbConfig . pageSearchFiledNum = getPageSearchFiledNum ( ) ; DbConfig . pageFieldRequiredNum = getPageFieldRequiredNum ( ) ; DbConfig . pageFieldRowNum = getPageFieldRowNum ( ) ; if ( url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> || url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DbConfig . dbType = DbConvertDef . MYSQL ; } else if ( url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> || url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DbConfig", "gt": ". dbType = DbConvertDef . ORACLE ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . model . database . util . DbConvertDef ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; @ Slf4j public class DbConfig { private static final String DATABASE_CONFIG = \"<STR_LIT>\" ; private static final String CODE_CONFIG = \"<STR_LIT>\" ; private static ResourceBundle DATABASE_RESOURCE_BUNDLE ; private static ResourceBundle CODE_RESOURCE_BUNDLE ; public static String dbType ; public static String driver ; public static String url ; public static String username ; public static String password ; public static String dbName ; public static String projectPath ; public static String bussiPackage ; public static String sourceRoot ; public static String webRoot ; public static String templatepath ; public static boolean dbFiledConvert ; public static String dbTableId ; public static String pageFieldRequiredNum ; public static String pageSearchFiledNum ; public static String pageFilterFields ; public static String pageFieldRowNum ; private static ResourceBundle getResourceBundleInConfig ( final String s ) { ResourceBundle resourceBundle = null ; InputStream inputStream = null ; final String string = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" + File . separator + s + \"<STR_LIT>\" ; try { inputStream = new BufferedInputStream ( new FileInputStream ( string ) ) ; resourceBundle = new PropertyResourceBundle ( inputStream ) ; ( ( BufferedInputStream ) inputStream ) . close ( ) ; if ( resourceBundle != null ) { log . debug ( \"<STR_LIT>\" + string ) ; } } catch ( IOException e ) { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } finally { if ( inputStream != null ) { try { ( ( BufferedInputStream ) inputStream ) . close ( ) ; } catch ( IOException ex2 ) { ex2 . printStackTrace ( ) ; } } } return resourceBundle ; } public static final String getDriver ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUrl ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getUsername ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPassword ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbName ( ) { return DATABASE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final boolean getDbFiledConvert ( ) { return ! CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ; } private static String getBussiPackage ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getTemplatepath ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getSourceRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getWebRoot ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getDbTableId ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFilterFields ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageSearchFiledNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static final String getPageFieldRequiredNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } private static String getPageFieldRowNum ( ) { return CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; } public static String getProjectPath ( ) { final String string = CODE_RESOURCE_BUNDLE . getString ( \"<STR_LIT>\" ) ; if ( string != null && ! \"<STR_LIT>\" . equals ( string ) ) { DbConfig . projectPath = string ; } return DbConfig . projectPath ; } public static void setProjectPath ( String projectPath ) { DbConfig . projectPath = projectPath ; } public static void setTemplatepath ( String templatepath ) { DbConfig . templatepath = templatepath ; } static { DATABASE_RESOURCE_BUNDLE = getResourceBundleInConfig ( DATABASE_CONFIG ) ; if ( DATABASE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + DATABASE_CONFIG ) ; DATABASE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( DATABASE_CONFIG ) ; } CODE_RESOURCE_BUNDLE = getResourceBundleInConfig ( CODE_CONFIG ) ; if ( CODE_RESOURCE_BUNDLE == null ) { log . debug ( \"<STR_LIT>\" + CODE_CONFIG ) ; CODE_RESOURCE_BUNDLE = ResourceBundle . getBundle ( CODE_CONFIG ) ; } DbConfig . dbType = \"<STR_LIT>\" ; DbConfig . driver = \"<STR_LIT>\" ; DbConfig . url = \"<STR_LIT>\" ; DbConfig . username = \"<STR_LIT>\" ; DbConfig . password = \"<STR_LIT>\" ; DbConfig . dbName = \"<STR_LIT>\" ; DbConfig . projectPath = \"<STR_LIT>\" ; DbConfig . bussiPackage = \"<STR_LIT>\" ; DbConfig . sourceRoot = \"<STR_LIT>\" ; DbConfig . webRoot = \"<STR_LIT>\" ; DbConfig . templatepath = \"<STR_LIT>\" ; DbConfig . dbFiledConvert = true ; DbConfig . pageFieldRequiredNum = \"<STR_LIT>\" ; DbConfig . pageSearchFiledNum = \"<STR_LIT>\" ; DbConfig . pageFieldRowNum = \"<STR_LIT>\" ; DbConfig . driver = getDriver ( ) ; DbConfig . url = getUrl ( ) ; DbConfig . username = getUsername ( ) ; DbConfig . password = getPassword ( ) ; DbConfig . dbName = getDbName ( ) ; DbConfig . sourceRoot = getSourceRoot ( ) ; DbConfig . webRoot = getWebRoot ( ) ; DbConfig . bussiPackage = getBussiPackage ( ) ; DbConfig . templatepath = getTemplatepath ( ) ; DbConfig . projectPath = getProjectPath ( ) ; DbConfig . dbTableId = getDbTableId ( ) ; DbConfig . dbFiledConvert = getDbFiledConvert ( ) ; DbConfig . pageFilterFields = getPageFilterFields ( ) ; DbConfig . pageSearchFiledNum = getPageSearchFiledNum ( ) ; DbConfig . pageFieldRequiredNum = getPageFieldRequiredNum ( ) ; DbConfig . pageFieldRowNum = getPageFieldRowNum ( ) ; if ( url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> || url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DbConfig . dbType = DbConvertDef . MYSQL ; } else if ( url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> || url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DbConfig . dbType = DbConvertDef . ORACLE ; } else", "gt": "if ( url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> || url . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) {"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return", "gt": "\"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return", "gt": "! isNumberType ( type ) ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String", "gt": "dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String", "gt": "dbFieldName = onlCgformField . getDbFieldName ( ) ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if", "gt": "( jsonObject . get ( dbFieldName ) == null ) {"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else", "gt": "if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) {"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else", "gt": "if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) {"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map", "gt": ". put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map", "gt": ". put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else", "gt": "if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) {"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map", "gt": ". put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map", "gt": ". put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String time = jsonObject . getString ( dbFieldName ) ; time = time . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map", "gt": ". put ( dbFieldName , time ) ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String time = jsonObject . getString ( dbFieldName ) ; time = time . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( dbFieldName , time ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String", "gt": "str = jsonObject . getString ( dbFieldName ) ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String time = jsonObject . getString ( dbFieldName ) ; time = time . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( dbFieldName , time ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String str = jsonObject . getString ( dbFieldName ) ; if", "gt": "( Func . isEmpty ( str ) || \"<STR_LIT>\" . equals ( str . trim ( ) ) ) {"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String time = jsonObject . getString ( dbFieldName ) ; time = time . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( dbFieldName , time ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String str = jsonObject . getString ( dbFieldName ) ; if ( Func . isEmpty ( str ) || \"<STR_LIT>\" . equals ( str . trim ( ) ) ) { map . put ( dbFieldName , null ) ; } else { map . put ( dbFieldName , str . trim ( ) ) ; } return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String time = jsonObject . getString ( dbFieldName ) ; time = time . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( dbFieldName , time ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String str = jsonObject . getString ( dbFieldName ) ; if ( Func . isEmpty ( str ) || \"<STR_LIT>\" . equals ( str . trim ( ) ) ) { map . put ( dbFieldName , null ) ; } else { map . put ( dbFieldName , str . trim ( ) ) ; } return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } public static String getSql ( String dbFieldName , Object dbType ) { if", "gt": "( dbType instanceof Integer ) {"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String time = jsonObject . getString ( dbFieldName ) ; time = time . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( dbFieldName , time ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String str = jsonObject . getString ( dbFieldName ) ; if ( Func . isEmpty ( str ) || \"<STR_LIT>\" . equals ( str . trim ( ) ) ) { map . put ( dbFieldName , null ) ; } else { map . put ( dbFieldName , str . trim ( ) ) ; } return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } public static String getSql ( String dbFieldName , Object dbType ) { if ( dbType instanceof Integer ) { return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String time = jsonObject . getString ( dbFieldName ) ; time = time . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( dbFieldName , time ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String str = jsonObject . getString ( dbFieldName ) ; if ( Func . isEmpty ( str ) || \"<STR_LIT>\" . equals ( str . trim ( ) ) ) { map . put ( dbFieldName , null ) ; } else { map . put ( dbFieldName , str . trim ( ) ) ; } return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } public static String getSql ( String dbFieldName , Object dbType ) { if ( dbType instanceof Integer ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof Long ) { return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String time = jsonObject . getString ( dbFieldName ) ; time = time . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( dbFieldName , time ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String str = jsonObject . getString ( dbFieldName ) ; if ( Func . isEmpty ( str ) || \"<STR_LIT>\" . equals ( str . trim ( ) ) ) { map . put ( dbFieldName , null ) ; } else { map . put ( dbFieldName , str . trim ( ) ) ; } return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } public static String getSql ( String dbFieldName , Object dbType ) { if ( dbType instanceof Integer ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof Long ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof Double ) { return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String time = jsonObject . getString ( dbFieldName ) ; time = time . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( dbFieldName , time ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String str = jsonObject . getString ( dbFieldName ) ; if ( Func . isEmpty ( str ) || \"<STR_LIT>\" . equals ( str . trim ( ) ) ) { map . put ( dbFieldName , null ) ; } else { map . put ( dbFieldName , str . trim ( ) ) ; } return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } public static String getSql ( String dbFieldName , Object dbType ) { if ( dbType instanceof Integer ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof Long ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof Double ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof BigDecimal ) { return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String time = jsonObject . getString ( dbFieldName ) ; time = time . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( dbFieldName , time ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String str = jsonObject . getString ( dbFieldName ) ; if ( Func . isEmpty ( str ) || \"<STR_LIT>\" . equals ( str . trim ( ) ) ) { map . put ( dbFieldName , null ) ; } else { map . put ( dbFieldName , str . trim ( ) ) ; } return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } public static String getSql ( String dbFieldName , Object dbType ) { if ( dbType instanceof Integer ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof Long ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof Double ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof BigDecimal ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof Date ) { return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . math . BigDecimal ; import java . util . Date ; import java . util . Map ; public class DataTypeUtil { public static boolean isNumberType ( String type ) { return \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) || \"<STR_LIT>\" . equals ( type ) ; } public static boolean isNotNumberType ( String type ) { return ! isNumberType ( type ) ; } public static boolean isDateType ( String type ) { return \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) || \"<STR_LIT>\" . equalsIgnoreCase ( type ) ; } public static String getSql ( String databaseType , CgformField onlCgformField , JSONObject jsonObject , Map < String , Object > map ) { String dbType = onlCgformField . getDbType ( ) . toLowerCase ( ) ; String dbFieldName = onlCgformField . getDbFieldName ( ) ; String fieldShowType = onlCgformField . getFieldShowType ( ) ; if ( jsonObject . get ( dbFieldName ) == null ) { return \"<STR_LIT>\" ; } else if ( DbType . INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getIntValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_INT . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getLongValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DOUBLE . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getDoubleValue ( dbFieldName ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BIG_DECIMAL . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , new BigDecimal ( jsonObject . getString ( dbFieldName ) ) ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . BLOB . toLowerCase ( ) . equals ( dbType ) ) { map . put ( dbFieldName , jsonObject . getString ( dbFieldName ) != null ? jsonObject . getString ( dbFieldName ) . getBytes ( ) : null ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( DbType . DATE . toLowerCase ( ) . equals ( dbType ) || DbType . DATE_TIME . toLowerCase ( ) . equals ( dbType ) || DbType . TIME . toLowerCase ( ) . equals ( dbType ) ) { String dbFieldNameStr = jsonObject . getString ( dbFieldName ) ; if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else if ( \"<STR_LIT>\" . equals ( databaseType ) ) { if ( \"<STR_LIT>\" . equals ( fieldShowType ) ) { map . put ( dbFieldName , dbFieldNameStr . length ( ) > <NUM_LIT> ? dbFieldNameStr . substring ( <NUM_LIT> , <NUM_LIT> ) : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { map . put ( dbFieldName , dbFieldNameStr . length ( ) == <NUM_LIT> ? jsonObject . getString ( dbFieldName ) + \"<STR_LIT>\" : dbFieldNameStr ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String time = jsonObject . getString ( dbFieldName ) ; time = time . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( dbFieldName , time ) ; return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } else { String str = jsonObject . getString ( dbFieldName ) ; if ( Func . isEmpty ( str ) || \"<STR_LIT>\" . equals ( str . trim ( ) ) ) { map . put ( dbFieldName , null ) ; } else { map . put ( dbFieldName , str . trim ( ) ) ; } return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } } public static String getSql ( String dbFieldName , Object dbType ) { if ( dbType instanceof Integer ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof Long ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof Double ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof BigDecimal ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else if ( dbType instanceof Date ) { return \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; } else { return", "gt": "\"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . mapper ; import org . springblade . cgform . model . KvModel ; import java . util . List ; import java . util . Map ; public interface BaseSqlMapper { int", "gt": "getProcessingProgressTotal ( String tableName , String batchCode ) ;"}
{"input": "package org . springblade . cgform . mapper ; import org . springblade . cgform . model . KvModel ; import java . util . List ; import java . util . Map ; public interface BaseSqlMapper { int getProcessingProgressTotal ( String tableName , String batchCode ) ; List < Long > getAdminIdList ( ) ; List", "gt": "< Map < String , Object > > baseSelectSqlList ( Map < String , Object > map ) ;"}
{"input": "package org . springblade . cgform . mapper ; import org . springblade . cgform . model . KvModel ; import java . util . List ; import java . util . Map ; public interface BaseSqlMapper { int getProcessingProgressTotal ( String tableName , String batchCode ) ; List < Long > getAdminIdList ( ) ; List < Map < String , Object > > baseSelectSqlList ( Map < String , Object > map ) ; Long", "gt": "baseIntegerSql ( Map < String , Object > map ) ;"}
{"input": "package org . springblade . cgform . mapper ; import org . springblade . cgform . model . KvModel ; import java . util . List ; import java . util . Map ; public interface BaseSqlMapper { int getProcessingProgressTotal ( String tableName , String batchCode ) ; List < Long > getAdminIdList ( ) ; List < Map < String , Object > > baseSelectSqlList ( Map < String , Object > map ) ; Long baseIntegerSql ( Map < String , Object > map ) ; void baseUpdateSql ( Map < String , Object > map ) ; void", "gt": "baseDeleteSql ( Map < String , Object > map ) ;"}
{"input": "package org . springblade . cgform . mapper ; import org . springblade . cgform . model . KvModel ; import java . util . List ; import java . util . Map ; public interface BaseSqlMapper { int getProcessingProgressTotal ( String tableName , String batchCode ) ; List < Long > getAdminIdList ( ) ; List < Map < String , Object > > baseSelectSqlList ( Map < String , Object > map ) ; Long baseIntegerSql ( Map < String , Object > map ) ; void baseUpdateSql ( Map < String , Object > map ) ; void baseDeleteSql ( Map < String , Object > map ) ; List < String > baseSelectByOneColumnSql ( Map < String , Object > map ) ; List", "gt": "< KvModel > getKvModelList ( Map < String , Object > map ) ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this", "gt": ". filedComment = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this", "gt": ". fieldType = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this", "gt": ". sort = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return", "gt": "this . sort ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return this . sort ; } public void setSort ( String sort ) { this", "gt": ". sort = sort ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return this . sort ; } public void setSort ( String sort ) { this . sort = sort ; } public String getFieldDbType ( ) { return this . fieldDbType ; } public void setFieldDbType ( String fieldDbType ) { this", "gt": ". fieldDbType = fieldDbType ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return this . sort ; } public void setSort ( String sort ) { this . sort = sort ; } public String getFieldDbType ( ) { return this . fieldDbType ; } public void setFieldDbType ( String fieldDbType ) { this . fieldDbType = fieldDbType ; } public String getNullable ( ) { return this . nullable ; } public void setNullable ( String nullable ) { this", "gt": ". nullable = nullable ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return this . sort ; } public void setSort ( String sort ) { this . sort = sort ; } public String getFieldDbType ( ) { return this . fieldDbType ; } public void setFieldDbType ( String fieldDbType ) { this . fieldDbType = fieldDbType ; } public String getNullable ( ) { return this . nullable ; } public void setNullable ( String nullable ) { this . nullable = nullable ; } public String getPrecision ( ) { return this . precision ; } public String getScale ( ) { return", "gt": "this . scale ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return this . sort ; } public void setSort ( String sort ) { this . sort = sort ; } public String getFieldDbType ( ) { return this . fieldDbType ; } public void setFieldDbType ( String fieldDbType ) { this . fieldDbType = fieldDbType ; } public String getNullable ( ) { return this . nullable ; } public void setNullable ( String nullable ) { this . nullable = nullable ; } public String getPrecision ( ) { return this . precision ; } public String getScale ( ) { return this . scale ; } public void setPrecision ( String precision ) { this . precision = precision ; } public void setScale ( String scale ) { this", "gt": ". scale = scale ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return this . sort ; } public void setSort ( String sort ) { this . sort = sort ; } public String getFieldDbType ( ) { return this . fieldDbType ; } public void setFieldDbType ( String fieldDbType ) { this . fieldDbType = fieldDbType ; } public String getNullable ( ) { return this . nullable ; } public void setNullable ( String nullable ) { this . nullable = nullable ; } public String getPrecision ( ) { return this . precision ; } public String getScale ( ) { return this . scale ; } public void setPrecision ( String precision ) { this . precision = precision ; } public void setScale ( String scale ) { this . scale = scale ; } public String getOptionType ( ) { return", "gt": "this . optionType ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return this . sort ; } public void setSort ( String sort ) { this . sort = sort ; } public String getFieldDbType ( ) { return this . fieldDbType ; } public void setFieldDbType ( String fieldDbType ) { this . fieldDbType = fieldDbType ; } public String getNullable ( ) { return this . nullable ; } public void setNullable ( String nullable ) { this . nullable = nullable ; } public String getPrecision ( ) { return this . precision ; } public String getScale ( ) { return this . scale ; } public void setPrecision ( String precision ) { this . precision = precision ; } public void setScale ( String scale ) { this . scale = scale ; } public String getOptionType ( ) { return this . optionType ; } public void setOptionType ( String optionType ) { this . optionType = optionType ; } public String getClassType ( ) { return", "gt": "this . classType ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return this . sort ; } public void setSort ( String sort ) { this . sort = sort ; } public String getFieldDbType ( ) { return this . fieldDbType ; } public void setFieldDbType ( String fieldDbType ) { this . fieldDbType = fieldDbType ; } public String getNullable ( ) { return this . nullable ; } public void setNullable ( String nullable ) { this . nullable = nullable ; } public String getPrecision ( ) { return this . precision ; } public String getScale ( ) { return this . scale ; } public void setPrecision ( String precision ) { this . precision = precision ; } public void setScale ( String scale ) { this . scale = scale ; } public String getOptionType ( ) { return this . optionType ; } public void setOptionType ( String optionType ) { this . optionType = optionType ; } public String getClassType ( ) { return this . classType ; } public void setClassType ( String classType ) { this . classType = classType ; } public String getFieldType ( ) { return", "gt": "this . fieldType ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return this . sort ; } public void setSort ( String sort ) { this . sort = sort ; } public String getFieldDbType ( ) { return this . fieldDbType ; } public void setFieldDbType ( String fieldDbType ) { this . fieldDbType = fieldDbType ; } public String getNullable ( ) { return this . nullable ; } public void setNullable ( String nullable ) { this . nullable = nullable ; } public String getPrecision ( ) { return this . precision ; } public String getScale ( ) { return this . scale ; } public void setPrecision ( String precision ) { this . precision = precision ; } public void setScale ( String scale ) { this . scale = scale ; } public String getOptionType ( ) { return this . optionType ; } public void setOptionType ( String optionType ) { this . optionType = optionType ; } public String getClassType ( ) { return this . classType ; } public void setClassType ( String classType ) { this . classType = classType ; } public String getFieldType ( ) { return this . fieldType ; } public void setFieldType ( String fieldType ) { this . fieldType = fieldType ; } public String getFieldName ( ) { return", "gt": "this . fieldName ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return this . sort ; } public void setSort ( String sort ) { this . sort = sort ; } public String getFieldDbType ( ) { return this . fieldDbType ; } public void setFieldDbType ( String fieldDbType ) { this . fieldDbType = fieldDbType ; } public String getNullable ( ) { return this . nullable ; } public void setNullable ( String nullable ) { this . nullable = nullable ; } public String getPrecision ( ) { return this . precision ; } public String getScale ( ) { return this . scale ; } public void setPrecision ( String precision ) { this . precision = precision ; } public void setScale ( String scale ) { this . scale = scale ; } public String getOptionType ( ) { return this . optionType ; } public void setOptionType ( String optionType ) { this . optionType = optionType ; } public String getClassType ( ) { return this . classType ; } public void setClassType ( String classType ) { this . classType = classType ; } public String getFieldType ( ) { return this . fieldType ; } public void setFieldType ( String fieldType ) { this . fieldType = fieldType ; } public String getFieldName ( ) { return this . fieldName ; } public void setFieldName ( String fieldName ) { this . fieldName = fieldName ; } public String getFiledComment ( ) { return this . filedComment ; } public void setFiledComment ( String filedComment ) { this . filedComment = filedComment ; } public String getClassType_row ( ) { if ( this . classType != null && this . classType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { return", "gt": "this . classType . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class ColumnVo extends CgFormColumnExtendVo { public static String OPTION_REQUIRED = \"<STR_LIT>\" ; public static String OPTION_NUMBER_INSEX = \"<STR_LIT>\" ; private String fieldDbName ; private String fieldName ; private String filedComment ; private String fieldType ; private String fieldDbType ; private String charmaxLength ; private String precision ; private String scale ; private String nullable ; private String sort ; private String classType ; private String classType_row ; private String optionType ; public ColumnVo ( ) { this . filedComment = \"<STR_LIT>\" ; this . fieldType = \"<STR_LIT>\" ; this . fieldDbType = \"<STR_LIT>\" ; this . charmaxLength = \"<STR_LIT>\" ; this . sort = \"<STR_LIT>\" ; this . classType = \"<STR_LIT>\" ; this . classType_row = \"<STR_LIT>\" ; this . optionType = \"<STR_LIT>\" ; } public String getSort ( ) { return this . sort ; } public void setSort ( String sort ) { this . sort = sort ; } public String getFieldDbType ( ) { return this . fieldDbType ; } public void setFieldDbType ( String fieldDbType ) { this . fieldDbType = fieldDbType ; } public String getNullable ( ) { return this . nullable ; } public void setNullable ( String nullable ) { this . nullable = nullable ; } public String getPrecision ( ) { return this . precision ; } public String getScale ( ) { return this . scale ; } public void setPrecision ( String precision ) { this . precision = precision ; } public void setScale ( String scale ) { this . scale = scale ; } public String getOptionType ( ) { return this . optionType ; } public void setOptionType ( String optionType ) { this . optionType = optionType ; } public String getClassType ( ) { return this . classType ; } public void setClassType ( String classType ) { this . classType = classType ; } public String getFieldType ( ) { return this . fieldType ; } public void setFieldType ( String fieldType ) { this . fieldType = fieldType ; } public String getFieldName ( ) { return this . fieldName ; } public void setFieldName ( String fieldName ) { this . fieldName = fieldName ; } public String getFiledComment ( ) { return this . filedComment ; } public void setFiledComment ( String filedComment ) { this . filedComment = filedComment ; } public String getClassType_row ( ) { if ( this . classType != null && this . classType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { return this . classType . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return this . classType_row ; } public void setClassType_row ( String classType_row ) { this . classType_row = classType_row ; } public String getCharmaxLength ( ) { if", "gt": "( this . charmaxLength == null || \"<STR_LIT>\" . equals ( this . charmaxLength ) ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformIndex extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; public static CgformIndex init ( CgformIndex index , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ; Long", "gt": "userId = createUser . getUserId ( ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformIndex extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; public static CgformIndex init ( CgformIndex index , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ; Long userId = createUser . getUserId ( ) ; index", "gt": ". setCreateUser ( userId ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformIndex extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; public static CgformIndex init ( CgformIndex index , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ; Long userId = createUser . getUserId ( ) ; index . setCreateUser ( userId ) ; index", "gt": ". setCreateDept ( Long . parseLong ( deptId ) ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformIndex extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; public static CgformIndex init ( CgformIndex index , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ; Long userId = createUser . getUserId ( ) ; index . setCreateUser ( userId ) ; index . setCreateDept ( Long . parseLong ( deptId ) ) ; index", "gt": ". setCreateTime ( DateUtil . now ( ) ) ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . CreateWalletAddressModelParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWalletClient { String", "gt": "API_PREFIX = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . CreateWalletAddressModelParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWalletClient { String API_PREFIX = \"<STR_LIT>\" ; String GET_BALANCE = API_PREFIX + \"<STR_LIT>\" ; String GET_ADDRESS = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "TRANSFER = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . CreateWalletAddressModelParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWalletClient { String API_PREFIX = \"<STR_LIT>\" ; String GET_BALANCE = API_PREFIX + \"<STR_LIT>\" ; String GET_ADDRESS = API_PREFIX + \"<STR_LIT>\" ; String TRANSFER = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "SYNCBLOCK = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . CreateWalletAddressModelParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWalletClient { String API_PREFIX = \"<STR_LIT>\" ; String GET_BALANCE = API_PREFIX + \"<STR_LIT>\" ; String GET_ADDRESS = API_PREFIX + \"<STR_LIT>\" ; String TRANSFER = API_PREFIX + \"<STR_LIT>\" ; String SYNCBLOCK = API_PREFIX + \"<STR_LIT>\" ; String JOB_HANDLE_CHAIN = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "JOB_COLLECT = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . CreateWalletAddressModelParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWalletClient { String API_PREFIX = \"<STR_LIT>\" ; String GET_BALANCE = API_PREFIX + \"<STR_LIT>\" ; String GET_ADDRESS = API_PREFIX + \"<STR_LIT>\" ; String TRANSFER = API_PREFIX + \"<STR_LIT>\" ; String SYNCBLOCK = API_PREFIX + \"<STR_LIT>\" ; String JOB_HANDLE_CHAIN = API_PREFIX + \"<STR_LIT>\" ; String JOB_COLLECT = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "JOB_SCAN_BLOCK = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . CreateWalletAddressModelParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWalletClient { String API_PREFIX = \"<STR_LIT>\" ; String GET_BALANCE = API_PREFIX + \"<STR_LIT>\" ; String GET_ADDRESS = API_PREFIX + \"<STR_LIT>\" ; String TRANSFER = API_PREFIX + \"<STR_LIT>\" ; String SYNCBLOCK = API_PREFIX + \"<STR_LIT>\" ; String JOB_HANDLE_CHAIN = API_PREFIX + \"<STR_LIT>\" ; String JOB_COLLECT = API_PREFIX + \"<STR_LIT>\" ; String JOB_SCAN_BLOCK = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "JOB_BALANCE_REMIND = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . CreateWalletAddressModelParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWalletClient { String API_PREFIX = \"<STR_LIT>\" ; String GET_BALANCE = API_PREFIX + \"<STR_LIT>\" ; String GET_ADDRESS = API_PREFIX + \"<STR_LIT>\" ; String TRANSFER = API_PREFIX + \"<STR_LIT>\" ; String SYNCBLOCK = API_PREFIX + \"<STR_LIT>\" ; String JOB_HANDLE_CHAIN = API_PREFIX + \"<STR_LIT>\" ; String JOB_COLLECT = API_PREFIX + \"<STR_LIT>\" ; String JOB_SCAN_BLOCK = API_PREFIX + \"<STR_LIT>\" ; String JOB_BALANCE_REMIND = API_PREFIX + \"<STR_LIT>\" ; String CHECK_ADDRESS = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "JOB_QRZT = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . model . CreateWalletAddressModelParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWalletClient { String API_PREFIX = \"<STR_LIT>\" ; String GET_BALANCE = API_PREFIX + \"<STR_LIT>\" ; String GET_ADDRESS = API_PREFIX + \"<STR_LIT>\" ; String TRANSFER = API_PREFIX + \"<STR_LIT>\" ; String SYNCBLOCK = API_PREFIX + \"<STR_LIT>\" ; String JOB_HANDLE_CHAIN = API_PREFIX + \"<STR_LIT>\" ; String JOB_COLLECT = API_PREFIX + \"<STR_LIT>\" ; String JOB_SCAN_BLOCK = API_PREFIX + \"<STR_LIT>\" ; String JOB_BALANCE_REMIND = API_PREFIX + \"<STR_LIT>\" ; String CHECK_ADDRESS = API_PREFIX + \"<STR_LIT>\" ; String JOB_QRZT = API_PREFIX + \"<STR_LIT>\" ; String", "gt": "GET_CHAIN_BALANCE = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . util ; import java . math . BigDecimal ; public class EthConvert { private EthConvert ( ) { } public static BigDecimal fromWei ( String number , Unit unit ) { return fromWei ( new BigDecimal ( number ) , unit ) ; } public static BigDecimal fromWei ( BigDecimal number , Unit unit ) { return", "gt": "number . divide ( unit . getWeiFactor ( ) ) ;"}
{"input": "package org . springblade . util ; import java . math . BigDecimal ; public class EthConvert { private EthConvert ( ) { } public static BigDecimal fromWei ( String number , Unit unit ) { return fromWei ( new BigDecimal ( number ) , unit ) ; } public static BigDecimal fromWei ( BigDecimal number , Unit unit ) { return number . divide ( unit . getWeiFactor ( ) ) ; } public static BigDecimal toWei ( String number , Unit unit ) { return toWei ( new BigDecimal ( number ) , unit ) ; } public static BigDecimal toWei ( BigDecimal number , Unit unit ) { return number . multiply ( unit . getWeiFactor ( ) ) ; } public enum Unit { WEI ( \"<STR_LIT>\" , <NUM_LIT> ) , KWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , WWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , MWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , LWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , GWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , SZABO ( \"<STR_LIT>\" , <NUM_LIT> ) , FINNEY ( \"<STR_LIT>\" , <NUM_LIT> ) , ETHER ( \"<STR_LIT>\" , <NUM_LIT> ) , KETHER ( \"<STR_LIT>\" , <NUM_LIT> ) , METHER ( \"<STR_LIT>\" , <NUM_LIT> ) , GETHER ( \"<STR_LIT>\" , <NUM_LIT> ) ; private String name ; private BigDecimal weiFactor ; Unit", "gt": "( String name , int factor ) {"}
{"input": "package org . springblade . util ; import java . math . BigDecimal ; public class EthConvert { private EthConvert ( ) { } public static BigDecimal fromWei ( String number , Unit unit ) { return fromWei ( new BigDecimal ( number ) , unit ) ; } public static BigDecimal fromWei ( BigDecimal number , Unit unit ) { return number . divide ( unit . getWeiFactor ( ) ) ; } public static BigDecimal toWei ( String number , Unit unit ) { return toWei ( new BigDecimal ( number ) , unit ) ; } public static BigDecimal toWei ( BigDecimal number , Unit unit ) { return number . multiply ( unit . getWeiFactor ( ) ) ; } public enum Unit { WEI ( \"<STR_LIT>\" , <NUM_LIT> ) , KWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , WWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , MWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , LWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , GWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , SZABO ( \"<STR_LIT>\" , <NUM_LIT> ) , FINNEY ( \"<STR_LIT>\" , <NUM_LIT> ) , ETHER ( \"<STR_LIT>\" , <NUM_LIT> ) , KETHER ( \"<STR_LIT>\" , <NUM_LIT> ) , METHER ( \"<STR_LIT>\" , <NUM_LIT> ) , GETHER ( \"<STR_LIT>\" , <NUM_LIT> ) ; private String name ; private BigDecimal weiFactor ; Unit ( String name , int factor ) { this", "gt": ". name = name ;"}
{"input": "package org . springblade . util ; import java . math . BigDecimal ; public class EthConvert { private EthConvert ( ) { } public static BigDecimal fromWei ( String number , Unit unit ) { return fromWei ( new BigDecimal ( number ) , unit ) ; } public static BigDecimal fromWei ( BigDecimal number , Unit unit ) { return number . divide ( unit . getWeiFactor ( ) ) ; } public static BigDecimal toWei ( String number , Unit unit ) { return toWei ( new BigDecimal ( number ) , unit ) ; } public static BigDecimal toWei ( BigDecimal number , Unit unit ) { return number . multiply ( unit . getWeiFactor ( ) ) ; } public enum Unit { WEI ( \"<STR_LIT>\" , <NUM_LIT> ) , KWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , WWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , MWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , LWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , GWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , SZABO ( \"<STR_LIT>\" , <NUM_LIT> ) , FINNEY ( \"<STR_LIT>\" , <NUM_LIT> ) , ETHER ( \"<STR_LIT>\" , <NUM_LIT> ) , KETHER ( \"<STR_LIT>\" , <NUM_LIT> ) , METHER ( \"<STR_LIT>\" , <NUM_LIT> ) , GETHER ( \"<STR_LIT>\" , <NUM_LIT> ) ; private String name ; private BigDecimal weiFactor ; Unit ( String name , int factor ) { this . name = name ; this", "gt": ". weiFactor = BigDecimal . TEN . pow ( factor ) ;"}
{"input": "package org . springblade . util ; import java . math . BigDecimal ; public class EthConvert { private EthConvert ( ) { } public static BigDecimal fromWei ( String number , Unit unit ) { return fromWei ( new BigDecimal ( number ) , unit ) ; } public static BigDecimal fromWei ( BigDecimal number , Unit unit ) { return number . divide ( unit . getWeiFactor ( ) ) ; } public static BigDecimal toWei ( String number , Unit unit ) { return toWei ( new BigDecimal ( number ) , unit ) ; } public static BigDecimal toWei ( BigDecimal number , Unit unit ) { return number . multiply ( unit . getWeiFactor ( ) ) ; } public enum Unit { WEI ( \"<STR_LIT>\" , <NUM_LIT> ) , KWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , WWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , MWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , LWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , GWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , SZABO ( \"<STR_LIT>\" , <NUM_LIT> ) , FINNEY ( \"<STR_LIT>\" , <NUM_LIT> ) , ETHER ( \"<STR_LIT>\" , <NUM_LIT> ) , KETHER ( \"<STR_LIT>\" , <NUM_LIT> ) , METHER ( \"<STR_LIT>\" , <NUM_LIT> ) , GETHER ( \"<STR_LIT>\" , <NUM_LIT> ) ; private String name ; private BigDecimal weiFactor ; Unit ( String name , int factor ) { this . name = name ; this . weiFactor = BigDecimal . TEN . pow ( factor ) ; } public BigDecimal getWeiFactor ( ) { return weiFactor ; } @ Override public String toString ( ) { return name ; } public static Unit fromString ( String name ) { if", "gt": "( name != null ) {"}
{"input": "package org . springblade . util ; import java . math . BigDecimal ; public class EthConvert { private EthConvert ( ) { } public static BigDecimal fromWei ( String number , Unit unit ) { return fromWei ( new BigDecimal ( number ) , unit ) ; } public static BigDecimal fromWei ( BigDecimal number , Unit unit ) { return number . divide ( unit . getWeiFactor ( ) ) ; } public static BigDecimal toWei ( String number , Unit unit ) { return toWei ( new BigDecimal ( number ) , unit ) ; } public static BigDecimal toWei ( BigDecimal number , Unit unit ) { return number . multiply ( unit . getWeiFactor ( ) ) ; } public enum Unit { WEI ( \"<STR_LIT>\" , <NUM_LIT> ) , KWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , WWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , MWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , LWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , GWEI ( \"<STR_LIT>\" , <NUM_LIT> ) , SZABO ( \"<STR_LIT>\" , <NUM_LIT> ) , FINNEY ( \"<STR_LIT>\" , <NUM_LIT> ) , ETHER ( \"<STR_LIT>\" , <NUM_LIT> ) , KETHER ( \"<STR_LIT>\" , <NUM_LIT> ) , METHER ( \"<STR_LIT>\" , <NUM_LIT> ) , GETHER ( \"<STR_LIT>\" , <NUM_LIT> ) ; private String name ; private BigDecimal weiFactor ; Unit ( String name , int factor ) { this . name = name ; this . weiFactor = BigDecimal . TEN . pow ( factor ) ; } public BigDecimal getWeiFactor ( ) { return weiFactor ; } @ Override public String toString ( ) { return name ; } public static Unit fromString ( String name ) { if ( name != null ) { for ( Unit unit : Unit . values ( ) ) { if ( name . equalsIgnoreCase ( unit . name ) ) { return unit ; } } } return", "gt": "Unit . valueOf ( name ) ;"}
