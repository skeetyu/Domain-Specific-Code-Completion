{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import com . google . common . collect . EvictingQueue ; import io . github . chensheng . dddboot . tools . collection . QueueUtil ; import java . util . ArrayDeque ; import java . util . Collections ; import java . util . Deque ; import java . util . Queue ; public class MoreQueues { public static < E > Queue < E > createStack ( int initSize ) { return Collections . asLifoQueue ( new ArrayDeque < E > ( initSize ) ) ; } public static < E > Queue < E > createConcurrentStack ( ) { return", "gt": "( Queue < E > ) Collections . asLifoQueue ( QueueUtil . newConcurrentNonBlockingDeque ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import com . google . common . collect . EvictingQueue ; import io . github . chensheng . dddboot . tools . collection . QueueUtil ; import java . util . ArrayDeque ; import java . util . Collections ; import java . util . Deque ; import java . util . Queue ; public class MoreQueues { public static < E > Queue < E > createStack ( int initSize ) { return Collections . asLifoQueue ( new ArrayDeque < E > ( initSize ) ) ; } public static < E > Queue < E > createConcurrentStack ( ) { return ( Queue < E > ) Collections . asLifoQueue ( QueueUtil . newConcurrentNonBlockingDeque ( ) ) ; } public static < E > EvictingQueue < E > createLRUQueue ( int maxSize ) { return", "gt": "EvictingQueue . create ( maxSize ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final", "gt": "String dataId = nacosPropertySource . getDataId ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final", "gt": "String groupId = nacosPropertySource . getGroupId ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener", "gt": "listener = new AbstractListener ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource", "gt": "newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources", "gt": "propertySources = environment . getPropertySources ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources", "gt": ". replace ( name , newNacosPropertySource ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { (", "gt": "( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService", "gt": ". addListener ( dataId , groupId , listener ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw", "gt": "new RuntimeException ( \"<STR_LIT>\" + properties , e ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String", "gt": "[ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for", "gt": "( String beanName : abstractNacosPropertySourceBuilderBeanNames ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String", "gt": "[ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String [ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ; for", "gt": "( String beanName : beanNames ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String [ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ; for ( String beanName : beanNames ) { processPropertySource ( beanName , beanFactory ) ; } } private void processPropertySource ( String beanName , ConfigurableListableBeanFactory beanFactory ) { if ( processedBeanNames . contains ( beanName ) ) { return ; } BeanDefinition", "gt": "beanDefinition = beanFactory . getBeanDefinition ( beanName ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String [ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ; for ( String beanName : beanNames ) { processPropertySource ( beanName , beanFactory ) ; } } private void processPropertySource ( String beanName , ConfigurableListableBeanFactory beanFactory ) { if ( processedBeanNames . contains ( beanName ) ) { return ; } BeanDefinition beanDefinition = beanFactory . getBeanDefinition ( beanName ) ; List", "gt": "< NacosPropertySource > nacosPropertySources = buildNacosPropertySources ( beanName , beanDefinition ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String [ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ; for ( String beanName : beanNames ) { processPropertySource ( beanName , beanFactory ) ; } } private void processPropertySource ( String beanName , ConfigurableListableBeanFactory beanFactory ) { if ( processedBeanNames . contains ( beanName ) ) { return ; } BeanDefinition beanDefinition = beanFactory . getBeanDefinition ( beanName ) ; List < NacosPropertySource > nacosPropertySources = buildNacosPropertySources ( beanName , beanDefinition ) ; for ( NacosPropertySource nacosPropertySource : nacosPropertySources ) { addNacosPropertySource ( nacosPropertySource ) ; Properties properties = configServiceBeanBuilder . resolveProperties ( nacosPropertySource . getAttributesMetadata ( ) ) ; addListenerIfAutoRefreshed ( nacosPropertySource , properties , environment ) ; } processedBeanNames . add ( beanName ) ; } private List < NacosPropertySource > buildNacosPropertySources ( String beanName , BeanDefinition beanDefinition ) { for", "gt": "( AbstractNacosPropertySourceBuilder builder : nacosPropertySourceBuilders ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String [ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ; for ( String beanName : beanNames ) { processPropertySource ( beanName , beanFactory ) ; } } private void processPropertySource ( String beanName , ConfigurableListableBeanFactory beanFactory ) { if ( processedBeanNames . contains ( beanName ) ) { return ; } BeanDefinition beanDefinition = beanFactory . getBeanDefinition ( beanName ) ; List < NacosPropertySource > nacosPropertySources = buildNacosPropertySources ( beanName , beanDefinition ) ; for ( NacosPropertySource nacosPropertySource : nacosPropertySources ) { addNacosPropertySource ( nacosPropertySource ) ; Properties properties = configServiceBeanBuilder . resolveProperties ( nacosPropertySource . getAttributesMetadata ( ) ) ; addListenerIfAutoRefreshed ( nacosPropertySource , properties , environment ) ; } processedBeanNames . add ( beanName ) ; } private List < NacosPropertySource > buildNacosPropertySources ( String beanName , BeanDefinition beanDefinition ) { for ( AbstractNacosPropertySourceBuilder builder : nacosPropertySourceBuilders ) { if", "gt": "( builder . supports ( beanDefinition ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String [ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ; for ( String beanName : beanNames ) { processPropertySource ( beanName , beanFactory ) ; } } private void processPropertySource ( String beanName , ConfigurableListableBeanFactory beanFactory ) { if ( processedBeanNames . contains ( beanName ) ) { return ; } BeanDefinition beanDefinition = beanFactory . getBeanDefinition ( beanName ) ; List < NacosPropertySource > nacosPropertySources = buildNacosPropertySources ( beanName , beanDefinition ) ; for ( NacosPropertySource nacosPropertySource : nacosPropertySources ) { addNacosPropertySource ( nacosPropertySource ) ; Properties properties = configServiceBeanBuilder . resolveProperties ( nacosPropertySource . getAttributesMetadata ( ) ) ; addListenerIfAutoRefreshed ( nacosPropertySource , properties , environment ) ; } processedBeanNames . add ( beanName ) ; } private List < NacosPropertySource > buildNacosPropertySources ( String beanName , BeanDefinition beanDefinition ) { for ( AbstractNacosPropertySourceBuilder builder : nacosPropertySourceBuilders ) { if ( builder . supports ( beanDefinition ) ) { return", "gt": "builder . build ( beanName , beanDefinition ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String [ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ; for ( String beanName : beanNames ) { processPropertySource ( beanName , beanFactory ) ; } } private void processPropertySource ( String beanName , ConfigurableListableBeanFactory beanFactory ) { if ( processedBeanNames . contains ( beanName ) ) { return ; } BeanDefinition beanDefinition = beanFactory . getBeanDefinition ( beanName ) ; List < NacosPropertySource > nacosPropertySources = buildNacosPropertySources ( beanName , beanDefinition ) ; for ( NacosPropertySource nacosPropertySource : nacosPropertySources ) { addNacosPropertySource ( nacosPropertySource ) ; Properties properties = configServiceBeanBuilder . resolveProperties ( nacosPropertySource . getAttributesMetadata ( ) ) ; addListenerIfAutoRefreshed ( nacosPropertySource , properties , environment ) ; } processedBeanNames . add ( beanName ) ; } private List < NacosPropertySource > buildNacosPropertySources ( String beanName , BeanDefinition beanDefinition ) { for ( AbstractNacosPropertySourceBuilder builder : nacosPropertySourceBuilders ) { if ( builder . supports ( beanDefinition ) ) { return builder . build ( beanName , beanDefinition ) ; } } return Collections . emptyList ( ) ; } private void addNacosPropertySource ( NacosPropertySource nacosPropertySource ) { MutablePropertySources propertySources = environment . getPropertySources ( ) ; boolean", "gt": "first = nacosPropertySource . isFirst ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String [ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ; for ( String beanName : beanNames ) { processPropertySource ( beanName , beanFactory ) ; } } private void processPropertySource ( String beanName , ConfigurableListableBeanFactory beanFactory ) { if ( processedBeanNames . contains ( beanName ) ) { return ; } BeanDefinition beanDefinition = beanFactory . getBeanDefinition ( beanName ) ; List < NacosPropertySource > nacosPropertySources = buildNacosPropertySources ( beanName , beanDefinition ) ; for ( NacosPropertySource nacosPropertySource : nacosPropertySources ) { addNacosPropertySource ( nacosPropertySource ) ; Properties properties = configServiceBeanBuilder . resolveProperties ( nacosPropertySource . getAttributesMetadata ( ) ) ; addListenerIfAutoRefreshed ( nacosPropertySource , properties , environment ) ; } processedBeanNames . add ( beanName ) ; } private List < NacosPropertySource > buildNacosPropertySources ( String beanName , BeanDefinition beanDefinition ) { for ( AbstractNacosPropertySourceBuilder builder : nacosPropertySourceBuilders ) { if ( builder . supports ( beanDefinition ) ) { return builder . build ( beanName , beanDefinition ) ; } } return Collections . emptyList ( ) ; } private void addNacosPropertySource ( NacosPropertySource nacosPropertySource ) { MutablePropertySources propertySources = environment . getPropertySources ( ) ; boolean first = nacosPropertySource . isFirst ( ) ; String", "gt": "before = nacosPropertySource . getBefore ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String [ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ; for ( String beanName : beanNames ) { processPropertySource ( beanName , beanFactory ) ; } } private void processPropertySource ( String beanName , ConfigurableListableBeanFactory beanFactory ) { if ( processedBeanNames . contains ( beanName ) ) { return ; } BeanDefinition beanDefinition = beanFactory . getBeanDefinition ( beanName ) ; List < NacosPropertySource > nacosPropertySources = buildNacosPropertySources ( beanName , beanDefinition ) ; for ( NacosPropertySource nacosPropertySource : nacosPropertySources ) { addNacosPropertySource ( nacosPropertySource ) ; Properties properties = configServiceBeanBuilder . resolveProperties ( nacosPropertySource . getAttributesMetadata ( ) ) ; addListenerIfAutoRefreshed ( nacosPropertySource , properties , environment ) ; } processedBeanNames . add ( beanName ) ; } private List < NacosPropertySource > buildNacosPropertySources ( String beanName , BeanDefinition beanDefinition ) { for ( AbstractNacosPropertySourceBuilder builder : nacosPropertySourceBuilders ) { if ( builder . supports ( beanDefinition ) ) { return builder . build ( beanName , beanDefinition ) ; } } return Collections . emptyList ( ) ; } private void addNacosPropertySource ( NacosPropertySource nacosPropertySource ) { MutablePropertySources propertySources = environment . getPropertySources ( ) ; boolean first = nacosPropertySource . isFirst ( ) ; String before = nacosPropertySource . getBefore ( ) ; String", "gt": "after = nacosPropertySource . getAfter ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String [ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ; for ( String beanName : beanNames ) { processPropertySource ( beanName , beanFactory ) ; } } private void processPropertySource ( String beanName , ConfigurableListableBeanFactory beanFactory ) { if ( processedBeanNames . contains ( beanName ) ) { return ; } BeanDefinition beanDefinition = beanFactory . getBeanDefinition ( beanName ) ; List < NacosPropertySource > nacosPropertySources = buildNacosPropertySources ( beanName , beanDefinition ) ; for ( NacosPropertySource nacosPropertySource : nacosPropertySources ) { addNacosPropertySource ( nacosPropertySource ) ; Properties properties = configServiceBeanBuilder . resolveProperties ( nacosPropertySource . getAttributesMetadata ( ) ) ; addListenerIfAutoRefreshed ( nacosPropertySource , properties , environment ) ; } processedBeanNames . add ( beanName ) ; } private List < NacosPropertySource > buildNacosPropertySources ( String beanName , BeanDefinition beanDefinition ) { for ( AbstractNacosPropertySourceBuilder builder : nacosPropertySourceBuilders ) { if ( builder . supports ( beanDefinition ) ) { return builder . build ( beanName , beanDefinition ) ; } } return Collections . emptyList ( ) ; } private void addNacosPropertySource ( NacosPropertySource nacosPropertySource ) { MutablePropertySources propertySources = environment . getPropertySources ( ) ; boolean first = nacosPropertySource . isFirst ( ) ; String before = nacosPropertySource . getBefore ( ) ; String after = nacosPropertySource . getAfter ( ) ; boolean hasBefore = ! nullSafeEquals ( NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE , before ) ; boolean hasAfter = ! nullSafeEquals ( NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE , after ) ; boolean isRelative = hasBefore || hasAfter ; if ( first ) { propertySources . addFirst ( nacosPropertySource ) ; } else if ( isRelative ) { if ( hasBefore ) { propertySources", "gt": ". addBefore ( before , nacosPropertySource ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . BeanDefinitionRegistryPostProcessor ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ConfigurationClassPostProcessor ; import org . springframework . context . annotation . PropertySource ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . core . env . MutablePropertySources ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; public class NacosPropertySourcePostProcessor implements BeanDefinitionRegistryPostProcessor , BeanFactoryPostProcessor , EnvironmentAware , Ordered { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static BeanFactory beanFactory ; private final Set < String > processedBeanNames = new LinkedHashSet < String > ( ) ; private ConfigurableEnvironment environment ; private Collection < AbstractNacosPropertySourceBuilder > nacosPropertySourceBuilders ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; public static void addListenerIfAutoRefreshed ( final NacosPropertySource nacosPropertySource , final Properties properties , final ConfigurableEnvironment environment ) { if ( ! nacosPropertySource . isAutoRefreshed ( ) ) { return ; } final String dataId = nacosPropertySource . getDataId ( ) ; final String groupId = nacosPropertySource . getGroupId ( ) ; final String type = nacosPropertySource . getType ( ) ; final NacosServiceFactory nacosServiceFactory = NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ; try { ConfigService configService = nacosServiceFactory . createConfigService ( properties ) ; Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { String name = nacosPropertySource . getName ( ) ; NacosPropertySource newNacosPropertySource = new NacosPropertySource ( dataId , groupId , name , config , type ) ; newNacosPropertySource . copy ( nacosPropertySource ) ; MutablePropertySources propertySources = environment . getPropertySources ( ) ; propertySources . replace ( name , newNacosPropertySource ) ; } } ; if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + properties , e ) ; } } @ Override public void postProcessBeanDefinitionRegistry ( BeanDefinitionRegistry registry ) throws BeansException { } @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { String [ ] abstractNacosPropertySourceBuilderBeanNames = BeanUtils . getBeanNames ( beanFactory , AbstractNacosPropertySourceBuilder . class ) ; this . nacosPropertySourceBuilders = new ArrayList < AbstractNacosPropertySourceBuilder > ( abstractNacosPropertySourceBuilderBeanNames . length ) ; for ( String beanName : abstractNacosPropertySourceBuilderBeanNames ) { this . nacosPropertySourceBuilders . add ( beanFactory . getBean ( beanName , AbstractNacosPropertySourceBuilder . class ) ) ; } NacosPropertySourcePostProcessor . beanFactory = beanFactory ; this . configServiceBeanBuilder = NacosBeanUtils . getConfigServiceBeanBuilder ( beanFactory ) ; String [ ] beanNames = beanFactory . getBeanDefinitionNames ( ) ; for ( String beanName : beanNames ) { processPropertySource ( beanName , beanFactory ) ; } } private void processPropertySource ( String beanName , ConfigurableListableBeanFactory beanFactory ) { if ( processedBeanNames . contains ( beanName ) ) { return ; } BeanDefinition beanDefinition = beanFactory . getBeanDefinition ( beanName ) ; List < NacosPropertySource > nacosPropertySources = buildNacosPropertySources ( beanName , beanDefinition ) ; for ( NacosPropertySource nacosPropertySource : nacosPropertySources ) { addNacosPropertySource ( nacosPropertySource ) ; Properties properties = configServiceBeanBuilder . resolveProperties ( nacosPropertySource . getAttributesMetadata ( ) ) ; addListenerIfAutoRefreshed ( nacosPropertySource , properties , environment ) ; } processedBeanNames . add ( beanName ) ; } private List < NacosPropertySource > buildNacosPropertySources ( String beanName , BeanDefinition beanDefinition ) { for ( AbstractNacosPropertySourceBuilder builder : nacosPropertySourceBuilders ) { if ( builder . supports ( beanDefinition ) ) { return builder . build ( beanName , beanDefinition ) ; } } return Collections . emptyList ( ) ; } private void addNacosPropertySource ( NacosPropertySource nacosPropertySource ) { MutablePropertySources propertySources = environment . getPropertySources ( ) ; boolean first = nacosPropertySource . isFirst ( ) ; String before = nacosPropertySource . getBefore ( ) ; String after = nacosPropertySource . getAfter ( ) ; boolean hasBefore = ! nullSafeEquals ( NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE , before ) ; boolean hasAfter = ! nullSafeEquals ( NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE , after ) ; boolean isRelative = hasBefore || hasAfter ; if ( first ) { propertySources . addFirst ( nacosPropertySource ) ; } else if ( isRelative ) { if ( hasBefore ) { propertySources . addBefore ( before , nacosPropertySource ) ; } if ( hasAfter ) { propertySources", "gt": ". addAfter ( after , nacosPropertySource ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import static io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultYamlConfigParse . createYaml ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; public class DefaultJsonConfigParse extends AbstractConfigParse { @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < Map < String , Object > > ( ) ; configText", "gt": "= configText . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import static io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultYamlConfigParse . createYaml ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; public class DefaultJsonConfigParse extends AbstractConfigParse { @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < Map < String , Object > > ( ) ; configText = configText . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; DefaultYamlConfigParse . process ( new DefaultYamlConfigParse . MatchCallback ( ) { @ Override public void process ( Map < String , Object > map ) { result . set ( map ) ; } } ,", "gt": "createYaml ( ) , configText ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . awt . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . beans . PropertyEditor ; import java . util . ArrayList ; import java . util . List ; public class NacosEnumEditor implements PropertyEditor { private final List < PropertyChangeListener > listeners = new ArrayList < > ( <NUM_LIT> ) ; private final Class type ; private final String [ ] tags ; private Object value ; public NacosEnumEditor ( Class var1 ) { Object", "gt": "[ ] var2 = var1 . getEnumConstants ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . awt . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . beans . PropertyEditor ; import java . util . ArrayList ; import java . util . List ; public class NacosEnumEditor implements PropertyEditor { private final List < PropertyChangeListener > listeners = new ArrayList < > ( <NUM_LIT> ) ; private final Class type ; private final String [ ] tags ; private Object value ; public NacosEnumEditor ( Class var1 ) { Object [ ] var2 = var1 . getEnumConstants ( ) ; if ( var2 == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { this . type = var1 ; this . tags = new String [ var2 . length ] ; for ( int var3 = <NUM_LIT> ; var3 < var2 . length ; ++ var3 ) { this . tags [ var3 ] = ( ( Enum ) var2 [ var3 ] ) . name ( ) ; } } } @ Override public Object getValue ( ) { return this . value ; } @ Override public void setValue ( Object var1 ) { if", "gt": "( var1 != null && ! this . type . isInstance ( var1 ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . awt . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . beans . PropertyEditor ; import java . util . ArrayList ; import java . util . List ; public class NacosEnumEditor implements PropertyEditor { private final List < PropertyChangeListener > listeners = new ArrayList < > ( <NUM_LIT> ) ; private final Class type ; private final String [ ] tags ; private Object value ; public NacosEnumEditor ( Class var1 ) { Object [ ] var2 = var1 . getEnumConstants ( ) ; if ( var2 == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { this . type = var1 ; this . tags = new String [ var2 . length ] ; for ( int var3 = <NUM_LIT> ; var3 < var2 . length ; ++ var3 ) { this . tags [ var3 ] = ( ( Enum ) var2 [ var3 ] ) . name ( ) ; } } } @ Override public Object getValue ( ) { return this . value ; } @ Override public void setValue ( Object var1 ) { if ( var1 != null && ! this . type . isInstance ( var1 ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { Object var2 ; PropertyChangeListener [ ] var3 ; synchronized ( this . listeners ) { label45 : { var2 = this . value ; this . value = var1 ; if ( var1 == null ) { if ( var2 != null ) { break label45 ; } } else", "gt": "if ( ! var1 . equals ( var2 ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . awt . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . beans . PropertyEditor ; import java . util . ArrayList ; import java . util . List ; public class NacosEnumEditor implements PropertyEditor { private final List < PropertyChangeListener > listeners = new ArrayList < > ( <NUM_LIT> ) ; private final Class type ; private final String [ ] tags ; private Object value ; public NacosEnumEditor ( Class var1 ) { Object [ ] var2 = var1 . getEnumConstants ( ) ; if ( var2 == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { this . type = var1 ; this . tags = new String [ var2 . length ] ; for ( int var3 = <NUM_LIT> ; var3 < var2 . length ; ++ var3 ) { this . tags [ var3 ] = ( ( Enum ) var2 [ var3 ] ) . name ( ) ; } } } @ Override public Object getValue ( ) { return this . value ; } @ Override public void setValue ( Object var1 ) { if ( var1 != null && ! this . type . isInstance ( var1 ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { Object var2 ; PropertyChangeListener [ ] var3 ; synchronized ( this . listeners ) { label45 : { var2 = this . value ; this . value = var1 ; if ( var1 == null ) { if ( var2 != null ) { break label45 ; } } else if ( ! var1 . equals ( var2 ) ) { break label45 ; } return ; } int var5 = this . listeners . size ( ) ; if ( var5 == <NUM_LIT> ) { return ; } var3", "gt": "= ( PropertyChangeListener [ ] ) this . listeners . toArray ( new PropertyChangeListener [ var5 ] ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . awt . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . beans . PropertyEditor ; import java . util . ArrayList ; import java . util . List ; public class NacosEnumEditor implements PropertyEditor { private final List < PropertyChangeListener > listeners = new ArrayList < > ( <NUM_LIT> ) ; private final Class type ; private final String [ ] tags ; private Object value ; public NacosEnumEditor ( Class var1 ) { Object [ ] var2 = var1 . getEnumConstants ( ) ; if ( var2 == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { this . type = var1 ; this . tags = new String [ var2 . length ] ; for ( int var3 = <NUM_LIT> ; var3 < var2 . length ; ++ var3 ) { this . tags [ var3 ] = ( ( Enum ) var2 [ var3 ] ) . name ( ) ; } } } @ Override public Object getValue ( ) { return this . value ; } @ Override public void setValue ( Object var1 ) { if ( var1 != null && ! this . type . isInstance ( var1 ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { Object var2 ; PropertyChangeListener [ ] var3 ; synchronized ( this . listeners ) { label45 : { var2 = this . value ; this . value = var1 ; if ( var1 == null ) { if ( var2 != null ) { break label45 ; } } else if ( ! var1 . equals ( var2 ) ) { break label45 ; } return ; } int var5 = this . listeners . size ( ) ; if ( var5 == <NUM_LIT> ) { return ; } var3 = ( PropertyChangeListener [ ] ) this . listeners . toArray ( new PropertyChangeListener [ var5 ] ) ; } PropertyChangeEvent var4 = new PropertyChangeEvent ( this , ( String ) null , var2 , var1 ) ; PropertyChangeListener [ ] var10 = var3 ; int var6 = var3 . length ; for ( int var7 = <NUM_LIT> ; var7 < var6 ; ++ var7 ) { PropertyChangeListener var8 = var10 [ var7 ] ; var8 . propertyChange ( var4 ) ; } } } @ Override public String getAsText ( ) { return", "gt": "this . value != null ? ( ( Enum ) this . value ) . name ( ) : null ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . awt . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . beans . PropertyEditor ; import java . util . ArrayList ; import java . util . List ; public class NacosEnumEditor implements PropertyEditor { private final List < PropertyChangeListener > listeners = new ArrayList < > ( <NUM_LIT> ) ; private final Class type ; private final String [ ] tags ; private Object value ; public NacosEnumEditor ( Class var1 ) { Object [ ] var2 = var1 . getEnumConstants ( ) ; if ( var2 == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { this . type = var1 ; this . tags = new String [ var2 . length ] ; for ( int var3 = <NUM_LIT> ; var3 < var2 . length ; ++ var3 ) { this . tags [ var3 ] = ( ( Enum ) var2 [ var3 ] ) . name ( ) ; } } } @ Override public Object getValue ( ) { return this . value ; } @ Override public void setValue ( Object var1 ) { if ( var1 != null && ! this . type . isInstance ( var1 ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { Object var2 ; PropertyChangeListener [ ] var3 ; synchronized ( this . listeners ) { label45 : { var2 = this . value ; this . value = var1 ; if ( var1 == null ) { if ( var2 != null ) { break label45 ; } } else if ( ! var1 . equals ( var2 ) ) { break label45 ; } return ; } int var5 = this . listeners . size ( ) ; if ( var5 == <NUM_LIT> ) { return ; } var3 = ( PropertyChangeListener [ ] ) this . listeners . toArray ( new PropertyChangeListener [ var5 ] ) ; } PropertyChangeEvent var4 = new PropertyChangeEvent ( this , ( String ) null , var2 , var1 ) ; PropertyChangeListener [ ] var10 = var3 ; int var6 = var3 . length ; for ( int var7 = <NUM_LIT> ; var7 < var6 ; ++ var7 ) { PropertyChangeListener var8 = var10 [ var7 ] ; var8 . propertyChange ( var4 ) ; } } } @ Override public String getAsText ( ) { return this . value != null ? ( ( Enum ) this . value ) . name ( ) : null ; } @ Override public void setAsText ( String var1 ) { this", "gt": ". setValue ( var1 != null ? Enum . valueOf ( this . type , var1 . toUpperCase ( ) ) : null ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . awt . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . beans . PropertyEditor ; import java . util . ArrayList ; import java . util . List ; public class NacosEnumEditor implements PropertyEditor { private final List < PropertyChangeListener > listeners = new ArrayList < > ( <NUM_LIT> ) ; private final Class type ; private final String [ ] tags ; private Object value ; public NacosEnumEditor ( Class var1 ) { Object [ ] var2 = var1 . getEnumConstants ( ) ; if ( var2 == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { this . type = var1 ; this . tags = new String [ var2 . length ] ; for ( int var3 = <NUM_LIT> ; var3 < var2 . length ; ++ var3 ) { this . tags [ var3 ] = ( ( Enum ) var2 [ var3 ] ) . name ( ) ; } } } @ Override public Object getValue ( ) { return this . value ; } @ Override public void setValue ( Object var1 ) { if ( var1 != null && ! this . type . isInstance ( var1 ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { Object var2 ; PropertyChangeListener [ ] var3 ; synchronized ( this . listeners ) { label45 : { var2 = this . value ; this . value = var1 ; if ( var1 == null ) { if ( var2 != null ) { break label45 ; } } else if ( ! var1 . equals ( var2 ) ) { break label45 ; } return ; } int var5 = this . listeners . size ( ) ; if ( var5 == <NUM_LIT> ) { return ; } var3 = ( PropertyChangeListener [ ] ) this . listeners . toArray ( new PropertyChangeListener [ var5 ] ) ; } PropertyChangeEvent var4 = new PropertyChangeEvent ( this , ( String ) null , var2 , var1 ) ; PropertyChangeListener [ ] var10 = var3 ; int var6 = var3 . length ; for ( int var7 = <NUM_LIT> ; var7 < var6 ; ++ var7 ) { PropertyChangeListener var8 = var10 [ var7 ] ; var8 . propertyChange ( var4 ) ; } } } @ Override public String getAsText ( ) { return this . value != null ? ( ( Enum ) this . value ) . name ( ) : null ; } @ Override public void setAsText ( String var1 ) { this . setValue ( var1 != null ? Enum . valueOf ( this . type , var1 . toUpperCase ( ) ) : null ) ; } @ Override public String [ ] getTags ( ) { return", "gt": "( String [ ] ) this . tags . clone ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . awt . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . beans . PropertyEditor ; import java . util . ArrayList ; import java . util . List ; public class NacosEnumEditor implements PropertyEditor { private final List < PropertyChangeListener > listeners = new ArrayList < > ( <NUM_LIT> ) ; private final Class type ; private final String [ ] tags ; private Object value ; public NacosEnumEditor ( Class var1 ) { Object [ ] var2 = var1 . getEnumConstants ( ) ; if ( var2 == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { this . type = var1 ; this . tags = new String [ var2 . length ] ; for ( int var3 = <NUM_LIT> ; var3 < var2 . length ; ++ var3 ) { this . tags [ var3 ] = ( ( Enum ) var2 [ var3 ] ) . name ( ) ; } } } @ Override public Object getValue ( ) { return this . value ; } @ Override public void setValue ( Object var1 ) { if ( var1 != null && ! this . type . isInstance ( var1 ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { Object var2 ; PropertyChangeListener [ ] var3 ; synchronized ( this . listeners ) { label45 : { var2 = this . value ; this . value = var1 ; if ( var1 == null ) { if ( var2 != null ) { break label45 ; } } else if ( ! var1 . equals ( var2 ) ) { break label45 ; } return ; } int var5 = this . listeners . size ( ) ; if ( var5 == <NUM_LIT> ) { return ; } var3 = ( PropertyChangeListener [ ] ) this . listeners . toArray ( new PropertyChangeListener [ var5 ] ) ; } PropertyChangeEvent var4 = new PropertyChangeEvent ( this , ( String ) null , var2 , var1 ) ; PropertyChangeListener [ ] var10 = var3 ; int var6 = var3 . length ; for ( int var7 = <NUM_LIT> ; var7 < var6 ; ++ var7 ) { PropertyChangeListener var8 = var10 [ var7 ] ; var8 . propertyChange ( var4 ) ; } } } @ Override public String getAsText ( ) { return this . value != null ? ( ( Enum ) this . value ) . name ( ) : null ; } @ Override public void setAsText ( String var1 ) { this . setValue ( var1 != null ? Enum . valueOf ( this . type , var1 . toUpperCase ( ) ) : null ) ; } @ Override public String [ ] getTags ( ) { return ( String [ ] ) this . tags . clone ( ) ; } @ Override public String getJavaInitializationString ( ) { String", "gt": "var1 = this . getAsText ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . awt . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . beans . PropertyEditor ; import java . util . ArrayList ; import java . util . List ; public class NacosEnumEditor implements PropertyEditor { private final List < PropertyChangeListener > listeners = new ArrayList < > ( <NUM_LIT> ) ; private final Class type ; private final String [ ] tags ; private Object value ; public NacosEnumEditor ( Class var1 ) { Object [ ] var2 = var1 . getEnumConstants ( ) ; if ( var2 == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { this . type = var1 ; this . tags = new String [ var2 . length ] ; for ( int var3 = <NUM_LIT> ; var3 < var2 . length ; ++ var3 ) { this . tags [ var3 ] = ( ( Enum ) var2 [ var3 ] ) . name ( ) ; } } } @ Override public Object getValue ( ) { return this . value ; } @ Override public void setValue ( Object var1 ) { if ( var1 != null && ! this . type . isInstance ( var1 ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { Object var2 ; PropertyChangeListener [ ] var3 ; synchronized ( this . listeners ) { label45 : { var2 = this . value ; this . value = var1 ; if ( var1 == null ) { if ( var2 != null ) { break label45 ; } } else if ( ! var1 . equals ( var2 ) ) { break label45 ; } return ; } int var5 = this . listeners . size ( ) ; if ( var5 == <NUM_LIT> ) { return ; } var3 = ( PropertyChangeListener [ ] ) this . listeners . toArray ( new PropertyChangeListener [ var5 ] ) ; } PropertyChangeEvent var4 = new PropertyChangeEvent ( this , ( String ) null , var2 , var1 ) ; PropertyChangeListener [ ] var10 = var3 ; int var6 = var3 . length ; for ( int var7 = <NUM_LIT> ; var7 < var6 ; ++ var7 ) { PropertyChangeListener var8 = var10 [ var7 ] ; var8 . propertyChange ( var4 ) ; } } } @ Override public String getAsText ( ) { return this . value != null ? ( ( Enum ) this . value ) . name ( ) : null ; } @ Override public void setAsText ( String var1 ) { this . setValue ( var1 != null ? Enum . valueOf ( this . type , var1 . toUpperCase ( ) ) : null ) ; } @ Override public String [ ] getTags ( ) { return ( String [ ] ) this . tags . clone ( ) ; } @ Override public String getJavaInitializationString ( ) { String var1 = this . getAsText ( ) ; return", "gt": "var1 != null ? this . type . getName ( ) + '<STR_LIT>' + var1 : \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . awt . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . beans . PropertyEditor ; import java . util . ArrayList ; import java . util . List ; public class NacosEnumEditor implements PropertyEditor { private final List < PropertyChangeListener > listeners = new ArrayList < > ( <NUM_LIT> ) ; private final Class type ; private final String [ ] tags ; private Object value ; public NacosEnumEditor ( Class var1 ) { Object [ ] var2 = var1 . getEnumConstants ( ) ; if ( var2 == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { this . type = var1 ; this . tags = new String [ var2 . length ] ; for ( int var3 = <NUM_LIT> ; var3 < var2 . length ; ++ var3 ) { this . tags [ var3 ] = ( ( Enum ) var2 [ var3 ] ) . name ( ) ; } } } @ Override public Object getValue ( ) { return this . value ; } @ Override public void setValue ( Object var1 ) { if ( var1 != null && ! this . type . isInstance ( var1 ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + var1 ) ; } else { Object var2 ; PropertyChangeListener [ ] var3 ; synchronized ( this . listeners ) { label45 : { var2 = this . value ; this . value = var1 ; if ( var1 == null ) { if ( var2 != null ) { break label45 ; } } else if ( ! var1 . equals ( var2 ) ) { break label45 ; } return ; } int var5 = this . listeners . size ( ) ; if ( var5 == <NUM_LIT> ) { return ; } var3 = ( PropertyChangeListener [ ] ) this . listeners . toArray ( new PropertyChangeListener [ var5 ] ) ; } PropertyChangeEvent var4 = new PropertyChangeEvent ( this , ( String ) null , var2 , var1 ) ; PropertyChangeListener [ ] var10 = var3 ; int var6 = var3 . length ; for ( int var7 = <NUM_LIT> ; var7 < var6 ; ++ var7 ) { PropertyChangeListener var8 = var10 [ var7 ] ; var8 . propertyChange ( var4 ) ; } } } @ Override public String getAsText ( ) { return this . value != null ? ( ( Enum ) this . value ) . name ( ) : null ; } @ Override public void setAsText ( String var1 ) { this . setValue ( var1 != null ? Enum . valueOf ( this . type , var1 . toUpperCase ( ) ) : null ) ; } @ Override public String [ ] getTags ( ) { return ( String [ ] ) this . tags . clone ( ) ; } @ Override public String getJavaInitializationString ( ) { String var1 = this . getAsText ( ) ; return var1 != null ? this . type . getName ( ) + '<STR_LIT>' + var1 : \"<STR_LIT>\" ; } @ Override public boolean isPaintable ( ) { return false ; } @ Override public void paintValue ( Graphics var1 , Rectangle var2 ) { } @ Override public boolean supportsCustomEditor ( ) { return false ; } @ Override public Component getCustomEditor ( ) { return null ; } @ Override public void addPropertyChangeListener ( PropertyChangeListener var1 ) { synchronized ( this . listeners ) { this", "gt": ". listeners . add ( var1 ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . annotation ; import io . github . chensheng . dddboot . openfeign . core . DefaultJacksonDecoder ; import io . github . chensheng . dddboot . openfeign . core . DefaultJacksonEncoder ; import feign . Contract ; import feign . RequestInterceptor ; import feign . Retryer ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( { ElementType . TYPE } )", "gt": "@ Retention ( RetentionPolicy . RUNTIME ) public @ interface FeignClient {"}
{"input": "package io . github . chensheng . dddboot . openfeign . annotation ; import io . github . chensheng . dddboot . openfeign . core . DefaultJacksonDecoder ; import io . github . chensheng . dddboot . openfeign . core . DefaultJacksonEncoder ; import feign . Contract ; import feign . RequestInterceptor ; import feign . Retryer ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface FeignClient { String name ( ) default \"<STR_LIT>\" ; String url ( ) ; Class < ? extends Encoder > encoder ( ) default DefaultJacksonEncoder . class ; Class", "gt": "< ? extends Decoder > decoder ( ) default DefaultJacksonDecoder . class ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . annotation ; import io . github . chensheng . dddboot . openfeign . core . DefaultJacksonDecoder ; import io . github . chensheng . dddboot . openfeign . core . DefaultJacksonEncoder ; import feign . Contract ; import feign . RequestInterceptor ; import feign . Retryer ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface FeignClient { String name ( ) default \"<STR_LIT>\" ; String url ( ) ; Class < ? extends Encoder > encoder ( ) default DefaultJacksonEncoder . class ; Class < ? extends Decoder > decoder ( ) default DefaultJacksonDecoder . class ; Class < ? extends ErrorDecoder > errorDecoder ( ) default ErrorDecoder . class ; Class", "gt": "< ? extends RequestInterceptor > [ ] interceptors ( ) default {"}
{"input": "package io . github . chensheng . dddboot . openfeign . annotation ; import io . github . chensheng . dddboot . openfeign . core . DefaultJacksonDecoder ; import io . github . chensheng . dddboot . openfeign . core . DefaultJacksonEncoder ; import feign . Contract ; import feign . RequestInterceptor ; import feign . Retryer ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface FeignClient { String name ( ) default \"<STR_LIT>\" ; String url ( ) ; Class < ? extends Encoder > encoder ( ) default DefaultJacksonEncoder . class ; Class < ? extends Decoder > decoder ( ) default DefaultJacksonDecoder . class ; Class < ? extends ErrorDecoder > errorDecoder ( ) default ErrorDecoder . class ; Class < ? extends RequestInterceptor > [ ] interceptors ( ) default { } ; Class < ? extends Retryer > [ ] retryer ( ) default { } ; Class", "gt": "< ? extends Contract > [ ] contract ( ) default {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import org . apache . commons . lang3 . StringUtils ; public class FilePathUtil { public static String normalizePath ( String path ) { if", "gt": "( Platforms . FILE_PATH_SEPARATOR_CHAR == Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR && StringUtils . indexOf ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR ) != - <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import org . apache . commons . lang3 . StringUtils ; public class FilePathUtil { public static String normalizePath ( String path ) { if ( Platforms . FILE_PATH_SEPARATOR_CHAR == Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR && StringUtils . indexOf ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return StringUtils . replaceChars ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR , Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR ) ; } return path ; } public static String simplifyPath ( String path ) { return", "gt": "Files . simplifyPath ( path ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import org . apache . commons . lang3 . StringUtils ; public class FilePathUtil { public static String normalizePath ( String path ) { if ( Platforms . FILE_PATH_SEPARATOR_CHAR == Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR && StringUtils . indexOf ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return StringUtils . replaceChars ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR , Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR ) ; } return path ; } public static String simplifyPath ( String path ) { return Files . simplifyPath ( path ) ; } public static String concat ( String baseName , String ... appendName ) { if ( appendName . length == <NUM_LIT> ) { return baseName ; } StringBuilder", "gt": "concatName = new StringBuilder ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import org . apache . commons . lang3 . StringUtils ; public class FilePathUtil { public static String normalizePath ( String path ) { if ( Platforms . FILE_PATH_SEPARATOR_CHAR == Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR && StringUtils . indexOf ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return StringUtils . replaceChars ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR , Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR ) ; } return path ; } public static String simplifyPath ( String path ) { return Files . simplifyPath ( path ) ; } public static String concat ( String baseName , String ... appendName ) { if ( appendName . length == <NUM_LIT> ) { return baseName ; } StringBuilder concatName = new StringBuilder ( ) ; if", "gt": "( MoreStringUtil . endWith ( baseName , Platforms . FILE_PATH_SEPARATOR_CHAR ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import org . apache . commons . lang3 . StringUtils ; public class FilePathUtil { public static String normalizePath ( String path ) { if ( Platforms . FILE_PATH_SEPARATOR_CHAR == Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR && StringUtils . indexOf ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return StringUtils . replaceChars ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR , Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR ) ; } return path ; } public static String simplifyPath ( String path ) { return Files . simplifyPath ( path ) ; } public static String concat ( String baseName , String ... appendName ) { if ( appendName . length == <NUM_LIT> ) { return baseName ; } StringBuilder concatName = new StringBuilder ( ) ; if ( MoreStringUtil . endWith ( baseName , Platforms . FILE_PATH_SEPARATOR_CHAR ) ) { concatName . append ( baseName ) . append ( appendName [ <NUM_LIT> ] ) ; } else { concatName . append ( baseName ) . append ( Platforms . FILE_PATH_SEPARATOR_CHAR ) . append ( appendName [ <NUM_LIT> ] ) ; } if", "gt": "( appendName . length > <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import org . apache . commons . lang3 . StringUtils ; public class FilePathUtil { public static String normalizePath ( String path ) { if ( Platforms . FILE_PATH_SEPARATOR_CHAR == Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR && StringUtils . indexOf ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return StringUtils . replaceChars ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR , Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR ) ; } return path ; } public static String simplifyPath ( String path ) { return Files . simplifyPath ( path ) ; } public static String concat ( String baseName , String ... appendName ) { if ( appendName . length == <NUM_LIT> ) { return baseName ; } StringBuilder concatName = new StringBuilder ( ) ; if ( MoreStringUtil . endWith ( baseName , Platforms . FILE_PATH_SEPARATOR_CHAR ) ) { concatName . append ( baseName ) . append ( appendName [ <NUM_LIT> ] ) ; } else { concatName . append ( baseName ) . append ( Platforms . FILE_PATH_SEPARATOR_CHAR ) . append ( appendName [ <NUM_LIT> ] ) ; } if ( appendName . length > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < appendName . length ; i ++ ) { concatName", "gt": ". append ( Platforms . FILE_PATH_SEPARATOR_CHAR ) . append ( appendName [ i ] ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import org . apache . commons . lang3 . StringUtils ; public class FilePathUtil { public static String normalizePath ( String path ) { if ( Platforms . FILE_PATH_SEPARATOR_CHAR == Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR && StringUtils . indexOf ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return StringUtils . replaceChars ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR , Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR ) ; } return path ; } public static String simplifyPath ( String path ) { return Files . simplifyPath ( path ) ; } public static String concat ( String baseName , String ... appendName ) { if ( appendName . length == <NUM_LIT> ) { return baseName ; } StringBuilder concatName = new StringBuilder ( ) ; if ( MoreStringUtil . endWith ( baseName , Platforms . FILE_PATH_SEPARATOR_CHAR ) ) { concatName . append ( baseName ) . append ( appendName [ <NUM_LIT> ] ) ; } else { concatName . append ( baseName ) . append ( Platforms . FILE_PATH_SEPARATOR_CHAR ) . append ( appendName [ <NUM_LIT> ] ) ; } if ( appendName . length > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < appendName . length ; i ++ ) { concatName . append ( Platforms . FILE_PATH_SEPARATOR_CHAR ) . append ( appendName [ i ] ) ; } } return concatName . toString ( ) ; } public static String getParentPath ( String path ) { String parentPath = path ; if", "gt": "( Platforms . FILE_PATH_SEPARATOR . equals ( parentPath ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import org . apache . commons . lang3 . StringUtils ; public class FilePathUtil { public static String normalizePath ( String path ) { if ( Platforms . FILE_PATH_SEPARATOR_CHAR == Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR && StringUtils . indexOf ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR ) != - <NUM_LIT> ) { return StringUtils . replaceChars ( path , Platforms . LINUX_FILE_PATH_SEPARATOR_CHAR , Platforms . WINDOWS_FILE_PATH_SEPARATOR_CHAR ) ; } return path ; } public static String simplifyPath ( String path ) { return Files . simplifyPath ( path ) ; } public static String concat ( String baseName , String ... appendName ) { if ( appendName . length == <NUM_LIT> ) { return baseName ; } StringBuilder concatName = new StringBuilder ( ) ; if ( MoreStringUtil . endWith ( baseName , Platforms . FILE_PATH_SEPARATOR_CHAR ) ) { concatName . append ( baseName ) . append ( appendName [ <NUM_LIT> ] ) ; } else { concatName . append ( baseName ) . append ( Platforms . FILE_PATH_SEPARATOR_CHAR ) . append ( appendName [ <NUM_LIT> ] ) ; } if ( appendName . length > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < appendName . length ; i ++ ) { concatName . append ( Platforms . FILE_PATH_SEPARATOR_CHAR ) . append ( appendName [ i ] ) ; } } return concatName . toString ( ) ; } public static String getParentPath ( String path ) { String parentPath = path ; if ( Platforms . FILE_PATH_SEPARATOR . equals ( parentPath ) ) { return parentPath ; } parentPath = MoreStringUtil . removeEnd ( parentPath , Platforms . FILE_PATH_SEPARATOR_CHAR ) ; int", "gt": "idx = parentPath . lastIndexOf ( Platforms . FILE_PATH_SEPARATOR_CHAR ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class", "gt": "< ? > type = value . getClass ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if", "gt": "( type . isArray ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return", "gt": "primitiveArrayToString ( value , componentType ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return primitiveArrayToString ( value , componentType ) ; } else { return objectArrayToString ( value ) ; } } else", "gt": "if ( value instanceof Iterable ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return primitiveArrayToString ( value , componentType ) ; } else { return objectArrayToString ( value ) ; } } else if ( value instanceof Iterable ) { return collectionToString ( value ) ; } return value . toString ( ) ; } private static String primitiveArrayToString ( Object value , Class componentType ) { StringBuilder", "gt": "sb = new StringBuilder ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return primitiveArrayToString ( value , componentType ) ; } else { return objectArrayToString ( value ) ; } } else if ( value instanceof Iterable ) { return collectionToString ( value ) ; } return value . toString ( ) ; } private static String primitiveArrayToString ( Object value , Class componentType ) { StringBuilder sb = new StringBuilder ( ) ; if ( componentType == int . class ) { sb", "gt": ". append ( Arrays . toString ( ( int [ ] ) value ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return primitiveArrayToString ( value , componentType ) ; } else { return objectArrayToString ( value ) ; } } else if ( value instanceof Iterable ) { return collectionToString ( value ) ; } return value . toString ( ) ; } private static String primitiveArrayToString ( Object value , Class componentType ) { StringBuilder sb = new StringBuilder ( ) ; if ( componentType == int . class ) { sb . append ( Arrays . toString ( ( int [ ] ) value ) ) ; } else if ( componentType == long . class ) { sb . append ( Arrays . toString ( ( long [ ] ) value ) ) ; } else if ( componentType == double . class ) { sb", "gt": ". append ( Arrays . toString ( ( double [ ] ) value ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return primitiveArrayToString ( value , componentType ) ; } else { return objectArrayToString ( value ) ; } } else if ( value instanceof Iterable ) { return collectionToString ( value ) ; } return value . toString ( ) ; } private static String primitiveArrayToString ( Object value , Class componentType ) { StringBuilder sb = new StringBuilder ( ) ; if ( componentType == int . class ) { sb . append ( Arrays . toString ( ( int [ ] ) value ) ) ; } else if ( componentType == long . class ) { sb . append ( Arrays . toString ( ( long [ ] ) value ) ) ; } else if ( componentType == double . class ) { sb . append ( Arrays . toString ( ( double [ ] ) value ) ) ; } else if ( componentType == float . class ) { sb . append ( Arrays . toString ( ( float [ ] ) value ) ) ; } else if ( componentType == boolean . class ) { sb", "gt": ". append ( Arrays . toString ( ( boolean [ ] ) value ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return primitiveArrayToString ( value , componentType ) ; } else { return objectArrayToString ( value ) ; } } else if ( value instanceof Iterable ) { return collectionToString ( value ) ; } return value . toString ( ) ; } private static String primitiveArrayToString ( Object value , Class componentType ) { StringBuilder sb = new StringBuilder ( ) ; if ( componentType == int . class ) { sb . append ( Arrays . toString ( ( int [ ] ) value ) ) ; } else if ( componentType == long . class ) { sb . append ( Arrays . toString ( ( long [ ] ) value ) ) ; } else if ( componentType == double . class ) { sb . append ( Arrays . toString ( ( double [ ] ) value ) ) ; } else if ( componentType == float . class ) { sb . append ( Arrays . toString ( ( float [ ] ) value ) ) ; } else if ( componentType == boolean . class ) { sb . append ( Arrays . toString ( ( boolean [ ] ) value ) ) ; } else if ( componentType == short . class ) { sb", "gt": ". append ( Arrays . toString ( ( short [ ] ) value ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return primitiveArrayToString ( value , componentType ) ; } else { return objectArrayToString ( value ) ; } } else if ( value instanceof Iterable ) { return collectionToString ( value ) ; } return value . toString ( ) ; } private static String primitiveArrayToString ( Object value , Class componentType ) { StringBuilder sb = new StringBuilder ( ) ; if ( componentType == int . class ) { sb . append ( Arrays . toString ( ( int [ ] ) value ) ) ; } else if ( componentType == long . class ) { sb . append ( Arrays . toString ( ( long [ ] ) value ) ) ; } else if ( componentType == double . class ) { sb . append ( Arrays . toString ( ( double [ ] ) value ) ) ; } else if ( componentType == float . class ) { sb . append ( Arrays . toString ( ( float [ ] ) value ) ) ; } else if ( componentType == boolean . class ) { sb . append ( Arrays . toString ( ( boolean [ ] ) value ) ) ; } else if ( componentType == short . class ) { sb . append ( Arrays . toString ( ( short [ ] ) value ) ) ; } else", "gt": "if ( componentType == byte . class ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return primitiveArrayToString ( value , componentType ) ; } else { return objectArrayToString ( value ) ; } } else if ( value instanceof Iterable ) { return collectionToString ( value ) ; } return value . toString ( ) ; } private static String primitiveArrayToString ( Object value , Class componentType ) { StringBuilder sb = new StringBuilder ( ) ; if ( componentType == int . class ) { sb . append ( Arrays . toString ( ( int [ ] ) value ) ) ; } else if ( componentType == long . class ) { sb . append ( Arrays . toString ( ( long [ ] ) value ) ) ; } else if ( componentType == double . class ) { sb . append ( Arrays . toString ( ( double [ ] ) value ) ) ; } else if ( componentType == float . class ) { sb . append ( Arrays . toString ( ( float [ ] ) value ) ) ; } else if ( componentType == boolean . class ) { sb . append ( Arrays . toString ( ( boolean [ ] ) value ) ) ; } else if ( componentType == short . class ) { sb . append ( Arrays . toString ( ( short [ ] ) value ) ) ; } else if ( componentType == byte . class ) { sb . append ( Arrays . toString ( ( byte [ ] ) value ) ) ; } else", "gt": "if ( componentType == char . class ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return primitiveArrayToString ( value , componentType ) ; } else { return objectArrayToString ( value ) ; } } else if ( value instanceof Iterable ) { return collectionToString ( value ) ; } return value . toString ( ) ; } private static String primitiveArrayToString ( Object value , Class componentType ) { StringBuilder sb = new StringBuilder ( ) ; if ( componentType == int . class ) { sb . append ( Arrays . toString ( ( int [ ] ) value ) ) ; } else if ( componentType == long . class ) { sb . append ( Arrays . toString ( ( long [ ] ) value ) ) ; } else if ( componentType == double . class ) { sb . append ( Arrays . toString ( ( double [ ] ) value ) ) ; } else if ( componentType == float . class ) { sb . append ( Arrays . toString ( ( float [ ] ) value ) ) ; } else if ( componentType == boolean . class ) { sb . append ( Arrays . toString ( ( boolean [ ] ) value ) ) ; } else if ( componentType == short . class ) { sb . append ( Arrays . toString ( ( short [ ] ) value ) ) ; } else if ( componentType == byte . class ) { sb . append ( Arrays . toString ( ( byte [ ] ) value ) ) ; } else if ( componentType == char . class ) { sb . append ( Arrays . toString ( ( char [ ] ) value ) ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return sb . toString ( ) ; } private static String objectArrayToString ( Object value ) { StringBuilder", "gt": "sb = new StringBuilder ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Objects ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . util . Arrays ; public class ObjectUtil { private static final String NULL = \"<STR_LIT>\" ; public static boolean equals ( @ Nullable Object a , @ Nullable Object b ) { return Objects . equal ( a , b ) ; } public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } public static String toPrettyString ( Object value ) { if ( value == null ) { return NULL ; } Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return primitiveArrayToString ( value , componentType ) ; } else { return objectArrayToString ( value ) ; } } else if ( value instanceof Iterable ) { return collectionToString ( value ) ; } return value . toString ( ) ; } private static String primitiveArrayToString ( Object value , Class componentType ) { StringBuilder sb = new StringBuilder ( ) ; if ( componentType == int . class ) { sb . append ( Arrays . toString ( ( int [ ] ) value ) ) ; } else if ( componentType == long . class ) { sb . append ( Arrays . toString ( ( long [ ] ) value ) ) ; } else if ( componentType == double . class ) { sb . append ( Arrays . toString ( ( double [ ] ) value ) ) ; } else if ( componentType == float . class ) { sb . append ( Arrays . toString ( ( float [ ] ) value ) ) ; } else if ( componentType == boolean . class ) { sb . append ( Arrays . toString ( ( boolean [ ] ) value ) ) ; } else if ( componentType == short . class ) { sb . append ( Arrays . toString ( ( short [ ] ) value ) ) ; } else if ( componentType == byte . class ) { sb . append ( Arrays . toString ( ( byte [ ] ) value ) ) ; } else if ( componentType == char . class ) { sb . append ( Arrays . toString ( ( char [ ] ) value ) ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return sb . toString ( ) ; } private static String objectArrayToString ( Object value ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( '<STR_LIT>' ) ; Object [ ] array = ( Object [ ] ) value ; for ( int i = <NUM_LIT> ; i < array . length ; i ++ ) { if ( i > <NUM_LIT> ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( toPrettyString ( array [ i ] ) ) ; } sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } private static String collectionToString ( Object value ) { Iterable iterable = ( Iterable ) value ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( '<STR_LIT>' ) ; int i = <NUM_LIT> ; for ( Object o : iterable ) { if ( i > <NUM_LIT> ) { sb . append ( '<STR_LIT>' ) ; } sb", "gt": ". append ( toPrettyString ( o ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . common . usermodel . HyperlinkType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CreationHelper ; import org . apache . poi . ss . usermodel . Hyperlink ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class HyperLinkConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return", "gt": "String . class == fieldType && CellValueType . HYPER_LINK . equals ( type ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . common . usermodel . HyperlinkType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CreationHelper ; import org . apache . poi . ss . usermodel . Hyperlink ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class HyperLinkConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return String . class == fieldType && CellValueType . HYPER_LINK . equals ( type ) ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { return cellContent ; } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { String value = ( String ) cellValue ; CreationHelper creationHelper = workbook . getCreationHelper ( ) ; Hyperlink", "gt": "link = creationHelper . createHyperlink ( HyperlinkType . URL ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import org . springframework . lang . Nullable ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; public class NacosCustomBooleanEditor extends PropertyEditorSupport { public static final String VALUE_TRUE = \"<STR_LIT>\" ; public static final String VALUE_FALSE = \"<STR_LIT>\" ; public static final String VALUE_ON = \"<STR_LIT>\" ; public static final String VALUE_OFF = \"<STR_LIT>\" ; public static final String VALUE_YES = \"<STR_LIT>\" ; public static final String VALUE_NO = \"<STR_LIT>\" ; public static final String VALUE_1 = \"<STR_LIT>\" ; public static final String VALUE_0 = \"<STR_LIT>\" ; @ Nullable private final String trueString ; @ Nullable private final String falseString ; private final boolean allowEmpty ; public NacosCustomBooleanEditor ( boolean allowEmpty ) { this ( null , null , allowEmpty ) ; } public NacosCustomBooleanEditor ( @ Nullable String trueString , @ Nullable String falseString , boolean allowEmpty ) { this . trueString = trueString ; this . falseString = falseString ; this . allowEmpty = allowEmpty ; } @ Override public void setValue ( Object value ) { super . setValue ( convert ( String . valueOf ( value ) ) ) ; } public Object convert ( String text ) throws IllegalArgumentException { String input = ( text != null ? text . trim ( ) : null ) ; if ( this . allowEmpty && ! StringUtils . hasLength ( input ) ) { return null ; } else", "gt": "if ( this . trueString != null && this . trueString . equalsIgnoreCase ( input ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import org . springframework . lang . Nullable ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; public class NacosCustomBooleanEditor extends PropertyEditorSupport { public static final String VALUE_TRUE = \"<STR_LIT>\" ; public static final String VALUE_FALSE = \"<STR_LIT>\" ; public static final String VALUE_ON = \"<STR_LIT>\" ; public static final String VALUE_OFF = \"<STR_LIT>\" ; public static final String VALUE_YES = \"<STR_LIT>\" ; public static final String VALUE_NO = \"<STR_LIT>\" ; public static final String VALUE_1 = \"<STR_LIT>\" ; public static final String VALUE_0 = \"<STR_LIT>\" ; @ Nullable private final String trueString ; @ Nullable private final String falseString ; private final boolean allowEmpty ; public NacosCustomBooleanEditor ( boolean allowEmpty ) { this ( null , null , allowEmpty ) ; } public NacosCustomBooleanEditor ( @ Nullable String trueString , @ Nullable String falseString , boolean allowEmpty ) { this . trueString = trueString ; this . falseString = falseString ; this . allowEmpty = allowEmpty ; } @ Override public void setValue ( Object value ) { super . setValue ( convert ( String . valueOf ( value ) ) ) ; } public Object convert ( String text ) throws IllegalArgumentException { String input = ( text != null ? text . trim ( ) : null ) ; if ( this . allowEmpty && ! StringUtils . hasLength ( input ) ) { return null ; } else if ( this . trueString != null && this . trueString . equalsIgnoreCase ( input ) ) { return Boolean . TRUE ; } else", "gt": "if ( this . falseString != null && this . falseString . equalsIgnoreCase ( input ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import org . springframework . lang . Nullable ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; public class NacosCustomBooleanEditor extends PropertyEditorSupport { public static final String VALUE_TRUE = \"<STR_LIT>\" ; public static final String VALUE_FALSE = \"<STR_LIT>\" ; public static final String VALUE_ON = \"<STR_LIT>\" ; public static final String VALUE_OFF = \"<STR_LIT>\" ; public static final String VALUE_YES = \"<STR_LIT>\" ; public static final String VALUE_NO = \"<STR_LIT>\" ; public static final String VALUE_1 = \"<STR_LIT>\" ; public static final String VALUE_0 = \"<STR_LIT>\" ; @ Nullable private final String trueString ; @ Nullable private final String falseString ; private final boolean allowEmpty ; public NacosCustomBooleanEditor ( boolean allowEmpty ) { this ( null , null , allowEmpty ) ; } public NacosCustomBooleanEditor ( @ Nullable String trueString , @ Nullable String falseString , boolean allowEmpty ) { this . trueString = trueString ; this . falseString = falseString ; this . allowEmpty = allowEmpty ; } @ Override public void setValue ( Object value ) { super . setValue ( convert ( String . valueOf ( value ) ) ) ; } public Object convert ( String text ) throws IllegalArgumentException { String input = ( text != null ? text . trim ( ) : null ) ; if ( this . allowEmpty && ! StringUtils . hasLength ( input ) ) { return null ; } else if ( this . trueString != null && this . trueString . equalsIgnoreCase ( input ) ) { return Boolean . TRUE ; } else if ( this . falseString != null && this . falseString . equalsIgnoreCase ( input ) ) { return Boolean . FALSE ; } else if ( this . trueString == null && ( VALUE_TRUE . equalsIgnoreCase ( input ) || VALUE_ON . equalsIgnoreCase ( input ) || VALUE_YES . equalsIgnoreCase ( input ) || VALUE_1 . equals ( input ) ) ) { return Boolean . TRUE ; } else if ( this . falseString == null && ( VALUE_FALSE . equalsIgnoreCase ( input ) || VALUE_OFF . equalsIgnoreCase ( input ) || VALUE_NO . equalsIgnoreCase ( input ) || VALUE_0 . equals ( input ) ) ) { return Boolean . FALSE ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + text + \"<STR_LIT>\" ) ; } } @ Override public String getAsText ( ) { String t = String . valueOf ( getValue ( ) ) ; if ( Boolean . TRUE . equals ( Boolean . valueOf ( t ) ) ) { return ( this . trueString != null ? this . trueString : VALUE_TRUE ) ; } else", "gt": "if ( Boolean . FALSE . equals ( Boolean . valueOf ( t ) ) ) {"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . service . UserMngCommandService ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . domain . user . UserDomainService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class UserMngCommandServiceImpl implements UserMngCommandService { @ Autowired private UserRepository userRepository ; @ Autowired private UserDomainService userDomainService ; @ Override public void enable ( Long userId ) { UserEntity", "gt": "user = userDomainService . validateUserId ( userId ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . ByteStreams ; import com . google . common . io . CharStreams ; import com . google . common . io . Closeables ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . * ; import java . util . List ; public class IOUtil { private static Logger logger = LoggerFactory . getLogger ( IOUtil . class ) ; public static void closeQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" , e ) ; } } public static String toString ( InputStream input ) throws IOException { InputStreamReader", "gt": "reader = new InputStreamReader ( input , Charsets . UTF_8 ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . ByteStreams ; import com . google . common . io . CharStreams ; import com . google . common . io . Closeables ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . * ; import java . util . List ; public class IOUtil { private static Logger logger = LoggerFactory . getLogger ( IOUtil . class ) ; public static void closeQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" , e ) ; } } public static String toString ( InputStream input ) throws IOException { InputStreamReader reader = new InputStreamReader ( input , Charsets . UTF_8 ) ; return toString ( reader ) ; } public static String toString ( Reader input ) throws IOException { return CharStreams . toString ( input ) ; } public static List < String > toLines ( final InputStream input ) throws IOException { return", "gt": "CharStreams . readLines ( new BufferedReader ( new InputStreamReader ( input , Charsets . UTF_8 ) ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . ByteStreams ; import com . google . common . io . CharStreams ; import com . google . common . io . Closeables ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . * ; import java . util . List ; public class IOUtil { private static Logger logger = LoggerFactory . getLogger ( IOUtil . class ) ; public static void closeQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" , e ) ; } } public static String toString ( InputStream input ) throws IOException { InputStreamReader reader = new InputStreamReader ( input , Charsets . UTF_8 ) ; return toString ( reader ) ; } public static String toString ( Reader input ) throws IOException { return CharStreams . toString ( input ) ; } public static List < String > toLines ( final InputStream input ) throws IOException { return CharStreams . readLines ( new BufferedReader ( new InputStreamReader ( input , Charsets . UTF_8 ) ) ) ; } public static List < String > toLines ( final Reader input ) throws IOException { return CharStreams . readLines ( toBufferedReader ( input ) ) ; } public static String readLine ( final InputStream input ) throws IOException { return", "gt": "new BufferedReader ( new InputStreamReader ( input , Charsets . UTF_8 ) ) . readLine ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . ByteStreams ; import com . google . common . io . CharStreams ; import com . google . common . io . Closeables ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . * ; import java . util . List ; public class IOUtil { private static Logger logger = LoggerFactory . getLogger ( IOUtil . class ) ; public static void closeQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" , e ) ; } } public static String toString ( InputStream input ) throws IOException { InputStreamReader reader = new InputStreamReader ( input , Charsets . UTF_8 ) ; return toString ( reader ) ; } public static String toString ( Reader input ) throws IOException { return CharStreams . toString ( input ) ; } public static List < String > toLines ( final InputStream input ) throws IOException { return CharStreams . readLines ( new BufferedReader ( new InputStreamReader ( input , Charsets . UTF_8 ) ) ) ; } public static List < String > toLines ( final Reader input ) throws IOException { return CharStreams . readLines ( toBufferedReader ( input ) ) ; } public static String readLine ( final InputStream input ) throws IOException { return new BufferedReader ( new InputStreamReader ( input , Charsets . UTF_8 ) ) . readLine ( ) ; } public static String readLine ( final Reader reader ) throws IOException { return", "gt": "toBufferedReader ( reader ) . readLine ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . ByteStreams ; import com . google . common . io . CharStreams ; import com . google . common . io . Closeables ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . * ; import java . util . List ; public class IOUtil { private static Logger logger = LoggerFactory . getLogger ( IOUtil . class ) ; public static void closeQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" , e ) ; } } public static String toString ( InputStream input ) throws IOException { InputStreamReader reader = new InputStreamReader ( input , Charsets . UTF_8 ) ; return toString ( reader ) ; } public static String toString ( Reader input ) throws IOException { return CharStreams . toString ( input ) ; } public static List < String > toLines ( final InputStream input ) throws IOException { return CharStreams . readLines ( new BufferedReader ( new InputStreamReader ( input , Charsets . UTF_8 ) ) ) ; } public static List < String > toLines ( final Reader input ) throws IOException { return CharStreams . readLines ( toBufferedReader ( input ) ) ; } public static String readLine ( final InputStream input ) throws IOException { return new BufferedReader ( new InputStreamReader ( input , Charsets . UTF_8 ) ) . readLine ( ) ; } public static String readLine ( final Reader reader ) throws IOException { return toBufferedReader ( reader ) . readLine ( ) ; } public static void write ( final String data , final OutputStream output ) throws IOException { if ( data != null ) { output . write ( data . getBytes ( Charsets . UTF_8 ) ) ; } } public static void write ( final String data , final Writer output ) throws IOException { if ( data != null ) { output . write ( data ) ; } } public static InputStream toInputStream ( String input ) { return", "gt": "new ByteArrayInputStream ( input . getBytes ( Charsets . UTF_8 ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . ByteStreams ; import com . google . common . io . CharStreams ; import com . google . common . io . Closeables ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . * ; import java . util . List ; public class IOUtil { private static Logger logger = LoggerFactory . getLogger ( IOUtil . class ) ; public static void closeQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" , e ) ; } } public static String toString ( InputStream input ) throws IOException { InputStreamReader reader = new InputStreamReader ( input , Charsets . UTF_8 ) ; return toString ( reader ) ; } public static String toString ( Reader input ) throws IOException { return CharStreams . toString ( input ) ; } public static List < String > toLines ( final InputStream input ) throws IOException { return CharStreams . readLines ( new BufferedReader ( new InputStreamReader ( input , Charsets . UTF_8 ) ) ) ; } public static List < String > toLines ( final Reader input ) throws IOException { return CharStreams . readLines ( toBufferedReader ( input ) ) ; } public static String readLine ( final InputStream input ) throws IOException { return new BufferedReader ( new InputStreamReader ( input , Charsets . UTF_8 ) ) . readLine ( ) ; } public static String readLine ( final Reader reader ) throws IOException { return toBufferedReader ( reader ) . readLine ( ) ; } public static void write ( final String data , final OutputStream output ) throws IOException { if ( data != null ) { output . write ( data . getBytes ( Charsets . UTF_8 ) ) ; } } public static void write ( final String data , final Writer output ) throws IOException { if ( data != null ) { output . write ( data ) ; } } public static InputStream toInputStream ( String input ) { return new ByteArrayInputStream ( input . getBytes ( Charsets . UTF_8 ) ) ; } public static Reader toInputStreamReader ( String input ) { return new InputStreamReader ( toInputStream ( input ) , Charsets . UTF_8 ) ; } public static long copy ( final Reader input , final Writer output ) throws IOException { return CharStreams . copy ( input , output ) ; } public static long copy ( final InputStream input , final OutputStream output ) throws IOException { return", "gt": "ByteStreams . copy ( input , output ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . microservice . core . ApplicationContextHolder ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import feign . RequestInterceptor ; import feign . RequestTemplate ; import org . example . ddduser . infrastructure . config . MicroserviceProperties ; public class WorkspaceSecurityInterceptor implements RequestInterceptor { @ Override public void apply ( RequestTemplate requestTemplate ) { MicroserviceProperties microserviceProperties = ApplicationContextHolder . get ( ) . getBean ( MicroserviceProperties . class ) ; MicroserviceProperties", "gt": ". MicroserviceConfig config = microserviceProperties . getWorkspace ( ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . microservice . core . ApplicationContextHolder ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import feign . RequestInterceptor ; import feign . RequestTemplate ; import org . example . ddduser . infrastructure . config . MicroserviceProperties ; public class WorkspaceSecurityInterceptor implements RequestInterceptor { @ Override public void apply ( RequestTemplate requestTemplate ) { MicroserviceProperties microserviceProperties = ApplicationContextHolder . get ( ) . getBean ( MicroserviceProperties . class ) ; MicroserviceProperties . MicroserviceConfig config = microserviceProperties . getWorkspace ( ) ; String", "gt": "accessKey = config . getAccessKey ( ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . microservice . core . ApplicationContextHolder ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import feign . RequestInterceptor ; import feign . RequestTemplate ; import org . example . ddduser . infrastructure . config . MicroserviceProperties ; public class WorkspaceSecurityInterceptor implements RequestInterceptor { @ Override public void apply ( RequestTemplate requestTemplate ) { MicroserviceProperties microserviceProperties = ApplicationContextHolder . get ( ) . getBean ( MicroserviceProperties . class ) ; MicroserviceProperties . MicroserviceConfig config = microserviceProperties . getWorkspace ( ) ; String accessKey = config . getAccessKey ( ) ; String secretKey = config . getSecretKey ( ) ; long timestamp = System . currentTimeMillis ( ) ; String signature = generateSignature ( secretKey , timestamp , requestTemplate ) ; requestTemplate", "gt": ". header ( \"<STR_LIT>\" , accessKey ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . microservice . core . ApplicationContextHolder ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import feign . RequestInterceptor ; import feign . RequestTemplate ; import org . example . ddduser . infrastructure . config . MicroserviceProperties ; public class WorkspaceSecurityInterceptor implements RequestInterceptor { @ Override public void apply ( RequestTemplate requestTemplate ) { MicroserviceProperties microserviceProperties = ApplicationContextHolder . get ( ) . getBean ( MicroserviceProperties . class ) ; MicroserviceProperties . MicroserviceConfig config = microserviceProperties . getWorkspace ( ) ; String accessKey = config . getAccessKey ( ) ; String secretKey = config . getSecretKey ( ) ; long timestamp = System . currentTimeMillis ( ) ; String signature = generateSignature ( secretKey , timestamp , requestTemplate ) ; requestTemplate . header ( \"<STR_LIT>\" , accessKey ) ; requestTemplate", "gt": ". header ( \"<STR_LIT>\" , signature ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . microservice . core . ApplicationContextHolder ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import feign . RequestInterceptor ; import feign . RequestTemplate ; import org . example . ddduser . infrastructure . config . MicroserviceProperties ; public class WorkspaceSecurityInterceptor implements RequestInterceptor { @ Override public void apply ( RequestTemplate requestTemplate ) { MicroserviceProperties microserviceProperties = ApplicationContextHolder . get ( ) . getBean ( MicroserviceProperties . class ) ; MicroserviceProperties . MicroserviceConfig config = microserviceProperties . getWorkspace ( ) ; String accessKey = config . getAccessKey ( ) ; String secretKey = config . getSecretKey ( ) ; long timestamp = System . currentTimeMillis ( ) ; String signature = generateSignature ( secretKey , timestamp , requestTemplate ) ; requestTemplate . header ( \"<STR_LIT>\" , accessKey ) ; requestTemplate . header ( \"<STR_LIT>\" , signature ) ; requestTemplate", "gt": ". header ( \"<STR_LIT>\" , String . valueOf ( timestamp ) ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . microservice . core . ApplicationContextHolder ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import feign . RequestInterceptor ; import feign . RequestTemplate ; import org . example . ddduser . infrastructure . config . MicroserviceProperties ; public class WorkspaceSecurityInterceptor implements RequestInterceptor { @ Override public void apply ( RequestTemplate requestTemplate ) { MicroserviceProperties microserviceProperties = ApplicationContextHolder . get ( ) . getBean ( MicroserviceProperties . class ) ; MicroserviceProperties . MicroserviceConfig config = microserviceProperties . getWorkspace ( ) ; String accessKey = config . getAccessKey ( ) ; String secretKey = config . getSecretKey ( ) ; long timestamp = System . currentTimeMillis ( ) ; String signature = generateSignature ( secretKey , timestamp , requestTemplate ) ; requestTemplate . header ( \"<STR_LIT>\" , accessKey ) ; requestTemplate . header ( \"<STR_LIT>\" , signature ) ; requestTemplate . header ( \"<STR_LIT>\" , String . valueOf ( timestamp ) ) ; } private String generateSignature ( String secretKey , long timestamp , RequestTemplate requestTemplate ) { return", "gt": "MD5Util . md5With32 ( secretKey + \"<STR_LIT>\" + timestamp + \"<STR_LIT>\" + requestTemplate . path ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . config . util . log . LogAutoFreshProcess ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigEnvironmentProcessor implements EnvironmentPostProcessor , Ordered { private final Logger logger = LoggerFactory . getLogger ( NacosConfigEnvironmentProcessor . class ) ; private final CacheableEventPublishingNacosServiceFactory nacosServiceFactory = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Map < String , ConfigService > serviceCache = new HashMap < > ( <NUM_LIT> ) ; private final LinkedList < NacosConfigLoader . DeferNacosPropertySource > deferPropertySources = new LinkedList < > ( ) ; private NacosConfigProperties nacosConfigProperties ; private Function < Properties , ConfigService > builder = properties -> { try { final String key = NacosUtils . identify ( properties ) ; if ( serviceCache . containsKey ( key ) ) { return serviceCache . get ( key ) ; } final", "gt": "ConfigService configService = NacosFactory . createConfigService ( properties ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . config . util . log . LogAutoFreshProcess ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigEnvironmentProcessor implements EnvironmentPostProcessor , Ordered { private final Logger logger = LoggerFactory . getLogger ( NacosConfigEnvironmentProcessor . class ) ; private final CacheableEventPublishingNacosServiceFactory nacosServiceFactory = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Map < String , ConfigService > serviceCache = new HashMap < > ( <NUM_LIT> ) ; private final LinkedList < NacosConfigLoader . DeferNacosPropertySource > deferPropertySources = new LinkedList < > ( ) ; private NacosConfigProperties nacosConfigProperties ; private Function < Properties , ConfigService > builder = properties -> { try { final String key = NacosUtils . identify ( properties ) ; if ( serviceCache . containsKey ( key ) ) { return serviceCache . get ( key ) ; } final ConfigService configService = NacosFactory . createConfigService ( properties ) ; serviceCache . put ( key , configService ) ; return nacosServiceFactory . deferCreateService ( configService , properties ) ; } catch ( NacosException e ) { throw", "gt": "new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . config . util . log . LogAutoFreshProcess ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigEnvironmentProcessor implements EnvironmentPostProcessor , Ordered { private final Logger logger = LoggerFactory . getLogger ( NacosConfigEnvironmentProcessor . class ) ; private final CacheableEventPublishingNacosServiceFactory nacosServiceFactory = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Map < String , ConfigService > serviceCache = new HashMap < > ( <NUM_LIT> ) ; private final LinkedList < NacosConfigLoader . DeferNacosPropertySource > deferPropertySources = new LinkedList < > ( ) ; private NacosConfigProperties nacosConfigProperties ; private Function < Properties , ConfigService > builder = properties -> { try { final String key = NacosUtils . identify ( properties ) ; if ( serviceCache . containsKey ( key ) ) { return serviceCache . get ( key ) ; } final ConfigService configService = NacosFactory . createConfigService ( properties ) ; serviceCache . put ( key , configService ) ; return nacosServiceFactory . deferCreateService ( configService , properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; @ Override public void postProcessEnvironment ( ConfigurableEnvironment environment , SpringApplication application ) { application . addInitializers ( new NacosConfigApplicationContextInitializer ( this ) ) ; nacosConfigProperties", "gt": "= NacosConfigPropertiesUtils . buildNacosConfigProperties ( environment ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . config . util . log . LogAutoFreshProcess ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigEnvironmentProcessor implements EnvironmentPostProcessor , Ordered { private final Logger logger = LoggerFactory . getLogger ( NacosConfigEnvironmentProcessor . class ) ; private final CacheableEventPublishingNacosServiceFactory nacosServiceFactory = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Map < String , ConfigService > serviceCache = new HashMap < > ( <NUM_LIT> ) ; private final LinkedList < NacosConfigLoader . DeferNacosPropertySource > deferPropertySources = new LinkedList < > ( ) ; private NacosConfigProperties nacosConfigProperties ; private Function < Properties , ConfigService > builder = properties -> { try { final String key = NacosUtils . identify ( properties ) ; if ( serviceCache . containsKey ( key ) ) { return serviceCache . get ( key ) ; } final ConfigService configService = NacosFactory . createConfigService ( properties ) ; serviceCache . put ( key , configService ) ; return nacosServiceFactory . deferCreateService ( configService , properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; @ Override public void postProcessEnvironment ( ConfigurableEnvironment environment , SpringApplication application ) { application . addInitializers ( new NacosConfigApplicationContextInitializer ( this ) ) ; nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( environment ) ; if ( enable ( ) ) { System", "gt": ". out . println ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . config . util . log . LogAutoFreshProcess ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigEnvironmentProcessor implements EnvironmentPostProcessor , Ordered { private final Logger logger = LoggerFactory . getLogger ( NacosConfigEnvironmentProcessor . class ) ; private final CacheableEventPublishingNacosServiceFactory nacosServiceFactory = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Map < String , ConfigService > serviceCache = new HashMap < > ( <NUM_LIT> ) ; private final LinkedList < NacosConfigLoader . DeferNacosPropertySource > deferPropertySources = new LinkedList < > ( ) ; private NacosConfigProperties nacosConfigProperties ; private Function < Properties , ConfigService > builder = properties -> { try { final String key = NacosUtils . identify ( properties ) ; if ( serviceCache . containsKey ( key ) ) { return serviceCache . get ( key ) ; } final ConfigService configService = NacosFactory . createConfigService ( properties ) ; serviceCache . put ( key , configService ) ; return nacosServiceFactory . deferCreateService ( configService , properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; @ Override public void postProcessEnvironment ( ConfigurableEnvironment environment , SpringApplication application ) { application . addInitializers ( new NacosConfigApplicationContextInitializer ( this ) ) ; nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( environment ) ; if ( enable ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; loadConfig ( environment ) ; NacosConfigLoader nacosConfigLoader = NacosConfigLoaderFactory . getSingleton ( nacosConfigProperties , environment , builder ) ; LogAutoFreshProcess . build ( environment , nacosConfigProperties , nacosConfigLoader , builder ) . process ( ) ; } } private void loadConfig ( ConfigurableEnvironment environment ) { NacosConfigLoader configLoader = new NacosConfigLoader ( nacosConfigProperties , environment , builder ) ; configLoader . loadConfig ( ) ; deferPropertySources", "gt": ". addAll ( configLoader . getNacosPropertySources ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . config . util . log . LogAutoFreshProcess ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigEnvironmentProcessor implements EnvironmentPostProcessor , Ordered { private final Logger logger = LoggerFactory . getLogger ( NacosConfigEnvironmentProcessor . class ) ; private final CacheableEventPublishingNacosServiceFactory nacosServiceFactory = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Map < String , ConfigService > serviceCache = new HashMap < > ( <NUM_LIT> ) ; private final LinkedList < NacosConfigLoader . DeferNacosPropertySource > deferPropertySources = new LinkedList < > ( ) ; private NacosConfigProperties nacosConfigProperties ; private Function < Properties , ConfigService > builder = properties -> { try { final String key = NacosUtils . identify ( properties ) ; if ( serviceCache . containsKey ( key ) ) { return serviceCache . get ( key ) ; } final ConfigService configService = NacosFactory . createConfigService ( properties ) ; serviceCache . put ( key , configService ) ; return nacosServiceFactory . deferCreateService ( configService , properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; @ Override public void postProcessEnvironment ( ConfigurableEnvironment environment , SpringApplication application ) { application . addInitializers ( new NacosConfigApplicationContextInitializer ( this ) ) ; nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( environment ) ; if ( enable ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; loadConfig ( environment ) ; NacosConfigLoader nacosConfigLoader = NacosConfigLoaderFactory . getSingleton ( nacosConfigProperties , environment , builder ) ; LogAutoFreshProcess . build ( environment , nacosConfigProperties , nacosConfigLoader , builder ) . process ( ) ; } } private void loadConfig ( ConfigurableEnvironment environment ) { NacosConfigLoader configLoader = new NacosConfigLoader ( nacosConfigProperties , environment , builder ) ; configLoader . loadConfig ( ) ; deferPropertySources . addAll ( configLoader . getNacosPropertySources ( ) ) ; } boolean enable ( ) { return", "gt": "nacosConfigProperties != null && nacosConfigProperties . getBootstrap ( ) . isLogEnable ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . config . util . log . LogAutoFreshProcess ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . core . Ordered ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigEnvironmentProcessor implements EnvironmentPostProcessor , Ordered { private final Logger logger = LoggerFactory . getLogger ( NacosConfigEnvironmentProcessor . class ) ; private final CacheableEventPublishingNacosServiceFactory nacosServiceFactory = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Map < String , ConfigService > serviceCache = new HashMap < > ( <NUM_LIT> ) ; private final LinkedList < NacosConfigLoader . DeferNacosPropertySource > deferPropertySources = new LinkedList < > ( ) ; private NacosConfigProperties nacosConfigProperties ; private Function < Properties , ConfigService > builder = properties -> { try { final String key = NacosUtils . identify ( properties ) ; if ( serviceCache . containsKey ( key ) ) { return serviceCache . get ( key ) ; } final ConfigService configService = NacosFactory . createConfigService ( properties ) ; serviceCache . put ( key , configService ) ; return nacosServiceFactory . deferCreateService ( configService , properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; @ Override public void postProcessEnvironment ( ConfigurableEnvironment environment , SpringApplication application ) { application . addInitializers ( new NacosConfigApplicationContextInitializer ( this ) ) ; nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( environment ) ; if ( enable ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; loadConfig ( environment ) ; NacosConfigLoader nacosConfigLoader = NacosConfigLoaderFactory . getSingleton ( nacosConfigProperties , environment , builder ) ; LogAutoFreshProcess . build ( environment , nacosConfigProperties , nacosConfigLoader , builder ) . process ( ) ; } } private void loadConfig ( ConfigurableEnvironment environment ) { NacosConfigLoader configLoader = new NacosConfigLoader ( nacosConfigProperties , environment , builder ) ; configLoader . loadConfig ( ) ; deferPropertySources . addAll ( configLoader . getNacosPropertySources ( ) ) ; } boolean enable ( ) { return nacosConfigProperties != null && nacosConfigProperties . getBootstrap ( ) . isLogEnable ( ) ; } LinkedList", "gt": "< NacosConfigLoader . DeferNacosPropertySource > getDeferPropertySources ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; public enum SizeUnit { BYTES , KILOBYTES , MEGABYTES , GIGABYTES ; private final double BYTES_PER_KILOBYTE = <NUM_LIT> ; private final double KILOBYTES_PER_MEGABYTE = <NUM_LIT> ; private final double MEGABYTES_PER_GIGABYTE = <NUM_LIT> ; public double toBytes ( final long input ) { double bytes ; switch ( this ) { case BYTES : bytes = input ; break ; case KILOBYTES : bytes = input * BYTES_PER_KILOBYTE ; break ; case", "gt": "MEGABYTES : bytes = input * BYTES_PER_KILOBYTE * KILOBYTES_PER_MEGABYTE ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; public enum SizeUnit { BYTES , KILOBYTES , MEGABYTES , GIGABYTES ; private final double BYTES_PER_KILOBYTE = <NUM_LIT> ; private final double KILOBYTES_PER_MEGABYTE = <NUM_LIT> ; private final double MEGABYTES_PER_GIGABYTE = <NUM_LIT> ; public double toBytes ( final long input ) { double bytes ; switch ( this ) { case BYTES : bytes = input ; break ; case KILOBYTES : bytes = input * BYTES_PER_KILOBYTE ; break ; case MEGABYTES : bytes = input * BYTES_PER_KILOBYTE * KILOBYTES_PER_MEGABYTE ; break ; case GIGABYTES : bytes = input * BYTES_PER_KILOBYTE * KILOBYTES_PER_MEGABYTE * MEGABYTES_PER_GIGABYTE ; break ; default", "gt": ": throw new RuntimeException ( \"<STR_LIT>\" + this + \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; public enum SizeUnit { BYTES , KILOBYTES , MEGABYTES , GIGABYTES ; private final double BYTES_PER_KILOBYTE = <NUM_LIT> ; private final double KILOBYTES_PER_MEGABYTE = <NUM_LIT> ; private final double MEGABYTES_PER_GIGABYTE = <NUM_LIT> ; public double toBytes ( final long input ) { double bytes ; switch ( this ) { case BYTES : bytes = input ; break ; case KILOBYTES : bytes = input * BYTES_PER_KILOBYTE ; break ; case MEGABYTES : bytes = input * BYTES_PER_KILOBYTE * KILOBYTES_PER_MEGABYTE ; break ; case GIGABYTES : bytes = input * BYTES_PER_KILOBYTE * KILOBYTES_PER_MEGABYTE * MEGABYTES_PER_GIGABYTE ; break ; default : throw new RuntimeException ( \"<STR_LIT>\" + this + \"<STR_LIT>\" ) ; } return bytes ; } public double toKiloBytes ( final long input ) { double kilobytes ; switch ( this ) { case", "gt": "BYTES : kilobytes = input / BYTES_PER_KILOBYTE ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; public enum SizeUnit { BYTES , KILOBYTES , MEGABYTES , GIGABYTES ; private final double BYTES_PER_KILOBYTE = <NUM_LIT> ; private final double KILOBYTES_PER_MEGABYTE = <NUM_LIT> ; private final double MEGABYTES_PER_GIGABYTE = <NUM_LIT> ; public double toBytes ( final long input ) { double bytes ; switch ( this ) { case BYTES : bytes = input ; break ; case KILOBYTES : bytes = input * BYTES_PER_KILOBYTE ; break ; case MEGABYTES : bytes = input * BYTES_PER_KILOBYTE * KILOBYTES_PER_MEGABYTE ; break ; case GIGABYTES : bytes = input * BYTES_PER_KILOBYTE * KILOBYTES_PER_MEGABYTE * MEGABYTES_PER_GIGABYTE ; break ; default : throw new RuntimeException ( \"<STR_LIT>\" + this + \"<STR_LIT>\" ) ; } return bytes ; } public double toKiloBytes ( final long input ) { double kilobytes ; switch ( this ) { case BYTES : kilobytes = input / BYTES_PER_KILOBYTE ; break ; case KILOBYTES : kilobytes = input ; break ; case MEGABYTES : kilobytes = input * KILOBYTES_PER_MEGABYTE ; break ; case GIGABYTES : kilobytes = input * KILOBYTES_PER_MEGABYTE * MEGABYTES_PER_GIGABYTE ; break ; default : throw new RuntimeException ( \"<STR_LIT>\" + this + \"<STR_LIT>\" ) ; } return kilobytes ; } public double toMegaBytes ( final long input ) { double megabytes ; switch ( this ) { case BYTES : megabytes = input / BYTES_PER_KILOBYTE / KILOBYTES_PER_MEGABYTE ; break ; case KILOBYTES : megabytes = input / KILOBYTES_PER_MEGABYTE ; break ; case MEGABYTES : megabytes = input ; break ; case GIGABYTES : megabytes = input * MEGABYTES_PER_GIGABYTE ; break ; default : throw new RuntimeException ( \"<STR_LIT>\" + this + \"<STR_LIT>\" ) ; } return megabytes ; } public double toGigaBytes ( final long input ) { double gigabytes ; switch ( this ) { case", "gt": "BYTES : gigabytes = input / BYTES_PER_KILOBYTE / KILOBYTES_PER_MEGABYTE / MEGABYTES_PER_GIGABYTE ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; public enum SizeUnit { BYTES , KILOBYTES , MEGABYTES , GIGABYTES ; private final double BYTES_PER_KILOBYTE = <NUM_LIT> ; private final double KILOBYTES_PER_MEGABYTE = <NUM_LIT> ; private final double MEGABYTES_PER_GIGABYTE = <NUM_LIT> ; public double toBytes ( final long input ) { double bytes ; switch ( this ) { case BYTES : bytes = input ; break ; case KILOBYTES : bytes = input * BYTES_PER_KILOBYTE ; break ; case MEGABYTES : bytes = input * BYTES_PER_KILOBYTE * KILOBYTES_PER_MEGABYTE ; break ; case GIGABYTES : bytes = input * BYTES_PER_KILOBYTE * KILOBYTES_PER_MEGABYTE * MEGABYTES_PER_GIGABYTE ; break ; default : throw new RuntimeException ( \"<STR_LIT>\" + this + \"<STR_LIT>\" ) ; } return bytes ; } public double toKiloBytes ( final long input ) { double kilobytes ; switch ( this ) { case BYTES : kilobytes = input / BYTES_PER_KILOBYTE ; break ; case KILOBYTES : kilobytes = input ; break ; case MEGABYTES : kilobytes = input * KILOBYTES_PER_MEGABYTE ; break ; case GIGABYTES : kilobytes = input * KILOBYTES_PER_MEGABYTE * MEGABYTES_PER_GIGABYTE ; break ; default : throw new RuntimeException ( \"<STR_LIT>\" + this + \"<STR_LIT>\" ) ; } return kilobytes ; } public double toMegaBytes ( final long input ) { double megabytes ; switch ( this ) { case BYTES : megabytes = input / BYTES_PER_KILOBYTE / KILOBYTES_PER_MEGABYTE ; break ; case KILOBYTES : megabytes = input / KILOBYTES_PER_MEGABYTE ; break ; case MEGABYTES : megabytes = input ; break ; case GIGABYTES : megabytes = input * MEGABYTES_PER_GIGABYTE ; break ; default : throw new RuntimeException ( \"<STR_LIT>\" + this + \"<STR_LIT>\" ) ; } return megabytes ; } public double toGigaBytes ( final long input ) { double gigabytes ; switch ( this ) { case BYTES : gigabytes = input / BYTES_PER_KILOBYTE / KILOBYTES_PER_MEGABYTE / MEGABYTES_PER_GIGABYTE ; break ; case KILOBYTES : gigabytes = input / KILOBYTES_PER_MEGABYTE / MEGABYTES_PER_GIGABYTE ; break ; case MEGABYTES : gigabytes = input / MEGABYTES_PER_GIGABYTE ; break ; case GIGABYTES : gigabytes = input ; break ; default", "gt": ": throw new RuntimeException ( \"<STR_LIT>\" + this + \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter", "gt": "annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for", "gt": "( BeanDefinition candidateComponent : candidateComponents ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert", "gt": ". isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map", "gt": "< String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String", "gt": "beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class", "gt": "< ? > beanUnderlyingClass = null ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder", "gt": ". addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder", "gt": ". addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder", "gt": ". addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder", "gt": ". addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder", "gt": ". addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder", "gt": ". addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ; BeanDefinition", "gt": "beanDefinition = bdBuilder . getBeanDefinition ( ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ; BeanDefinition beanDefinition = bdBuilder . getBeanDefinition ( ) ; BeanDefinitionHolder", "gt": "holder = new BeanDefinitionHolder ( beanDefinition , beanName ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ; BeanDefinition beanDefinition = bdBuilder . getBeanDefinition ( ) ; BeanDefinitionHolder holder = new BeanDefinitionHolder ( beanDefinition , beanName ) ; BeanDefinitionReaderUtils", "gt": ". registerBeanDefinition ( holder , registry ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ; BeanDefinition beanDefinition = bdBuilder . getBeanDefinition ( ) ; BeanDefinitionHolder holder = new BeanDefinitionHolder ( beanDefinition , beanName ) ; BeanDefinitionReaderUtils . registerBeanDefinition ( holder , registry ) ; } private String getUrl ( Map < String , Object > attributes ) { String", "gt": "url = ( String ) attributes . get ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ; BeanDefinition beanDefinition = bdBuilder . getBeanDefinition ( ) ; BeanDefinitionHolder holder = new BeanDefinitionHolder ( beanDefinition , beanName ) ; BeanDefinitionReaderUtils . registerBeanDefinition ( holder , registry ) ; } private String getUrl ( Map < String , Object > attributes ) { String url = ( String ) attributes . get ( \"<STR_LIT>\" ) ; return", "gt": "this . environment . resolvePlaceholders ( url ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ; BeanDefinition beanDefinition = bdBuilder . getBeanDefinition ( ) ; BeanDefinitionHolder holder = new BeanDefinitionHolder ( beanDefinition , beanName ) ; BeanDefinitionReaderUtils . registerBeanDefinition ( holder , registry ) ; } private String getUrl ( Map < String , Object > attributes ) { String url = ( String ) attributes . get ( \"<STR_LIT>\" ) ; return this . environment . resolvePlaceholders ( url ) ; } private Class < ? > getSingleType ( Map < String , Object > attributes , String attributeName ) { Object", "gt": "singleType = attributes . get ( attributeName ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ; BeanDefinition beanDefinition = bdBuilder . getBeanDefinition ( ) ; BeanDefinitionHolder holder = new BeanDefinitionHolder ( beanDefinition , beanName ) ; BeanDefinitionReaderUtils . registerBeanDefinition ( holder , registry ) ; } private String getUrl ( Map < String , Object > attributes ) { String url = ( String ) attributes . get ( \"<STR_LIT>\" ) ; return this . environment . resolvePlaceholders ( url ) ; } private Class < ? > getSingleType ( Map < String , Object > attributes , String attributeName ) { Object singleType = attributes . get ( attributeName ) ; if ( singleType == null ) { return null ; } return", "gt": "( Class < ? > ) singleType ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ; BeanDefinition beanDefinition = bdBuilder . getBeanDefinition ( ) ; BeanDefinitionHolder holder = new BeanDefinitionHolder ( beanDefinition , beanName ) ; BeanDefinitionReaderUtils . registerBeanDefinition ( holder , registry ) ; } private String getUrl ( Map < String , Object > attributes ) { String url = ( String ) attributes . get ( \"<STR_LIT>\" ) ; return this . environment . resolvePlaceholders ( url ) ; } private Class < ? > getSingleType ( Map < String , Object > attributes , String attributeName ) { Object singleType = attributes . get ( attributeName ) ; if ( singleType == null ) { return null ; } return ( Class < ? > ) singleType ; } private Class < ? > [ ] getMultiTypes ( Map < String , Object > attributes , String attributeName ) { Object multiTypes = attributes . get ( attributeName ) ; if ( multiTypes == null ) { return null ; } return ( Class < ? > [ ] ) multiTypes ; } private String generateBeanName ( AnnotationMetadata annotationMetadata , Map < String , Object > attributes ) { if ( attributes != null && attributes . containsKey ( \"<STR_LIT>\" ) && TextUtil . isNotEmpty ( ( String ) attributes . get ( \"<STR_LIT>\" ) ) ) { return ( ( String ) attributes . get ( \"<STR_LIT>\" ) ) . trim ( ) ; } return annotationMetadata . getClassName ( ) ; } private Set < String > resolveBasePackages ( ) { Set", "gt": "< String > basePackages = new HashSet < String > ( ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ; BeanDefinition beanDefinition = bdBuilder . getBeanDefinition ( ) ; BeanDefinitionHolder holder = new BeanDefinitionHolder ( beanDefinition , beanName ) ; BeanDefinitionReaderUtils . registerBeanDefinition ( holder , registry ) ; } private String getUrl ( Map < String , Object > attributes ) { String url = ( String ) attributes . get ( \"<STR_LIT>\" ) ; return this . environment . resolvePlaceholders ( url ) ; } private Class < ? > getSingleType ( Map < String , Object > attributes , String attributeName ) { Object singleType = attributes . get ( attributeName ) ; if ( singleType == null ) { return null ; } return ( Class < ? > ) singleType ; } private Class < ? > [ ] getMultiTypes ( Map < String , Object > attributes , String attributeName ) { Object multiTypes = attributes . get ( attributeName ) ; if ( multiTypes == null ) { return null ; } return ( Class < ? > [ ] ) multiTypes ; } private String generateBeanName ( AnnotationMetadata annotationMetadata , Map < String , Object > attributes ) { if ( attributes != null && attributes . containsKey ( \"<STR_LIT>\" ) && TextUtil . isNotEmpty ( ( String ) attributes . get ( \"<STR_LIT>\" ) ) ) { return ( ( String ) attributes . get ( \"<STR_LIT>\" ) ) . trim ( ) ; } return annotationMetadata . getClassName ( ) ; } private Set < String > resolveBasePackages ( ) { Set < String > basePackages = new HashSet < String > ( ) ; String pkg = this . environment . getProperty ( OpenFeignProperties . PROP_BASE_PACKAGE ) ; if", "gt": "( TextUtil . isNotEmpty ( pkg ) ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ; BeanDefinition beanDefinition = bdBuilder . getBeanDefinition ( ) ; BeanDefinitionHolder holder = new BeanDefinitionHolder ( beanDefinition , beanName ) ; BeanDefinitionReaderUtils . registerBeanDefinition ( holder , registry ) ; } private String getUrl ( Map < String , Object > attributes ) { String url = ( String ) attributes . get ( \"<STR_LIT>\" ) ; return this . environment . resolvePlaceholders ( url ) ; } private Class < ? > getSingleType ( Map < String , Object > attributes , String attributeName ) { Object singleType = attributes . get ( attributeName ) ; if ( singleType == null ) { return null ; } return ( Class < ? > ) singleType ; } private Class < ? > [ ] getMultiTypes ( Map < String , Object > attributes , String attributeName ) { Object multiTypes = attributes . get ( attributeName ) ; if ( multiTypes == null ) { return null ; } return ( Class < ? > [ ] ) multiTypes ; } private String generateBeanName ( AnnotationMetadata annotationMetadata , Map < String , Object > attributes ) { if ( attributes != null && attributes . containsKey ( \"<STR_LIT>\" ) && TextUtil . isNotEmpty ( ( String ) attributes . get ( \"<STR_LIT>\" ) ) ) { return ( ( String ) attributes . get ( \"<STR_LIT>\" ) ) . trim ( ) ; } return annotationMetadata . getClassName ( ) ; } private Set < String > resolveBasePackages ( ) { Set < String > basePackages = new HashSet < String > ( ) ; String pkg = this . environment . getProperty ( OpenFeignProperties . PROP_BASE_PACKAGE ) ; if ( TextUtil . isNotEmpty ( pkg ) ) { basePackages", "gt": ". add ( pkg . trim ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignAutoConfiguration ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . ClassUtils ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . BeanDefinitionHolder ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionReaderUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . ResourceLoaderAware ; import org . springframework . context . annotation . ClassPathScanningCandidateComponentProvider ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . env . Environment ; import org . springframework . core . io . ResourceLoader ; import org . springframework . core . type . AnnotationMetadata ; import org . springframework . core . type . filter . AnnotationTypeFilter ; import org . springframework . util . Assert ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class FeignClientRegistrar implements ImportBeanDefinitionRegistrar , ResourceLoaderAware , EnvironmentAware { private ResourceLoader resourceLoader ; private Environment environment ; @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { ClassPathScanningCandidateComponentProvider scanner = getScanner ( ) ; scanner . setResourceLoader ( this . resourceLoader ) ; AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter ( FeignClient . class ) ; scanner . addIncludeFilter ( annotationTypeFilter ) ; Set < String > basePackages = resolveBasePackages ( ) ; if ( CollectionUtil . isEmpty ( basePackages ) ) { return ; } for ( String basePackage : basePackages ) { this . doScan ( registry , basePackage , scanner ) ; } } private void doScan ( BeanDefinitionRegistry registry , String basePackage , ClassPathScanningCandidateComponentProvider scanner ) { Set < BeanDefinition > candidateComponents = scanner . findCandidateComponents ( basePackage ) ; for ( BeanDefinition candidateComponent : candidateComponents ) { if ( ! ( candidateComponent instanceof AnnotatedBeanDefinition ) ) { continue ; } AnnotatedBeanDefinition beanDefinition = ( AnnotatedBeanDefinition ) candidateComponent ; AnnotationMetadata annotationMetadata = beanDefinition . getMetadata ( ) ; Assert . isTrue ( annotationMetadata . isInterface ( ) , \"<STR_LIT>\" ) ; Map < String , Object > attributes = annotationMetadata . getAnnotationAttributes ( FeignClient . class . getCanonicalName ( ) ) ; String beanUnderlyingClassName = beanDefinition . getBeanClassName ( ) ; Class < ? > beanUnderlyingClass = null ; try { beanUnderlyingClass = ClassUtils . getClass ( beanUnderlyingClassName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( \"<STR_LIT>\" + beanUnderlyingClassName + \"<STR_LIT>\" , e ) ; } String beanName = generateBeanName ( annotationMetadata , attributes ) ; registerFeignClient ( registry , beanName , beanUnderlyingClass , attributes ) ; } } private void registerFeignClient ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanUnderlyingClass , Map < String , Object > attributes ) { BeanDefinitionBuilder bdBuilder = BeanDefinitionBuilder . genericBeanDefinition ( FeignClientFactoryBean . class ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , beanUnderlyingClass ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getUrl ( attributes ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getSingleType ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyValue ( \"<STR_LIT>\" , getMultiTypes ( attributes , \"<STR_LIT>\" ) ) ; bdBuilder . addPropertyReference ( \"<STR_LIT>\" , OpenFeignAutoConfiguration . DEFAULT_FEIGN_CLIENT_BEAN_NAME ) ; BeanDefinition beanDefinition = bdBuilder . getBeanDefinition ( ) ; BeanDefinitionHolder holder = new BeanDefinitionHolder ( beanDefinition , beanName ) ; BeanDefinitionReaderUtils . registerBeanDefinition ( holder , registry ) ; } private String getUrl ( Map < String , Object > attributes ) { String url = ( String ) attributes . get ( \"<STR_LIT>\" ) ; return this . environment . resolvePlaceholders ( url ) ; } private Class < ? > getSingleType ( Map < String , Object > attributes , String attributeName ) { Object singleType = attributes . get ( attributeName ) ; if ( singleType == null ) { return null ; } return ( Class < ? > ) singleType ; } private Class < ? > [ ] getMultiTypes ( Map < String , Object > attributes , String attributeName ) { Object multiTypes = attributes . get ( attributeName ) ; if ( multiTypes == null ) { return null ; } return ( Class < ? > [ ] ) multiTypes ; } private String generateBeanName ( AnnotationMetadata annotationMetadata , Map < String , Object > attributes ) { if ( attributes != null && attributes . containsKey ( \"<STR_LIT>\" ) && TextUtil . isNotEmpty ( ( String ) attributes . get ( \"<STR_LIT>\" ) ) ) { return ( ( String ) attributes . get ( \"<STR_LIT>\" ) ) . trim ( ) ; } return annotationMetadata . getClassName ( ) ; } private Set < String > resolveBasePackages ( ) { Set < String > basePackages = new HashSet < String > ( ) ; String pkg = this . environment . getProperty ( OpenFeignProperties . PROP_BASE_PACKAGE ) ; if ( TextUtil . isNotEmpty ( pkg ) ) { basePackages . add ( pkg . trim ( ) ) ; } return basePackages ; } private ClassPathScanningCandidateComponentProvider getScanner ( ) { return", "gt": "new ClassPathScanningCandidateComponentProvider ( false , this . environment ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . core . env . Environment ; import org . w3c . dom . Element ; public class NacosAnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser { @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) { Environment", "gt": "environment = parserContext . getDelegate ( ) . getReaderContext ( ) . getReader ( ) . getEnvironment ( ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . util . CollectionUtils ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Map ; public class ResponseBodyDecorateCenter { private Log logger = LogFactory . getLog ( getClass ( ) ) ; private ApplicationContext applicationContext ; public ResponseBodyDecorateCenter ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public Object doDecorate ( Object body ) { if ( body == null ) { return null ; } Collection", "gt": "< ResponseBodyDecorator > decorators = getDecorators ( ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . util . CollectionUtils ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Map ; public class ResponseBodyDecorateCenter { private Log logger = LogFactory . getLog ( getClass ( ) ) ; private ApplicationContext applicationContext ; public ResponseBodyDecorateCenter ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public Object doDecorate ( Object body ) { if ( body == null ) { return null ; } Collection < ResponseBodyDecorator > decorators = getDecorators ( ) ; if ( CollectionUtils . isEmpty ( decorators ) ) { return body ; } for", "gt": "( ResponseBodyDecorator decorator : decorators ) {"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . util . CollectionUtils ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Map ; public class ResponseBodyDecorateCenter { private Log logger = LogFactory . getLog ( getClass ( ) ) ; private ApplicationContext applicationContext ; public ResponseBodyDecorateCenter ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public Object doDecorate ( Object body ) { if ( body == null ) { return null ; } Collection < ResponseBodyDecorator > decorators = getDecorators ( ) ; if ( CollectionUtils . isEmpty ( decorators ) ) { return body ; } for ( ResponseBodyDecorator decorator : decorators ) { try { body", "gt": "= decorator . decorate ( body ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . util . CollectionUtils ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Map ; public class ResponseBodyDecorateCenter { private Log logger = LogFactory . getLog ( getClass ( ) ) ; private ApplicationContext applicationContext ; public ResponseBodyDecorateCenter ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public Object doDecorate ( Object body ) { if ( body == null ) { return null ; } Collection < ResponseBodyDecorator > decorators = getDecorators ( ) ; if ( CollectionUtils . isEmpty ( decorators ) ) { return body ; } for ( ResponseBodyDecorator decorator : decorators ) { try { body = decorator . decorate ( body ) ; } catch ( Exception e ) { logger", "gt": ". error ( \"<STR_LIT>\" , e ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . util . CollectionUtils ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Map ; public class ResponseBodyDecorateCenter { private Log logger = LogFactory . getLog ( getClass ( ) ) ; private ApplicationContext applicationContext ; public ResponseBodyDecorateCenter ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public Object doDecorate ( Object body ) { if ( body == null ) { return null ; } Collection < ResponseBodyDecorator > decorators = getDecorators ( ) ; if ( CollectionUtils . isEmpty ( decorators ) ) { return body ; } for ( ResponseBodyDecorator decorator : decorators ) { try { body = decorator . decorate ( body ) ; } catch ( Exception e ) { logger . error ( \"<STR_LIT>\" , e ) ; } } return body ; } private Collection < ResponseBodyDecorator > getDecorators ( ) { try { Map < String , ResponseBodyDecorator > decoratorMap = applicationContext . getBeansOfType ( ResponseBodyDecorator . class ) ; if ( decoratorMap == null || decoratorMap . size ( ) == <NUM_LIT> ) { return null ; } Collection < ResponseBodyDecorator > decorators = decoratorMap . values ( ) ; List", "gt": "< ResponseBodyDecorator > sortedDecorators = new ArrayList < ResponseBodyDecorator > ( decorators ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . util . CollectionUtils ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Map ; public class ResponseBodyDecorateCenter { private Log logger = LogFactory . getLog ( getClass ( ) ) ; private ApplicationContext applicationContext ; public ResponseBodyDecorateCenter ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public Object doDecorate ( Object body ) { if ( body == null ) { return null ; } Collection < ResponseBodyDecorator > decorators = getDecorators ( ) ; if ( CollectionUtils . isEmpty ( decorators ) ) { return body ; } for ( ResponseBodyDecorator decorator : decorators ) { try { body = decorator . decorate ( body ) ; } catch ( Exception e ) { logger . error ( \"<STR_LIT>\" , e ) ; } } return body ; } private Collection < ResponseBodyDecorator > getDecorators ( ) { try { Map < String , ResponseBodyDecorator > decoratorMap = applicationContext . getBeansOfType ( ResponseBodyDecorator . class ) ; if ( decoratorMap == null || decoratorMap . size ( ) == <NUM_LIT> ) { return null ; } Collection < ResponseBodyDecorator > decorators = decoratorMap . values ( ) ; List < ResponseBodyDecorator > sortedDecorators = new ArrayList < ResponseBodyDecorator > ( decorators ) ; sortedDecorators", "gt": ". sort ( ( o1 , o2 ) -> {"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . util . CollectionUtils ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Map ; public class ResponseBodyDecorateCenter { private Log logger = LogFactory . getLog ( getClass ( ) ) ; private ApplicationContext applicationContext ; public ResponseBodyDecorateCenter ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public Object doDecorate ( Object body ) { if ( body == null ) { return null ; } Collection < ResponseBodyDecorator > decorators = getDecorators ( ) ; if ( CollectionUtils . isEmpty ( decorators ) ) { return body ; } for ( ResponseBodyDecorator decorator : decorators ) { try { body = decorator . decorate ( body ) ; } catch ( Exception e ) { logger . error ( \"<STR_LIT>\" , e ) ; } } return body ; } private Collection < ResponseBodyDecorator > getDecorators ( ) { try { Map < String , ResponseBodyDecorator > decoratorMap = applicationContext . getBeansOfType ( ResponseBodyDecorator . class ) ; if ( decoratorMap == null || decoratorMap . size ( ) == <NUM_LIT> ) { return null ; } Collection < ResponseBodyDecorator > decorators = decoratorMap . values ( ) ; List < ResponseBodyDecorator > sortedDecorators = new ArrayList < ResponseBodyDecorator > ( decorators ) ; sortedDecorators . sort ( ( o1 , o2 ) -> { if ( o1 . getOrder ( ) < o2 . getOrder ( ) ) { return - <NUM_LIT> ; } else", "gt": "if ( o1 . getOrder ( ) > o2 . getOrder ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import java . util . Date ; public class ClockUtil { private static Clock instance = new DefaultClock ( ) ; public static long elapsedTime ( long beginTime ) { return currentTimeMillis ( ) - beginTime ; } public static synchronized DummyClock useDummyClock ( ) { instance = new DummyClock ( ) ; return ( DummyClock ) instance ; } public static synchronized DummyClock useDummyClock ( long timeStampMills ) { instance", "gt": "= new DummyClock ( timeStampMills ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import java . util . Date ; public class ClockUtil { private static Clock instance = new DefaultClock ( ) ; public static long elapsedTime ( long beginTime ) { return currentTimeMillis ( ) - beginTime ; } public static synchronized DummyClock useDummyClock ( ) { instance = new DummyClock ( ) ; return ( DummyClock ) instance ; } public static synchronized DummyClock useDummyClock ( long timeStampMills ) { instance = new DummyClock ( timeStampMills ) ; return ( DummyClock ) instance ; } public static synchronized DummyClock useDummyClock ( Date date ) { instance", "gt": "= new DummyClock ( date ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import java . util . Date ; public class ClockUtil { private static Clock instance = new DefaultClock ( ) ; public static long elapsedTime ( long beginTime ) { return currentTimeMillis ( ) - beginTime ; } public static synchronized DummyClock useDummyClock ( ) { instance = new DummyClock ( ) ; return ( DummyClock ) instance ; } public static synchronized DummyClock useDummyClock ( long timeStampMills ) { instance = new DummyClock ( timeStampMills ) ; return ( DummyClock ) instance ; } public static synchronized DummyClock useDummyClock ( Date date ) { instance = new DummyClock ( date ) ; return ( DummyClock ) instance ; } public static synchronized void useDefaultClock ( ) { instance = new DefaultClock ( ) ; } public static Date currentDate ( ) { return instance . currentDate ( ) ; } public static long currentTimeMillis ( ) { return instance . currentTimeMillis ( ) ; } public static long nanoTime ( ) { return instance . nanoTime ( ) ; } public interface Clock { Date currentDate ( ) ; long currentTimeMillis ( ) ; long nanoTime ( ) ; } public static class DefaultClock implements Clock { @ Override public Date currentDate ( ) { return new Date ( ) ; } @ Override public long currentTimeMillis ( ) { return System . currentTimeMillis ( ) ; } @ Override public long nanoTime ( ) { return System . nanoTime ( ) ; } } public static class DummyClock implements Clock { private long time ; private long nanoTme ; public DummyClock ( ) { this", "gt": "( System . currentTimeMillis ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import java . util . Date ; public class ClockUtil { private static Clock instance = new DefaultClock ( ) ; public static long elapsedTime ( long beginTime ) { return currentTimeMillis ( ) - beginTime ; } public static synchronized DummyClock useDummyClock ( ) { instance = new DummyClock ( ) ; return ( DummyClock ) instance ; } public static synchronized DummyClock useDummyClock ( long timeStampMills ) { instance = new DummyClock ( timeStampMills ) ; return ( DummyClock ) instance ; } public static synchronized DummyClock useDummyClock ( Date date ) { instance = new DummyClock ( date ) ; return ( DummyClock ) instance ; } public static synchronized void useDefaultClock ( ) { instance = new DefaultClock ( ) ; } public static Date currentDate ( ) { return instance . currentDate ( ) ; } public static long currentTimeMillis ( ) { return instance . currentTimeMillis ( ) ; } public static long nanoTime ( ) { return instance . nanoTime ( ) ; } public interface Clock { Date currentDate ( ) ; long currentTimeMillis ( ) ; long nanoTime ( ) ; } public static class DefaultClock implements Clock { @ Override public Date currentDate ( ) { return new Date ( ) ; } @ Override public long currentTimeMillis ( ) { return System . currentTimeMillis ( ) ; } @ Override public long nanoTime ( ) { return System . nanoTime ( ) ; } } public static class DummyClock implements Clock { private long time ; private long nanoTme ; public DummyClock ( ) { this ( System . currentTimeMillis ( ) ) ; } public DummyClock ( Date date ) { this", "gt": "( date . getTime ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import java . util . Date ; public class ClockUtil { private static Clock instance = new DefaultClock ( ) ; public static long elapsedTime ( long beginTime ) { return currentTimeMillis ( ) - beginTime ; } public static synchronized DummyClock useDummyClock ( ) { instance = new DummyClock ( ) ; return ( DummyClock ) instance ; } public static synchronized DummyClock useDummyClock ( long timeStampMills ) { instance = new DummyClock ( timeStampMills ) ; return ( DummyClock ) instance ; } public static synchronized DummyClock useDummyClock ( Date date ) { instance = new DummyClock ( date ) ; return ( DummyClock ) instance ; } public static synchronized void useDefaultClock ( ) { instance = new DefaultClock ( ) ; } public static Date currentDate ( ) { return instance . currentDate ( ) ; } public static long currentTimeMillis ( ) { return instance . currentTimeMillis ( ) ; } public static long nanoTime ( ) { return instance . nanoTime ( ) ; } public interface Clock { Date currentDate ( ) ; long currentTimeMillis ( ) ; long nanoTime ( ) ; } public static class DefaultClock implements Clock { @ Override public Date currentDate ( ) { return new Date ( ) ; } @ Override public long currentTimeMillis ( ) { return System . currentTimeMillis ( ) ; } @ Override public long nanoTime ( ) { return System . nanoTime ( ) ; } } public static class DummyClock implements Clock { private long time ; private long nanoTme ; public DummyClock ( ) { this ( System . currentTimeMillis ( ) ) ; } public DummyClock ( Date date ) { this ( date . getTime ( ) ) ; } public DummyClock ( long time ) { this . time = time ; this", "gt": ". nanoTme = System . nanoTime ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import java . util . Date ; public class ClockUtil { private static Clock instance = new DefaultClock ( ) ; public static long elapsedTime ( long beginTime ) { return currentTimeMillis ( ) - beginTime ; } public static synchronized DummyClock useDummyClock ( ) { instance = new DummyClock ( ) ; return ( DummyClock ) instance ; } public static synchronized DummyClock useDummyClock ( long timeStampMills ) { instance = new DummyClock ( timeStampMills ) ; return ( DummyClock ) instance ; } public static synchronized DummyClock useDummyClock ( Date date ) { instance = new DummyClock ( date ) ; return ( DummyClock ) instance ; } public static synchronized void useDefaultClock ( ) { instance = new DefaultClock ( ) ; } public static Date currentDate ( ) { return instance . currentDate ( ) ; } public static long currentTimeMillis ( ) { return instance . currentTimeMillis ( ) ; } public static long nanoTime ( ) { return instance . nanoTime ( ) ; } public interface Clock { Date currentDate ( ) ; long currentTimeMillis ( ) ; long nanoTime ( ) ; } public static class DefaultClock implements Clock { @ Override public Date currentDate ( ) { return new Date ( ) ; } @ Override public long currentTimeMillis ( ) { return System . currentTimeMillis ( ) ; } @ Override public long nanoTime ( ) { return System . nanoTime ( ) ; } } public static class DummyClock implements Clock { private long time ; private long nanoTme ; public DummyClock ( ) { this ( System . currentTimeMillis ( ) ) ; } public DummyClock ( Date date ) { this ( date . getTime ( ) ) ; } public DummyClock ( long time ) { this . time = time ; this . nanoTme = System . nanoTime ( ) ; } @ Override public Date currentDate ( ) { return new Date ( time ) ; } @ Override public long currentTimeMillis ( ) { return time ; } @ Override public long nanoTime ( ) { return nanoTme ; } public void updateNow ( Date newDate ) { time", "gt": "= newDate . getTime ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this", "gt": ". exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this", "gt": ". exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object", "gt": "value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member", "gt": "member = injectedElement . getMember ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return", "gt": "convertIfNecessary ( ( Method ) member , value ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return", "gt": "super . postProcessBeforeInitialization ( bean , beanName ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for", "gt": "( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String", "gt": "key = environment . resolvePlaceholders ( entry . getKey ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String", "gt": "newValue = environment . getProperty ( key ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List", "gt": "< NacosValueTarget > beanPropertyList = entry . getValue ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for", "gt": "( NacosValueTarget target : beanPropertyList ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String", "gt": "md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean", "gt": "isUpdate = ! target . lastMD5 . equals ( md5String ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object", "gt": "evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if", "gt": "( target . method == null ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String", "gt": "spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String", "gt": "value = beanFactory . resolveEmbeddedValue ( strVal ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter", "gt": "converter = beanFactory . getTypeConverter ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return", "gt": "converter . convertIfNecessary ( value , field . getType ( ) , field ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter", "gt": "converter = beanFactory . getTypeConverter ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if", "gt": "( arguments . length == <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation", "gt": "( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if", "gt": "( annotation . autoRefreshed ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap", "gt": "( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if", "gt": "( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if", "gt": "( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex", "gt": "= beginIndex + PLACEHOLDER_PREFIX . length ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int", "gt": "endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if", "gt": "( endIndex == - <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if ( endIndex == - <NUM_LIT> ) { return null ; } placeholder", "gt": "= placeholder . substring ( beginIndex , endIndex ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if ( endIndex == - <NUM_LIT> ) { return null ; } placeholder = placeholder . substring ( beginIndex , endIndex ) ; int", "gt": "separatorIndex = placeholder . indexOf ( VALUE_SEPARATOR ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if ( endIndex == - <NUM_LIT> ) { return null ; } placeholder = placeholder . substring ( beginIndex , endIndex ) ; int separatorIndex = placeholder . indexOf ( VALUE_SEPARATOR ) ; if", "gt": "( separatorIndex != - <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if ( endIndex == - <NUM_LIT> ) { return null ; } placeholder = placeholder . substring ( beginIndex , endIndex ) ; int separatorIndex = placeholder . indexOf ( VALUE_SEPARATOR ) ; if ( separatorIndex != - <NUM_LIT> ) { return placeholder . substring ( <NUM_LIT> , separatorIndex ) ; } return placeholder ; } private < K , V > void put2ListMap ( Map < K , List < V > > map , K key , V value ) { List < V > valueList = map . get ( key ) ; if ( valueList == null ) { valueList = new ArrayList < V > ( ) ; } valueList . add ( value ) ; map . put ( key , valueList ) ; } private void setMethod ( NacosValueTarget nacosValueTarget , Object propertyValue ) { Method method = nacosValueTarget . method ; ReflectionUtils . makeAccessible ( method ) ; try { method . invoke ( nacosValueTarget . bean , convertIfNecessary ( method , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" , method . getName ( ) , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger", "gt": ". error ( \"<STR_LIT>\" + method . getName ( ) + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if ( endIndex == - <NUM_LIT> ) { return null ; } placeholder = placeholder . substring ( beginIndex , endIndex ) ; int separatorIndex = placeholder . indexOf ( VALUE_SEPARATOR ) ; if ( separatorIndex != - <NUM_LIT> ) { return placeholder . substring ( <NUM_LIT> , separatorIndex ) ; } return placeholder ; } private < K , V > void put2ListMap ( Map < K , List < V > > map , K key , V value ) { List < V > valueList = map . get ( key ) ; if ( valueList == null ) { valueList = new ArrayList < V > ( ) ; } valueList . add ( value ) ; map . put ( key , valueList ) ; } private void setMethod ( NacosValueTarget nacosValueTarget , Object propertyValue ) { Method method = nacosValueTarget . method ; ReflectionUtils . makeAccessible ( method ) ; try { method . invoke ( nacosValueTarget . bean , convertIfNecessary ( method , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" , method . getName ( ) , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + method . getName ( ) + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private void setField ( final NacosValueTarget nacosValueTarget , final Object propertyValue ) { final Object bean = nacosValueTarget . bean ; Field field = nacosValueTarget . field ; String fieldName = field . getName ( ) ; try { ReflectionUtils . makeAccessible ( field ) ; field . set ( bean , convertIfNecessary ( field , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + \"<STR_LIT>\" , fieldName , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private static class NacosValueTarget { private final Object bean ; private final String beanName ; private final Method method ; private final Field field ; private String lastMD5 ; private final String nacosValueExpr ; NacosValueTarget", "gt": "( Object bean , String beanName , Method method , Field field , String nacosValueExpr ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if ( endIndex == - <NUM_LIT> ) { return null ; } placeholder = placeholder . substring ( beginIndex , endIndex ) ; int separatorIndex = placeholder . indexOf ( VALUE_SEPARATOR ) ; if ( separatorIndex != - <NUM_LIT> ) { return placeholder . substring ( <NUM_LIT> , separatorIndex ) ; } return placeholder ; } private < K , V > void put2ListMap ( Map < K , List < V > > map , K key , V value ) { List < V > valueList = map . get ( key ) ; if ( valueList == null ) { valueList = new ArrayList < V > ( ) ; } valueList . add ( value ) ; map . put ( key , valueList ) ; } private void setMethod ( NacosValueTarget nacosValueTarget , Object propertyValue ) { Method method = nacosValueTarget . method ; ReflectionUtils . makeAccessible ( method ) ; try { method . invoke ( nacosValueTarget . bean , convertIfNecessary ( method , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" , method . getName ( ) , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + method . getName ( ) + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private void setField ( final NacosValueTarget nacosValueTarget , final Object propertyValue ) { final Object bean = nacosValueTarget . bean ; Field field = nacosValueTarget . field ; String fieldName = field . getName ( ) ; try { ReflectionUtils . makeAccessible ( field ) ; field . set ( bean , convertIfNecessary ( field , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + \"<STR_LIT>\" , fieldName , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private static class NacosValueTarget { private final Object bean ; private final String beanName ; private final Method method ; private final Field field ; private String lastMD5 ; private final String nacosValueExpr ; NacosValueTarget ( Object bean , String beanName , Method method , Field field , String nacosValueExpr ) { this . bean = bean ; this . beanName = beanName ; this . method = method ; this . field = field ; this . lastMD5 = \"<STR_LIT>\" ; this . nacosValueExpr = resolveExpr ( nacosValueExpr ) ; } private String resolveExpr ( String nacosValueExpr ) { try { int", "gt": "replaceHolderBegin = nacosValueExpr . indexOf ( PLACEHOLDER_PREFIX ) + PLACEHOLDER_PREFIX . length ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if ( endIndex == - <NUM_LIT> ) { return null ; } placeholder = placeholder . substring ( beginIndex , endIndex ) ; int separatorIndex = placeholder . indexOf ( VALUE_SEPARATOR ) ; if ( separatorIndex != - <NUM_LIT> ) { return placeholder . substring ( <NUM_LIT> , separatorIndex ) ; } return placeholder ; } private < K , V > void put2ListMap ( Map < K , List < V > > map , K key , V value ) { List < V > valueList = map . get ( key ) ; if ( valueList == null ) { valueList = new ArrayList < V > ( ) ; } valueList . add ( value ) ; map . put ( key , valueList ) ; } private void setMethod ( NacosValueTarget nacosValueTarget , Object propertyValue ) { Method method = nacosValueTarget . method ; ReflectionUtils . makeAccessible ( method ) ; try { method . invoke ( nacosValueTarget . bean , convertIfNecessary ( method , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" , method . getName ( ) , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + method . getName ( ) + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private void setField ( final NacosValueTarget nacosValueTarget , final Object propertyValue ) { final Object bean = nacosValueTarget . bean ; Field field = nacosValueTarget . field ; String fieldName = field . getName ( ) ; try { ReflectionUtils . makeAccessible ( field ) ; field . set ( bean , convertIfNecessary ( field , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + \"<STR_LIT>\" , fieldName , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private static class NacosValueTarget { private final Object bean ; private final String beanName ; private final Method method ; private final Field field ; private String lastMD5 ; private final String nacosValueExpr ; NacosValueTarget ( Object bean , String beanName , Method method , Field field , String nacosValueExpr ) { this . bean = bean ; this . beanName = beanName ; this . method = method ; this . field = field ; this . lastMD5 = \"<STR_LIT>\" ; this . nacosValueExpr = resolveExpr ( nacosValueExpr ) ; } private String resolveExpr ( String nacosValueExpr ) { try { int replaceHolderBegin = nacosValueExpr . indexOf ( PLACEHOLDER_PREFIX ) + PLACEHOLDER_PREFIX . length ( ) ; int replaceHolderEnd = replaceHolderBegin ; for ( int i = <NUM_LIT> ; replaceHolderEnd", "gt": "< nacosValueExpr . length ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if ( endIndex == - <NUM_LIT> ) { return null ; } placeholder = placeholder . substring ( beginIndex , endIndex ) ; int separatorIndex = placeholder . indexOf ( VALUE_SEPARATOR ) ; if ( separatorIndex != - <NUM_LIT> ) { return placeholder . substring ( <NUM_LIT> , separatorIndex ) ; } return placeholder ; } private < K , V > void put2ListMap ( Map < K , List < V > > map , K key , V value ) { List < V > valueList = map . get ( key ) ; if ( valueList == null ) { valueList = new ArrayList < V > ( ) ; } valueList . add ( value ) ; map . put ( key , valueList ) ; } private void setMethod ( NacosValueTarget nacosValueTarget , Object propertyValue ) { Method method = nacosValueTarget . method ; ReflectionUtils . makeAccessible ( method ) ; try { method . invoke ( nacosValueTarget . bean , convertIfNecessary ( method , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" , method . getName ( ) , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + method . getName ( ) + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private void setField ( final NacosValueTarget nacosValueTarget , final Object propertyValue ) { final Object bean = nacosValueTarget . bean ; Field field = nacosValueTarget . field ; String fieldName = field . getName ( ) ; try { ReflectionUtils . makeAccessible ( field ) ; field . set ( bean , convertIfNecessary ( field , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + \"<STR_LIT>\" , fieldName , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private static class NacosValueTarget { private final Object bean ; private final String beanName ; private final Method method ; private final Field field ; private String lastMD5 ; private final String nacosValueExpr ; NacosValueTarget ( Object bean , String beanName , Method method , Field field , String nacosValueExpr ) { this . bean = bean ; this . beanName = beanName ; this . method = method ; this . field = field ; this . lastMD5 = \"<STR_LIT>\" ; this . nacosValueExpr = resolveExpr ( nacosValueExpr ) ; } private String resolveExpr ( String nacosValueExpr ) { try { int replaceHolderBegin = nacosValueExpr . indexOf ( PLACEHOLDER_PREFIX ) + PLACEHOLDER_PREFIX . length ( ) ; int replaceHolderEnd = replaceHolderBegin ; for ( int i = <NUM_LIT> ; replaceHolderEnd < nacosValueExpr . length ( ) ; replaceHolderEnd ++ ) { char", "gt": "ch = nacosValueExpr . charAt ( replaceHolderEnd ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if ( endIndex == - <NUM_LIT> ) { return null ; } placeholder = placeholder . substring ( beginIndex , endIndex ) ; int separatorIndex = placeholder . indexOf ( VALUE_SEPARATOR ) ; if ( separatorIndex != - <NUM_LIT> ) { return placeholder . substring ( <NUM_LIT> , separatorIndex ) ; } return placeholder ; } private < K , V > void put2ListMap ( Map < K , List < V > > map , K key , V value ) { List < V > valueList = map . get ( key ) ; if ( valueList == null ) { valueList = new ArrayList < V > ( ) ; } valueList . add ( value ) ; map . put ( key , valueList ) ; } private void setMethod ( NacosValueTarget nacosValueTarget , Object propertyValue ) { Method method = nacosValueTarget . method ; ReflectionUtils . makeAccessible ( method ) ; try { method . invoke ( nacosValueTarget . bean , convertIfNecessary ( method , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" , method . getName ( ) , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + method . getName ( ) + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private void setField ( final NacosValueTarget nacosValueTarget , final Object propertyValue ) { final Object bean = nacosValueTarget . bean ; Field field = nacosValueTarget . field ; String fieldName = field . getName ( ) ; try { ReflectionUtils . makeAccessible ( field ) ; field . set ( bean , convertIfNecessary ( field , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + \"<STR_LIT>\" , fieldName , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private static class NacosValueTarget { private final Object bean ; private final String beanName ; private final Method method ; private final Field field ; private String lastMD5 ; private final String nacosValueExpr ; NacosValueTarget ( Object bean , String beanName , Method method , Field field , String nacosValueExpr ) { this . bean = bean ; this . beanName = beanName ; this . method = method ; this . field = field ; this . lastMD5 = \"<STR_LIT>\" ; this . nacosValueExpr = resolveExpr ( nacosValueExpr ) ; } private String resolveExpr ( String nacosValueExpr ) { try { int replaceHolderBegin = nacosValueExpr . indexOf ( PLACEHOLDER_PREFIX ) + PLACEHOLDER_PREFIX . length ( ) ; int replaceHolderEnd = replaceHolderBegin ; for ( int i = <NUM_LIT> ; replaceHolderEnd < nacosValueExpr . length ( ) ; replaceHolderEnd ++ ) { char ch = nacosValueExpr . charAt ( replaceHolderEnd ) ; if ( PLACEHOLDER_MATCH_PREFIX == ch ) { i ++ ; } else if ( PLACEHOLDER_MATCH_SUFFIX == ch && -- i == - <NUM_LIT> ) { break ; } } String", "gt": "replaceHolder = nacosValueExpr . substring ( replaceHolderBegin , replaceHolderEnd ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if ( endIndex == - <NUM_LIT> ) { return null ; } placeholder = placeholder . substring ( beginIndex , endIndex ) ; int separatorIndex = placeholder . indexOf ( VALUE_SEPARATOR ) ; if ( separatorIndex != - <NUM_LIT> ) { return placeholder . substring ( <NUM_LIT> , separatorIndex ) ; } return placeholder ; } private < K , V > void put2ListMap ( Map < K , List < V > > map , K key , V value ) { List < V > valueList = map . get ( key ) ; if ( valueList == null ) { valueList = new ArrayList < V > ( ) ; } valueList . add ( value ) ; map . put ( key , valueList ) ; } private void setMethod ( NacosValueTarget nacosValueTarget , Object propertyValue ) { Method method = nacosValueTarget . method ; ReflectionUtils . makeAccessible ( method ) ; try { method . invoke ( nacosValueTarget . bean , convertIfNecessary ( method , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" , method . getName ( ) , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + method . getName ( ) + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private void setField ( final NacosValueTarget nacosValueTarget , final Object propertyValue ) { final Object bean = nacosValueTarget . bean ; Field field = nacosValueTarget . field ; String fieldName = field . getName ( ) ; try { ReflectionUtils . makeAccessible ( field ) ; field . set ( bean , convertIfNecessary ( field , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + \"<STR_LIT>\" , fieldName , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private static class NacosValueTarget { private final Object bean ; private final String beanName ; private final Method method ; private final Field field ; private String lastMD5 ; private final String nacosValueExpr ; NacosValueTarget ( Object bean , String beanName , Method method , Field field , String nacosValueExpr ) { this . bean = bean ; this . beanName = beanName ; this . method = method ; this . field = field ; this . lastMD5 = \"<STR_LIT>\" ; this . nacosValueExpr = resolveExpr ( nacosValueExpr ) ; } private String resolveExpr ( String nacosValueExpr ) { try { int replaceHolderBegin = nacosValueExpr . indexOf ( PLACEHOLDER_PREFIX ) + PLACEHOLDER_PREFIX . length ( ) ; int replaceHolderEnd = replaceHolderBegin ; for ( int i = <NUM_LIT> ; replaceHolderEnd < nacosValueExpr . length ( ) ; replaceHolderEnd ++ ) { char ch = nacosValueExpr . charAt ( replaceHolderEnd ) ; if ( PLACEHOLDER_MATCH_PREFIX == ch ) { i ++ ; } else if ( PLACEHOLDER_MATCH_SUFFIX == ch && -- i == - <NUM_LIT> ) { break ; } } String replaceHolder = nacosValueExpr . substring ( replaceHolderBegin , replaceHolderEnd ) ; int", "gt": "separatorIndex = replaceHolder . indexOf ( VALUE_SEPARATOR ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . config . annotation . NacosValue ; import com . alibaba . nacos . common . utils . MD5Utils ; import io . github . chensheng . dddboot . nacos . spring . annotation . AbstractAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigReceivedEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationListener ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . MethodParameter ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; public class NacosValueAnnotationBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements BeanFactoryAware , EnvironmentAware , ApplicationListener < NacosConfigReceivedEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final String SPEL_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_PREFIX = \"<STR_LIT>\" ; private static final String PLACEHOLDER_SUFFIX = \"<STR_LIT>\" ; private static final char PLACEHOLDER_MATCH_PREFIX = '<STR_LIT>' ; private static final char PLACEHOLDER_MATCH_SUFFIX = '<STR_LIT>' ; private static final String VALUE_SEPARATOR = \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private Map < String , List < NacosValueTarget > > placeholderNacosValueTargetMap = new HashMap < String , List < NacosValueTarget > > ( ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private BeanExpressionResolver exprResolver ; private BeanExpressionContext exprContext ; public NacosValueAnnotationBeanPostProcessor ( ) { super ( NacosValue . class ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { if ( ! ( beanFactory instanceof ConfigurableListableBeanFactory ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; this . exprResolver = ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanExpressionResolver ( ) ; this . exprContext = new BeanExpressionContext ( ( ConfigurableListableBeanFactory ) beanFactory , null ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { Object value = resolveStringValue ( attributes . getString ( \"<STR_LIT>\" ) ) ; Member member = injectedElement . getMember ( ) ; if ( member instanceof Field ) { return convertIfNecessary ( ( Field ) member , value ) ; } if ( member instanceof Method ) { return convertIfNecessary ( ( Method ) member , value ) ; } return null ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { return bean . getClass ( ) . getName ( ) + attributes ; } @ Override public Object postProcessBeforeInitialization ( Object bean , final String beanName ) throws BeansException { doWithFields ( bean , beanName ) ; doWithMethods ( bean , beanName ) ; return super . postProcessBeforeInitialization ( bean , beanName ) ; } @ Override public void onApplicationEvent ( NacosConfigReceivedEvent event ) { for ( Map . Entry < String , List < NacosValueTarget > > entry : placeholderNacosValueTargetMap . entrySet ( ) ) { String key = environment . resolvePlaceholders ( entry . getKey ( ) ) ; String newValue = environment . getProperty ( key ) ; if ( newValue == null ) { continue ; } List < NacosValueTarget > beanPropertyList = entry . getValue ( ) ; for ( NacosValueTarget target : beanPropertyList ) { String md5String = MD5Utils . md5Hex ( newValue , \"<STR_LIT>\" ) ; boolean isUpdate = ! target . lastMD5 . equals ( md5String ) ; if ( isUpdate ) { target . updateLastMD5 ( md5String ) ; Object evaluatedValue = resolveNotifyValue ( target . nacosValueExpr , key , newValue ) ; if ( target . method == null ) { setField ( target , evaluatedValue ) ; } else { setMethod ( target , evaluatedValue ) ; } } } } } private Object resolveNotifyValue ( String nacosValueExpr , String key , String newValue ) { String spelExpr = nacosValueExpr . replaceAll ( \"<STR_LIT>\" + key + PLACEHOLDER_SUFFIX , newValue ) ; return resolveStringValue ( spelExpr ) ; } private Object resolveStringValue ( String strVal ) { String value = beanFactory . resolveEmbeddedValue ( strVal ) ; if ( exprResolver != null && value != null ) { return exprResolver . evaluate ( value , exprContext ) ; } return value ; } private Object convertIfNecessary ( Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } private Object convertIfNecessary ( Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } private void doWithFields ( final Object bean , final String beanName ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( field , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , field . getModifiers ( ) , null , field ) ; } } ) ; } private void doWithMethods ( final Object bean , final String beanName ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { NacosValue annotation = getAnnotation ( method , NacosValue . class ) ; doWithAnnotation ( beanName , bean , annotation , method . getModifiers ( ) , method , null ) ; } } ) ; } private void doWithAnnotation ( String beanName , Object bean , NacosValue annotation , int modifiers , Method method , Field field ) { if ( annotation != null ) { if ( Modifier . isStatic ( modifiers ) ) { return ; } if ( annotation . autoRefreshed ( ) ) { String placeholder = resolvePlaceholder ( annotation . value ( ) ) ; if ( placeholder == null ) { return ; } NacosValueTarget nacosValueTarget = new NacosValueTarget ( bean , beanName , method , field , annotation . value ( ) ) ; put2ListMap ( placeholderNacosValueTargetMap , placeholder , nacosValueTarget ) ; } } } private String resolvePlaceholder ( String placeholder ) { if ( ! placeholder . startsWith ( PLACEHOLDER_PREFIX ) && ! placeholder . startsWith ( SPEL_PREFIX ) ) { return null ; } if ( ! placeholder . endsWith ( PLACEHOLDER_SUFFIX ) ) { return null ; } if ( placeholder . length ( ) <= PLACEHOLDER_PREFIX . length ( ) + PLACEHOLDER_SUFFIX . length ( ) ) { return null ; } int beginIndex = placeholder . indexOf ( PLACEHOLDER_PREFIX ) ; if ( beginIndex == - <NUM_LIT> ) { return null ; } beginIndex = beginIndex + PLACEHOLDER_PREFIX . length ( ) ; int endIndex = placeholder . indexOf ( PLACEHOLDER_SUFFIX , beginIndex ) ; if ( endIndex == - <NUM_LIT> ) { return null ; } placeholder = placeholder . substring ( beginIndex , endIndex ) ; int separatorIndex = placeholder . indexOf ( VALUE_SEPARATOR ) ; if ( separatorIndex != - <NUM_LIT> ) { return placeholder . substring ( <NUM_LIT> , separatorIndex ) ; } return placeholder ; } private < K , V > void put2ListMap ( Map < K , List < V > > map , K key , V value ) { List < V > valueList = map . get ( key ) ; if ( valueList == null ) { valueList = new ArrayList < V > ( ) ; } valueList . add ( value ) ; map . put ( key , valueList ) ; } private void setMethod ( NacosValueTarget nacosValueTarget , Object propertyValue ) { Method method = nacosValueTarget . method ; ReflectionUtils . makeAccessible ( method ) ; try { method . invoke ( nacosValueTarget . bean , convertIfNecessary ( method , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" , method . getName ( ) , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + method . getName ( ) + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private void setField ( final NacosValueTarget nacosValueTarget , final Object propertyValue ) { final Object bean = nacosValueTarget . bean ; Field field = nacosValueTarget . field ; String fieldName = field . getName ( ) ; try { ReflectionUtils . makeAccessible ( field ) ; field . set ( bean , convertIfNecessary ( field , propertyValue ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + \"<STR_LIT>\" , fieldName , nacosValueTarget . beanName , propertyValue ) ; } } catch ( Throwable e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + nacosValueTarget . beanName + \"<STR_LIT>\" , e ) ; } } } private static class NacosValueTarget { private final Object bean ; private final String beanName ; private final Method method ; private final Field field ; private String lastMD5 ; private final String nacosValueExpr ; NacosValueTarget ( Object bean , String beanName , Method method , Field field , String nacosValueExpr ) { this . bean = bean ; this . beanName = beanName ; this . method = method ; this . field = field ; this . lastMD5 = \"<STR_LIT>\" ; this . nacosValueExpr = resolveExpr ( nacosValueExpr ) ; } private String resolveExpr ( String nacosValueExpr ) { try { int replaceHolderBegin = nacosValueExpr . indexOf ( PLACEHOLDER_PREFIX ) + PLACEHOLDER_PREFIX . length ( ) ; int replaceHolderEnd = replaceHolderBegin ; for ( int i = <NUM_LIT> ; replaceHolderEnd < nacosValueExpr . length ( ) ; replaceHolderEnd ++ ) { char ch = nacosValueExpr . charAt ( replaceHolderEnd ) ; if ( PLACEHOLDER_MATCH_PREFIX == ch ) { i ++ ; } else if ( PLACEHOLDER_MATCH_SUFFIX == ch && -- i == - <NUM_LIT> ) { break ; } } String replaceHolder = nacosValueExpr . substring ( replaceHolderBegin , replaceHolderEnd ) ; int separatorIndex = replaceHolder . indexOf ( VALUE_SEPARATOR ) ; if", "gt": "( separatorIndex != - <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . PropertySource ; import java . util . * ; import java . util . concurrent . Callable ; public class AttributeExtractTask implements Callable < Map < String , String > > { private final String prefix ; private final ConfigurableEnvironment environment ; public AttributeExtractTask ( String prefix , ConfigurableEnvironment environment ) { this . prefix = prefix ; this . environment = environment ; } @ Override public Map < String , String > call ( ) throws Exception { List < Map < String , String > > defer = new LinkedList < > ( ) ; MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; for ( PropertySource propertySource : mutablePropertySources ) { calculate", "gt": "( propertySource . getSource ( ) , defer ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . PropertySource ; import java . util . * ; import java . util . concurrent . Callable ; public class AttributeExtractTask implements Callable < Map < String , String > > { private final String prefix ; private final ConfigurableEnvironment environment ; public AttributeExtractTask ( String prefix , ConfigurableEnvironment environment ) { this . prefix = prefix ; this . environment = environment ; } @ Override public Map < String , String > call ( ) throws Exception { List < Map < String , String > > defer = new LinkedList < > ( ) ; MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; for ( PropertySource propertySource : mutablePropertySources ) { calculate ( propertySource . getSource ( ) , defer ) ; } Map", "gt": "< String , String > result = new HashMap < > ( <NUM_LIT> ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . PropertySource ; import java . util . * ; import java . util . concurrent . Callable ; public class AttributeExtractTask implements Callable < Map < String , String > > { private final String prefix ; private final ConfigurableEnvironment environment ; public AttributeExtractTask ( String prefix , ConfigurableEnvironment environment ) { this . prefix = prefix ; this . environment = environment ; } @ Override public Map < String , String > call ( ) throws Exception { List < Map < String , String > > defer = new LinkedList < > ( ) ; MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; for ( PropertySource propertySource : mutablePropertySources ) { calculate ( propertySource . getSource ( ) , defer ) ; } Map < String , String > result = new HashMap < > ( <NUM_LIT> ) ; Collections . reverse ( defer ) ; for", "gt": "( Map < String , String > item : defer ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . PropertySource ; import java . util . * ; import java . util . concurrent . Callable ; public class AttributeExtractTask implements Callable < Map < String , String > > { private final String prefix ; private final ConfigurableEnvironment environment ; public AttributeExtractTask ( String prefix , ConfigurableEnvironment environment ) { this . prefix = prefix ; this . environment = environment ; } @ Override public Map < String , String > call ( ) throws Exception { List < Map < String , String > > defer = new LinkedList < > ( ) ; MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; for ( PropertySource propertySource : mutablePropertySources ) { calculate ( propertySource . getSource ( ) , defer ) ; } Map < String , String > result = new HashMap < > ( <NUM_LIT> ) ; Collections . reverse ( defer ) ; for ( Map < String , String > item : defer ) { result . putAll ( item ) ; } return result ; } private void calculate ( Object source , List < Map < String , String > > defer ) { if ( source instanceof PropertySource ) { calculate", "gt": "( ( ( PropertySource ) source ) . getSource ( ) , defer ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . PropertySource ; import java . util . * ; import java . util . concurrent . Callable ; public class AttributeExtractTask implements Callable < Map < String , String > > { private final String prefix ; private final ConfigurableEnvironment environment ; public AttributeExtractTask ( String prefix , ConfigurableEnvironment environment ) { this . prefix = prefix ; this . environment = environment ; } @ Override public Map < String , String > call ( ) throws Exception { List < Map < String , String > > defer = new LinkedList < > ( ) ; MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; for ( PropertySource propertySource : mutablePropertySources ) { calculate ( propertySource . getSource ( ) , defer ) ; } Map < String , String > result = new HashMap < > ( <NUM_LIT> ) ; Collections . reverse ( defer ) ; for ( Map < String , String > item : defer ) { result . putAll ( item ) ; } return result ; } private void calculate ( Object source , List < Map < String , String > > defer ) { if ( source instanceof PropertySource ) { calculate ( ( ( PropertySource ) source ) . getSource ( ) , defer ) ; } if ( source instanceof Map ) { Map", "gt": "< String , String > map = new HashMap < > ( <NUM_LIT> ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . PropertySource ; import java . util . * ; import java . util . concurrent . Callable ; public class AttributeExtractTask implements Callable < Map < String , String > > { private final String prefix ; private final ConfigurableEnvironment environment ; public AttributeExtractTask ( String prefix , ConfigurableEnvironment environment ) { this . prefix = prefix ; this . environment = environment ; } @ Override public Map < String , String > call ( ) throws Exception { List < Map < String , String > > defer = new LinkedList < > ( ) ; MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; for ( PropertySource propertySource : mutablePropertySources ) { calculate ( propertySource . getSource ( ) , defer ) ; } Map < String , String > result = new HashMap < > ( <NUM_LIT> ) ; Collections . reverse ( defer ) ; for ( Map < String , String > item : defer ) { result . putAll ( item ) ; } return result ; } private void calculate ( Object source , List < Map < String , String > > defer ) { if ( source instanceof PropertySource ) { calculate ( ( ( PropertySource ) source ) . getSource ( ) , defer ) ; } if ( source instanceof Map ) { Map < String , String > map = new HashMap < > ( <NUM_LIT> ) ; for", "gt": "( Object entry : ( ( Map ) source ) . entrySet ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . PropertySource ; import java . util . * ; import java . util . concurrent . Callable ; public class AttributeExtractTask implements Callable < Map < String , String > > { private final String prefix ; private final ConfigurableEnvironment environment ; public AttributeExtractTask ( String prefix , ConfigurableEnvironment environment ) { this . prefix = prefix ; this . environment = environment ; } @ Override public Map < String , String > call ( ) throws Exception { List < Map < String , String > > defer = new LinkedList < > ( ) ; MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; for ( PropertySource propertySource : mutablePropertySources ) { calculate ( propertySource . getSource ( ) , defer ) ; } Map < String , String > result = new HashMap < > ( <NUM_LIT> ) ; Collections . reverse ( defer ) ; for ( Map < String , String > item : defer ) { result . putAll ( item ) ; } return result ; } private void calculate ( Object source , List < Map < String , String > > defer ) { if ( source instanceof PropertySource ) { calculate ( ( ( PropertySource ) source ) . getSource ( ) , defer ) ; } if ( source instanceof Map ) { Map < String , String > map = new HashMap < > ( <NUM_LIT> ) ; for ( Object entry : ( ( Map ) source ) . entrySet ( ) ) { Map . Entry < Object , Object > element = ( Map . Entry < Object , Object > ) entry ; String key = String . valueOf ( element . getKey ( ) ) ; if ( key . startsWith ( prefix ) ) { map", "gt": ". put ( key , String . valueOf ( element . getValue ( ) ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . PropertySource ; import java . util . * ; import java . util . concurrent . Callable ; public class AttributeExtractTask implements Callable < Map < String , String > > { private final String prefix ; private final ConfigurableEnvironment environment ; public AttributeExtractTask ( String prefix , ConfigurableEnvironment environment ) { this . prefix = prefix ; this . environment = environment ; } @ Override public Map < String , String > call ( ) throws Exception { List < Map < String , String > > defer = new LinkedList < > ( ) ; MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; for ( PropertySource propertySource : mutablePropertySources ) { calculate ( propertySource . getSource ( ) , defer ) ; } Map < String , String > result = new HashMap < > ( <NUM_LIT> ) ; Collections . reverse ( defer ) ; for ( Map < String , String > item : defer ) { result . putAll ( item ) ; } return result ; } private void calculate ( Object source , List < Map < String , String > > defer ) { if ( source instanceof PropertySource ) { calculate ( ( ( PropertySource ) source ) . getSource ( ) , defer ) ; } if ( source instanceof Map ) { Map < String , String > map = new HashMap < > ( <NUM_LIT> ) ; for ( Object entry : ( ( Map ) source ) . entrySet ( ) ) { Map . Entry < Object , Object > element = ( Map . Entry < Object , Object > ) entry ; String key = String . valueOf ( element . getKey ( ) ) ; if ( key . startsWith ( prefix ) ) { map . put ( key , String . valueOf ( element . getValue ( ) ) ) ; } } if ( ! map . isEmpty ( ) ) { defer . add ( map ) ; } } if ( source instanceof List || source instanceof Set ) { Collection", "gt": "sources = ( Collection ) source ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . PropertySource ; import java . util . * ; import java . util . concurrent . Callable ; public class AttributeExtractTask implements Callable < Map < String , String > > { private final String prefix ; private final ConfigurableEnvironment environment ; public AttributeExtractTask ( String prefix , ConfigurableEnvironment environment ) { this . prefix = prefix ; this . environment = environment ; } @ Override public Map < String , String > call ( ) throws Exception { List < Map < String , String > > defer = new LinkedList < > ( ) ; MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; for ( PropertySource propertySource : mutablePropertySources ) { calculate ( propertySource . getSource ( ) , defer ) ; } Map < String , String > result = new HashMap < > ( <NUM_LIT> ) ; Collections . reverse ( defer ) ; for ( Map < String , String > item : defer ) { result . putAll ( item ) ; } return result ; } private void calculate ( Object source , List < Map < String , String > > defer ) { if ( source instanceof PropertySource ) { calculate ( ( ( PropertySource ) source ) . getSource ( ) , defer ) ; } if ( source instanceof Map ) { Map < String , String > map = new HashMap < > ( <NUM_LIT> ) ; for ( Object entry : ( ( Map ) source ) . entrySet ( ) ) { Map . Entry < Object , Object > element = ( Map . Entry < Object , Object > ) entry ; String key = String . valueOf ( element . getKey ( ) ) ; if ( key . startsWith ( prefix ) ) { map . put ( key , String . valueOf ( element . getValue ( ) ) ) ; } } if ( ! map . isEmpty ( ) ) { defer . add ( map ) ; } } if ( source instanceof List || source instanceof Set ) { Collection sources = ( Collection ) source ; for", "gt": "( Object obj : sources ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . pojo . Instance ; import com . alibaba . nacos . api . naming . pojo . Service ; import com . alibaba . nacos . api . selector . AbstractSelector ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import java . util . Map ; import java . util . Properties ; class DelegatingNamingMaintainService implements NamingMaintainService , NacosServiceMetaData { private final NamingMaintainService delegate ; private final Properties properties ; DelegatingNamingMaintainService ( NamingMaintainService delegate , Properties properties ) { this . delegate = delegate ; this . properties = properties ; } @ Override public void updateInstance ( String serviceName , Instance instance ) throws NacosException { delegate . updateInstance ( serviceName , instance ) ; } @ Override public void updateInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . updateInstance ( serviceName , groupName , instance ) ; } @ Override public Service queryService ( String serviceName ) throws NacosException { return delegate . queryService ( serviceName ) ; } @ Override public Service queryService ( String serviceName , String groupName ) throws NacosException { return delegate . queryService ( serviceName , groupName ) ; } @ Override public void createService ( String serviceName ) throws NacosException { delegate . createService ( serviceName ) ; } @ Override public void createService ( String serviceName , String groupName ) throws NacosException { delegate . createService ( serviceName , groupName ) ; } @ Override public void createService ( String serviceName , String groupName , float protectThreshold ) throws NacosException { delegate . createService ( serviceName , groupName , protectThreshold ) ; } @ Override public void createService ( String serviceName , String groupName , float protectThreshold , String expression ) throws NacosException { delegate", "gt": ". createService ( serviceName , groupName , protectThreshold , expression ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . pojo . Instance ; import com . alibaba . nacos . api . naming . pojo . Service ; import com . alibaba . nacos . api . selector . AbstractSelector ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import java . util . Map ; import java . util . Properties ; class DelegatingNamingMaintainService implements NamingMaintainService , NacosServiceMetaData { private final NamingMaintainService delegate ; private final Properties properties ; DelegatingNamingMaintainService ( NamingMaintainService delegate , Properties properties ) { this . delegate = delegate ; this . properties = properties ; } @ Override public void updateInstance ( String serviceName , Instance instance ) throws NacosException { delegate . updateInstance ( serviceName , instance ) ; } @ Override public void updateInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . updateInstance ( serviceName , groupName , instance ) ; } @ Override public Service queryService ( String serviceName ) throws NacosException { return delegate . queryService ( serviceName ) ; } @ Override public Service queryService ( String serviceName , String groupName ) throws NacosException { return delegate . queryService ( serviceName , groupName ) ; } @ Override public void createService ( String serviceName ) throws NacosException { delegate . createService ( serviceName ) ; } @ Override public void createService ( String serviceName , String groupName ) throws NacosException { delegate . createService ( serviceName , groupName ) ; } @ Override public void createService ( String serviceName , String groupName , float protectThreshold ) throws NacosException { delegate . createService ( serviceName , groupName , protectThreshold ) ; } @ Override public void createService ( String serviceName , String groupName , float protectThreshold , String expression ) throws NacosException { delegate . createService ( serviceName , groupName , protectThreshold , expression ) ; } @ Override public void createService ( Service service , AbstractSelector selector ) throws NacosException { delegate", "gt": ". createService ( service , selector ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . pojo . Instance ; import com . alibaba . nacos . api . naming . pojo . Service ; import com . alibaba . nacos . api . selector . AbstractSelector ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import java . util . Map ; import java . util . Properties ; class DelegatingNamingMaintainService implements NamingMaintainService , NacosServiceMetaData { private final NamingMaintainService delegate ; private final Properties properties ; DelegatingNamingMaintainService ( NamingMaintainService delegate , Properties properties ) { this . delegate = delegate ; this . properties = properties ; } @ Override public void updateInstance ( String serviceName , Instance instance ) throws NacosException { delegate . updateInstance ( serviceName , instance ) ; } @ Override public void updateInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . updateInstance ( serviceName , groupName , instance ) ; } @ Override public Service queryService ( String serviceName ) throws NacosException { return delegate . queryService ( serviceName ) ; } @ Override public Service queryService ( String serviceName , String groupName ) throws NacosException { return delegate . queryService ( serviceName , groupName ) ; } @ Override public void createService ( String serviceName ) throws NacosException { delegate . createService ( serviceName ) ; } @ Override public void createService ( String serviceName , String groupName ) throws NacosException { delegate . createService ( serviceName , groupName ) ; } @ Override public void createService ( String serviceName , String groupName , float protectThreshold ) throws NacosException { delegate . createService ( serviceName , groupName , protectThreshold ) ; } @ Override public void createService ( String serviceName , String groupName , float protectThreshold , String expression ) throws NacosException { delegate . createService ( serviceName , groupName , protectThreshold , expression ) ; } @ Override public void createService ( Service service , AbstractSelector selector ) throws NacosException { delegate . createService ( service , selector ) ; } @ Override public boolean deleteService ( String serviceName ) throws NacosException { return delegate . deleteService ( serviceName ) ; } @ Override public boolean deleteService ( String serviceName , String groupName ) throws NacosException { return delegate . deleteService ( serviceName , groupName ) ; } @ Override public void updateService ( String serviceName , String groupName , float protectThreshold ) throws NacosException { delegate . updateService ( serviceName , groupName , protectThreshold ) ; } @ Override public void updateService ( String serviceName , String groupName , float protectThreshold , Map < String , String > metadata ) throws NacosException { delegate", "gt": ". updateService ( serviceName , groupName , protectThreshold , metadata ) ;"}
{"input": "package io . github . chensheng . dddboot . web . config ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . github . chensheng . dddboot . web . core . CustomResponseBodyAdvice ; import io . github . chensheng . dddboot . web . core . CustomWebExceptionHandler ; import io . github . chensheng . dddboot . web . core . ResponseBodyDecorateCenter ; import io . github . chensheng . dddboot . web . core . SmartStringToDateConverter ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . web . servlet . WebMvcAutoConfiguration ; import org . springframework . context . ApplicationContext ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . converter . StringHttpMessageConverter ; import org . springframework . http . converter . json . Jackson2ObjectMapperBuilder ; import org . springframework . http . converter . json . MappingJackson2HttpMessageConverter ; import org . springframework . http . converter . xml . MappingJackson2XmlHttpMessageConverter ; import org . springframework . web . servlet . DispatcherServlet ; import java . nio . charset . Charset ; import java . text . SimpleDateFormat ; import java . util . TimeZone ; @ Configuration @ ConditionalOnClass ( { DispatcherServlet . class } )", "gt": "@ AutoConfigureBefore ( WebMvcAutoConfiguration . class ) public class CustomWebAutoConfiguration {"}
{"input": "package io . github . chensheng . dddboot . web . config ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . github . chensheng . dddboot . web . core . CustomResponseBodyAdvice ; import io . github . chensheng . dddboot . web . core . CustomWebExceptionHandler ; import io . github . chensheng . dddboot . web . core . ResponseBodyDecorateCenter ; import io . github . chensheng . dddboot . web . core . SmartStringToDateConverter ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . web . servlet . WebMvcAutoConfiguration ; import org . springframework . context . ApplicationContext ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . converter . StringHttpMessageConverter ; import org . springframework . http . converter . json . Jackson2ObjectMapperBuilder ; import org . springframework . http . converter . json . MappingJackson2HttpMessageConverter ; import org . springframework . http . converter . xml . MappingJackson2XmlHttpMessageConverter ; import org . springframework . web . servlet . DispatcherServlet ; import java . nio . charset . Charset ; import java . text . SimpleDateFormat ; import java . util . TimeZone ; @ Configuration @ ConditionalOnClass ( { DispatcherServlet . class } ) @ AutoConfigureBefore ( WebMvcAutoConfiguration . class ) public class CustomWebAutoConfiguration { @ Bean public CustomResponseBodyAdvice customResponseBodyAdvice ( ResponseBodyDecorateCenter responseBodyDecorateCenter ) { return new CustomResponseBodyAdvice ( responseBodyDecorateCenter ) ; } @ Bean public CustomWebExceptionHandler customWebExceptionHandler ( ) { return new CustomWebExceptionHandler ( ) ; } @ Bean public SmartStringToDateConverter smartStringToDateConverter ( ) { return new SmartStringToDateConverter ( ) ; } @ Bean public MappingJackson2HttpMessageConverter jsonConverter ( ) { Jackson2ObjectMapperBuilder", "gt": "builder = new Jackson2ObjectMapperBuilder ( ) . json ( ) . failOnUnknownProperties ( false ) . serializationInclusion ( JsonInclude . Include . NON_NULL ) . serializerByType ( Long . class , ToStringSerializer . instance ) . timeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) . dateFormat ( new SimpleDateFormat ( \"<STR_LIT>\" ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . EnumUtils ; import java . util . EnumSet ; public class EnumUtil { public static < E extends Enum < E > > long generateBits ( final Class < E > enumClass , final Iterable < ? extends E > values ) { return", "gt": "EnumUtils . generateBitVector ( enumClass , values ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Type ; import java . util . Date ; import java . util . Map ; public class DefaultJacksonEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( bodyType == MAP_STRING_WILDCARD ) { this . encodeForm ( object , bodyType , template ) ; return ; } String", "gt": "bodyTemplate = JsonMapper . nonNullMapper ( ) . toJson ( object ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Type ; import java . util . Date ; import java . util . Map ; public class DefaultJacksonEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( bodyType == MAP_STRING_WILDCARD ) { this . encodeForm ( object , bodyType , template ) ; return ; } String bodyTemplate = JsonMapper . nonNullMapper ( ) . toJson ( object ) ; template", "gt": ". body ( Request . Body . bodyTemplate ( bodyTemplate , Util . UTF_8 ) ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Type ; import java . util . Date ; import java . util . Map ; public class DefaultJacksonEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( bodyType == MAP_STRING_WILDCARD ) { this . encodeForm ( object , bodyType , template ) ; return ; } String bodyTemplate = JsonMapper . nonNullMapper ( ) . toJson ( object ) ; template . body ( Request . Body . bodyTemplate ( bodyTemplate , Util . UTF_8 ) ) ; } private void encodeForm ( Object object , Type bodyType , RequestTemplate template ) { if ( object == null || ! ( object instanceof Map ) ) { return ; } Map", "gt": "< String , Object > form = ( Map < String , Object > ) object ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Type ; import java . util . Date ; import java . util . Map ; public class DefaultJacksonEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( bodyType == MAP_STRING_WILDCARD ) { this . encodeForm ( object , bodyType , template ) ; return ; } String bodyTemplate = JsonMapper . nonNullMapper ( ) . toJson ( object ) ; template . body ( Request . Body . bodyTemplate ( bodyTemplate , Util . UTF_8 ) ) ; } private void encodeForm ( Object object , Type bodyType , RequestTemplate template ) { if ( object == null || ! ( object instanceof Map ) ) { return ; } Map < String , Object > form = ( Map < String , Object > ) object ; StringBuilder", "gt": "formBody = new StringBuilder ( ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Type ; import java . util . Date ; import java . util . Map ; public class DefaultJacksonEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( bodyType == MAP_STRING_WILDCARD ) { this . encodeForm ( object , bodyType , template ) ; return ; } String bodyTemplate = JsonMapper . nonNullMapper ( ) . toJson ( object ) ; template . body ( Request . Body . bodyTemplate ( bodyTemplate , Util . UTF_8 ) ) ; } private void encodeForm ( Object object , Type bodyType , RequestTemplate template ) { if ( object == null || ! ( object instanceof Map ) ) { return ; } Map < String , Object > form = ( Map < String , Object > ) object ; StringBuilder formBody = new StringBuilder ( ) ; for", "gt": "( Map . Entry < String , Object > entry : form . entrySet ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Type ; import java . util . Date ; import java . util . Map ; public class DefaultJacksonEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( bodyType == MAP_STRING_WILDCARD ) { this . encodeForm ( object , bodyType , template ) ; return ; } String bodyTemplate = JsonMapper . nonNullMapper ( ) . toJson ( object ) ; template . body ( Request . Body . bodyTemplate ( bodyTemplate , Util . UTF_8 ) ) ; } private void encodeForm ( Object object , Type bodyType , RequestTemplate template ) { if ( object == null || ! ( object instanceof Map ) ) { return ; } Map < String , Object > form = ( Map < String , Object > ) object ; StringBuilder formBody = new StringBuilder ( ) ; for ( Map . Entry < String , Object > entry : form . entrySet ( ) ) { String name = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value == null ) { continue ; } String valueStr ; if ( value instanceof Date ) { valueStr", "gt": "= DateFormatUtil . formatDate ( FORM_DATETIME_FORMAT , ( Date ) value ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Type ; import java . util . Date ; import java . util . Map ; public class DefaultJacksonEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( bodyType == MAP_STRING_WILDCARD ) { this . encodeForm ( object , bodyType , template ) ; return ; } String bodyTemplate = JsonMapper . nonNullMapper ( ) . toJson ( object ) ; template . body ( Request . Body . bodyTemplate ( bodyTemplate , Util . UTF_8 ) ) ; } private void encodeForm ( Object object , Type bodyType , RequestTemplate template ) { if ( object == null || ! ( object instanceof Map ) ) { return ; } Map < String , Object > form = ( Map < String , Object > ) object ; StringBuilder formBody = new StringBuilder ( ) ; for ( Map . Entry < String , Object > entry : form . entrySet ( ) ) { String name = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value == null ) { continue ; } String valueStr ; if ( value instanceof Date ) { valueStr = DateFormatUtil . formatDate ( FORM_DATETIME_FORMAT , ( Date ) value ) ; } else { valueStr", "gt": "= String . valueOf ( value ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Type ; import java . util . Date ; import java . util . Map ; public class DefaultJacksonEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( bodyType == MAP_STRING_WILDCARD ) { this . encodeForm ( object , bodyType , template ) ; return ; } String bodyTemplate = JsonMapper . nonNullMapper ( ) . toJson ( object ) ; template . body ( Request . Body . bodyTemplate ( bodyTemplate , Util . UTF_8 ) ) ; } private void encodeForm ( Object object , Type bodyType , RequestTemplate template ) { if ( object == null || ! ( object instanceof Map ) ) { return ; } Map < String , Object > form = ( Map < String , Object > ) object ; StringBuilder formBody = new StringBuilder ( ) ; for ( Map . Entry < String , Object > entry : form . entrySet ( ) ) { String name = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value == null ) { continue ; } String valueStr ; if ( value instanceof Date ) { valueStr = DateFormatUtil . formatDate ( FORM_DATETIME_FORMAT , ( Date ) value ) ; } else { valueStr = String . valueOf ( value ) ; } formBody", "gt": ". append ( name ) . append ( \"<STR_LIT>\" ) . append ( valueStr ) . append ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Type ; import java . util . Date ; import java . util . Map ; public class DefaultJacksonEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( bodyType == MAP_STRING_WILDCARD ) { this . encodeForm ( object , bodyType , template ) ; return ; } String bodyTemplate = JsonMapper . nonNullMapper ( ) . toJson ( object ) ; template . body ( Request . Body . bodyTemplate ( bodyTemplate , Util . UTF_8 ) ) ; } private void encodeForm ( Object object , Type bodyType , RequestTemplate template ) { if ( object == null || ! ( object instanceof Map ) ) { return ; } Map < String , Object > form = ( Map < String , Object > ) object ; StringBuilder formBody = new StringBuilder ( ) ; for ( Map . Entry < String , Object > entry : form . entrySet ( ) ) { String name = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value == null ) { continue ; } String valueStr ; if ( value instanceof Date ) { valueStr = DateFormatUtil . formatDate ( FORM_DATETIME_FORMAT , ( Date ) value ) ; } else { valueStr = String . valueOf ( value ) ; } formBody . append ( name ) . append ( \"<STR_LIT>\" ) . append ( valueStr ) . append ( \"<STR_LIT>\" ) ; } template", "gt": ". body ( Request . Body . bodyTemplate ( formBody . toString ( ) , Util . UTF_8 ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return", "gt": "Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return", "gt": "Ints . toByteArray ( value ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return", "gt": "toBytes ( Double . doubleToRawLongBits ( val ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return", "gt": "Ints . fromByteArray ( bytes ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return", "gt": "Double . longBitsToDouble ( toLong ( bytes ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return", "gt": "NumberUtils . isCreatable ( str ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if", "gt": "( StringUtils . isEmpty ( value ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if ( StringUtils . isEmpty ( value ) ) { return false ; } int", "gt": "index = value . startsWith ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if ( StringUtils . isEmpty ( value ) ) { return false ; } int index = value . startsWith ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; return", "gt": "value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if ( StringUtils . isEmpty ( value ) ) { return false ; } int index = value . startsWith ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; return value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) ; } public static int toInt ( @ NotNull String str ) { return", "gt": "Integer . parseInt ( str ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if ( StringUtils . isEmpty ( value ) ) { return false ; } int index = value . startsWith ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; return value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) ; } public static int toInt ( @ NotNull String str ) { return Integer . parseInt ( str ) ; } public static int toInt ( @ Nullable String str , int defaultValue ) { return NumberUtils . toInt ( str , defaultValue ) ; } public static long toLong ( @ NotNull String str ) { return Long . parseLong ( str ) ; } public static long toLong ( @ Nullable String str , long defaultValue ) { return NumberUtils . toLong ( str , defaultValue ) ; } public static double toDouble ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . parseDouble ( str ) ; } public static double toDouble ( @ Nullable String str , double defaultValue ) { return NumberUtils . toDouble ( str , defaultValue ) ; } public static Integer toIntObject ( @ NotNull String str ) { return", "gt": "Integer . valueOf ( str ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if ( StringUtils . isEmpty ( value ) ) { return false ; } int index = value . startsWith ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; return value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) ; } public static int toInt ( @ NotNull String str ) { return Integer . parseInt ( str ) ; } public static int toInt ( @ Nullable String str , int defaultValue ) { return NumberUtils . toInt ( str , defaultValue ) ; } public static long toLong ( @ NotNull String str ) { return Long . parseLong ( str ) ; } public static long toLong ( @ Nullable String str , long defaultValue ) { return NumberUtils . toLong ( str , defaultValue ) ; } public static double toDouble ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . parseDouble ( str ) ; } public static double toDouble ( @ Nullable String str , double defaultValue ) { return NumberUtils . toDouble ( str , defaultValue ) ; } public static Integer toIntObject ( @ NotNull String str ) { return Integer . valueOf ( str ) ; } public static Integer toIntObject ( @ Nullable String str , Integer defaultValue ) { if", "gt": "( StringUtils . isEmpty ( str ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if ( StringUtils . isEmpty ( value ) ) { return false ; } int index = value . startsWith ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; return value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) ; } public static int toInt ( @ NotNull String str ) { return Integer . parseInt ( str ) ; } public static int toInt ( @ Nullable String str , int defaultValue ) { return NumberUtils . toInt ( str , defaultValue ) ; } public static long toLong ( @ NotNull String str ) { return Long . parseLong ( str ) ; } public static long toLong ( @ Nullable String str , long defaultValue ) { return NumberUtils . toLong ( str , defaultValue ) ; } public static double toDouble ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . parseDouble ( str ) ; } public static double toDouble ( @ Nullable String str , double defaultValue ) { return NumberUtils . toDouble ( str , defaultValue ) ; } public static Integer toIntObject ( @ NotNull String str ) { return Integer . valueOf ( str ) ; } public static Integer toIntObject ( @ Nullable String str , Integer defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Integer . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Long toLongObject ( @ NotNull String str ) { return Long . valueOf ( str ) ; } public static Long toLongObject ( @ Nullable String str , Long defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Long . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Double toDoubleObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . valueOf ( str ) ; } public static Double toDoubleObject ( @ Nullable String str , Double defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Double . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Integer hexToIntObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return", "gt": "Integer . decode ( str ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if ( StringUtils . isEmpty ( value ) ) { return false ; } int index = value . startsWith ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; return value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) ; } public static int toInt ( @ NotNull String str ) { return Integer . parseInt ( str ) ; } public static int toInt ( @ Nullable String str , int defaultValue ) { return NumberUtils . toInt ( str , defaultValue ) ; } public static long toLong ( @ NotNull String str ) { return Long . parseLong ( str ) ; } public static long toLong ( @ Nullable String str , long defaultValue ) { return NumberUtils . toLong ( str , defaultValue ) ; } public static double toDouble ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . parseDouble ( str ) ; } public static double toDouble ( @ Nullable String str , double defaultValue ) { return NumberUtils . toDouble ( str , defaultValue ) ; } public static Integer toIntObject ( @ NotNull String str ) { return Integer . valueOf ( str ) ; } public static Integer toIntObject ( @ Nullable String str , Integer defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Integer . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Long toLongObject ( @ NotNull String str ) { return Long . valueOf ( str ) ; } public static Long toLongObject ( @ Nullable String str , Long defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Long . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Double toDoubleObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . valueOf ( str ) ; } public static Double toDoubleObject ( @ Nullable String str , Double defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Double . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Integer hexToIntObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Integer . decode ( str ) ; } public static Integer hexToIntObject ( @ Nullable String str , Integer defaultValue ) { if", "gt": "( StringUtils . isEmpty ( str ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if ( StringUtils . isEmpty ( value ) ) { return false ; } int index = value . startsWith ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; return value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) ; } public static int toInt ( @ NotNull String str ) { return Integer . parseInt ( str ) ; } public static int toInt ( @ Nullable String str , int defaultValue ) { return NumberUtils . toInt ( str , defaultValue ) ; } public static long toLong ( @ NotNull String str ) { return Long . parseLong ( str ) ; } public static long toLong ( @ Nullable String str , long defaultValue ) { return NumberUtils . toLong ( str , defaultValue ) ; } public static double toDouble ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . parseDouble ( str ) ; } public static double toDouble ( @ Nullable String str , double defaultValue ) { return NumberUtils . toDouble ( str , defaultValue ) ; } public static Integer toIntObject ( @ NotNull String str ) { return Integer . valueOf ( str ) ; } public static Integer toIntObject ( @ Nullable String str , Integer defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Integer . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Long toLongObject ( @ NotNull String str ) { return Long . valueOf ( str ) ; } public static Long toLongObject ( @ Nullable String str , Long defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Long . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Double toDoubleObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . valueOf ( str ) ; } public static Double toDoubleObject ( @ Nullable String str , Double defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Double . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Integer hexToIntObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Integer . decode ( str ) ; } public static Integer hexToIntObject ( @ Nullable String str , Integer defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return", "gt": "Integer . decode ( str ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if ( StringUtils . isEmpty ( value ) ) { return false ; } int index = value . startsWith ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; return value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) ; } public static int toInt ( @ NotNull String str ) { return Integer . parseInt ( str ) ; } public static int toInt ( @ Nullable String str , int defaultValue ) { return NumberUtils . toInt ( str , defaultValue ) ; } public static long toLong ( @ NotNull String str ) { return Long . parseLong ( str ) ; } public static long toLong ( @ Nullable String str , long defaultValue ) { return NumberUtils . toLong ( str , defaultValue ) ; } public static double toDouble ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . parseDouble ( str ) ; } public static double toDouble ( @ Nullable String str , double defaultValue ) { return NumberUtils . toDouble ( str , defaultValue ) ; } public static Integer toIntObject ( @ NotNull String str ) { return Integer . valueOf ( str ) ; } public static Integer toIntObject ( @ Nullable String str , Integer defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Integer . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Long toLongObject ( @ NotNull String str ) { return Long . valueOf ( str ) ; } public static Long toLongObject ( @ Nullable String str , Long defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Long . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Double toDoubleObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . valueOf ( str ) ; } public static Double toDoubleObject ( @ Nullable String str , Double defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Double . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Integer hexToIntObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Integer . decode ( str ) ; } public static Integer hexToIntObject ( @ Nullable String str , Integer defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Integer . decode ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Long hexToLongObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Long . decode ( str ) ; } public static Long hexToLongObject ( @ Nullable String str , Long defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return", "gt": "Long . decode ( str ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if ( StringUtils . isEmpty ( value ) ) { return false ; } int index = value . startsWith ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; return value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) ; } public static int toInt ( @ NotNull String str ) { return Integer . parseInt ( str ) ; } public static int toInt ( @ Nullable String str , int defaultValue ) { return NumberUtils . toInt ( str , defaultValue ) ; } public static long toLong ( @ NotNull String str ) { return Long . parseLong ( str ) ; } public static long toLong ( @ Nullable String str , long defaultValue ) { return NumberUtils . toLong ( str , defaultValue ) ; } public static double toDouble ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . parseDouble ( str ) ; } public static double toDouble ( @ Nullable String str , double defaultValue ) { return NumberUtils . toDouble ( str , defaultValue ) ; } public static Integer toIntObject ( @ NotNull String str ) { return Integer . valueOf ( str ) ; } public static Integer toIntObject ( @ Nullable String str , Integer defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Integer . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Long toLongObject ( @ NotNull String str ) { return Long . valueOf ( str ) ; } public static Long toLongObject ( @ Nullable String str , Long defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Long . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Double toDoubleObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . valueOf ( str ) ; } public static Double toDoubleObject ( @ Nullable String str , Double defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Double . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Integer hexToIntObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Integer . decode ( str ) ; } public static Integer hexToIntObject ( @ Nullable String str , Integer defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Integer . decode ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Long hexToLongObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Long . decode ( str ) ; } public static Long hexToLongObject ( @ Nullable String str , Long defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Long . decode ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static String toString ( int i ) { return Integer . toString ( i ) ; } public static String toString ( @ NotNull Integer i ) { return i . toString ( ) ; } public static String toString ( long l ) { return Long . toString ( l ) ; } public static String toString ( @ NotNull Long l ) { return l . toString ( ) ; } public static String toString ( double d ) { return Double . toString ( d ) ; } public static String toString ( @ NotNull Double d ) { return d . toString ( ) ; } public static String to2DigitString ( double d ) { return", "gt": "String . format ( Locale . ROOT , \"<STR_LIT>\" , d ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . math . NumberUtils ; import java . util . Locale ; public class NumberUtil { private static final double DEFAULT_DOUBLE_EPSILON = <NUM_LIT> ; public static boolean equalsWithin ( double d1 , double d2 ) { return Math . abs ( d1 - d2 ) < DEFAULT_DOUBLE_EPSILON ; } public static boolean equalsWithin ( double d1 , double d2 , double epsilon ) { return Math . abs ( d1 - d2 ) < epsilon ; } public static byte [ ] toBytes ( int value ) { return Ints . toByteArray ( value ) ; } public static byte [ ] toBytes ( long value ) { return Longs . toByteArray ( value ) ; } public static byte [ ] toBytes ( double val ) { return toBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static int toInt ( byte [ ] bytes ) { return Ints . fromByteArray ( bytes ) ; } public static long toLong ( byte [ ] bytes ) { return Longs . fromByteArray ( bytes ) ; } public static double toDouble ( byte [ ] bytes ) { return Double . longBitsToDouble ( toLong ( bytes ) ) ; } public static boolean isNumber ( @ Nullable String str ) { return NumberUtils . isCreatable ( str ) ; } public static boolean isHexNumber ( @ Nullable String value ) { if ( StringUtils . isEmpty ( value ) ) { return false ; } int index = value . startsWith ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; return value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) || value . startsWith ( \"<STR_LIT>\" , index ) ; } public static int toInt ( @ NotNull String str ) { return Integer . parseInt ( str ) ; } public static int toInt ( @ Nullable String str , int defaultValue ) { return NumberUtils . toInt ( str , defaultValue ) ; } public static long toLong ( @ NotNull String str ) { return Long . parseLong ( str ) ; } public static long toLong ( @ Nullable String str , long defaultValue ) { return NumberUtils . toLong ( str , defaultValue ) ; } public static double toDouble ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . parseDouble ( str ) ; } public static double toDouble ( @ Nullable String str , double defaultValue ) { return NumberUtils . toDouble ( str , defaultValue ) ; } public static Integer toIntObject ( @ NotNull String str ) { return Integer . valueOf ( str ) ; } public static Integer toIntObject ( @ Nullable String str , Integer defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Integer . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Long toLongObject ( @ NotNull String str ) { return Long . valueOf ( str ) ; } public static Long toLongObject ( @ Nullable String str , Long defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Long . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Double toDoubleObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Double . valueOf ( str ) ; } public static Double toDoubleObject ( @ Nullable String str , Double defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Double . valueOf ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Integer hexToIntObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Integer . decode ( str ) ; } public static Integer hexToIntObject ( @ Nullable String str , Integer defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Integer . decode ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static Long hexToLongObject ( @ NotNull String str ) { if ( str == null ) { throw new NumberFormatException ( \"<STR_LIT>\" ) ; } return Long . decode ( str ) ; } public static Long hexToLongObject ( @ Nullable String str , Long defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } try { return Long . decode ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static String toString ( int i ) { return Integer . toString ( i ) ; } public static String toString ( @ NotNull Integer i ) { return i . toString ( ) ; } public static String toString ( long l ) { return Long . toString ( l ) ; } public static String toString ( @ NotNull Long l ) { return l . toString ( ) ; } public static String toString ( double d ) { return Double . toString ( d ) ; } public static String toString ( @ NotNull Double d ) { return d . toString ( ) ; } public static String to2DigitString ( double d ) { return String . format ( Locale . ROOT , \"<STR_LIT>\" , d ) ; } public static int toInt32 ( long x ) { if", "gt": "( ( int ) x == x ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class MoreValidate extends org . apache . commons . lang3 . Validate { public static int positive ( @ Nullable String role , int x ) { if ( x <= <NUM_LIT> ) { throw", "gt": "new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class MoreValidate extends org . apache . commons . lang3 . Validate { public static int positive ( @ Nullable String role , int x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer positive ( @ Nullable String role , Integer x ) { if ( x . intValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static long positive ( @ Nullable String role , long x ) { if ( x <= <NUM_LIT> ) { throw", "gt": "new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class MoreValidate extends org . apache . commons . lang3 . Validate { public static int positive ( @ Nullable String role , int x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer positive ( @ Nullable String role , Integer x ) { if ( x . intValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static long positive ( @ Nullable String role , long x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Long positive ( @ Nullable String role , Long x ) { if", "gt": "( x . longValue ( ) <= <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class MoreValidate extends org . apache . commons . lang3 . Validate { public static int positive ( @ Nullable String role , int x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer positive ( @ Nullable String role , Integer x ) { if ( x . intValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static long positive ( @ Nullable String role , long x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Long positive ( @ Nullable String role , Long x ) { if ( x . longValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static double positive ( @ Nullable String role , double x ) { if", "gt": "( ! ( x > <NUM_LIT> ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class MoreValidate extends org . apache . commons . lang3 . Validate { public static int positive ( @ Nullable String role , int x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer positive ( @ Nullable String role , Integer x ) { if ( x . intValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static long positive ( @ Nullable String role , long x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Long positive ( @ Nullable String role , Long x ) { if ( x . longValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static double positive ( @ Nullable String role , double x ) { if ( ! ( x > <NUM_LIT> ) ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static int nonNegative ( @ Nullable String role , int x ) { if ( x < <NUM_LIT> ) { throw", "gt": "new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class MoreValidate extends org . apache . commons . lang3 . Validate { public static int positive ( @ Nullable String role , int x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer positive ( @ Nullable String role , Integer x ) { if ( x . intValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static long positive ( @ Nullable String role , long x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Long positive ( @ Nullable String role , Long x ) { if ( x . longValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static double positive ( @ Nullable String role , double x ) { if ( ! ( x > <NUM_LIT> ) ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static int nonNegative ( @ Nullable String role , int x ) { if ( x < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer nonNegative ( @ Nullable String role , Integer x ) { if", "gt": "( x . intValue ( ) < <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class MoreValidate extends org . apache . commons . lang3 . Validate { public static int positive ( @ Nullable String role , int x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer positive ( @ Nullable String role , Integer x ) { if ( x . intValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static long positive ( @ Nullable String role , long x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Long positive ( @ Nullable String role , Long x ) { if ( x . longValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static double positive ( @ Nullable String role , double x ) { if ( ! ( x > <NUM_LIT> ) ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static int nonNegative ( @ Nullable String role , int x ) { if ( x < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer nonNegative ( @ Nullable String role , Integer x ) { if ( x . intValue ( ) < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static long nonNegative ( @ Nullable String role , long x ) { if ( x < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Long nonNegative ( @ Nullable String role , Long x ) { if", "gt": "( x . longValue ( ) < <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class MoreValidate extends org . apache . commons . lang3 . Validate { public static int positive ( @ Nullable String role , int x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer positive ( @ Nullable String role , Integer x ) { if ( x . intValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static long positive ( @ Nullable String role , long x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Long positive ( @ Nullable String role , Long x ) { if ( x . longValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static double positive ( @ Nullable String role , double x ) { if ( ! ( x > <NUM_LIT> ) ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static int nonNegative ( @ Nullable String role , int x ) { if ( x < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer nonNegative ( @ Nullable String role , Integer x ) { if ( x . intValue ( ) < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static long nonNegative ( @ Nullable String role , long x ) { if ( x < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Long nonNegative ( @ Nullable String role , Long x ) { if ( x . longValue ( ) < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static double nonNegative ( @ Nullable String role , double x ) { if", "gt": "( ! ( x >= <NUM_LIT> ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class MoreValidate extends org . apache . commons . lang3 . Validate { public static int positive ( @ Nullable String role , int x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer positive ( @ Nullable String role , Integer x ) { if ( x . intValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static long positive ( @ Nullable String role , long x ) { if ( x <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Long positive ( @ Nullable String role , Long x ) { if ( x . longValue ( ) <= <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static double positive ( @ Nullable String role , double x ) { if ( ! ( x > <NUM_LIT> ) ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static int nonNegative ( @ Nullable String role , int x ) { if ( x < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Integer nonNegative ( @ Nullable String role , Integer x ) { if ( x . intValue ( ) < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static long nonNegative ( @ Nullable String role , long x ) { if ( x < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static Long nonNegative ( @ Nullable String role , Long x ) { if ( x . longValue ( ) < <NUM_LIT> ) { throw new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ; } return x ; } public static double nonNegative ( @ Nullable String role , double x ) { if ( ! ( x >= <NUM_LIT> ) ) { throw", "gt": "new IllegalArgumentException ( role + \"<STR_LIT>\" + x + \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . Iterator ; import java . util . Map ; public interface LongObjectMap < V > extends Map < Long , V > { interface PrimitiveEntry < V > { long key ( ) ; V value ( ) ; void setValue ( V value ) ; } V get ( long key ) ; V", "gt": "put ( long key , V value ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT>", "gt": ", <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> }"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return", "gt": "DateUtils . isSameDay ( date1 , date2 ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if", "gt": "( date == null || start == null || end == null || start . after ( end ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return", "gt": "DateUtils . addMonths ( date , - amount ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return", "gt": "DateUtils . addWeeks ( date , - amount ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return", "gt": "DateUtils . addDays ( date , - amount ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return", "gt": "DateUtils . addHours ( date , amount ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return", "gt": "DateUtils . addHours ( date , - amount ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return", "gt": "DateUtils . addMinutes ( date , amount ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return", "gt": "DateUtils . addMinutes ( date , - amount ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return", "gt": "DateUtils . addSeconds ( date , - amount ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if", "gt": "( amount < <NUM_LIT> || amount > <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return", "gt": "DateUtils . setMonths ( date , amount - <NUM_LIT> ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return", "gt": "DateUtils . setHours ( date , amount ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return", "gt": "DateUtils . setMinutes ( date , amount ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return", "gt": "DateUtils . setSeconds ( date , amount ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int", "gt": "result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return", "gt": "getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return", "gt": "getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate", "gt": ". notNull ( date , \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar", "gt": "cal = Calendar . getInstance ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal", "gt": ". setFirstDayOfWeek ( Calendar . MONDAY ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return", "gt": "cal . get ( field ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return", "gt": "new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return", "gt": "new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return", "gt": "DateUtils . ceiling ( date , Calendar . MONTH ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return", "gt": "DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return", "gt": "new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return", "gt": "DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ; } public static Date beginOfDate ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . DATE ) ; } public static Date endOfDate ( @ NotNull final Date date ) { return", "gt": "new Date ( nextDate ( date ) . getTime ( ) - <NUM_LIT> ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ; } public static Date beginOfDate ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . DATE ) ; } public static Date endOfDate ( @ NotNull final Date date ) { return new Date ( nextDate ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextDate ( @ NotNull final Date date ) { return", "gt": "DateUtils . ceiling ( date , Calendar . DATE ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ; } public static Date beginOfDate ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . DATE ) ; } public static Date endOfDate ( @ NotNull final Date date ) { return new Date ( nextDate ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextDate ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . DATE ) ; } public static Date beginOfHour ( @ NotNull final Date date ) { return", "gt": "DateUtils . truncate ( date , Calendar . HOUR_OF_DAY ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ; } public static Date beginOfDate ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . DATE ) ; } public static Date endOfDate ( @ NotNull final Date date ) { return new Date ( nextDate ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextDate ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . DATE ) ; } public static Date beginOfHour ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . HOUR_OF_DAY ) ; } public static Date endOfHour ( @ NotNull final Date date ) { return", "gt": "new Date ( nextHour ( date ) . getTime ( ) - <NUM_LIT> ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ; } public static Date beginOfDate ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . DATE ) ; } public static Date endOfDate ( @ NotNull final Date date ) { return new Date ( nextDate ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextDate ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . DATE ) ; } public static Date beginOfHour ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . HOUR_OF_DAY ) ; } public static Date endOfHour ( @ NotNull final Date date ) { return new Date ( nextHour ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextHour ( @ NotNull final Date date ) { return", "gt": "DateUtils . ceiling ( date , Calendar . HOUR_OF_DAY ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ; } public static Date beginOfDate ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . DATE ) ; } public static Date endOfDate ( @ NotNull final Date date ) { return new Date ( nextDate ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextDate ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . DATE ) ; } public static Date beginOfHour ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . HOUR_OF_DAY ) ; } public static Date endOfHour ( @ NotNull final Date date ) { return new Date ( nextHour ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextHour ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . HOUR_OF_DAY ) ; } public static Date beginOfMinute ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MINUTE ) ; } public static Date endOfMinute ( @ NotNull final Date date ) { return new Date ( nextMinute ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMinute ( @ NotNull final Date date ) { return", "gt": "DateUtils . ceiling ( date , Calendar . MINUTE ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ; } public static Date beginOfDate ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . DATE ) ; } public static Date endOfDate ( @ NotNull final Date date ) { return new Date ( nextDate ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextDate ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . DATE ) ; } public static Date beginOfHour ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . HOUR_OF_DAY ) ; } public static Date endOfHour ( @ NotNull final Date date ) { return new Date ( nextHour ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextHour ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . HOUR_OF_DAY ) ; } public static Date beginOfMinute ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MINUTE ) ; } public static Date endOfMinute ( @ NotNull final Date date ) { return new Date ( nextMinute ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMinute ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MINUTE ) ; } public static boolean isLeapYear ( @ NotNull final Date date ) { return", "gt": "isLeapYear ( get ( date , Calendar . YEAR ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ; } public static Date beginOfDate ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . DATE ) ; } public static Date endOfDate ( @ NotNull final Date date ) { return new Date ( nextDate ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextDate ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . DATE ) ; } public static Date beginOfHour ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . HOUR_OF_DAY ) ; } public static Date endOfHour ( @ NotNull final Date date ) { return new Date ( nextHour ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextHour ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . HOUR_OF_DAY ) ; } public static Date beginOfMinute ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MINUTE ) ; } public static Date endOfMinute ( @ NotNull final Date date ) { return new Date ( nextMinute ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMinute ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MINUTE ) ; } public static boolean isLeapYear ( @ NotNull final Date date ) { return isLeapYear ( get ( date , Calendar . YEAR ) ) ; } public static boolean isLeapYear ( int y ) { boolean result = false ; if ( ( ( y % <NUM_LIT> ) == <NUM_LIT> ) && ( ( y < <NUM_LIT> ) || ( ( y % <NUM_LIT> ) != <NUM_LIT> ) || ( ( y % <NUM_LIT> ) == <NUM_LIT> ) ) ) { result = true ; } return result ; } public static int getMonthLength ( @ NotNull final Date date ) { int year = get ( date , Calendar . YEAR ) ; int", "gt": "month = get ( date , Calendar . MONTH ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ; } public static Date beginOfDate ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . DATE ) ; } public static Date endOfDate ( @ NotNull final Date date ) { return new Date ( nextDate ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextDate ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . DATE ) ; } public static Date beginOfHour ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . HOUR_OF_DAY ) ; } public static Date endOfHour ( @ NotNull final Date date ) { return new Date ( nextHour ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextHour ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . HOUR_OF_DAY ) ; } public static Date beginOfMinute ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MINUTE ) ; } public static Date endOfMinute ( @ NotNull final Date date ) { return new Date ( nextMinute ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMinute ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MINUTE ) ; } public static boolean isLeapYear ( @ NotNull final Date date ) { return isLeapYear ( get ( date , Calendar . YEAR ) ) ; } public static boolean isLeapYear ( int y ) { boolean result = false ; if ( ( ( y % <NUM_LIT> ) == <NUM_LIT> ) && ( ( y < <NUM_LIT> ) || ( ( y % <NUM_LIT> ) != <NUM_LIT> ) || ( ( y % <NUM_LIT> ) == <NUM_LIT> ) ) ) { result = true ; } return result ; } public static int getMonthLength ( @ NotNull final Date date ) { int year = get ( date , Calendar . YEAR ) ; int month = get ( date , Calendar . MONTH ) ; return", "gt": "getMonthLength ( year , month ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ; } public static Date beginOfDate ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . DATE ) ; } public static Date endOfDate ( @ NotNull final Date date ) { return new Date ( nextDate ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextDate ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . DATE ) ; } public static Date beginOfHour ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . HOUR_OF_DAY ) ; } public static Date endOfHour ( @ NotNull final Date date ) { return new Date ( nextHour ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextHour ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . HOUR_OF_DAY ) ; } public static Date beginOfMinute ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MINUTE ) ; } public static Date endOfMinute ( @ NotNull final Date date ) { return new Date ( nextMinute ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMinute ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MINUTE ) ; } public static boolean isLeapYear ( @ NotNull final Date date ) { return isLeapYear ( get ( date , Calendar . YEAR ) ) ; } public static boolean isLeapYear ( int y ) { boolean result = false ; if ( ( ( y % <NUM_LIT> ) == <NUM_LIT> ) && ( ( y < <NUM_LIT> ) || ( ( y % <NUM_LIT> ) != <NUM_LIT> ) || ( ( y % <NUM_LIT> ) == <NUM_LIT> ) ) ) { result = true ; } return result ; } public static int getMonthLength ( @ NotNull final Date date ) { int year = get ( date , Calendar . YEAR ) ; int month = get ( date , Calendar . MONTH ) ; return getMonthLength ( year , month ) ; } public static int getMonthLength ( int year , int month ) { if", "gt": "( ( month < <NUM_LIT> ) || ( month > <NUM_LIT> ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . time . DateUtils ; import java . util . Calendar ; import java . util . Date ; public class DateUtil { public static final long MILLIS_PER_SECOND = <NUM_LIT> ; public static final long MILLIS_PER_MINUTE = <NUM_LIT> * MILLIS_PER_SECOND ; public static final long MILLIS_PER_HOUR = <NUM_LIT> * MILLIS_PER_MINUTE ; public static final long MILLIS_PER_DAY = <NUM_LIT> * MILLIS_PER_HOUR ; private static final int [ ] MONTH_LENGTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static boolean isSameDay ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return DateUtils . isSameDay ( date1 , date2 ) ; } public static boolean isSameTime ( @ NotNull final Date date1 , @ NotNull final Date date2 ) { return date1 . compareTo ( date2 ) == <NUM_LIT> ; } public static boolean isBetween ( @ NotNull final Date date , @ NotNull final Date start , @ NotNull final Date end ) { if ( date == null || start == null || end == null || start . after ( end ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ! date . before ( start ) && ! date . after ( end ) ; } public static Date addMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , amount ) ; } public static Date subMonths ( @ NotNull final Date date , int amount ) { return DateUtils . addMonths ( date , - amount ) ; } public static Date addWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , amount ) ; } public static Date subWeeks ( @ NotNull final Date date , int amount ) { return DateUtils . addWeeks ( date , - amount ) ; } public static Date addDays ( @ NotNull final Date date , final int amount ) { return DateUtils . addDays ( date , amount ) ; } public static Date subDays ( @ NotNull final Date date , int amount ) { return DateUtils . addDays ( date , - amount ) ; } public static Date addHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , amount ) ; } public static Date subHours ( @ NotNull final Date date , int amount ) { return DateUtils . addHours ( date , - amount ) ; } public static Date addMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , amount ) ; } public static Date subMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . addMinutes ( date , - amount ) ; } public static Date addSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , amount ) ; } public static Date subSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . addSeconds ( date , - amount ) ; } public static Date setYears ( @ NotNull final Date date , int amount ) { return DateUtils . setYears ( date , amount ) ; } public static Date setMonths ( @ NotNull final Date date , int amount ) { if ( amount < <NUM_LIT> || amount > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return DateUtils . setMonths ( date , amount - <NUM_LIT> ) ; } public static Date setDays ( @ NotNull final Date date , int amount ) { return DateUtils . setDays ( date , amount ) ; } public static Date setHours ( @ NotNull final Date date , int amount ) { return DateUtils . setHours ( date , amount ) ; } public static Date setMinutes ( @ NotNull final Date date , int amount ) { return DateUtils . setMinutes ( date , amount ) ; } public static Date setSeconds ( @ NotNull final Date date , int amount ) { return DateUtils . setSeconds ( date , amount ) ; } public static Date setMilliseconds ( @ NotNull final Date date , int amount ) { return DateUtils . setMilliseconds ( date , amount ) ; } public static int getDayOfWeek ( @ NotNull final Date date ) { int result = getWithMondayFirst ( date , Calendar . DAY_OF_WEEK ) ; return result == <NUM_LIT> ? <NUM_LIT> : result - <NUM_LIT> ; } public static int getDayOfYear ( @ NotNull final Date date ) { return get ( date , Calendar . DAY_OF_YEAR ) ; } public static int getWeekOfMonth ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_MONTH ) ; } public static int getWeekOfYear ( @ NotNull final Date date ) { return getWithMondayFirst ( date , Calendar . WEEK_OF_YEAR ) ; } private static int get ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } private static int getWithMondayFirst ( final Date date , int field ) { Validate . notNull ( date , \"<STR_LIT>\" ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; cal . setTime ( date ) ; return cal . get ( field ) ; } public static Date beginOfYear ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . YEAR ) ; } public static Date endOfYear ( @ NotNull final Date date ) { return new Date ( nextYear ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextYear ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . YEAR ) ; } public static Date beginOfMonth ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MONTH ) ; } public static Date endOfMonth ( @ NotNull final Date date ) { return new Date ( nextMonth ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMonth ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MONTH ) ; } public static Date beginOfWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . subDays ( date , DateUtil . getDayOfWeek ( date ) - <NUM_LIT> ) , Calendar . DATE ) ; } public static Date endOfWeek ( @ NotNull final Date date ) { return new Date ( nextWeek ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextWeek ( @ NotNull final Date date ) { return DateUtils . truncate ( DateUtil . addDays ( date , <NUM_LIT> - DateUtil . getDayOfWeek ( date ) ) , Calendar . DATE ) ; } public static Date beginOfDate ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . DATE ) ; } public static Date endOfDate ( @ NotNull final Date date ) { return new Date ( nextDate ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextDate ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . DATE ) ; } public static Date beginOfHour ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . HOUR_OF_DAY ) ; } public static Date endOfHour ( @ NotNull final Date date ) { return new Date ( nextHour ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextHour ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . HOUR_OF_DAY ) ; } public static Date beginOfMinute ( @ NotNull final Date date ) { return DateUtils . truncate ( date , Calendar . MINUTE ) ; } public static Date endOfMinute ( @ NotNull final Date date ) { return new Date ( nextMinute ( date ) . getTime ( ) - <NUM_LIT> ) ; } public static Date nextMinute ( @ NotNull final Date date ) { return DateUtils . ceiling ( date , Calendar . MINUTE ) ; } public static boolean isLeapYear ( @ NotNull final Date date ) { return isLeapYear ( get ( date , Calendar . YEAR ) ) ; } public static boolean isLeapYear ( int y ) { boolean result = false ; if ( ( ( y % <NUM_LIT> ) == <NUM_LIT> ) && ( ( y < <NUM_LIT> ) || ( ( y % <NUM_LIT> ) != <NUM_LIT> ) || ( ( y % <NUM_LIT> ) == <NUM_LIT> ) ) ) { result = true ; } return result ; } public static int getMonthLength ( @ NotNull final Date date ) { int year = get ( date , Calendar . YEAR ) ; int month = get ( date , Calendar . MONTH ) ; return getMonthLength ( year , month ) ; } public static int getMonthLength ( int year , int month ) { if ( ( month < <NUM_LIT> ) || ( month > <NUM_LIT> ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + month ) ; } if ( month == <NUM_LIT> ) { return", "gt": "isLeapYear ( year ) ? <NUM_LIT> : <NUM_LIT> ;"}
