{"input": "import django <EOL> if django . __version__ . split ( '<STR_LIT>' ) [ <NUM_LIT> ] >= '<STR_LIT>' : <EOL> from django . urls import re_path as url <EOL> else : <EOL> from django . conf . urls import url , include <EOL> from api import views <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , views . login ) , <EOL> url ( r'<STR_LIT>' , views . logout ) , <EOL> url ( r'<STR_LIT>' , views . ab ) , <EOL> url ( r'<STR_LIT>' , views . ab_get ) , <EOL> url ( r'<STR_LIT>' , views . users ) , <EOL> url ( r'<STR_LIT>' , views . peers ) , <EOL> url ( r'<STR_LIT>' , views . currentUser ) , <EOL> url", "gt": "( r'<STR_LIT>' , views . sysinfo ) ,", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> (", "gt": "_ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) ,", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> ( _ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) , <EOL> ) <EOL> readonly_fields = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> add_fieldsets = ( <EOL> ( None , { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } <EOL> ) , <EOL> ) <EOL> search_fields = ( '<STR_LIT>' , ) <EOL> ordering = ( '<STR_LIT>' , ) <EOL> filter_horizontal = ( ) <EOL> admin . site . register ( models . UserProfile , UserAdmin ) <EOL> admin . site . register ( models . RustDeskToken , models . RustDeskTokenAdmin ) <EOL> admin . site . register ( models . RustDeskTag , models . RustDeskTagAdmin ) <EOL> admin . site . register ( models . RustDeskPeer , models . RustDeskPeerAdmin ) <EOL> admin . site . register ( models . RustDesDevice , models . RustDesDeviceAdmin ) <EOL> admin . site . register ( models . ShareLink , models . ShareLinkAdmin ) <EOL> admin . site . unregister ( Group ) <EOL> admin . site . site_header = _ ( '<STR_LIT>' ) <EOL> admin", "gt": ". site . site_title = _ ( '<STR_LIT>' )", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> ( _ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) , <EOL> ) <EOL> readonly_fields = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> add_fieldsets = ( <EOL> ( None , { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } <EOL> ) , <EOL> ) <EOL> search_fields = ( '<STR_LIT>' , ) <EOL> ordering = ( '<STR_LIT>' , ) <EOL> filter_horizontal = ( ) <EOL> admin . site . register ( models . UserProfile , UserAdmin ) <EOL> admin . site . register ( models . RustDeskToken , models . RustDeskTokenAdmin ) <EOL> admin . site . register ( models . RustDeskTag , models . RustDeskTagAdmin ) <EOL> admin . site . register ( models . RustDeskPeer , models . RustDeskPeerAdmin ) <EOL> admin . site . register ( models . RustDesDevice , models . RustDesDeviceAdmin ) <EOL> admin . site . register ( models . ShareLink , models . ShareLinkAdmin ) <EOL> admin", "gt": ". site . unregister ( Group )", "repo": "rustdesk-api-server"}
{"input": "import django <EOL> if django . __version__ . split ( '<STR_LIT>' ) [ <NUM_LIT> ] >= '<STR_LIT>' : <EOL> from django . urls import re_path as url <EOL> else : <EOL> from django . conf . urls import url , include <EOL> from api import views <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , views . login ) , <EOL> url ( r'<STR_LIT>' , views . logout ) , <EOL> url ( r'<STR_LIT>' , views . ab ) , <EOL> url ( r'<STR_LIT>' , views . ab_get ) , <EOL> url", "gt": "( r'<STR_LIT>' , views . users ) ,", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user", "gt": "= super ( UserChangeForm , self ) . save ( commit = False )", "repo": "rustdesk-api-server"}
{"input": "import django <EOL> if django . __version__ . split ( '<STR_LIT>' ) [ <NUM_LIT> ] >= '<STR_LIT>' : <EOL> from django . urls import re_path as url <EOL> else : <EOL> from django . conf . urls import url , include <EOL> from api import views <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , views . login ) , <EOL> url ( r'<STR_LIT>' , views . logout ) , <EOL> url ( r'<STR_LIT>' , views . ab ) , <EOL> url", "gt": "( r'<STR_LIT>' , views . ab_get ) ,", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> ( _ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) , <EOL> ) <EOL> readonly_fields = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> add_fieldsets = ( <EOL> ( None , { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } <EOL> ) , <EOL> ) <EOL> search_fields = ( '<STR_LIT>' , ) <EOL> ordering = ( '<STR_LIT>' , ) <EOL> filter_horizontal = ( ) <EOL> admin . site . register ( models . UserProfile , UserAdmin ) <EOL> admin . site . register ( models . RustDeskToken , models . RustDeskTokenAdmin ) <EOL> admin . site . register ( models . RustDeskTag , models . RustDeskTagAdmin ) <EOL> admin . site . register ( models . RustDeskPeer , models . RustDeskPeerAdmin ) <EOL> admin . site . register ( models . RustDesDevice , models . RustDesDeviceAdmin ) <EOL> admin", "gt": ". site . register ( models . ShareLink , models . ShareLinkAdmin )", "repo": "rustdesk-api-server"}
{"input": "import django <EOL> if django . __version__ . split ( '<STR_LIT>' ) [ <NUM_LIT> ] >= '<STR_LIT>' : <EOL> from django . urls import re_path as url <EOL> else : <EOL> from django . conf . urls import url , include <EOL> from api import views <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , views . login ) , <EOL> url ( r'<STR_LIT>' , views . logout ) , <EOL> url ( r'<STR_LIT>' , views . ab ) , <EOL> url ( r'<STR_LIT>' , views . ab_get ) , <EOL> url ( r'<STR_LIT>' , views . users ) , <EOL> url ( r'<STR_LIT>' , views . peers ) , <EOL> url ( r'<STR_LIT>' , views . currentUser ) , <EOL> url ( r'<STR_LIT>' , views . sysinfo ) , <EOL> url ( r'<STR_LIT>' , views . heartbeat ) , <EOL> url ( r'<STR_LIT>' , views . user_action ) , <EOL> url ( r'<STR_LIT>' , views . work ) , <EOL> url ( r'<STR_LIT>' , views . down_peers ) , <EOL> url", "gt": "( r'<STR_LIT>' , views . share ) ,", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> ( _ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) , <EOL> ) <EOL> readonly_fields = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> add_fieldsets = ( <EOL> ( None , { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } <EOL> ) , <EOL> ) <EOL> search_fields", "gt": "= ( '<STR_LIT>' , )", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter", "gt": "= ( '<STR_LIT>' , '<STR_LIT>' )", "repo": "rustdesk-api-server"}
{"input": "import django <EOL> if django . __version__ . split ( '<STR_LIT>' ) [ <NUM_LIT> ] >= '<STR_LIT>' : <EOL> from django . urls import re_path as url <EOL> else : <EOL> from django . conf . urls import url , include <EOL> from api import views <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , views . login ) , <EOL> url ( r'<STR_LIT>' , views . logout ) , <EOL> url ( r'<STR_LIT>' , views . ab ) , <EOL> url ( r'<STR_LIT>' , views . ab_get ) , <EOL> url ( r'<STR_LIT>' , views . users ) , <EOL> url ( r'<STR_LIT>' , views . peers ) , <EOL> url ( r'<STR_LIT>' , views . currentUser ) , <EOL> url ( r'<STR_LIT>' , views . sysinfo ) , <EOL> url", "gt": "( r'<STR_LIT>' , views . heartbeat ) ,", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password", "gt": "= ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) )", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> ( _ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) , <EOL> ) <EOL> readonly_fields", "gt": "= ( '<STR_LIT>' , '<STR_LIT>' )", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> ( _ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) , <EOL> ) <EOL> readonly_fields = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> add_fieldsets = ( <EOL> ( None , { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } <EOL> ) , <EOL> ) <EOL> search_fields = ( '<STR_LIT>' , ) <EOL> ordering", "gt": "= ( '<STR_LIT>' , )", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> ( _ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) , <EOL> ) <EOL> readonly_fields = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> add_fieldsets = ( <EOL> ( None , { <EOL> '<STR_LIT>'", "gt": ": ( '<STR_LIT>' , ) ,", "repo": "rustdesk-api-server"}
{"input": "import django <EOL> if django . __version__ . split ( '<STR_LIT>' ) [ <NUM_LIT> ] >= '<STR_LIT>' : <EOL> from django . urls import re_path as url <EOL> else : <EOL> from django . conf . urls import url , include <EOL> from api import views <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , views . login ) , <EOL> url ( r'<STR_LIT>' , views . logout ) , <EOL> url ( r'<STR_LIT>' , views . ab ) , <EOL> url ( r'<STR_LIT>' , views . ab_get ) , <EOL> url ( r'<STR_LIT>' , views . users ) , <EOL> url ( r'<STR_LIT>' , views . peers ) , <EOL> url ( r'<STR_LIT>' , views . currentUser ) , <EOL> url ( r'<STR_LIT>' , views . sysinfo ) , <EOL> url ( r'<STR_LIT>' , views . heartbeat ) , <EOL> url ( r'<STR_LIT>' , views . user_action ) , <EOL> url ( r'<STR_LIT>' , views . work ) , <EOL> url", "gt": "( r'<STR_LIT>' , views . down_peers ) ,", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user", "gt": ". save ( )", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> ( _ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) , <EOL> ) <EOL> readonly_fields = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> add_fieldsets = ( <EOL> ( None , { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } <EOL> ) , <EOL> ) <EOL> search_fields = ( '<STR_LIT>' , ) <EOL> ordering = ( '<STR_LIT>' , ) <EOL> filter_horizontal = ( ) <EOL> admin . site . register ( models . UserProfile , UserAdmin ) <EOL> admin . site . register ( models . RustDeskToken , models . RustDeskTokenAdmin ) <EOL> admin . site . register ( models . RustDeskTag , models . RustDeskTagAdmin ) <EOL> admin", "gt": ". site . register ( models . RustDeskPeer , models . RustDeskPeerAdmin )", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> ( _ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) , <EOL> ) <EOL> readonly_fields = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> add_fieldsets = ( <EOL> ( None , { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } <EOL> ) , <EOL> ) <EOL> search_fields = ( '<STR_LIT>' , ) <EOL> ordering = ( '<STR_LIT>' , ) <EOL> filter_horizontal = ( ) <EOL> admin . site . register ( models . UserProfile , UserAdmin ) <EOL> admin . site . register ( models . RustDeskToken , models . RustDeskTokenAdmin ) <EOL> admin . site . register ( models . RustDeskTag , models . RustDeskTagAdmin ) <EOL> admin . site . register ( models . RustDeskPeer , models . RustDeskPeerAdmin ) <EOL> admin . site . register ( models . RustDesDevice , models . RustDesDeviceAdmin ) <EOL> admin . site . register ( models . ShareLink , models . ShareLinkAdmin ) <EOL> admin . site . unregister ( Group ) <EOL> admin", "gt": ". site . site_header = _ ( '<STR_LIT>' )", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> ( _ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) , <EOL> ) <EOL> readonly_fields = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> add_fieldsets = ( <EOL> ( None , { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } <EOL> ) , <EOL> ) <EOL> search_fields = ( '<STR_LIT>' , ) <EOL> ordering = ( '<STR_LIT>' , ) <EOL> filter_horizontal = ( ) <EOL> admin . site . register ( models . UserProfile , UserAdmin ) <EOL> admin . site . register ( models . RustDeskToken , models . RustDeskTokenAdmin ) <EOL> admin", "gt": ". site . register ( models . RustDeskTag , models . RustDeskTagAdmin )", "repo": "rustdesk-api-server"}
{"input": "import django <EOL> if django . __version__ . split ( '<STR_LIT>' ) [ <NUM_LIT> ] >= '<STR_LIT>' : <EOL> from django . urls import re_path as url <EOL> else : <EOL> from django . conf . urls import url , include <EOL> from api import views <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , views . login ) , <EOL> url ( r'<STR_LIT>' , views . logout ) , <EOL> url ( r'<STR_LIT>' , views . ab ) , <EOL> url ( r'<STR_LIT>' , views . ab_get ) , <EOL> url ( r'<STR_LIT>' , views . users ) , <EOL> url ( r'<STR_LIT>' , views . peers ) , <EOL> url ( r'<STR_LIT>' , views . currentUser ) , <EOL> url ( r'<STR_LIT>' , views . sysinfo ) , <EOL> url ( r'<STR_LIT>' , views . heartbeat ) , <EOL> url ( r'<STR_LIT>' , views . user_action ) , <EOL> url", "gt": "( r'<STR_LIT>' , views . work ) ,", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fieldsets = ( <EOL> ( _ ( '<STR_LIT>' ) , { '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) } ) , <EOL> ) <EOL> readonly_fields = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> add_fieldsets = ( <EOL> ( None , { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , ) , <EOL> '<STR_LIT>'", "gt": ": ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) }", "repo": "rustdesk-api-server"}
{"input": "import django <EOL> if django . __version__ . split ( '<STR_LIT>' ) [ <NUM_LIT> ] >= '<STR_LIT>' : <EOL> from django . urls import re_path as url <EOL> else : <EOL> from django . conf . urls import url , include <EOL> from api import views <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , views . login ) , <EOL> url ( r'<STR_LIT>' , views . logout ) , <EOL> url ( r'<STR_LIT>' , views . ab ) , <EOL> url ( r'<STR_LIT>' , views . ab_get ) , <EOL> url ( r'<STR_LIT>' , views . users ) , <EOL> url", "gt": "( r'<STR_LIT>' , views . peers ) ,", "repo": "rustdesk-api-server"}
{"input": "from django . contrib import admin <EOL> from api import models <EOL> from django import forms <EOL> from django . contrib . auth . models import Group <EOL> from django . contrib . auth . admin import UserAdmin as BaseUserAdmin <EOL> from django . contrib . auth . forms import ReadOnlyPasswordHashField <EOL> from django . utils . translation import gettext as _ <EOL> class UserCreationForm ( forms . ModelForm ) : <EOL> password1 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> password2 = forms . CharField ( label = _ ( '<STR_LIT>' ) , widget = forms . PasswordInput ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password2 ( self ) : <EOL> password1 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> password2 = self . cleaned_data . get ( \"<STR_LIT>\" ) <EOL> if password1 and password2 and password1 != password2 : <EOL> raise forms . ValidationError ( _ ( \"<STR_LIT>\" ) ) <EOL> return password2 <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserCreationForm , self ) . save ( commit = False ) <EOL> user . set_password ( self . cleaned_data [ \"<STR_LIT>\" ] ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserChangeForm ( forms . ModelForm ) : <EOL> password = ReadOnlyPasswordHashField ( label = ( _ ( \"<STR_LIT>\" ) ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> class Meta : <EOL> model = models . UserProfile <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def clean_password ( self ) : <EOL> return self . initial [ \"<STR_LIT>\" ] <EOL> def save ( self , commit = True ) : <EOL> user = super ( UserChangeForm , self ) . save ( commit = False ) <EOL> if commit : <EOL> user . save ( ) <EOL> return user <EOL> class UserAdmin ( BaseUserAdmin ) : <EOL> form = UserChangeForm <EOL> add_form = UserCreationForm <EOL> password = ReadOnlyPasswordHashField ( label = ( \"<STR_LIT>\" ) , help_text = ( \"<STR_LIT>\" ) ) <EOL> list_display", "gt": "= ( '<STR_LIT>' , '<STR_LIT>' )", "repo": "rustdesk-api-server"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . model_id == \"<STR_LIT>\" <EOL> assert backend . config . token_limit == <NUM_LIT> <EOL> assert backend . config . init_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> llm_model = backend . get_llm_model ( ) <EOL> assert llm_model . key == \"<STR_LIT>\" <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_prompt_with_custom_kwargs ( mocker ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . prompt_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> prompt_mock", "gt": "= mocker . patch ( \"<STR_LIT>\" )", "repo": "wagtail-ai"}
{"input": "import pytest <EOL> from wagtail_ai import tokens <EOL> def test_get_default_token_limit_for_known_model ( ) : <EOL> assert tokens . get_default_token_limit ( \"<STR_LIT>\" ) == <NUM_LIT> <EOL> def", "gt": "test_get_default_token_limit_for_unknown_model ( ) :", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend", "gt": "= get_ai_backend ( \"<STR_LIT>\" )", "repo": "wagtail-ai"}
{"input": "import pytest <EOL> from wagtail_ai import tokens <EOL> def test_get_default_token_limit_for_known_model ( ) : <EOL> assert tokens . get_default_token_limit ( \"<STR_LIT>\" ) == <NUM_LIT> <EOL> def test_get_default_token_limit_for_unknown_model ( ) : <EOL> with pytest . raises ( tokens . NoTokenLimitFound , match = \"<STR_LIT>\" ) : <EOL> tokens", "gt": ". get_default_token_limit ( \"<STR_LIT>\" )", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert", "gt": "backend . config . model_id == \"<STR_LIT>\"", "repo": "wagtail-ai"}
{"input": "import pytest <EOL> from wagtail_ai import tokens <EOL> def test_get_default_token_limit_for_known_model ( ) : <EOL> assert", "gt": "tokens . get_default_token_limit ( \"<STR_LIT>\" ) == <NUM_LIT>", "repo": "wagtail-ai"}
{"input": "import uuid <EOL> import wagtail . search . index <EOL> from django . db import migrations , models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . AutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . UUIDField ( default = uuid . uuid4 , editable = False , unique = True ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . SmallIntegerField ( editable = False , null = True , unique = True ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . TextField ( <EOL> help_text = \"<STR_LIT>\" , <EOL> null = True , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> choices = [ <EOL> (", "gt": "\"<STR_LIT>\" , \"<STR_LIT>\" ) ,", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . model_id == \"<STR_LIT>\" <EOL> assert backend . config . token_limit == <NUM_LIT> <EOL> assert", "gt": "backend . config . init_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" }", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . model_id == \"<STR_LIT>\" <EOL> assert backend . config . token_limit == <NUM_LIT> <EOL> assert backend . config . init_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> llm_model = backend . get_llm_model ( ) <EOL> assert llm_model . key == \"<STR_LIT>\" <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> } , <EOL> } <EOL> ) <EOL> def", "gt": "test_llm_prompt_with_custom_kwargs ( mocker ) :", "repo": "wagtail-ai"}
{"input": "import uuid <EOL> import wagtail . search . index <EOL> from django . db import migrations , models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . AutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . UUIDField ( default = uuid . uuid4 , editable = False , unique = True ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . SmallIntegerField ( editable = False , null = True , unique = True ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . TextField ( <EOL> help_text = \"<STR_LIT>\" , <EOL> null = True , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> choices = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> (", "gt": "\"<STR_LIT>\" , \"<STR_LIT>\" ) ,", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . model_id == \"<STR_LIT>\" <EOL> assert backend . config . token_limit == <NUM_LIT> <EOL> assert backend . config . init_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> llm_model = backend . get_llm_model ( ) <EOL> assert llm_model . key == \"<STR_LIT>\" <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_prompt_with_custom_kwargs ( mocker ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert", "gt": "backend . config . prompt_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" }", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . model_id == \"<STR_LIT>\" <EOL> assert backend . config . token_limit == <NUM_LIT> <EOL> assert backend . config . init_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> llm_model = backend . get_llm_model ( ) <EOL> assert llm_model . key == \"<STR_LIT>\" <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_prompt_with_custom_kwargs ( mocker ) : <EOL> backend", "gt": "= get_ai_backend ( \"<STR_LIT>\" )", "repo": "wagtail-ai"}
{"input": "import uuid <EOL> import wagtail . search . index <EOL> from django . db import migrations , models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . AutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . UUIDField ( default = uuid . uuid4 , editable = False , unique = True ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . SmallIntegerField ( editable = False , null = True , unique = True ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> blank = True , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . TextField ( <EOL> help_text = \"<STR_LIT>\" , <EOL> null = True , <EOL> ) , <EOL> ) , <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . CharField ( <EOL> choices = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] , <EOL> help_text = \"<STR_LIT>\" , <EOL> max_length = <NUM_LIT> , <EOL> ) , <EOL> ) , <EOL> ] , <EOL> bases", "gt": "= ( models . Model , wagtail . search . index . Indexed ) ,", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . model_id == \"<STR_LIT>\" <EOL> assert backend . config . token_limit == <NUM_LIT> <EOL> assert backend . config . init_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> llm_model = backend . get_llm_model ( ) <EOL> assert llm_model . key == \"<STR_LIT>\" <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_prompt_with_custom_kwargs ( mocker ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . prompt_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> prompt_mock = mocker . patch ( \"<STR_LIT>\" ) <EOL> backend", "gt": ". prompt_with_context ( pre_prompt = \"<STR_LIT>\" , context = \"<STR_LIT>\" )", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def", "gt": "test_llm_custom_init_kwargs ( llm_backend_class ) :", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\"", "gt": ": { \"<STR_LIT>\" : \"<STR_LIT>\" } ,", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . model_id == \"<STR_LIT>\" <EOL> assert backend . config . token_limit == <NUM_LIT> <EOL> assert backend . config . init_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> llm_model", "gt": "= backend . get_llm_model ( )", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . model_id == \"<STR_LIT>\" <EOL> assert backend . config . token_limit == <NUM_LIT> <EOL> assert backend . config . init_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> llm_model = backend . get_llm_model ( ) <EOL> assert", "gt": "llm_model . key == \"<STR_LIT>\"", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . model_id == \"<STR_LIT>\" <EOL> assert", "gt": "backend . config . token_limit == <NUM_LIT>", "repo": "wagtail-ai"}
{"input": "import os <EOL> import re <EOL> import pytest <EOL> from test_utils . settings import custom_ai_backend_class , custom_ai_backend_settings <EOL> from wagtail_ai . ai import InvalidAIBackendError , get_ai_backend <EOL> try : <EOL> import llm <EOL> except ImportError : <EOL> llm_installed = False <EOL> else : <EOL> llm_installed = True <EOL> skip_if_llm_not_installed = pytest . mark . skipif ( <EOL> not llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> skip_if_llm_installed = pytest . mark . skipif ( <EOL> llm_installed , reason = \"<STR_LIT>\" <EOL> ) <EOL> @ pytest . fixture <EOL> def llm_backend_class ( ) : <EOL> from wagtail_ai . ai . llm import LLMBackend <EOL> return LLMBackend <EOL> @ skip_if_llm_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_import_error ( ) : <EOL> with pytest . raises ( <EOL> InvalidAIBackendError , <EOL> match = re . escape ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) : <EOL> get_ai_backend ( \"<STR_LIT>\" ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_class ( \"<STR_LIT>\" ) <EOL> def test_get_configured_backend_instance ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert isinstance ( backend , llm_backend_class ) <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_custom_init_kwargs ( llm_backend_class ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . model_id == \"<STR_LIT>\" <EOL> assert backend . config . token_limit == <NUM_LIT> <EOL> assert backend . config . init_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> llm_model = backend . get_llm_model ( ) <EOL> assert llm_model . key == \"<STR_LIT>\" <EOL> @ skip_if_llm_not_installed <EOL> @ custom_ai_backend_settings ( <EOL> new_value = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> } , <EOL> } <EOL> ) <EOL> def test_llm_prompt_with_custom_kwargs ( mocker ) : <EOL> backend = get_ai_backend ( \"<STR_LIT>\" ) <EOL> assert backend . config . prompt_kwargs == { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> prompt_mock = mocker . patch ( \"<STR_LIT>\" ) <EOL> backend . prompt_with_context ( pre_prompt = \"<STR_LIT>\" , context = \"<STR_LIT>\" ) <EOL> prompt_mock . assert_called_once_with ( <EOL> os", "gt": ". linesep . join ( [ \"<STR_LIT>\" , \"<STR_LIT>\" ] ) ,", "repo": "wagtail-ai"}
{"input": "import pytest <EOL> from wagtail_ai import tokens <EOL> def test_get_default_token_limit_for_known_model ( ) : <EOL> assert tokens . get_default_token_limit ( \"<STR_LIT>\" ) == <NUM_LIT> <EOL> def test_get_default_token_limit_for_unknown_model ( ) : <EOL> with", "gt": "pytest . raises ( tokens . NoTokenLimitFound , match = \"<STR_LIT>\" ) :", "repo": "wagtail-ai"}
{"input": "import requests , datetime , time , re , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_viu ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> url = '<STR_LIT>' <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> js = res . json ( ) [ '<STR_LIT>' ] <EOL> for j in js : <EOL> title = j [ '<STR_LIT>' ] . strip ( ) <EOL> desc1 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc2 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc = '<STR_LIT>' . join ( [ desc1 , desc2 ] ) if len ( desc2 ) > <NUM_LIT> else desc1 <EOL> desc = '<STR_LIT>' <EOL> starttime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> endtime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> if starttime . date ( ) < dt : <EOL> continue <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : desc , <EOL> '<STR_LIT>' : starttime . date ( ) , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg", "gt": "= '<STR_LIT>' % ( spidername , e )", "repo": "epg"}
{"input": "import requests , datetime , time , re , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_viu ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> url = '<STR_LIT>' <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> js = res . json ( ) [ '<STR_LIT>' ] <EOL> for j in js : <EOL> title = j [ '<STR_LIT>' ] . strip ( ) <EOL> desc1 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc2 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc = '<STR_LIT>' . join ( [ desc1 , desc2 ] ) if len ( desc2 ) > <NUM_LIT> else desc1 <EOL> desc = '<STR_LIT>' <EOL> starttime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> endtime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> if starttime . date ( ) < dt : <EOL> continue <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : desc , <EOL> '<STR_LIT>' : starttime . date ( ) , <EOL> } <EOL> epgs . append ( epg ) <EOL> except", "gt": "Exception as e :", "repo": "epg"}
{"input": "import requests , datetime , time , re , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_viu ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> url = '<STR_LIT>' <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> js = res . json ( ) [ '<STR_LIT>' ] <EOL> for j in js : <EOL> title = j [ '<STR_LIT>' ] . strip ( ) <EOL> desc1 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc2 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc = '<STR_LIT>' . join ( [ desc1 , desc2 ] ) if len ( desc2 ) > <NUM_LIT> else desc1 <EOL> desc = '<STR_LIT>' <EOL> starttime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> endtime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> if starttime . date ( ) < dt : <EOL> continue <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : desc , <EOL> '<STR_LIT>' : starttime . date ( ) , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername", "gt": "= os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ]", "repo": "epg"}
{"input": "from bs4 import BeautifulSoup as bs <EOL> import requests , datetime , os <EOL> from utils . general import headers <EOL> def get_epgs_btv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = \"<STR_LIT>\" % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> res_j = res . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> old_dt = datetime . datetime ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> n = <NUM_LIT> <EOL> max_n = len ( res_j ) <EOL> for epga in res_j : <EOL> n += <NUM_LIT> <EOL> starttime = epga [ '<STR_LIT>' ] <EOL> endtime = epga [ '<STR_LIT>' ] <EOL> title = epga [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . strptime ( need_date + starttime , '<STR_LIT>' ) <EOL> if n == max_n and endtime [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> endtime = endtime + datetime . timedelta ( days = <NUM_LIT> ) <EOL> else : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg", "gt": "= '<STR_LIT>' % ( spidername , e )", "repo": "epg"}
{"input": "import requests , re , datetime , json , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_cctv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = '<STR_LIT>' % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> programs = json . loads ( re . search ( '<STR_LIT>' , res . text ) . group ( <NUM_LIT> ) ) <EOL> prog_lists = programs [ '<STR_LIT>' ] [ channel_id ] [ '<STR_LIT>' ] <EOL> for prog_list in prog_lists : <EOL> title = prog_list [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . fromtimestamp ( prog_list [ '<STR_LIT>' ] ) <EOL> endtime = datetime . datetime . fromtimestamp ( prog_list [ '<STR_LIT>' ] ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> epglen = len ( epgs ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_cctv ( ) : <EOL> channels = [ ] <EOL> host = '<STR_LIT>' <EOL> url = '<STR_LIT>' % host <EOL> res = requests . get ( url , headers = headers ) <EOL> res . encoding = '<STR_LIT>' <EOL> soup = bs ( res . text , '<STR_LIT>' ) <EOL> lis = soup . select ( '<STR_LIT>' ) <EOL> need_date = datetime . datetime . now ( ) . strftime ( '<STR_LIT>' ) <EOL> for li in lis : <EOL> id = li . select ( '<STR_LIT>' ) [ <NUM_LIT> ] . attrs [ '<STR_LIT>' ] . strip ( ) <EOL> logo = '<STR_LIT>' + li . select ( '<STR_LIT>' ) [ <NUM_LIT> ] . attrs [ '<STR_LIT>' ] . strip ( ) <EOL> url_info = '<STR_LIT>' % ( id , need_date ) <EOL> res = requests . get ( url_info , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> research = re . search ( '<STR_LIT>' , res . text ) <EOL> name = research . group ( <NUM_LIT> ) <EOL> url", "gt": "= research . group ( <NUM_LIT> )", "repo": "epg"}
{"input": "from bs4 import BeautifulSoup as bs <EOL> import requests , datetime , os <EOL> from utils . general import headers <EOL> def get_epgs_btv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = \"<STR_LIT>\" % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> res_j = res . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> old_dt = datetime . datetime ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> n = <NUM_LIT> <EOL> max_n = len ( res_j ) <EOL> for epga in res_j : <EOL> n += <NUM_LIT> <EOL> starttime = epga [ '<STR_LIT>' ] <EOL> endtime = epga [ '<STR_LIT>' ] <EOL> title = epga [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . strptime ( need_date + starttime , '<STR_LIT>' ) <EOL> if n == max_n and endtime [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> endtime = endtime + datetime . timedelta ( days = <NUM_LIT> ) <EOL> else : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_btv ( ) : <EOL> channels = [ ] <EOL> url = '<STR_LIT>' <EOL> res = requests . get ( url , headers = headers ) <EOL> res . encoding = '<STR_LIT>' <EOL> soup = bs ( res . text , '<STR_LIT>' ) <EOL> lis = soup . select ( '<STR_LIT>' ) <EOL> for li in lis : <EOL> name = li . div . text . replace ( '<STR_LIT>' , '<STR_LIT>' ) . strip ( ) <EOL> id = li . attrs [ '<STR_LIT>' ] <EOL> channel = { <EOL> '<STR_LIT>' : name , <EOL> '<STR_LIT>' : [ id ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> channels", "gt": ". append ( channel )", "repo": "epg"}
{"input": "import time , re , os , unicodedata <EOL> import django <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from web . models import Crawl_log <EOL> from web . models import Channel , Epg <EOL> def log ( msg , level = <NUM_LIT> ) : <EOL> t = time . strftime ( '<STR_LIT>' , time . localtime ( ) ) + '<STR_LIT>' <EOL> m = t + '<STR_LIT>' + str ( msg ) <EOL> dbinfo = Crawl_log ( msg = msg , level = level ) <EOL> dbinfo", "gt": ". save ( )", "repo": "epg"}
{"input": "from bs4 import BeautifulSoup as bs <EOL> import requests , datetime , os <EOL> from utils . general import headers <EOL> def get_epgs_btv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = \"<STR_LIT>\" % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> res_j = res . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> old_dt = datetime . datetime ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> n = <NUM_LIT> <EOL> max_n = len ( res_j ) <EOL> for epga in res_j : <EOL> n += <NUM_LIT> <EOL> starttime = epga [ '<STR_LIT>' ] <EOL> endtime = epga [ '<STR_LIT>' ] <EOL> title = epga [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . strptime ( need_date + starttime , '<STR_LIT>' ) <EOL> if n == max_n and endtime [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> endtime = endtime + datetime . timedelta ( days = <NUM_LIT> ) <EOL> else : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_btv ( ) : <EOL> channels = [ ] <EOL> url = '<STR_LIT>' <EOL> res = requests . get ( url , headers = headers ) <EOL> res . encoding = '<STR_LIT>' <EOL> soup = bs ( res . text , '<STR_LIT>' ) <EOL> lis = soup . select ( '<STR_LIT>' ) <EOL> for li in lis : <EOL> name = li . div . text . replace ( '<STR_LIT>' , '<STR_LIT>' ) . strip ( ) <EOL> id = li . attrs [ '<STR_LIT>' ] <EOL> channel = { <EOL> '<STR_LIT>' : name , <EOL> '<STR_LIT>' : [ id ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> channels . append ( channel ) <EOL> infos = soup . select ( '<STR_LIT>' ) <EOL> n = <NUM_LIT> <EOL> for info in infos : <EOL> desc", "gt": "= info . text . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' )", "repo": "epg"}
{"input": "from bs4 import BeautifulSoup as bs <EOL> import requests , datetime , os <EOL> from utils . general import headers <EOL> def get_epgs_btv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = \"<STR_LIT>\" % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> res_j = res . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> old_dt = datetime . datetime ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> n = <NUM_LIT> <EOL> max_n = len ( res_j ) <EOL> for epga in res_j : <EOL> n += <NUM_LIT> <EOL> starttime = epga [ '<STR_LIT>' ] <EOL> endtime = epga [ '<STR_LIT>' ] <EOL> title = epga [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . strptime ( need_date + starttime , '<STR_LIT>' ) <EOL> if n == max_n and endtime [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> endtime = endtime + datetime . timedelta ( days = <NUM_LIT> ) <EOL> else : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_btv ( ) : <EOL> channels = [ ] <EOL> url = '<STR_LIT>' <EOL> res = requests . get ( url , headers = headers ) <EOL> res . encoding = '<STR_LIT>' <EOL> soup = bs ( res . text , '<STR_LIT>' ) <EOL> lis = soup . select ( '<STR_LIT>' ) <EOL> for li in lis : <EOL> name = li . div . text . replace ( '<STR_LIT>' , '<STR_LIT>' ) . strip ( ) <EOL> id = li . attrs [ '<STR_LIT>' ] <EOL> channel = { <EOL> '<STR_LIT>' : name , <EOL> '<STR_LIT>' : [ id ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> channels . append ( channel ) <EOL> infos", "gt": "= soup . select ( '<STR_LIT>' )", "repo": "epg"}
{"input": "import requests , datetime , time , re , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_viu ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> url = '<STR_LIT>' <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> js = res . json ( ) [ '<STR_LIT>' ] <EOL> for j in js : <EOL> title = j [ '<STR_LIT>' ] . strip ( ) <EOL> desc1 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc2 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc = '<STR_LIT>' . join ( [ desc1 , desc2 ] ) if len ( desc2 ) > <NUM_LIT> else desc1 <EOL> desc = '<STR_LIT>' <EOL> starttime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> endtime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> if starttime . date ( ) < dt : <EOL> continue <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : desc , <EOL> '<STR_LIT>' : starttime . date ( ) , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>'", "gt": ": starttime . date ( ) if '<STR_LIT>' in dir ( ) else dt ,", "repo": "epg"}
{"input": "import time , re , os , unicodedata <EOL> import django <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from web . models import Crawl_log <EOL> from web . models import Channel , Epg <EOL> def log ( msg , level = <NUM_LIT> ) : <EOL> t = time . strftime ( '<STR_LIT>' , time . localtime ( ) ) + '<STR_LIT>' <EOL> m = t + '<STR_LIT>' + str ( msg ) <EOL> dbinfo = Crawl_log ( msg = msg , level = level ) <EOL> dbinfo . save ( ) <EOL> print ( m ) <EOL> def", "gt": "get_html_info ( need_date ) :", "repo": "epg"}
{"input": "import requests , re , datetime , json , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_cctv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = '<STR_LIT>' % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> programs = json . loads ( re . search ( '<STR_LIT>' , res . text ) . group ( <NUM_LIT> ) ) <EOL> prog_lists = programs [ '<STR_LIT>' ] [ channel_id ] [ '<STR_LIT>' ] <EOL> for prog_list in prog_lists : <EOL> title = prog_list [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . fromtimestamp ( prog_list [ '<STR_LIT>' ] ) <EOL> endtime = datetime . datetime . fromtimestamp ( prog_list [ '<STR_LIT>' ] ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> epglen = len ( epgs ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def", "gt": "get_channels_cctv ( ) :", "repo": "epg"}
{"input": "import requests , re , datetime , json , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_cctv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = '<STR_LIT>' % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> programs = json . loads ( re . search ( '<STR_LIT>' , res . text ) . group ( <NUM_LIT> ) ) <EOL> prog_lists = programs [ '<STR_LIT>' ] [ channel_id ] [ '<STR_LIT>' ] <EOL> for prog_list in prog_lists : <EOL> title = prog_list [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . fromtimestamp ( prog_list [ '<STR_LIT>' ] ) <EOL> endtime = datetime . datetime . fromtimestamp ( prog_list [ '<STR_LIT>' ] ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> epglen = len ( epgs ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_cctv ( ) : <EOL> channels = [ ] <EOL> host = '<STR_LIT>' <EOL> url = '<STR_LIT>' % host <EOL> res = requests . get ( url , headers = headers ) <EOL> res . encoding = '<STR_LIT>' <EOL> soup = bs ( res . text , '<STR_LIT>' ) <EOL> lis = soup . select ( '<STR_LIT>' ) <EOL> need_date = datetime . datetime . now ( ) . strftime ( '<STR_LIT>' ) <EOL> for li in lis : <EOL> id = li . select ( '<STR_LIT>' ) [ <NUM_LIT> ] . attrs [ '<STR_LIT>' ] . strip ( ) <EOL> logo = '<STR_LIT>' + li . select ( '<STR_LIT>' ) [ <NUM_LIT> ] . attrs [ '<STR_LIT>' ] . strip ( ) <EOL> url_info", "gt": "= '<STR_LIT>' % ( id , need_date )", "repo": "epg"}
{"input": "from bs4 import BeautifulSoup as bs <EOL> import requests , datetime , os <EOL> from utils . general import headers <EOL> def get_epgs_btv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = \"<STR_LIT>\" % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> res_j = res . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> old_dt = datetime . datetime ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> n = <NUM_LIT> <EOL> max_n = len ( res_j ) <EOL> for epga in res_j : <EOL> n += <NUM_LIT> <EOL> starttime = epga [ '<STR_LIT>' ] <EOL> endtime = epga [ '<STR_LIT>' ] <EOL> title = epga [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . strptime ( need_date + starttime , '<STR_LIT>' ) <EOL> if n == max_n and endtime [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> endtime = endtime + datetime . timedelta ( days = <NUM_LIT> ) <EOL> else : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_btv ( ) : <EOL> channels = [ ] <EOL> url = '<STR_LIT>' <EOL> res = requests . get ( url , headers = headers ) <EOL> res . encoding = '<STR_LIT>' <EOL> soup = bs ( res . text , '<STR_LIT>' ) <EOL> lis = soup . select ( '<STR_LIT>' ) <EOL> for li in lis : <EOL> name = li . div . text . replace ( '<STR_LIT>' , '<STR_LIT>' ) . strip ( ) <EOL> id = li . attrs [ '<STR_LIT>' ] <EOL> channel = { <EOL> '<STR_LIT>' : name , <EOL> '<STR_LIT>' : [ id ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> channels . append ( channel ) <EOL> infos = soup . select ( '<STR_LIT>' ) <EOL> n = <NUM_LIT> <EOL> for info in infos : <EOL> desc = info . text . strip ( ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if '<STR_LIT>' in desc : <EOL> continue <EOL> channels", "gt": "[ n ] [ '<STR_LIT>' ] = desc", "repo": "epg"}
{"input": "import time , re , os , unicodedata <EOL> import django <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from web . models import Crawl_log <EOL> from web . models import Channel , Epg <EOL> def log ( msg , level = <NUM_LIT> ) : <EOL> t = time . strftime ( '<STR_LIT>' , time . localtime ( ) ) + '<STR_LIT>' <EOL> m = t + '<STR_LIT>' + str ( msg ) <EOL> dbinfo = Crawl_log ( msg = msg , level = level ) <EOL> dbinfo . save ( ) <EOL> print ( m ) <EOL> def get_html_info ( need_date ) : <EOL> channels = Channel . get_need_channels ( Channel , '<STR_LIT>' ) <EOL> epgs = Epg . get_epgs ( Epg , channels [ <NUM_LIT> ] , need_date ) <EOL> epg_no = epgs . count ( ) <EOL> return ( { <EOL> '<STR_LIT>' : epg_no , <EOL> '<STR_LIT>'", "gt": ": channels [ <NUM_LIT> ] ,", "repo": "epg"}
{"input": "from bs4 import BeautifulSoup as bs <EOL> import requests , datetime , os <EOL> from utils . general import headers <EOL> def get_epgs_btv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = \"<STR_LIT>\" % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> res_j = res . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> old_dt = datetime . datetime ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> n = <NUM_LIT> <EOL> max_n = len ( res_j ) <EOL> for epga in res_j : <EOL> n += <NUM_LIT> <EOL> starttime = epga [ '<STR_LIT>' ] <EOL> endtime = epga [ '<STR_LIT>' ] <EOL> title = epga [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . strptime ( need_date + starttime , '<STR_LIT>' ) <EOL> if n == max_n and endtime [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> endtime = endtime + datetime . timedelta ( days = <NUM_LIT> ) <EOL> else : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_btv ( ) : <EOL> channels = [ ] <EOL> url = '<STR_LIT>' <EOL> res = requests . get ( url , headers = headers ) <EOL> res . encoding = '<STR_LIT>' <EOL> soup", "gt": "= bs ( res . text , '<STR_LIT>' )", "repo": "epg"}
{"input": "import requests , re , datetime , json , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_cctv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = '<STR_LIT>' % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> programs = json . loads ( re . search ( '<STR_LIT>' , res . text ) . group ( <NUM_LIT> ) ) <EOL> prog_lists = programs [ '<STR_LIT>' ] [ channel_id ] [ '<STR_LIT>' ] <EOL> for prog_list in prog_lists : <EOL> title = prog_list [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . fromtimestamp ( prog_list [ '<STR_LIT>' ] ) <EOL> endtime = datetime . datetime . fromtimestamp ( prog_list [ '<STR_LIT>' ] ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> epglen = len ( epgs ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_cctv ( ) : <EOL> channels = [ ] <EOL> host = '<STR_LIT>' <EOL> url = '<STR_LIT>' % host <EOL> res = requests . get ( url , headers = headers ) <EOL> res . encoding = '<STR_LIT>' <EOL> soup", "gt": "= bs ( res . text , '<STR_LIT>' )", "repo": "epg"}
{"input": "import requests , datetime , time , re , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_viu ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> url = '<STR_LIT>' <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> js = res . json ( ) [ '<STR_LIT>' ] <EOL> for j in js : <EOL> title = j [ '<STR_LIT>' ] . strip ( ) <EOL> desc1 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc2 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc = '<STR_LIT>' . join ( [ desc1 , desc2 ] ) if len ( desc2 ) > <NUM_LIT> else desc1 <EOL> desc = '<STR_LIT>' <EOL> starttime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> endtime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> if starttime . date ( ) < dt : <EOL> continue <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : desc , <EOL> '<STR_LIT>'", "gt": ": starttime . date ( ) ,", "repo": "epg"}
{"input": "import requests , datetime , time , re , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_viu ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> url = '<STR_LIT>' <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> js = res . json ( ) [ '<STR_LIT>' ] <EOL> for j in js : <EOL> title = j [ '<STR_LIT>' ] . strip ( ) <EOL> desc1 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc2 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc = '<STR_LIT>' . join ( [ desc1 , desc2 ] ) if len ( desc2 ) > <NUM_LIT> else desc1 <EOL> desc = '<STR_LIT>' <EOL> starttime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> endtime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> if starttime . date ( ) < dt : <EOL> continue <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : desc , <EOL> '<STR_LIT>' : starttime . date ( ) , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : starttime . date ( ) if '<STR_LIT>' in dir ( ) else dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def", "gt": "get_channels_viu ( ) :", "repo": "epg"}
{"input": "from bs4 import BeautifulSoup as bs <EOL> import requests , datetime , os <EOL> from utils . general import headers <EOL> def get_epgs_btv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = \"<STR_LIT>\" % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> res_j = res . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> old_dt = datetime . datetime ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> n = <NUM_LIT> <EOL> max_n = len ( res_j ) <EOL> for epga in res_j : <EOL> n += <NUM_LIT> <EOL> starttime = epga [ '<STR_LIT>' ] <EOL> endtime = epga [ '<STR_LIT>' ] <EOL> title = epga [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . strptime ( need_date + starttime , '<STR_LIT>' ) <EOL> if n == max_n and endtime [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> endtime = endtime + datetime . timedelta ( days = <NUM_LIT> ) <EOL> else : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_btv ( ) : <EOL> channels = [ ] <EOL> url = '<STR_LIT>' <EOL> res", "gt": "= requests . get ( url , headers = headers )", "repo": "epg"}
{"input": "import requests , datetime , time , re , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_viu ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> url = '<STR_LIT>' <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> js = res . json ( ) [ '<STR_LIT>' ] <EOL> for j in js : <EOL> title = j [ '<STR_LIT>' ] . strip ( ) <EOL> desc1 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc2 = j [ '<STR_LIT>' ] if '<STR_LIT>' in j else '<STR_LIT>' <EOL> desc = '<STR_LIT>' . join ( [ desc1 , desc2 ] ) if len ( desc2 ) > <NUM_LIT> else desc1 <EOL> desc = '<STR_LIT>' <EOL> starttime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> endtime = datetime . datetime . fromtimestamp ( j [ '<STR_LIT>' ] / <NUM_LIT> ) <EOL> if starttime . date ( ) < dt : <EOL> continue <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : desc , <EOL> '<STR_LIT>' : starttime . date ( ) , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : starttime . date ( ) if '<STR_LIT>' in dir ( ) else dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_viu ( ) : <EOL> channel = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> channels", "gt": "= [ channel ]", "repo": "epg"}
{"input": "import requests , re , datetime , json , os <EOL> from utils . general import headers <EOL> from bs4 import BeautifulSoup as bs <EOL> def get_epgs_cctv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = '<STR_LIT>' % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> programs = json . loads ( re . search ( '<STR_LIT>' , res . text ) . group ( <NUM_LIT> ) ) <EOL> prog_lists = programs [ '<STR_LIT>' ] [ channel_id ] [ '<STR_LIT>' ] <EOL> for prog_list in prog_lists : <EOL> title = prog_list [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . fromtimestamp ( prog_list [ '<STR_LIT>' ] ) <EOL> endtime = datetime . datetime . fromtimestamp ( prog_list [ '<STR_LIT>' ] ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> epglen = len ( epgs ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_cctv ( ) : <EOL> channels = [ ] <EOL> host = '<STR_LIT>' <EOL> url = '<STR_LIT>' % host <EOL> res = requests . get ( url , headers = headers ) <EOL> res . encoding = '<STR_LIT>' <EOL> soup = bs ( res . text , '<STR_LIT>' ) <EOL> lis = soup . select ( '<STR_LIT>' ) <EOL> need_date = datetime . datetime . now ( ) . strftime ( '<STR_LIT>' ) <EOL> for li in lis : <EOL> id", "gt": "= li . select ( '<STR_LIT>' ) [ <NUM_LIT> ] . attrs [ '<STR_LIT>' ] . strip ( )", "repo": "epg"}
{"input": "import time , re , os , unicodedata <EOL> import django <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from web . models import Crawl_log <EOL> from web . models import Channel , Epg <EOL> def log ( msg , level = <NUM_LIT> ) : <EOL> t = time . strftime ( '<STR_LIT>' , time . localtime ( ) ) + '<STR_LIT>' <EOL> m = t + '<STR_LIT>' + str ( msg ) <EOL> dbinfo = Crawl_log ( msg = msg , level = level ) <EOL> dbinfo . save ( ) <EOL> print ( m ) <EOL> def get_html_info ( need_date ) : <EOL> channels", "gt": "= Channel . get_need_channels ( Channel , '<STR_LIT>' )", "repo": "epg"}
{"input": "from bs4 import BeautifulSoup as bs <EOL> import requests , datetime , os <EOL> from utils . general import headers <EOL> def get_epgs_btv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = \"<STR_LIT>\" % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> res_j = res . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> old_dt = datetime . datetime ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> n = <NUM_LIT> <EOL> max_n = len ( res_j ) <EOL> for epga in res_j : <EOL> n += <NUM_LIT> <EOL> starttime = epga [ '<STR_LIT>' ] <EOL> endtime = epga [ '<STR_LIT>' ] <EOL> title = epga [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . strptime ( need_date + starttime , '<STR_LIT>' ) <EOL> if n == max_n and endtime [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> endtime = endtime + datetime . timedelta ( days = <NUM_LIT> ) <EOL> else : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def get_channels_btv ( ) : <EOL> channels = [ ] <EOL> url = '<STR_LIT>' <EOL> res = requests . get ( url , headers = headers ) <EOL> res . encoding = '<STR_LIT>' <EOL> soup = bs ( res . text , '<STR_LIT>' ) <EOL> lis = soup . select ( '<STR_LIT>' ) <EOL> for li in lis : <EOL> name", "gt": "= li . div . text . replace ( '<STR_LIT>' , '<STR_LIT>' ) . strip ( )", "repo": "epg"}
{"input": "from bs4 import BeautifulSoup as bs <EOL> import requests , datetime , os <EOL> from utils . general import headers <EOL> def get_epgs_btv ( channel , channel_id , dt , func_arg ) : <EOL> epgs = [ ] <EOL> msg = '<STR_LIT>' <EOL> success = <NUM_LIT> <EOL> need_date = dt . strftime ( '<STR_LIT>' ) <EOL> url = \"<STR_LIT>\" % ( channel_id , need_date ) <EOL> try : <EOL> res = requests . get ( url , headers = headers , timeout = <NUM_LIT> ) <EOL> res . encoding = '<STR_LIT>' <EOL> res_j = res . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> old_dt = datetime . datetime ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> n = <NUM_LIT> <EOL> max_n = len ( res_j ) <EOL> for epga in res_j : <EOL> n += <NUM_LIT> <EOL> starttime = epga [ '<STR_LIT>' ] <EOL> endtime = epga [ '<STR_LIT>' ] <EOL> title = epga [ '<STR_LIT>' ] <EOL> starttime = datetime . datetime . strptime ( need_date + starttime , '<STR_LIT>' ) <EOL> if n == max_n and endtime [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> endtime = endtime + datetime . timedelta ( days = <NUM_LIT> ) <EOL> else : <EOL> endtime = datetime . datetime . strptime ( need_date + endtime , '<STR_LIT>' ) <EOL> epg = { '<STR_LIT>' : channel . id , <EOL> '<STR_LIT>' : starttime , <EOL> '<STR_LIT>' : endtime , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : dt , <EOL> } <EOL> epgs . append ( epg ) <EOL> except Exception as e : <EOL> success = <NUM_LIT> <EOL> spidername = os . path . basename ( __file__ ) . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> msg = '<STR_LIT>' % ( spidername , e ) <EOL> ret = { <EOL> '<STR_LIT>' : success , <EOL> '<STR_LIT>' : epgs , <EOL> '<STR_LIT>' : msg , <EOL> '<STR_LIT>' : dt , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> return ret <EOL> def", "gt": "get_channels_btv ( ) :", "repo": "epg"}
{"input": "import functools <EOL> from datetime import datetime , timedelta <EOL> def cache ( ttl = timedelta ( minutes = <NUM_LIT> ) ) : <EOL> def wrap ( func ) : <EOL> cache = { } <EOL> @ functools . wraps ( func ) <EOL> def wrapped ( * args , ** kw ) : <EOL> now = datetime . now ( ) <EOL> key = tuple ( args ) , frozenset ( kw . items ( ) ) <EOL> if key not in cache or now - cache [ key ] [ <NUM_LIT> ] > ttl : <EOL> value", "gt": "= func ( * args , ** kw )", "repo": "django-webhook"}
{"input": "import functools <EOL> from datetime import datetime , timedelta <EOL> def cache ( ttl = timedelta ( minutes = <NUM_LIT> ) ) : <EOL> def wrap ( func ) : <EOL> cache = { } <EOL> @ functools . wraps ( func ) <EOL> def wrapped ( * args , ** kw ) : <EOL> now = datetime . now ( ) <EOL> key = tuple ( args ) , frozenset ( kw . items ( ) ) <EOL> if key not in cache or now - cache [ key ] [ <NUM_LIT> ] > ttl : <EOL> value = func ( * args , ** kw ) <EOL> cache", "gt": "[ key ] = ( now , value )", "repo": "django-webhook"}
{"input": "import hmac <EOL> from hashlib import sha256 <EOL> from flask import Flask , Response , request <EOL> app = Flask ( __name__ ) <EOL> webhook_secret = \"<STR_LIT>\" <EOL> @ app . route ( \"<STR_LIT>\" , methods = [ \"<STR_LIT>\" ] ) <EOL> def webhook ( ) : <EOL> signatures_str = request . headers . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> signatures = signatures_str . split ( \"<STR_LIT>\" ) <EOL> timestamp = request . headers [ \"<STR_LIT>\" ] <EOL> for signature in signatures : <EOL> digest_payload = bytes ( timestamp , \"<STR_LIT>\" ) + b\"<STR_LIT>\" + request . data <EOL> digest = hmac . new ( <EOL> key = webhook_secret . encode ( ) , <EOL> msg = digest_payload , <EOL> digestmod = sha256 , <EOL> ) <EOL> signature_valid = hmac . compare_digest ( digest . hexdigest ( ) , signature ) <EOL> if not signature_valid : <EOL> app . logger . warning ( \"<STR_LIT>\" ) <EOL> return Response ( \"<STR_LIT>\" , status = <NUM_LIT> ) <EOL> app . logger . info ( request . json ) <EOL> return", "gt": "Response ( \"<STR_LIT>\" , status = <NUM_LIT> )", "repo": "django-webhook"}
{"input": "import hmac <EOL> from hashlib import sha256 <EOL> from flask import Flask , Response , request <EOL> app = Flask ( __name__ ) <EOL> webhook_secret = \"<STR_LIT>\" <EOL> @ app . route ( \"<STR_LIT>\" , methods = [ \"<STR_LIT>\" ] ) <EOL> def webhook ( ) : <EOL> signatures_str = request . headers . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> signatures = signatures_str . split ( \"<STR_LIT>\" ) <EOL> timestamp = request . headers [ \"<STR_LIT>\" ] <EOL> for signature in signatures : <EOL> digest_payload = bytes ( timestamp , \"<STR_LIT>\" ) + b\"<STR_LIT>\" + request . data <EOL> digest = hmac . new ( <EOL> key = webhook_secret . encode ( ) , <EOL> msg = digest_payload , <EOL> digestmod = sha256 , <EOL> ) <EOL> signature_valid", "gt": "= hmac . compare_digest ( digest . hexdigest ( ) , signature )", "repo": "django-webhook"}
{"input": "import hmac <EOL> from hashlib import sha256 <EOL> from flask import Flask , Response , request <EOL> app = Flask ( __name__ ) <EOL> webhook_secret = \"<STR_LIT>\" <EOL> @ app . route ( \"<STR_LIT>\" , methods = [ \"<STR_LIT>\" ] ) <EOL> def webhook ( ) : <EOL> signatures_str = request . headers . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> signatures = signatures_str . split ( \"<STR_LIT>\" ) <EOL> timestamp = request . headers [ \"<STR_LIT>\" ] <EOL> for signature in signatures : <EOL> digest_payload = bytes ( timestamp , \"<STR_LIT>\" ) + b\"<STR_LIT>\" + request . data <EOL> digest = hmac . new ( <EOL> key = webhook_secret . encode ( ) , <EOL> msg = digest_payload , <EOL> digestmod = sha256 , <EOL> ) <EOL> signature_valid = hmac . compare_digest ( digest . hexdigest ( ) , signature ) <EOL> if not signature_valid : <EOL> app", "gt": ". logger . warning ( \"<STR_LIT>\" )", "repo": "django-webhook"}
{"input": "import hmac <EOL> from hashlib import sha256 <EOL> from flask import Flask , Response , request <EOL> app = Flask ( __name__ ) <EOL> webhook_secret = \"<STR_LIT>\" <EOL> @ app . route ( \"<STR_LIT>\" , methods = [ \"<STR_LIT>\" ] ) <EOL> def webhook ( ) : <EOL> signatures_str = request . headers . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> signatures = signatures_str . split ( \"<STR_LIT>\" ) <EOL> timestamp = request . headers [ \"<STR_LIT>\" ] <EOL> for signature in signatures : <EOL> digest_payload = bytes ( timestamp , \"<STR_LIT>\" ) + b\"<STR_LIT>\" + request . data <EOL> digest = hmac . new ( <EOL> key = webhook_secret . encode ( ) , <EOL> msg = digest_payload , <EOL> digestmod = sha256 , <EOL> ) <EOL> signature_valid = hmac . compare_digest ( digest . hexdigest ( ) , signature ) <EOL> if not signature_valid : <EOL> app . logger . warning ( \"<STR_LIT>\" ) <EOL> return", "gt": "Response ( \"<STR_LIT>\" , status = <NUM_LIT> )", "repo": "django-webhook"}
{"input": "import functools <EOL> from datetime import datetime , timedelta <EOL> def cache ( ttl = timedelta ( minutes = <NUM_LIT> ) ) : <EOL> def wrap ( func ) : <EOL> cache = { } <EOL> @ functools . wraps ( func ) <EOL> def wrapped ( * args , ** kw ) : <EOL> now = datetime . now ( ) <EOL> key = tuple ( args ) , frozenset ( kw . items ( ) ) <EOL> if key not in cache or now - cache [ key ] [ <NUM_LIT> ] > ttl : <EOL> value = func ( * args , ** kw ) <EOL> cache [ key ] = ( now , value ) <EOL> return", "gt": "cache [ key ] [ <NUM_LIT> ]", "repo": "django-webhook"}
{"input": "import functools <EOL> from datetime import datetime , timedelta <EOL> def cache ( ttl = timedelta ( minutes = <NUM_LIT> ) ) : <EOL> def wrap ( func ) : <EOL> cache = { } <EOL> @ functools . wraps ( func ) <EOL> def wrapped ( * args , ** kw ) : <EOL> now", "gt": "= datetime . now ( )", "repo": "django-webhook"}
{"input": "from django . db import migrations , models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . AutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ] , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . AutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> (", "gt": "\"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) ,", "repo": "django-webhook"}
{"input": "import functools <EOL> from datetime import datetime , timedelta <EOL> def cache ( ttl = timedelta ( minutes = <NUM_LIT> ) ) : <EOL> def wrap ( func ) : <EOL> cache = { } <EOL> @ functools . wraps ( func ) <EOL> def wrapped ( * args , ** kw ) : <EOL> now = datetime . now ( ) <EOL> key = tuple ( args ) , frozenset ( kw . items ( ) ) <EOL> if", "gt": "key not in cache or now - cache [ key ] [ <NUM_LIT> ] > ttl :", "repo": "django-webhook"}
{"input": "import hmac <EOL> from hashlib import sha256 <EOL> from flask import Flask , Response , request <EOL> app = Flask ( __name__ ) <EOL> webhook_secret = \"<STR_LIT>\" <EOL> @ app . route ( \"<STR_LIT>\" , methods = [ \"<STR_LIT>\" ] ) <EOL> def webhook ( ) : <EOL> signatures_str = request . headers . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> signatures = signatures_str . split ( \"<STR_LIT>\" ) <EOL> timestamp = request . headers [ \"<STR_LIT>\" ] <EOL> for signature in signatures : <EOL> digest_payload = bytes ( timestamp , \"<STR_LIT>\" ) + b\"<STR_LIT>\" + request . data <EOL> digest = hmac . new ( <EOL> key", "gt": "= webhook_secret . encode ( ) ,", "repo": "django-webhook"}
{"input": "import hmac <EOL> from hashlib import sha256 <EOL> from flask import Flask , Response , request <EOL> app = Flask ( __name__ ) <EOL> webhook_secret = \"<STR_LIT>\" <EOL> @ app . route ( \"<STR_LIT>\" , methods = [ \"<STR_LIT>\" ] ) <EOL> def webhook ( ) : <EOL> signatures_str = request . headers . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> signatures = signatures_str . split ( \"<STR_LIT>\" ) <EOL> timestamp = request . headers [ \"<STR_LIT>\" ] <EOL> for signature in signatures : <EOL> digest_payload", "gt": "= bytes ( timestamp , \"<STR_LIT>\" ) + b\"<STR_LIT>\" + request . data", "repo": "django-webhook"}
{"input": "import functools <EOL> from datetime import datetime , timedelta <EOL> def cache ( ttl = timedelta ( minutes = <NUM_LIT> ) ) : <EOL> def wrap ( func ) : <EOL> cache = { } <EOL> @ functools . wraps ( func ) <EOL> def wrapped ( * args , ** kw ) : <EOL> now = datetime . now ( ) <EOL> key", "gt": "= tuple ( args ) , frozenset ( kw . items ( ) )", "repo": "django-webhook"}
{"input": "from django . db import migrations , models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . AutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ] , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = \"<STR_LIT>\" , <EOL> fields = [ <EOL> ( <EOL> \"<STR_LIT>\" , <EOL> models . AutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = \"<STR_LIT>\" , <EOL> ) , <EOL> ) , <EOL> ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> (", "gt": "\"<STR_LIT>\" , models . EmailField ( max_length = <NUM_LIT> ) ) ,", "repo": "django-webhook"}
{"input": "import hmac <EOL> from hashlib import sha256 <EOL> from flask import Flask , Response , request <EOL> app = Flask ( __name__ ) <EOL> webhook_secret = \"<STR_LIT>\" <EOL> @ app . route ( \"<STR_LIT>\" , methods = [ \"<STR_LIT>\" ] ) <EOL> def webhook ( ) : <EOL> signatures_str = request . headers . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> signatures = signatures_str . split ( \"<STR_LIT>\" ) <EOL> timestamp = request . headers [ \"<STR_LIT>\" ] <EOL> for signature in signatures : <EOL> digest_payload = bytes ( timestamp , \"<STR_LIT>\" ) + b\"<STR_LIT>\" + request . data <EOL> digest", "gt": "= hmac . new (", "repo": "django-webhook"}
{"input": "import hmac <EOL> from hashlib import sha256 <EOL> from flask import Flask , Response , request <EOL> app = Flask ( __name__ ) <EOL> webhook_secret = \"<STR_LIT>\" <EOL> @ app . route ( \"<STR_LIT>\" , methods = [ \"<STR_LIT>\" ] ) <EOL> def webhook ( ) : <EOL> signatures_str = request . headers . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> signatures = signatures_str . split ( \"<STR_LIT>\" ) <EOL> timestamp = request . headers [ \"<STR_LIT>\" ] <EOL> for signature in signatures : <EOL> digest_payload = bytes ( timestamp , \"<STR_LIT>\" ) + b\"<STR_LIT>\" + request . data <EOL> digest = hmac . new ( <EOL> key = webhook_secret . encode ( ) , <EOL> msg = digest_payload , <EOL> digestmod = sha256 , <EOL> ) <EOL> signature_valid = hmac . compare_digest ( digest . hexdigest ( ) , signature ) <EOL> if not signature_valid : <EOL> app . logger . warning ( \"<STR_LIT>\" ) <EOL> return Response ( \"<STR_LIT>\" , status = <NUM_LIT> ) <EOL> app", "gt": ". logger . info ( request . json )", "repo": "django-webhook"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> def get_cache ( ) : <EOL> import os <EOL> try : <EOL> servers", "gt": "= os . environ [ '<STR_LIT>' ]", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> def get_cache ( ) : <EOL> import os <EOL> try : <EOL> servers = os . environ [ '<STR_LIT>' ] <EOL> username = os . environ [ '<STR_LIT>' ] <EOL> password = os . environ [ '<STR_LIT>' ] <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> , <EOL> '<STR_LIT>' : servers , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : username , <EOL> '<STR_LIT>' : password , <EOL> } <EOL> } <EOL> } <EOL> except : <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> , <EOL> } <EOL> } <EOL> CACHES = get_cache ( ) <EOL> prod_db = dj_database_url . config ( conn_max_age = <NUM_LIT> ) <EOL> DATABASES [ '<STR_LIT>' ] . update ( prod_db ) <EOL> django_heroku", "gt": ". settings ( locals ( ) )", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> def get_cache ( ) : <EOL> import os <EOL> try : <EOL> servers = os . environ [ '<STR_LIT>' ] <EOL> username = os . environ [ '<STR_LIT>' ] <EOL> password = os . environ [ '<STR_LIT>' ] <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> , <EOL> '<STR_LIT>' : servers , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : username , <EOL> '<STR_LIT>' : password , <EOL> } <EOL> } <EOL> } <EOL> except : <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> , <EOL> } <EOL> } <EOL> CACHES = get_cache ( ) <EOL> prod_db = dj_database_url . config ( conn_max_age = <NUM_LIT> ) <EOL> DATABASES [ '<STR_LIT>' ] . update ( prod_db ) <EOL> django_heroku . settings ( locals ( ) ) <EOL> DATABASES", "gt": "[ '<STR_LIT>' ] [ '<STR_LIT>' ] = <NUM_LIT>", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\"", "gt": ": [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] ,", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> def get_cache ( ) : <EOL> import os <EOL> try : <EOL> servers = os . environ [ '<STR_LIT>' ] <EOL> username = os . environ [ '<STR_LIT>' ] <EOL> password = os . environ [ '<STR_LIT>' ] <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> , <EOL> '<STR_LIT>' : servers , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : username , <EOL> '<STR_LIT>' : password , <EOL> } <EOL> } <EOL> } <EOL> except : <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> , <EOL> } <EOL> } <EOL> CACHES = get_cache ( ) <EOL> prod_db", "gt": "= dj_database_url . config ( conn_max_age = <NUM_LIT> )", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\"", "gt": ": [ ( BROKER_URL ) ] ,", "repo": "summarizepaper"}
{"input": "from django . db import migrations , models <EOL> import django . utils . timezone <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = models . DateTimeField ( auto_now_add = True , default = django . utils . timezone . now ) , <EOL> preserve_default = False , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field", "gt": "= models . DateTimeField ( auto_now = True ) ,", "repo": "summarizepaper"}
{"input": "from django . db import migrations , models <EOL> import django . utils . timezone <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field", "gt": "= models . DateTimeField ( auto_now_add = True , default = django . utils . timezone . now ) ,", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> def get_cache ( ) : <EOL> import os <EOL> try : <EOL> servers = os . environ [ '<STR_LIT>' ] <EOL> username = os . environ [ '<STR_LIT>' ] <EOL> password = os . environ [ '<STR_LIT>' ] <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> , <EOL> '<STR_LIT>' : servers , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : username , <EOL> '<STR_LIT>' : password , <EOL> } <EOL> } <EOL> } <EOL> except : <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> , <EOL> } <EOL> } <EOL> CACHES = get_cache ( ) <EOL> prod_db = dj_database_url . config ( conn_max_age = <NUM_LIT> ) <EOL> DATABASES", "gt": "[ '<STR_LIT>' ] . update ( prod_db )", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> (", "gt": "'<STR_LIT>' , _ ( '<STR_LIT>' ) ) ,", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if", "gt": "'<STR_LIT>' in os . environ :", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS", "gt": "= ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , )", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> def get_cache ( ) : <EOL> import os <EOL> try : <EOL> servers = os . environ [ '<STR_LIT>' ] <EOL> username = os . environ [ '<STR_LIT>' ] <EOL> password = os . environ [ '<STR_LIT>' ] <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> , <EOL> '<STR_LIT>' : servers , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : username , <EOL> '<STR_LIT>' : password , <EOL> } <EOL> } <EOL> } <EOL> except : <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>'", "gt": ": <NUM_LIT> * <NUM_LIT> ,", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> def", "gt": "get_cache ( ) :", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT", "gt": "= os . path . join ( BASE_DIR , '<STR_LIT>' )", "repo": "summarizepaper"}
{"input": "from django import template <EOL> register = template . Library ( ) <EOL> @ register . filter <EOL> def", "gt": "dash_slash ( value ) :", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> def get_cache ( ) : <EOL> import os <EOL> try : <EOL> servers = os . environ [ '<STR_LIT>' ] <EOL> username = os . environ [ '<STR_LIT>' ] <EOL> password", "gt": "= os . environ [ '<STR_LIT>' ]", "repo": "summarizepaper"}
{"input": "from django import template <EOL> register = template . Library ( ) <EOL> @ register . filter <EOL> def dash_slash ( value ) : <EOL> return", "gt": "value . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" )", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> def get_cache ( ) : <EOL> import os <EOL> try : <EOL> servers = os . environ [ '<STR_LIT>' ] <EOL> username", "gt": "= os . environ [ '<STR_LIT>' ]", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> def get_cache ( ) : <EOL> import os <EOL> try : <EOL> servers = os . environ [ '<STR_LIT>' ] <EOL> username = os . environ [ '<STR_LIT>' ] <EOL> password = os . environ [ '<STR_LIT>' ] <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>'", "gt": ": <NUM_LIT> * <NUM_LIT> ,", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY", "gt": "= os . getenv ( '<STR_LIT>' )", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> (", "gt": "'<STR_LIT>' , _ ( '<STR_LIT>' ) ) ,", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> ) <EOL> TIME_ZONE = '<STR_LIT>' <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> USE_TZ = True <EOL> STATIC_URL = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( os . path . join ( BASE_DIR , '<STR_LIT>' ) , ) <EOL> STATIC_ROOT = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> STATICFILES_STORAGE = '<STR_LIT>' <EOL> ASGI_APPLICATION = '<STR_LIT>' <EOL> ROSETTA_MESSAGES_PER_PAGE = <NUM_LIT> <EOL> ROSETTA_ENABLE_TRANSLATION_SUGGESTIONS = True <EOL> YANDEX_TRANSLATE_KEY = os . getenv ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in os . environ : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : [ ( BROKER_URL ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> else : <EOL> CHANNEL_LAYERS = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ ( \"<STR_LIT>\" , <NUM_LIT> ) ] , <EOL> } , <EOL> } , <EOL> } <EOL> def get_cache ( ) : <EOL> import os <EOL> try : <EOL> servers = os . environ [ '<STR_LIT>' ] <EOL> username = os . environ [ '<STR_LIT>' ] <EOL> password = os . environ [ '<STR_LIT>' ] <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> , <EOL> '<STR_LIT>' : servers , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : username , <EOL> '<STR_LIT>' : password , <EOL> } <EOL> } <EOL> } <EOL> except : <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> , <EOL> } <EOL> } <EOL> CACHES", "gt": "= get_cache ( )", "repo": "summarizepaper"}
{"input": "import os <EOL> from urllib . parse import urlparse <EOL> import django_heroku <EOL> import dj_database_url <EOL> BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) <EOL> TEMPLATE_DIR = os . path . join ( BASE_DIR , '<STR_LIT>' ) <EOL> SECURE_REFERRER_POLICY = '<STR_LIT>' <EOL> SECRET_KEY = os . getenv ( '<STR_LIT>' ) <EOL> OPENAI_KEY = os . getenv ( '<STR_LIT>' ) <EOL> SECRETSG = os . getenv ( '<STR_LIT>' ) <EOL> EMAIL_BACKEND = '<STR_LIT>' <EOL> EMAIL_HOST = '<STR_LIT>' <EOL> EMAIL_PORT = <NUM_LIT> <EOL> EMAIL_HOST_USER = '<STR_LIT>' <EOL> EMAIL_HOST_PASSWORD = SECRETSG <EOL> EMAIL_USE_TLS = True <EOL> if '<STR_LIT>' in os . environ : <EOL> DEBUG = False <EOL> else : <EOL> DEBUG = True <EOL> CSRF_TRUSTED_ORIGINS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> BROKER_URL = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> BROKER_POOL_LIMIT = None <EOL> BROKER_CONNECTION_MAX_RETRIES = None <EOL> BROKER_TRANSPORT_OPTIONS = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } <EOL> INSTALLED_APPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> MIDDLEWARE = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> AUTHENTICATION_BACKENDS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATES = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ TEMPLATE_DIR ] , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . join ( BASE_DIR , '<STR_LIT>' ) , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] <EOL> from django . utils . translation import gettext_lazy as _ <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> LANGUAGES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> LOCALE_PATHS = ( <EOL> os", "gt": ". path . join ( BASE_DIR , '<STR_LIT>' ) ,", "repo": "summarizepaper"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> max_response_tokens = openai_model [ '<STR_LIT>' ] <EOL> if max_response_tokens > <NUM_LIT> : <EOL> max_response_tokens = <NUM_LIT> <EOL> self . _model = ChatOpenAI ( <EOL> api_key = api_key , <EOL> api_base = api_base , <EOL> model_name = openai_model [ '<STR_LIT>' ] , <EOL> max_tokens = max_response_tokens , <EOL> streaming = True , <EOL> ) <EOL> return self . _model <EOL> embedding_model = EmbeddingModel ( ) <EOL> chat_model = ChatModel ( ) <EOL> def pickle_faiss ( db ) : <EOL> idx = faiss . serialize_index ( db . index ) <EOL> pickled = pickle . dumps ( ( db . docstore , db . index_to_docstore_id , idx ) ) <EOL> return pickled <EOL> def unpick_faiss ( pickled , embedding_func = None ) : <EOL> if not embedding_func : <EOL> embedding_func = embedding_model . function <EOL> docstore , index_to_docstore_id , idx = pickle . loads ( pickled ) <EOL> index = faiss . deserialize_index ( idx ) <EOL> db = FAISS ( embedding_func . embed_query , index , docstore , index_to_docstore_id ) <EOL> return db <EOL> def get_embedding_document ( file , mime ) : <EOL> loaders = { <EOL> '<STR_LIT>' : TextLoader , <EOL> '<STR_LIT>' : PyPDFLoader , <EOL> '<STR_LIT>' : Docx2txtLoader , <EOL> '<STR_LIT>' : UnstructuredPowerPointLoader , <EOL> } <EOL> loader = loaders [ mime ] ( file ) <EOL> docs = loader . load ( ) <EOL> embeddings_function = embedding_model . function <EOL> for doc in docs : <EOL> hash_str = str ( hashlib . md5 ( str ( doc ) . encode ( ) ) . hexdigest ( ) ) <EOL> doc . metadata [ '<STR_LIT>' ] = hash_str <EOL> documents = text_splitter . split_documents ( docs ) <EOL> db = FAISS . from_documents ( documents , embeddings_function ) <EOL> return pickle_faiss ( db ) <EOL> condense_question_template = <EOL> MY_CONDENSE_QUESTION_PROMPT = PromptTemplate . from_template ( condense_question_template ) <EOL> def langchain_doc_chat ( messages ) : <EOL> db = messages [ '<STR_LIT>' ] <EOL> retriever = db . as_retriever ( <EOL> search_type = \"<STR_LIT>\" , <EOL> search_kwargs = { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } , <EOL> ) <EOL> memory = ConversationBufferWindowMemory ( memory_key = '<STR_LIT>' , return_messages = True , k = <NUM_LIT> ) <EOL> for msg in messages [ '<STR_LIT>' ] : <EOL> if msg . get ( '<STR_LIT>' , '<STR_LIT>' ) == '<STR_LIT>' : <EOL> memory . chat_memory . add_ai_message ( msg [ '<STR_LIT>' ] ) <EOL> else : <EOL> memory . chat_memory . add_user_message ( msg [ '<STR_LIT>' ] ) <EOL> question_generator = LLMChain ( <EOL> llm = chat_model . model , <EOL> prompt = MY_CONDENSE_QUESTION_PROMPT <EOL> ) <EOL> doc_chain = load_qa_chain ( <EOL> llm = chat_model . model , <EOL> chain_type = \"<STR_LIT>\" , <EOL> ) <EOL> chain = ConversationalRetrievalChain ( <EOL> retriever = retriever , <EOL> memory = memory , <EOL> question_generator = question_generator , <EOL> combine_docs_chain = doc_chain , <EOL> ) <EOL> results = [ ] <EOL> msgs = messages [ '<STR_LIT>' ] <EOL> q = msgs [ - <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . debug ( q ) <EOL> OSC . send_token = False <EOL> async def do_chain ( ) : <EOL> result = await chain . acall ( <EOL> { '<STR_LIT>' : q } , <EOL> callbacks = [ OSC ] , <EOL> ) <EOL> _queue . put ( - <NUM_LIT> ) <EOL> return result <EOL> def ctx_mgr ( ) : <EOL> result = asyncio . run ( do_chain ( ) ) <EOL> results", "gt": ". append ( result )", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> max_response_tokens = openai_model [ '<STR_LIT>' ] <EOL> if max_response_tokens > <NUM_LIT> : <EOL> max_response_tokens = <NUM_LIT> <EOL> self . _model = ChatOpenAI ( <EOL> api_key = api_key , <EOL> api_base = api_base , <EOL> model_name = openai_model [ '<STR_LIT>' ] , <EOL> max_tokens = max_response_tokens , <EOL> streaming = True , <EOL> ) <EOL> return self . _model <EOL> embedding_model = EmbeddingModel ( ) <EOL> chat_model = ChatModel ( ) <EOL> def pickle_faiss ( db ) : <EOL> idx = faiss . serialize_index ( db . index ) <EOL> pickled", "gt": "= pickle . dumps ( ( db . docstore , db . index_to_docstore_id , idx ) )", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> max_response_tokens = openai_model [ '<STR_LIT>' ] <EOL> if max_response_tokens > <NUM_LIT> : <EOL> max_response_tokens = <NUM_LIT> <EOL> self . _model = ChatOpenAI ( <EOL> api_key = api_key , <EOL> api_base = api_base , <EOL> model_name = openai_model [ '<STR_LIT>' ] , <EOL> max_tokens = max_response_tokens , <EOL> streaming = True , <EOL> ) <EOL> return self . _model <EOL> embedding_model = EmbeddingModel ( ) <EOL> chat_model = ChatModel ( ) <EOL> def pickle_faiss ( db ) : <EOL> idx = faiss . serialize_index ( db . index ) <EOL> pickled = pickle . dumps ( ( db . docstore , db . index_to_docstore_id , idx ) ) <EOL> return pickled <EOL> def unpick_faiss ( pickled , embedding_func = None ) : <EOL> if not embedding_func : <EOL> embedding_func = embedding_model . function <EOL> docstore , index_to_docstore_id , idx = pickle . loads ( pickled ) <EOL> index = faiss . deserialize_index ( idx ) <EOL> db = FAISS ( embedding_func . embed_query , index , docstore , index_to_docstore_id ) <EOL> return db <EOL> def get_embedding_document ( file , mime ) : <EOL> loaders = { <EOL> '<STR_LIT>' : TextLoader , <EOL> '<STR_LIT>' : PyPDFLoader , <EOL> '<STR_LIT>' : Docx2txtLoader , <EOL> '<STR_LIT>' : UnstructuredPowerPointLoader , <EOL> } <EOL> loader = loaders [ mime ] ( file ) <EOL> docs = loader . load ( ) <EOL> embeddings_function = embedding_model . function <EOL> for doc in docs : <EOL> hash_str = str ( hashlib . md5 ( str ( doc ) . encode ( ) ) . hexdigest ( ) ) <EOL> doc . metadata [ '<STR_LIT>' ] = hash_str <EOL> documents = text_splitter . split_documents ( docs ) <EOL> db = FAISS . from_documents ( documents , embeddings_function ) <EOL> return pickle_faiss ( db ) <EOL> condense_question_template = <EOL> MY_CONDENSE_QUESTION_PROMPT = PromptTemplate . from_template ( condense_question_template ) <EOL> def langchain_doc_chat ( messages ) : <EOL> db = messages [ '<STR_LIT>' ] <EOL> retriever = db . as_retriever ( <EOL> search_type = \"<STR_LIT>\" , <EOL> search_kwargs = { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } , <EOL> ) <EOL> memory = ConversationBufferWindowMemory ( memory_key = '<STR_LIT>' , return_messages = True , k = <NUM_LIT> ) <EOL> for msg in messages [ '<STR_LIT>' ] : <EOL> if msg . get ( '<STR_LIT>' , '<STR_LIT>' ) == '<STR_LIT>' : <EOL> memory . chat_memory . add_ai_message ( msg [ '<STR_LIT>' ] ) <EOL> else : <EOL> memory . chat_memory . add_user_message ( msg [ '<STR_LIT>' ] ) <EOL> question_generator = LLMChain ( <EOL> llm = chat_model . model , <EOL> prompt = MY_CONDENSE_QUESTION_PROMPT <EOL> ) <EOL> doc_chain = load_qa_chain ( <EOL> llm", "gt": "= chat_model . model ,", "repo": "chatgpt-ui-server"}
{"input": "import requests <EOL> from typing import List <EOL> from bs4 import BeautifulSoup <EOL> from . search_abc import SearchRequest , SearchResponse , SearchResult <EOL> import os <EOL> proxies = None <EOL> for key in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> value = os . getenv ( key ) <EOL> if value : <EOL> proxies = { <EOL> '<STR_LIT>' : value , <EOL> '<STR_LIT>' : value , <EOL> } <EOL> break <EOL> BASE_URL = '<STR_LIT>' <EOL> def get_html ( search : SearchRequest ) -> SearchResponse : <EOL> query = search . query [ : <NUM_LIT> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : search . ua <EOL> } <EOL> data = { <EOL> '<STR_LIT>' : query , <EOL> '<STR_LIT>' : search . timerange , <EOL> '<STR_LIT>' : search . region , <EOL> } <EOL> response = requests . post ( f'<STR_LIT>' , headers = headers , data = data , proxies = proxies ) <EOL> if not response . ok : <EOL> raise Exception ( f'<STR_LIT>' ) <EOL> return SearchResponse ( response . status_code , response . text , response . url ) <EOL> def html_to_search_results ( html : str , num_results : int ) -> List [ SearchResult ] : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> results = [ ] <EOL> zero_click_link = soup . select_one ( '<STR_LIT>' ) <EOL> if zero_click_link : <EOL> title = zero_click_link . text <EOL> body = soup . select_one ( '<STR_LIT>' ) . text . strip ( ) <EOL> url = zero_click_link [ '<STR_LIT>' ] <EOL> results . append ( SearchResult ( title , body , url ) ) <EOL> upper_bound = num_results - <NUM_LIT> if zero_click_link else num_results <EOL> web_links = soup . select ( '<STR_LIT>' ) [ : upper_bound ] <EOL> web_snippets = soup . select ( '<STR_LIT>' ) [ : upper_bound ] <EOL> for", "gt": "link , snippet in zip ( web_links , web_snippets ) :", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> max_response_tokens = openai_model [ '<STR_LIT>' ] <EOL> if max_response_tokens > <NUM_LIT> : <EOL> max_response_tokens = <NUM_LIT> <EOL> self . _model = ChatOpenAI ( <EOL> api_key = api_key , <EOL> api_base = api_base , <EOL> model_name = openai_model [ '<STR_LIT>' ] , <EOL> max_tokens = max_response_tokens , <EOL> streaming = True , <EOL> ) <EOL> return self . _model <EOL> embedding_model = EmbeddingModel ( ) <EOL> chat_model = ChatModel ( ) <EOL> def pickle_faiss ( db ) : <EOL> idx = faiss . serialize_index ( db . index ) <EOL> pickled = pickle . dumps ( ( db . docstore , db . index_to_docstore_id , idx ) ) <EOL> return pickled <EOL> def unpick_faiss ( pickled , embedding_func = None ) : <EOL> if not embedding_func : <EOL> embedding_func = embedding_model . function <EOL> docstore , index_to_docstore_id , idx = pickle . loads ( pickled ) <EOL> index = faiss . deserialize_index ( idx ) <EOL> db = FAISS ( embedding_func . embed_query , index , docstore , index_to_docstore_id ) <EOL> return db <EOL> def get_embedding_document ( file , mime ) : <EOL> loaders = { <EOL> '<STR_LIT>' : TextLoader , <EOL> '<STR_LIT>' : PyPDFLoader , <EOL> '<STR_LIT>' : Docx2txtLoader , <EOL> '<STR_LIT>' : UnstructuredPowerPointLoader , <EOL> } <EOL> loader = loaders [ mime ] ( file ) <EOL> docs = loader . load ( ) <EOL> embeddings_function = embedding_model . function <EOL> for doc in docs : <EOL> hash_str = str ( hashlib . md5 ( str ( doc ) . encode ( ) ) . hexdigest ( ) ) <EOL> doc . metadata [ '<STR_LIT>' ] = hash_str <EOL> documents = text_splitter . split_documents ( docs ) <EOL> db = FAISS . from_documents ( documents , embeddings_function ) <EOL> return pickle_faiss ( db ) <EOL> condense_question_template = <EOL> MY_CONDENSE_QUESTION_PROMPT = PromptTemplate . from_template ( condense_question_template ) <EOL> def langchain_doc_chat ( messages ) : <EOL> db = messages [ '<STR_LIT>' ] <EOL> retriever = db . as_retriever ( <EOL> search_type = \"<STR_LIT>\" , <EOL> search_kwargs = { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } , <EOL> ) <EOL> memory = ConversationBufferWindowMemory ( memory_key = '<STR_LIT>' , return_messages = True , k = <NUM_LIT> ) <EOL> for msg in messages [ '<STR_LIT>' ] : <EOL> if msg . get ( '<STR_LIT>' , '<STR_LIT>' ) == '<STR_LIT>' : <EOL> memory . chat_memory . add_ai_message ( msg [ '<STR_LIT>' ] ) <EOL> else : <EOL> memory", "gt": ". chat_memory . add_user_message ( msg [ '<STR_LIT>' ] )", "repo": "chatgpt-ui-server"}
{"input": "import requests <EOL> from typing import List <EOL> from bs4 import BeautifulSoup <EOL> from . search_abc import SearchRequest , SearchResponse , SearchResult <EOL> import os <EOL> proxies = None <EOL> for key in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> value = os . getenv ( key ) <EOL> if value : <EOL> proxies = { <EOL> '<STR_LIT>' : value , <EOL> '<STR_LIT>' : value , <EOL> } <EOL> break <EOL> BASE_URL = '<STR_LIT>' <EOL> def get_html ( search : SearchRequest ) -> SearchResponse : <EOL> query = search . query [ : <NUM_LIT> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : search . ua <EOL> } <EOL> data = { <EOL> '<STR_LIT>' : query , <EOL> '<STR_LIT>' : search . timerange , <EOL> '<STR_LIT>' : search . region , <EOL> } <EOL> response = requests . post ( f'<STR_LIT>' , headers = headers , data = data , proxies = proxies ) <EOL> if not response . ok : <EOL> raise Exception ( f'<STR_LIT>' ) <EOL> return SearchResponse ( response . status_code , response . text , response . url ) <EOL> def html_to_search_results ( html : str , num_results : int ) -> List [ SearchResult ] : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> results = [ ] <EOL> zero_click_link = soup . select_one ( '<STR_LIT>' ) <EOL> if zero_click_link : <EOL> title = zero_click_link . text <EOL> body = soup . select_one ( '<STR_LIT>' ) . text . strip ( ) <EOL> url = zero_click_link [ '<STR_LIT>' ] <EOL> results . append ( SearchResult ( title , body , url ) ) <EOL> upper_bound = num_results - <NUM_LIT> if zero_click_link else num_results <EOL> web_links = soup . select ( '<STR_LIT>' ) [ : upper_bound ] <EOL> web_snippets = soup . select ( '<STR_LIT>' ) [ : upper_bound ] <EOL> for link , snippet in zip ( web_links , web_snippets ) : <EOL> title = link . text <EOL> body = snippet . text . strip ( ) <EOL> url = link [ '<STR_LIT>' ] <EOL> results", "gt": ". append ( SearchResult ( title , body , url ) )", "repo": "chatgpt-ui-server"}
{"input": "import requests <EOL> from typing import List <EOL> from bs4 import BeautifulSoup <EOL> from . search_abc import SearchRequest , SearchResponse , SearchResult <EOL> import os <EOL> proxies = None <EOL> for key in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> value = os . getenv ( key ) <EOL> if value : <EOL> proxies = { <EOL> '<STR_LIT>' : value , <EOL> '<STR_LIT>' : value , <EOL> } <EOL> break <EOL> BASE_URL = '<STR_LIT>' <EOL> def get_html ( search : SearchRequest ) -> SearchResponse : <EOL> query = search . query [ : <NUM_LIT> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : search . ua <EOL> } <EOL> data = { <EOL> '<STR_LIT>' : query , <EOL> '<STR_LIT>' : search . timerange , <EOL> '<STR_LIT>' : search . region , <EOL> } <EOL> response = requests . post ( f'<STR_LIT>' , headers = headers , data = data , proxies = proxies ) <EOL> if not response . ok : <EOL> raise Exception ( f'<STR_LIT>' ) <EOL> return SearchResponse ( response . status_code , response . text , response . url ) <EOL> def html_to_search_results ( html : str , num_results : int ) -> List [ SearchResult ] : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> results = [ ] <EOL> zero_click_link = soup . select_one ( '<STR_LIT>' ) <EOL> if zero_click_link : <EOL> title = zero_click_link . text <EOL> body = soup . select_one ( '<STR_LIT>' ) . text . strip ( ) <EOL> url = zero_click_link [ '<STR_LIT>' ] <EOL> results . append ( SearchResult ( title , body , url ) ) <EOL> upper_bound = num_results - <NUM_LIT> if zero_click_link else num_results <EOL> web_links = soup . select ( '<STR_LIT>' ) [ : upper_bound ] <EOL> web_snippets = soup . select ( '<STR_LIT>' ) [ : upper_bound ] <EOL> for link , snippet in zip ( web_links , web_snippets ) : <EOL> title = link . text <EOL> body = snippet . text . strip ( ) <EOL> url = link [ '<STR_LIT>' ] <EOL> results . append ( SearchResult ( title , body , url ) ) <EOL> return results <EOL> def web_search ( search : SearchRequest , num_results : int ) -> List [ SearchResult ] : <EOL> response", "gt": "= get_html ( search )", "repo": "chatgpt-ui-server"}
{"input": "from django . db import models <EOL> from rest_framework import serializers <EOL> from . models import Conversation , Message , Prompt , EmbeddingDocument , Setting <EOL> class ConversationSerializer ( serializers . ModelSerializer ) : <EOL> class Meta : <EOL> model = Conversation <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MessageSerializer ( serializers . ModelSerializer ) : <EOL> class Meta : <EOL> model = Message <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class PromptSerializer ( serializers . ModelSerializer ) : <EOL> prompt", "gt": "= serializers . CharField ( trim_whitespace = False , allow_blank = True )", "repo": "chatgpt-ui-server"}
{"input": "import requests <EOL> from typing import List <EOL> from bs4 import BeautifulSoup <EOL> from . search_abc import SearchRequest , SearchResponse , SearchResult <EOL> import os <EOL> proxies = None <EOL> for key in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> value = os . getenv ( key ) <EOL> if value : <EOL> proxies = { <EOL> '<STR_LIT>' : value , <EOL> '<STR_LIT>' : value , <EOL> } <EOL> break <EOL> BASE_URL = '<STR_LIT>' <EOL> def get_html ( search : SearchRequest ) -> SearchResponse : <EOL> query = search . query [ : <NUM_LIT> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : search . ua <EOL> } <EOL> data = { <EOL> '<STR_LIT>' : query , <EOL> '<STR_LIT>' : search . timerange , <EOL> '<STR_LIT>' : search . region , <EOL> } <EOL> response = requests . post ( f'<STR_LIT>' , headers = headers , data = data , proxies = proxies ) <EOL> if not response . ok : <EOL> raise Exception ( f'<STR_LIT>' ) <EOL> return SearchResponse ( response . status_code , response . text , response . url ) <EOL> def html_to_search_results ( html : str , num_results : int ) -> List [ SearchResult ] : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> results = [ ] <EOL> zero_click_link = soup . select_one ( '<STR_LIT>' ) <EOL> if zero_click_link : <EOL> title = zero_click_link . text <EOL> body = soup . select_one ( '<STR_LIT>' ) . text . strip ( ) <EOL> url = zero_click_link [ '<STR_LIT>' ] <EOL> results . append ( SearchResult ( title , body , url ) ) <EOL> upper_bound = num_results - <NUM_LIT> if zero_click_link else num_results <EOL> web_links", "gt": "= soup . select ( '<STR_LIT>' ) [ : upper_bound ]", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> max_response_tokens = openai_model [ '<STR_LIT>' ] <EOL> if max_response_tokens > <NUM_LIT> : <EOL> max_response_tokens = <NUM_LIT> <EOL> self . _model = ChatOpenAI ( <EOL> api_key = api_key , <EOL> api_base = api_base , <EOL> model_name = openai_model [ '<STR_LIT>' ] , <EOL> max_tokens = max_response_tokens , <EOL> streaming = True , <EOL> ) <EOL> return self . _model <EOL> embedding_model = EmbeddingModel ( ) <EOL> chat_model = ChatModel ( ) <EOL> def pickle_faiss ( db ) : <EOL> idx = faiss . serialize_index ( db . index ) <EOL> pickled = pickle . dumps ( ( db . docstore , db . index_to_docstore_id , idx ) ) <EOL> return pickled <EOL> def unpick_faiss ( pickled , embedding_func = None ) : <EOL> if not embedding_func : <EOL> embedding_func = embedding_model . function <EOL> docstore , index_to_docstore_id , idx = pickle . loads ( pickled ) <EOL> index = faiss . deserialize_index ( idx ) <EOL> db = FAISS ( embedding_func . embed_query , index , docstore , index_to_docstore_id ) <EOL> return db <EOL> def get_embedding_document ( file , mime ) : <EOL> loaders = { <EOL> '<STR_LIT>' : TextLoader , <EOL> '<STR_LIT>' : PyPDFLoader , <EOL> '<STR_LIT>' : Docx2txtLoader , <EOL> '<STR_LIT>' : UnstructuredPowerPointLoader , <EOL> } <EOL> loader = loaders [ mime ] ( file ) <EOL> docs = loader . load ( ) <EOL> embeddings_function = embedding_model . function <EOL> for doc in docs : <EOL> hash_str = str ( hashlib . md5 ( str ( doc ) . encode ( ) ) . hexdigest ( ) ) <EOL> doc . metadata [ '<STR_LIT>' ] = hash_str <EOL> documents = text_splitter . split_documents ( docs ) <EOL> db", "gt": "= FAISS . from_documents ( documents , embeddings_function )", "repo": "chatgpt-ui-server"}
{"input": "import requests <EOL> from typing import List <EOL> from bs4 import BeautifulSoup <EOL> from . search_abc import SearchRequest , SearchResponse , SearchResult <EOL> import os <EOL> proxies = None <EOL> for key in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> value = os . getenv ( key ) <EOL> if value : <EOL> proxies = { <EOL> '<STR_LIT>' : value , <EOL> '<STR_LIT>' : value , <EOL> } <EOL> break <EOL> BASE_URL = '<STR_LIT>' <EOL> def get_html ( search : SearchRequest ) -> SearchResponse : <EOL> query = search . query [ : <NUM_LIT> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : search . ua <EOL> } <EOL> data = { <EOL> '<STR_LIT>' : query , <EOL> '<STR_LIT>' : search . timerange , <EOL> '<STR_LIT>' : search . region , <EOL> } <EOL> response = requests . post ( f'<STR_LIT>' , headers = headers , data = data , proxies = proxies ) <EOL> if not response . ok : <EOL> raise Exception ( f'<STR_LIT>' ) <EOL> return SearchResponse ( response . status_code , response . text , response . url ) <EOL> def html_to_search_results ( html : str , num_results : int ) -> List [ SearchResult ] : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> results = [ ] <EOL> zero_click_link = soup . select_one ( '<STR_LIT>' ) <EOL> if zero_click_link : <EOL> title = zero_click_link . text <EOL> body = soup . select_one ( '<STR_LIT>' ) . text . strip ( ) <EOL> url = zero_click_link [ '<STR_LIT>' ] <EOL> results . append ( SearchResult ( title , body , url ) ) <EOL> upper_bound = num_results - <NUM_LIT> if zero_click_link else num_results <EOL> web_links = soup . select ( '<STR_LIT>' ) [ : upper_bound ] <EOL> web_snippets", "gt": "= soup . select ( '<STR_LIT>' ) [ : upper_bound ]", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> max_response_tokens = openai_model [ '<STR_LIT>' ] <EOL> if max_response_tokens > <NUM_LIT> : <EOL> max_response_tokens = <NUM_LIT> <EOL> self . _model = ChatOpenAI ( <EOL> api_key = api_key , <EOL> api_base = api_base , <EOL> model_name = openai_model [ '<STR_LIT>' ] , <EOL> max_tokens = max_response_tokens , <EOL> streaming = True , <EOL> ) <EOL> return self . _model <EOL> embedding_model = EmbeddingModel ( ) <EOL> chat_model = ChatModel ( ) <EOL> def pickle_faiss ( db ) : <EOL> idx = faiss . serialize_index ( db . index ) <EOL> pickled = pickle . dumps ( ( db . docstore , db . index_to_docstore_id , idx ) ) <EOL> return pickled <EOL> def unpick_faiss ( pickled , embedding_func = None ) : <EOL> if not embedding_func : <EOL> embedding_func = embedding_model . function <EOL> docstore , index_to_docstore_id , idx = pickle . loads ( pickled ) <EOL> index = faiss . deserialize_index ( idx ) <EOL> db = FAISS ( embedding_func . embed_query , index , docstore , index_to_docstore_id ) <EOL> return db <EOL> def get_embedding_document ( file , mime ) : <EOL> loaders = { <EOL> '<STR_LIT>' : TextLoader , <EOL> '<STR_LIT>' : PyPDFLoader , <EOL> '<STR_LIT>' : Docx2txtLoader , <EOL> '<STR_LIT>' : UnstructuredPowerPointLoader , <EOL> } <EOL> loader = loaders [ mime ] ( file ) <EOL> docs = loader . load ( ) <EOL> embeddings_function = embedding_model . function <EOL> for doc in docs : <EOL> hash_str = str ( hashlib . md5 ( str ( doc ) . encode ( ) ) . hexdigest ( ) ) <EOL> doc . metadata [ '<STR_LIT>' ] = hash_str <EOL> documents", "gt": "= text_splitter . split_documents ( docs )", "repo": "chatgpt-ui-server"}
{"input": "import requests <EOL> from typing import List <EOL> from bs4 import BeautifulSoup <EOL> from . search_abc import SearchRequest , SearchResponse , SearchResult <EOL> import os <EOL> proxies = None <EOL> for key in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> value = os . getenv ( key ) <EOL> if value : <EOL> proxies = { <EOL> '<STR_LIT>' : value , <EOL> '<STR_LIT>' : value , <EOL> } <EOL> break <EOL> BASE_URL = '<STR_LIT>' <EOL> def get_html ( search : SearchRequest ) -> SearchResponse : <EOL> query = search . query [ : <NUM_LIT> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : search . ua <EOL> } <EOL> data = { <EOL> '<STR_LIT>' : query , <EOL> '<STR_LIT>' : search . timerange , <EOL> '<STR_LIT>' : search . region , <EOL> } <EOL> response = requests . post ( f'<STR_LIT>' , headers = headers , data = data , proxies = proxies ) <EOL> if not response . ok : <EOL> raise Exception ( f'<STR_LIT>' ) <EOL> return SearchResponse ( response . status_code , response . text , response . url ) <EOL> def html_to_search_results ( html : str , num_results : int ) -> List [ SearchResult ] : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> results = [ ] <EOL> zero_click_link = soup . select_one ( '<STR_LIT>' ) <EOL> if zero_click_link : <EOL> title = zero_click_link . text <EOL> body", "gt": "= soup . select_one ( '<STR_LIT>' ) . text . strip ( )", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> max_response_tokens = openai_model [ '<STR_LIT>' ] <EOL> if max_response_tokens > <NUM_LIT> : <EOL> max_response_tokens = <NUM_LIT> <EOL> self . _model = ChatOpenAI ( <EOL> api_key = api_key , <EOL> api_base = api_base , <EOL> model_name = openai_model [ '<STR_LIT>' ] , <EOL> max_tokens = max_response_tokens , <EOL> streaming = True , <EOL> ) <EOL> return self . _model <EOL> embedding_model = EmbeddingModel ( ) <EOL> chat_model = ChatModel ( ) <EOL> def pickle_faiss ( db ) : <EOL> idx = faiss . serialize_index ( db . index ) <EOL> pickled = pickle . dumps ( ( db . docstore , db . index_to_docstore_id , idx ) ) <EOL> return pickled <EOL> def unpick_faiss ( pickled , embedding_func = None ) : <EOL> if not embedding_func : <EOL> embedding_func = embedding_model . function <EOL> docstore , index_to_docstore_id , idx = pickle . loads ( pickled ) <EOL> index = faiss . deserialize_index ( idx ) <EOL> db = FAISS ( embedding_func . embed_query , index , docstore , index_to_docstore_id ) <EOL> return db <EOL> def get_embedding_document ( file , mime ) : <EOL> loaders = { <EOL> '<STR_LIT>' : TextLoader , <EOL> '<STR_LIT>' : PyPDFLoader , <EOL> '<STR_LIT>' : Docx2txtLoader , <EOL> '<STR_LIT>' : UnstructuredPowerPointLoader , <EOL> } <EOL> loader", "gt": "= loaders [ mime ] ( file )", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> max_response_tokens = openai_model [ '<STR_LIT>' ] <EOL> if max_response_tokens > <NUM_LIT> : <EOL> max_response_tokens = <NUM_LIT> <EOL> self . _model = ChatOpenAI ( <EOL> api_key = api_key , <EOL> api_base = api_base , <EOL> model_name = openai_model [ '<STR_LIT>' ] , <EOL> max_tokens = max_response_tokens , <EOL> streaming = True , <EOL> ) <EOL> return self . _model <EOL> embedding_model = EmbeddingModel ( ) <EOL> chat_model = ChatModel ( ) <EOL> def pickle_faiss ( db ) : <EOL> idx = faiss . serialize_index ( db . index ) <EOL> pickled = pickle . dumps ( ( db . docstore , db . index_to_docstore_id , idx ) ) <EOL> return pickled <EOL> def unpick_faiss ( pickled , embedding_func = None ) : <EOL> if not embedding_func : <EOL> embedding_func = embedding_model . function <EOL> docstore , index_to_docstore_id , idx = pickle . loads ( pickled ) <EOL> index = faiss . deserialize_index ( idx ) <EOL> db = FAISS ( embedding_func . embed_query , index , docstore , index_to_docstore_id ) <EOL> return db <EOL> def get_embedding_document ( file , mime ) : <EOL> loaders = { <EOL> '<STR_LIT>' : TextLoader , <EOL> '<STR_LIT>' : PyPDFLoader , <EOL> '<STR_LIT>' : Docx2txtLoader , <EOL> '<STR_LIT>' : UnstructuredPowerPointLoader , <EOL> } <EOL> loader = loaders [ mime ] ( file ) <EOL> docs = loader . load ( ) <EOL> embeddings_function = embedding_model . function <EOL> for doc in docs : <EOL> hash_str = str ( hashlib . md5 ( str ( doc ) . encode ( ) ) . hexdigest ( ) ) <EOL> doc . metadata [ '<STR_LIT>' ] = hash_str <EOL> documents = text_splitter . split_documents ( docs ) <EOL> db = FAISS . from_documents ( documents , embeddings_function ) <EOL> return pickle_faiss ( db ) <EOL> condense_question_template = <EOL> MY_CONDENSE_QUESTION_PROMPT = PromptTemplate . from_template ( condense_question_template ) <EOL> def langchain_doc_chat ( messages ) : <EOL> db = messages [ '<STR_LIT>' ] <EOL> retriever = db . as_retriever ( <EOL> search_type = \"<STR_LIT>\" , <EOL> search_kwargs = { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } , <EOL> ) <EOL> memory = ConversationBufferWindowMemory ( memory_key = '<STR_LIT>' , return_messages = True , k = <NUM_LIT> ) <EOL> for msg in messages [ '<STR_LIT>' ] : <EOL> if msg . get ( '<STR_LIT>' , '<STR_LIT>' ) == '<STR_LIT>' : <EOL> memory . chat_memory . add_ai_message ( msg [ '<STR_LIT>' ] ) <EOL> else : <EOL> memory . chat_memory . add_user_message ( msg [ '<STR_LIT>' ] ) <EOL> question_generator = LLMChain ( <EOL> llm = chat_model . model , <EOL> prompt = MY_CONDENSE_QUESTION_PROMPT <EOL> ) <EOL> doc_chain = load_qa_chain ( <EOL> llm = chat_model . model , <EOL> chain_type = \"<STR_LIT>\" , <EOL> ) <EOL> chain = ConversationalRetrievalChain ( <EOL> retriever = retriever , <EOL> memory = memory , <EOL> question_generator = question_generator , <EOL> combine_docs_chain = doc_chain , <EOL> ) <EOL> results = [ ] <EOL> msgs = messages [ '<STR_LIT>' ] <EOL> q = msgs [ - <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> logger . debug ( q ) <EOL> OSC . send_token = False <EOL> async def do_chain ( ) : <EOL> result = await chain . acall ( <EOL> { '<STR_LIT>' : q } , <EOL> callbacks = [ OSC ] , <EOL> ) <EOL> _queue . put ( - <NUM_LIT> ) <EOL> return result <EOL> def ctx_mgr ( ) : <EOL> result = asyncio . run ( do_chain ( ) ) <EOL> results . append ( result ) <EOL> thread = threading . Thread ( target = ctx_mgr ) <EOL> thread . start ( ) <EOL> while True : <EOL> item = _queue . get ( ) <EOL> if", "gt": "item == - <NUM_LIT> :", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> max_response_tokens = openai_model [ '<STR_LIT>' ] <EOL> if max_response_tokens > <NUM_LIT> : <EOL> max_response_tokens = <NUM_LIT> <EOL> self . _model = ChatOpenAI ( <EOL> api_key = api_key , <EOL> api_base = api_base , <EOL> model_name = openai_model [ '<STR_LIT>' ] , <EOL> max_tokens = max_response_tokens , <EOL> streaming = True , <EOL> ) <EOL> return self . _model <EOL> embedding_model = EmbeddingModel ( ) <EOL> chat_model = ChatModel ( ) <EOL> def pickle_faiss ( db ) : <EOL> idx = faiss . serialize_index ( db . index ) <EOL> pickled = pickle . dumps ( ( db . docstore , db . index_to_docstore_id , idx ) ) <EOL> return pickled <EOL> def unpick_faiss ( pickled , embedding_func = None ) : <EOL> if not embedding_func : <EOL> embedding_func = embedding_model . function <EOL> docstore , index_to_docstore_id , idx = pickle . loads ( pickled ) <EOL> index = faiss . deserialize_index ( idx ) <EOL> db", "gt": "= FAISS ( embedding_func . embed_query , index , docstore , index_to_docstore_id )", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self", "gt": ". name = '<STR_LIT>'", "repo": "chatgpt-ui-server"}
{"input": "import requests <EOL> from typing import List <EOL> from bs4 import BeautifulSoup <EOL> from . search_abc import SearchRequest , SearchResponse , SearchResult <EOL> import os <EOL> proxies = None <EOL> for key in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> value = os . getenv ( key ) <EOL> if value : <EOL> proxies = { <EOL> '<STR_LIT>' : value , <EOL> '<STR_LIT>' : value , <EOL> } <EOL> break <EOL> BASE_URL = '<STR_LIT>' <EOL> def get_html ( search : SearchRequest ) -> SearchResponse : <EOL> query = search . query [ : <NUM_LIT> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : search . ua <EOL> } <EOL> data = { <EOL> '<STR_LIT>' : query , <EOL> '<STR_LIT>' : search . timerange , <EOL> '<STR_LIT>' : search . region , <EOL> } <EOL> response = requests . post ( f'<STR_LIT>' , headers = headers , data = data , proxies = proxies ) <EOL> if not response . ok : <EOL> raise Exception ( f'<STR_LIT>' ) <EOL> return", "gt": "SearchResponse ( response . status_code , response . text , response . url )", "repo": "chatgpt-ui-server"}
{"input": "from django . conf import settings <EOL> from django . contrib . auth import authenticate , get_user_model <EOL> from rest_framework import exceptions , serializers <EOL> UserModel = get_user_model ( ) <EOL> class UserDetailsSerializer ( serializers . ModelSerializer ) : <EOL> @ staticmethod <EOL> def validate_username ( username ) : <EOL> if '<STR_LIT>' not in settings . INSTALLED_APPS : <EOL> return username <EOL> from allauth . account . adapter import get_adapter <EOL> username = get_adapter ( ) . clean_username ( username ) <EOL> return username <EOL> class Meta : <EOL> extra_fields = [ ] <EOL> if hasattr ( UserModel , '<STR_LIT>' ) : <EOL> extra_fields . append ( UserModel . USERNAME_FIELD ) <EOL> if hasattr ( UserModel , '<STR_LIT>' ) : <EOL> extra_fields . append ( UserModel . EMAIL_FIELD ) <EOL> if", "gt": "hasattr ( UserModel , '<STR_LIT>' ) :", "repo": "chatgpt-ui-server"}
{"input": "import requests <EOL> from typing import List <EOL> from bs4 import BeautifulSoup <EOL> from . search_abc import SearchRequest , SearchResponse , SearchResult <EOL> import os <EOL> proxies = None <EOL> for key in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> value = os . getenv ( key ) <EOL> if value : <EOL> proxies = { <EOL> '<STR_LIT>' : value , <EOL> '<STR_LIT>' : value , <EOL> } <EOL> break <EOL> BASE_URL = '<STR_LIT>' <EOL> def get_html ( search : SearchRequest ) -> SearchResponse : <EOL> query = search . query [ : <NUM_LIT> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : search . ua <EOL> } <EOL> data = { <EOL> '<STR_LIT>' : query , <EOL> '<STR_LIT>' : search . timerange , <EOL> '<STR_LIT>' : search . region , <EOL> } <EOL> response = requests . post ( f'<STR_LIT>' , headers = headers , data = data , proxies = proxies ) <EOL> if not response . ok : <EOL> raise Exception ( f'<STR_LIT>' ) <EOL> return SearchResponse ( response . status_code , response . text , response . url ) <EOL> def html_to_search_results ( html : str , num_results : int ) -> List [ SearchResult ] : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> results = [ ] <EOL> zero_click_link = soup . select_one ( '<STR_LIT>' ) <EOL> if zero_click_link : <EOL> title = zero_click_link . text <EOL> body = soup . select_one ( '<STR_LIT>' ) . text . strip ( ) <EOL> url = zero_click_link [ '<STR_LIT>' ] <EOL> results . append ( SearchResult ( title , body , url ) ) <EOL> upper_bound = num_results - <NUM_LIT> if zero_click_link else num_results <EOL> web_links = soup . select ( '<STR_LIT>' ) [ : upper_bound ] <EOL> web_snippets = soup . select ( '<STR_LIT>' ) [ : upper_bound ] <EOL> for link , snippet in zip ( web_links , web_snippets ) : <EOL> title = link . text <EOL> body = snippet . text . strip ( ) <EOL> url = link [ '<STR_LIT>' ] <EOL> results . append ( SearchResult ( title , body , url ) ) <EOL> return results <EOL> def web_search ( search : SearchRequest , num_results : int ) -> List [ SearchResult ] : <EOL> response = get_html ( search ) <EOL> if response . url == f'<STR_LIT>' : <EOL> return html_to_search_results ( response . html , num_results ) <EOL> else : <EOL> raise", "gt": "Exception ( f'<STR_LIT>' )", "repo": "chatgpt-ui-server"}
{"input": "import requests <EOL> from typing import List <EOL> from bs4 import BeautifulSoup <EOL> from . search_abc import SearchRequest , SearchResponse , SearchResult <EOL> import os <EOL> proxies = None <EOL> for key in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> value = os . getenv ( key ) <EOL> if value : <EOL> proxies = { <EOL> '<STR_LIT>' : value , <EOL> '<STR_LIT>' : value , <EOL> } <EOL> break <EOL> BASE_URL = '<STR_LIT>' <EOL> def get_html ( search : SearchRequest ) -> SearchResponse : <EOL> query = search . query [ : <NUM_LIT> ] <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : search . ua <EOL> } <EOL> data = { <EOL> '<STR_LIT>' : query , <EOL> '<STR_LIT>' : search . timerange , <EOL> '<STR_LIT>' : search . region , <EOL> } <EOL> response = requests . post ( f'<STR_LIT>' , headers = headers , data = data , proxies = proxies ) <EOL> if not response . ok : <EOL> raise Exception ( f'<STR_LIT>' ) <EOL> return SearchResponse ( response . status_code , response . text , response . url ) <EOL> def html_to_search_results ( html : str , num_results : int ) -> List [ SearchResult ] : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> results = [ ] <EOL> zero_click_link = soup . select_one ( '<STR_LIT>' ) <EOL> if zero_click_link : <EOL> title = zero_click_link . text <EOL> body = soup . select_one ( '<STR_LIT>' ) . text . strip ( ) <EOL> url", "gt": "= zero_click_link [ '<STR_LIT>' ]", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> max_response_tokens = openai_model [ '<STR_LIT>' ] <EOL> if max_response_tokens > <NUM_LIT> : <EOL> max_response_tokens = <NUM_LIT> <EOL> self . _model = ChatOpenAI ( <EOL> api_key = api_key , <EOL> api_base = api_base , <EOL> model_name = openai_model [ '<STR_LIT>' ] , <EOL> max_tokens = max_response_tokens , <EOL> streaming = True , <EOL> ) <EOL> return self . _model <EOL> embedding_model = EmbeddingModel ( ) <EOL> chat_model = ChatModel ( ) <EOL> def pickle_faiss ( db ) : <EOL> idx = faiss . serialize_index ( db . index ) <EOL> pickled = pickle . dumps ( ( db . docstore , db . index_to_docstore_id , idx ) ) <EOL> return pickled <EOL> def unpick_faiss ( pickled , embedding_func = None ) : <EOL> if not embedding_func : <EOL> embedding_func", "gt": "= embedding_model . function", "repo": "chatgpt-ui-server"}
{"input": "from django . db import models <EOL> from rest_framework import serializers <EOL> from . models import Conversation , Message , Prompt , EmbeddingDocument , Setting <EOL> class ConversationSerializer ( serializers . ModelSerializer ) : <EOL> class Meta : <EOL> model = Conversation <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MessageSerializer ( serializers . ModelSerializer ) : <EOL> class Meta : <EOL> model = Message <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class PromptSerializer ( serializers . ModelSerializer ) : <EOL> prompt = serializers . CharField ( trim_whitespace = False , allow_blank = True ) <EOL> class Meta : <EOL> model = Prompt <EOL> fields", "gt": "= [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ]", "repo": "chatgpt-ui-server"}
{"input": "from django . db import models <EOL> from rest_framework import serializers <EOL> from . models import Conversation , Message , Prompt , EmbeddingDocument , Setting <EOL> class ConversationSerializer ( serializers . ModelSerializer ) : <EOL> class Meta : <EOL> model = Conversation <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class MessageSerializer ( serializers . ModelSerializer ) : <EOL> class Meta : <EOL> model = Message <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class PromptSerializer ( serializers . ModelSerializer ) : <EOL> prompt = serializers . CharField ( trim_whitespace = False , allow_blank = True ) <EOL> class Meta : <EOL> model = Prompt <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class EmbeddingDocumentSerializer ( serializers . ModelSerializer ) : <EOL> class Meta : <EOL> model = EmbeddingDocument <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> read_only_fields = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> class SettingSerializer ( serializers . ModelSerializer ) : <EOL> class Meta : <EOL> model = Setting <EOL> fields", "gt": "= ( '<STR_LIT>' , '<STR_LIT>' )", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import threading <EOL> import queue <EOL> import pickle <EOL> from typing import Any , Dict , Optional , Union , Mapping <EOL> import uuid <EOL> from uuid import UUID <EOL> import faiss <EOL> import hashlib <EOL> import openai <EOL> from langchain . document_loaders import ( <EOL> TextLoader , <EOL> PyPDFLoader , <EOL> Docx2txtLoader , <EOL> UnstructuredPowerPointLoader , <EOL> ) <EOL> from langchain . text_splitter import RecursiveCharacterTextSplitter <EOL> from langchain . embeddings . openai import OpenAIEmbeddings <EOL> from langchain . vectorstores import FAISS <EOL> from langchain . prompts . prompt import PromptTemplate <EOL> from langchain . chat_models import ChatOpenAI <EOL> from langchain . schema import ( <EOL> AIMessage , <EOL> HumanMessage , <EOL> SystemMessage , <EOL> ChatGeneration , <EOL> ChatResult , <EOL> ) <EOL> from langchain . chains import ( <EOL> LLMChain , <EOL> ConversationalRetrievalChain , <EOL> ) <EOL> from langchain . chains . question_answering import load_qa_chain <EOL> from langchain . chains . conversational_retrieval . prompts import CONDENSE_QUESTION_PROMPT <EOL> from langchain . memory import ConversationBufferWindowMemory <EOL> from langchain . callbacks import get_openai_callback <EOL> from langchain . callbacks . streaming_stdout import StreamingStdOutCallbackHandler <EOL> from langchain . callbacks . base import ( <EOL> BaseCallbackHandler , <EOL> AsyncCallbackHandler , <EOL> ) <EOL> from langchain . callbacks . manager import ( <EOL> CallbackManagerForChainRun , <EOL> AsyncCallbackManagerForChainRun , <EOL> ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> text_splitter = RecursiveCharacterTextSplitter . from_tiktoken_encoder ( chunk_size = <NUM_LIT> , chunk_overlap = <NUM_LIT> ) <EOL> embedding_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_env = { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> openai_model = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> _queue = queue . Queue ( ) <EOL> def setup_openai_env ( api_base = None , api_key = None ) : <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_base <EOL> if not openai_env [ '<STR_LIT>' ] : <EOL> openai_env [ '<STR_LIT>' ] = api_key <EOL> openai . api_base = openai_env [ '<STR_LIT>' ] <EOL> openai . api_key = openai_env [ '<STR_LIT>' ] <EOL> openai . api_version = None <EOL> return ( openai_env [ '<STR_LIT>' ] , openai_env [ '<STR_LIT>' ] ) <EOL> def setup_openai_model ( model ) : <EOL> logger . debug ( model ) <EOL> openai_model . update ( model ) <EOL> logger . debug ( model ) <EOL> class OutputStreamingCallbackHandler ( BaseCallbackHandler ) : <EOL> send_token : bool = False <EOL> def on_llm_new_token ( self , token : str , ** kwargs : Any ) -> None : <EOL> if self . send_token : <EOL> _queue . put ( token ) <EOL> def on_chain_start ( self , serialized , inputs , ** kwargs ) -> Any : <EOL> logger . debug ( '<STR_LIT>' , serialized ) <EOL> if serialized [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . send_token = True <EOL> def on_chain_end ( self , outputs : Dict [ str , Any ] , * , run_id : UUID , parent_run_id : Optional [ UUID ] = None , ** kwargs : Any , ) -> None : <EOL> def on_llm_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> def on_chain_error ( self , error : Union [ Exception , KeyboardInterrupt ] , ** kwargs : Any ) -> None : <EOL> _queue . put ( - <NUM_LIT> ) <EOL> OSC = OutputStreamingCallbackHandler ( ) <EOL> class EmbeddingModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _function = None <EOL> @ property <EOL> def function ( self ) : <EOL> if not self . _function : <EOL> setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> self . _function = OpenAIEmbeddings ( ) <EOL> return self . _function <EOL> class ChatModel : <EOL> def __init__ ( self ) : <EOL> self . name = None <EOL> self . _model = None <EOL> @ property <EOL> def model ( self ) : <EOL> if not self . _model : <EOL> api_base , api_key = setup_openai_env ( ) <EOL> self . name = '<STR_LIT>' <EOL> max_response_tokens = openai_model [ '<STR_LIT>' ] <EOL> if max_response_tokens > <NUM_LIT> : <EOL> max_response_tokens = <NUM_LIT> <EOL> self . _model = ChatOpenAI ( <EOL> api_key = api_key , <EOL> api_base = api_base , <EOL> model_name = openai_model [ '<STR_LIT>' ] , <EOL> max_tokens = max_response_tokens , <EOL> streaming = True , <EOL> ) <EOL> return self . _model <EOL> embedding_model = EmbeddingModel ( ) <EOL> chat_model = ChatModel ( ) <EOL> def pickle_faiss ( db ) : <EOL> idx = faiss . serialize_index ( db . index ) <EOL> pickled = pickle . dumps ( ( db . docstore , db . index_to_docstore_id , idx ) ) <EOL> return pickled <EOL> def unpick_faiss ( pickled , embedding_func = None ) : <EOL> if not embedding_func : <EOL> embedding_func = embedding_model . function <EOL> docstore , index_to_docstore_id , idx = pickle . loads ( pickled ) <EOL> index = faiss . deserialize_index ( idx ) <EOL> db = FAISS ( embedding_func . embed_query , index , docstore , index_to_docstore_id ) <EOL> return db <EOL> def get_embedding_document ( file , mime ) : <EOL> loaders = { <EOL> '<STR_LIT>' : TextLoader , <EOL> '<STR_LIT>' : PyPDFLoader , <EOL> '<STR_LIT>' : Docx2txtLoader , <EOL> '<STR_LIT>' : UnstructuredPowerPointLoader , <EOL> } <EOL> loader = loaders [ mime ] ( file ) <EOL> docs = loader . load ( ) <EOL> embeddings_function = embedding_model . function <EOL> for doc in docs : <EOL> hash_str = str ( hashlib . md5 ( str ( doc ) . encode ( ) ) . hexdigest ( ) ) <EOL> doc . metadata [ '<STR_LIT>' ] = hash_str <EOL> documents = text_splitter . split_documents ( docs ) <EOL> db = FAISS . from_documents ( documents , embeddings_function ) <EOL> return pickle_faiss ( db ) <EOL> condense_question_template = <EOL> MY_CONDENSE_QUESTION_PROMPT = PromptTemplate . from_template ( condense_question_template ) <EOL> def langchain_doc_chat ( messages ) : <EOL> db", "gt": "= messages [ '<STR_LIT>' ]", "repo": "chatgpt-ui-server"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from django . core . wsgi import get_wsgi_application <EOL> BASE_DIR = Path ( __file__ ) . resolve ( strict = True ) . parent . parent <EOL> sys . path . append ( str ( BASE_DIR / \"<STR_LIT>\" ) ) <EOL> os", "gt": ". environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" )", "repo": "Delphic"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from django . core . wsgi import get_wsgi_application <EOL> BASE_DIR = Path ( __file__ ) . resolve ( strict = True ) . parent . parent <EOL> sys", "gt": ". path . append ( str ( BASE_DIR / \"<STR_LIT>\" ) )", "repo": "Delphic"}
{"input": "from django . contrib import admin <EOL> from . models import Collection , Document <EOL> class DocumentInline ( admin . StackedInline ) : <EOL> model = Document <EOL> extra = <NUM_LIT> <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class CollectionAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , ) <EOL> search_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> fields = ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> readonly_fields", "gt": "= ( \"<STR_LIT>\" , \"<STR_LIT>\" )", "repo": "Delphic"}
{"input": "__version__ = \"<STR_LIT>\" <EOL> __version_info__ = tuple ( <EOL> int", "gt": "( num ) if num . isdigit ( ) else num", "repo": "Delphic"}
{"input": "from . base import * <EOL> from . base import env <EOL> SECRET_KEY = env ( <EOL> \"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> TEST_RUNNER = \"<STR_LIT>\" <EOL> PASSWORD_HASHERS = [ \"<STR_LIT>\" ] <EOL> EMAIL_BACKEND = \"<STR_LIT>\" <EOL> TEMPLATES [ <NUM_LIT> ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] = True <EOL> ALLOWED_HOSTS", "gt": "= [ \"<STR_LIT>\" ]", "repo": "Delphic"}
{"input": "from . base import * <EOL> from . base import env <EOL> SECRET_KEY = env ( <EOL> \"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> TEST_RUNNER = \"<STR_LIT>\" <EOL> PASSWORD_HASHERS", "gt": "= [ \"<STR_LIT>\" ]", "repo": "Delphic"}
{"input": "from django . contrib import admin <EOL> from . models import Collection , Document <EOL> class DocumentInline ( admin . StackedInline ) : <EOL> model = Document <EOL> extra = <NUM_LIT> <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class CollectionAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , ) <EOL> search_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> fields = ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> inlines = [ DocumentInline ] <EOL> admin . site . register ( Collection , CollectionAdmin ) <EOL> class DocumentAdmin ( admin . ModelAdmin ) : <EOL> list_display", "gt": "= ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" )", "repo": "Delphic"}
{"input": "from django . contrib import admin <EOL> from . models import Collection , Document <EOL> class DocumentInline ( admin . StackedInline ) : <EOL> model = Document <EOL> extra = <NUM_LIT> <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class CollectionAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , ) <EOL> search_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> fields = ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> inlines = [ DocumentInline ] <EOL> admin", "gt": ". site . register ( Collection , CollectionAdmin )", "repo": "Delphic"}
{"input": "from django . contrib import admin <EOL> from . models import Collection , Document <EOL> class DocumentInline ( admin . StackedInline ) : <EOL> model = Document <EOL> extra = <NUM_LIT> <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class CollectionAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , ) <EOL> search_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> fields = ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> inlines = [ DocumentInline ] <EOL> admin . site . register ( Collection , CollectionAdmin ) <EOL> class DocumentAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> search_fields", "gt": "= ( \"<STR_LIT>\" , )", "repo": "Delphic"}
{"input": "from . base import * <EOL> from . base import env <EOL> SECRET_KEY = env ( <EOL> \"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> ) <EOL> TEST_RUNNER = \"<STR_LIT>\" <EOL> PASSWORD_HASHERS = [ \"<STR_LIT>\" ] <EOL> EMAIL_BACKEND = \"<STR_LIT>\" <EOL> TEMPLATES", "gt": "[ <NUM_LIT> ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] = True", "repo": "Delphic"}
{"input": "__version__ = \"<STR_LIT>\" <EOL> __version_info__ = tuple ( <EOL> int ( num ) if num . isdigit ( ) else num <EOL> for", "gt": "num in __version__ . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT> ) . split ( \"<STR_LIT>\" )", "repo": "Delphic"}
{"input": "from django . contrib import admin <EOL> from . models import Collection , Document <EOL> class DocumentInline ( admin . StackedInline ) : <EOL> model = Document <EOL> extra = <NUM_LIT> <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class CollectionAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , ) <EOL> search_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> fields = ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> inlines = [ DocumentInline ] <EOL> admin . site . register ( Collection , CollectionAdmin ) <EOL> class DocumentAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> search_fields = ( \"<STR_LIT>\" , ) <EOL> fields", "gt": "= ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" )", "repo": "Delphic"}
{"input": "from django . contrib import admin <EOL> from . models import Collection , Document <EOL> class DocumentInline ( admin . StackedInline ) : <EOL> model = Document <EOL> extra = <NUM_LIT> <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class CollectionAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , ) <EOL> search_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> fields = ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> inlines = [ DocumentInline ] <EOL> admin . site . register ( Collection , CollectionAdmin ) <EOL> class DocumentAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter", "gt": "= ( \"<STR_LIT>\" , \"<STR_LIT>\" )", "repo": "Delphic"}
{"input": "from django . contrib import admin <EOL> from . models import Collection , Document <EOL> class DocumentInline ( admin . StackedInline ) : <EOL> model = Document <EOL> extra = <NUM_LIT> <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class CollectionAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , ) <EOL> search_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> fields = ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> inlines", "gt": "= [ DocumentInline ]", "repo": "Delphic"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from django . core . wsgi import get_wsgi_application <EOL> BASE_DIR", "gt": "= Path ( __file__ ) . resolve ( strict = True ) . parent . parent", "repo": "Delphic"}
{"input": "from django . contrib import admin <EOL> from . models import Collection , Document <EOL> class DocumentInline ( admin . StackedInline ) : <EOL> model = Document <EOL> extra = <NUM_LIT> <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class CollectionAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , ) <EOL> search_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> fields = ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> inlines = [ DocumentInline ] <EOL> admin . site . register ( Collection , CollectionAdmin ) <EOL> class DocumentAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> search_fields = ( \"<STR_LIT>\" , ) <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields", "gt": "= ( \"<STR_LIT>\" , \"<STR_LIT>\" )", "repo": "Delphic"}
{"input": "import os <EOL> import sys <EOL> from pathlib import Path <EOL> from django . core . wsgi import get_wsgi_application <EOL> BASE_DIR = Path ( __file__ ) . resolve ( strict = True ) . parent . parent <EOL> sys . path . append ( str ( BASE_DIR / \"<STR_LIT>\" ) ) <EOL> os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> application", "gt": "= get_wsgi_application ( )", "repo": "Delphic"}
{"input": "from django . contrib import admin <EOL> from . models import Collection , Document <EOL> class DocumentInline ( admin . StackedInline ) : <EOL> model = Document <EOL> extra = <NUM_LIT> <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class CollectionAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , ) <EOL> search_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> fields = ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> inlines = [ DocumentInline ] <EOL> admin . site . register ( Collection , CollectionAdmin ) <EOL> class", "gt": "DocumentAdmin ( admin . ModelAdmin ) :", "repo": "Delphic"}
{"input": "from django . contrib import admin <EOL> from . models import Collection , Document <EOL> class DocumentInline ( admin . StackedInline ) : <EOL> model = Document <EOL> extra = <NUM_LIT> <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class CollectionAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , ) <EOL> search_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> fields = ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> inlines = [ DocumentInline ] <EOL> admin . site . register ( Collection , CollectionAdmin ) <EOL> class DocumentAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> list_filter = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> search_fields = ( \"<STR_LIT>\" , ) <EOL> fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> readonly_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> admin", "gt": ". site . register ( Document , DocumentAdmin )", "repo": "Delphic"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\"", "gt": ": app [ \"<STR_LIT>\" ] ,", "repo": "django-admin-site-search"}
{"input": "from django . contrib . auth . models import User <EOL> from django . core . management import BaseCommand <EOL> from django . db import IntegrityError <EOL> from dev . football . players . factories import PlayerAttributesFactory , PlayerFactory <EOL> from dev . football . stadiums . factories import PitchFactory , StadiumFactory <EOL> from dev . football . teams . factories import SquadFactory , TeamFactory <EOL> from dev . football . teams . models import Team <EOL> USERNAME = \"<STR_LIT>\" <EOL> PASSWORD = \"<STR_LIT>\" <EOL> TEAM_1 = \"<STR_LIT>\" <EOL> TEAM_2 = \"<STR_LIT>\" <EOL> class Command ( BaseCommand ) : <EOL> help = \"<STR_LIT>\" <EOL> def handle ( self , * args , ** options ) : <EOL> self . stdout . write ( f\"<STR_LIT>\" ) <EOL> try : <EOL> User . objects . create_superuser ( username = USERNAME , password = PASSWORD ) <EOL> self . stdout . write ( self . style . SUCCESS ( f'<STR_LIT>' ) ) <EOL> except IntegrityError : <EOL> self . stdout . write ( self . style . WARNING ( f'<STR_LIT>' ) ) <EOL> self . stdout . write ( f\"<STR_LIT>\" ) <EOL> for", "gt": "name in [ TEAM_1 , TEAM_2 ] :", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts", "gt": "[ \"<STR_LIT>\" ] += <NUM_LIT>", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except", "gt": "Exception as ex :", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results [ \"<STR_LIT>\" ] . append ( app_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> return JsonResponse ( { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } ) <EOL> def", "gt": "match_app ( self , query : str , name : str ) -> bool :", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results [ \"<STR_LIT>\" ] . append ( app_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> return JsonResponse ( { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } ) <EOL> def match_app ( self , query : str , name : str ) -> bool : <EOL> return query . lower ( ) in name . lower ( ) <EOL> def match_model ( <EOL> self , query : str , name : str , object_name : str , fields : List [ Field ] <EOL> ) -> bool : <EOL> _query = query . lower ( ) <EOL> if _query in name . lower ( ) or _query in object_name . lower ( ) : <EOL> return True <EOL> for", "gt": "field in fields :", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\"", "gt": ": str ( obj ) ,", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results [ \"<STR_LIT>\" ] . append ( app_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> return JsonResponse ( { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } ) <EOL> def match_app ( self , query : str , name : str ) -> bool : <EOL> return query . lower ( ) in name . lower ( ) <EOL> def match_model ( <EOL> self , query : str , name : str , object_name : str , fields : List [ Field ] <EOL> ) -> bool : <EOL> _query = query . lower ( ) <EOL> if _query in name . lower ( ) or _query in object_name . lower ( ) : <EOL> return True <EOL> for field in fields : <EOL> verbose_name = getattr ( field , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> help_text = getattr ( field , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if _query in field . name or _query in verbose_name or _query in help_text : <EOL> return True <EOL> return False <EOL> def match_objects ( <EOL> self , query : str , model_class : Model , model_fields : List [ Field ] <EOL> ) -> QuerySet : <EOL> filters = Q ( ) <EOL> for field in model_fields : <EOL> filter_ = self . filter_field ( query , field ) <EOL> if filter_ : <EOL> filters |= filter_ <EOL> if filters : <EOL> results = model_class . objects . filter ( filters ) [ : <NUM_LIT> ] <EOL> else : <EOL> results = model_class . objects . none ( ) <EOL> return results <EOL> def filter_field ( self , query : str , field : Field ) -> Optional [ Q ] : <EOL> if isinstance ( field , CharField ) : <EOL> return Q ( ** { f\"<STR_LIT>\" : query } ) <EOL> def", "gt": "get_model_class ( self , app_label : str , model_dict : dict ) -> Optional [ Model ] :", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results [ \"<STR_LIT>\" ] . append ( app_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> return JsonResponse ( { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } ) <EOL> def match_app ( self , query : str , name : str ) -> bool : <EOL> return query . lower ( ) in name . lower ( ) <EOL> def match_model ( <EOL> self , query : str , name : str , object_name : str , fields : List [ Field ] <EOL> ) -> bool : <EOL> _query", "gt": "= query . lower ( )", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results [ \"<STR_LIT>\" ] . append ( app_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> return JsonResponse ( { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } ) <EOL> def match_app ( self , query : str , name : str ) -> bool : <EOL> return query . lower ( ) in name . lower ( ) <EOL> def match_model ( <EOL> self , query : str , name : str , object_name : str , fields : List [ Field ] <EOL> ) -> bool : <EOL> _query = query . lower ( ) <EOL> if _query in name . lower ( ) or _query in object_name . lower ( ) : <EOL> return True <EOL> for field in fields : <EOL> verbose_name = getattr ( field , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> help_text = getattr ( field , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if _query in field . name or _query in verbose_name or _query in help_text : <EOL> return True <EOL> return False <EOL> def match_objects ( <EOL> self , query : str , model_class : Model , model_fields : List [ Field ] <EOL> ) -> QuerySet : <EOL> filters = Q ( ) <EOL> for field in model_fields : <EOL> filter_ = self . filter_field ( query , field ) <EOL> if filter_ : <EOL> filters |= filter_ <EOL> if filters : <EOL> results = model_class . objects . filter ( filters ) [ : <NUM_LIT> ] <EOL> else : <EOL> results = model_class . objects . none ( ) <EOL> return results <EOL> def filter_field ( self , query : str , field : Field ) -> Optional [ Q ] : <EOL> if", "gt": "isinstance ( field , CharField ) :", "repo": "django-admin-site-search"}
{"input": "from django . contrib . auth . models import User <EOL> from django . core . management import BaseCommand <EOL> from django . db import IntegrityError <EOL> from dev . football . players . factories import PlayerAttributesFactory , PlayerFactory <EOL> from dev . football . stadiums . factories import PitchFactory , StadiumFactory <EOL> from dev . football . teams . factories import SquadFactory , TeamFactory <EOL> from dev . football . teams . models import Team <EOL> USERNAME = \"<STR_LIT>\" <EOL> PASSWORD = \"<STR_LIT>\" <EOL> TEAM_1 = \"<STR_LIT>\" <EOL> TEAM_2 = \"<STR_LIT>\" <EOL> class Command ( BaseCommand ) : <EOL> help = \"<STR_LIT>\" <EOL> def handle ( self , * args , ** options ) : <EOL> self . stdout . write ( f\"<STR_LIT>\" ) <EOL> try : <EOL> User . objects . create_superuser ( username = USERNAME , password = PASSWORD ) <EOL> self . stdout . write ( self . style . SUCCESS ( f'<STR_LIT>' ) ) <EOL> except IntegrityError : <EOL> self . stdout . write ( self . style . WARNING ( f'<STR_LIT>' ) ) <EOL> self . stdout . write ( f\"<STR_LIT>\" ) <EOL> for name in [ TEAM_1 , TEAM_2 ] : <EOL> team = Team . objects . filter ( name = name ) . first ( ) <EOL> if not team : <EOL> TeamFactory ( name = name ) <EOL> self . stdout . write ( self . style . SUCCESS ( f'<STR_LIT>' ) ) <EOL> else : <EOL> self . stdout . write ( self . style . WARNING ( f'<STR_LIT>' ) ) <EOL> self", "gt": ". stdout . write ( f\"<STR_LIT>\" )", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results [ \"<STR_LIT>\" ] . append ( app_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> return", "gt": "JsonResponse ( { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } )", "repo": "django-admin-site-search"}
{"input": "from factory import SubFactory , django , fuzzy <EOL> from dev . football . players . models import Player , PlayerAttributes <EOL> class PlayerFactory ( django . DjangoModelFactory ) : <EOL> name = fuzzy . FuzzyText ( ) <EOL> key = fuzzy . FuzzyText ( ) <EOL> class Meta : <EOL> model = Player <EOL> class PlayerAttributesFactory ( django . DjangoModelFactory ) : <EOL> player = SubFactory ( PlayerFactory ) <EOL> position = \"<STR_LIT>\" <EOL> age", "gt": "= fuzzy . FuzzyInteger ( low = <NUM_LIT> , high = <NUM_LIT> )", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if", "gt": "app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) :", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results", "gt": "[ \"<STR_LIT>\" ] . append ( app_result )", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results [ \"<STR_LIT>\" ] . append ( app_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> return JsonResponse ( { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } ) <EOL> def match_app ( self , query : str , name : str ) -> bool : <EOL> return query . lower ( ) in name . lower ( ) <EOL> def match_model ( <EOL> self , query : str , name : str , object_name : str , fields : List [ Field ] <EOL> ) -> bool : <EOL> _query = query . lower ( ) <EOL> if", "gt": "_query in name . lower ( ) or _query in object_name . lower ( ) :", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results [ \"<STR_LIT>\" ] . append ( app_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> return JsonResponse ( { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } ) <EOL> def match_app ( self , query : str , name : str ) -> bool : <EOL> return query . lower ( ) in name . lower ( ) <EOL> def match_model ( <EOL> self , query : str , name : str , object_name : str , fields : List [ Field ] <EOL> ) -> bool : <EOL> _query = query . lower ( ) <EOL> if _query in name . lower ( ) or _query in object_name . lower ( ) : <EOL> return True <EOL> for field in fields : <EOL> verbose_name = getattr ( field , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> help_text = getattr ( field , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if _query in field . name or _query in verbose_name or _query in help_text : <EOL> return True <EOL> return False <EOL> def match_objects ( <EOL> self , query : str , model_class : Model , model_fields : List [ Field ] <EOL> ) -> QuerySet : <EOL> filters = Q ( ) <EOL> for field in model_fields : <EOL> filter_ = self . filter_field ( query , field ) <EOL> if filter_ : <EOL> filters |= filter_ <EOL> if filters : <EOL> results = model_class . objects . filter ( filters ) [ : <NUM_LIT> ] <EOL> else : <EOL> results", "gt": "= model_class . objects . none ( )", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results [ \"<STR_LIT>\" ] . append ( app_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> return JsonResponse ( { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } ) <EOL> def match_app ( self , query : str , name : str ) -> bool : <EOL> return query . lower ( ) in name . lower ( ) <EOL> def match_model ( <EOL> self", "gt": ", query : str , name : str , object_name : str , fields : List [ Field ]", "repo": "django-admin-site-search"}
{"input": "from django . contrib . auth . models import User <EOL> from django . core . management import BaseCommand <EOL> from django . db import IntegrityError <EOL> from dev . football . players . factories import PlayerAttributesFactory , PlayerFactory <EOL> from dev . football . stadiums . factories import PitchFactory , StadiumFactory <EOL> from dev . football . teams . factories import SquadFactory , TeamFactory <EOL> from dev . football . teams . models import Team <EOL> USERNAME = \"<STR_LIT>\" <EOL> PASSWORD = \"<STR_LIT>\" <EOL> TEAM_1 = \"<STR_LIT>\" <EOL> TEAM_2 = \"<STR_LIT>\" <EOL> class Command ( BaseCommand ) : <EOL> help = \"<STR_LIT>\" <EOL> def handle ( self , * args , ** options ) : <EOL> self . stdout . write ( f\"<STR_LIT>\" ) <EOL> try : <EOL> User . objects . create_superuser ( username = USERNAME , password = PASSWORD ) <EOL> self . stdout . write ( self . style . SUCCESS ( f'<STR_LIT>' ) ) <EOL> except IntegrityError : <EOL> self", "gt": ". stdout . write ( self . style . WARNING ( f'<STR_LIT>' ) )", "repo": "django-admin-site-search"}
{"input": "from django . contrib . auth . models import User <EOL> from django . core . management import BaseCommand <EOL> from django . db import IntegrityError <EOL> from dev . football . players . factories import PlayerAttributesFactory , PlayerFactory <EOL> from dev . football . stadiums . factories import PitchFactory , StadiumFactory <EOL> from dev . football . teams . factories import SquadFactory , TeamFactory <EOL> from dev . football . teams . models import Team <EOL> USERNAME = \"<STR_LIT>\" <EOL> PASSWORD = \"<STR_LIT>\" <EOL> TEAM_1 = \"<STR_LIT>\" <EOL> TEAM_2 = \"<STR_LIT>\" <EOL> class Command ( BaseCommand ) : <EOL> help = \"<STR_LIT>\" <EOL> def handle ( self , * args , ** options ) : <EOL> self . stdout . write ( f\"<STR_LIT>\" ) <EOL> try : <EOL> User . objects . create_superuser ( username = USERNAME , password = PASSWORD ) <EOL> self . stdout . write ( self . style . SUCCESS ( f'<STR_LIT>' ) ) <EOL> except IntegrityError : <EOL> self . stdout . write ( self . style . WARNING ( f'<STR_LIT>' ) ) <EOL> self . stdout . write ( f\"<STR_LIT>\" ) <EOL> for name in [ TEAM_1 , TEAM_2 ] : <EOL> team = Team . objects . filter ( name = name ) . first ( ) <EOL> if not team : <EOL> TeamFactory ( name = name ) <EOL> self . stdout . write ( self . style . SUCCESS ( f'<STR_LIT>' ) ) <EOL> else : <EOL> self . stdout . write ( self . style . WARNING ( f'<STR_LIT>' ) ) <EOL> self . stdout . write ( f\"<STR_LIT>\" ) <EOL> for factory in [ <EOL> PlayerFactory , <EOL> PlayerAttributesFactory , <EOL> StadiumFactory , <EOL> PitchFactory , <EOL> TeamFactory , <EOL> SquadFactory , <EOL> ] : <EOL> obj = factory ( ) <EOL> self", "gt": ". stdout . write ( self . style . SUCCESS ( f'<STR_LIT>' ) )", "repo": "django-admin-site-search"}
{"input": "from factory import SubFactory , django , fuzzy <EOL> from dev . football . players . models import Player , PlayerAttributes <EOL> class PlayerFactory ( django . DjangoModelFactory ) : <EOL> name = fuzzy . FuzzyText ( ) <EOL> key = fuzzy . FuzzyText ( ) <EOL> class Meta : <EOL> model = Player <EOL> class PlayerAttributesFactory ( django . DjangoModelFactory ) : <EOL> player = SubFactory ( PlayerFactory ) <EOL> position = \"<STR_LIT>\" <EOL> age = fuzzy . FuzzyInteger ( low = <NUM_LIT> , high = <NUM_LIT> ) <EOL> nationality = \"<STR_LIT>\" <EOL> score_defence = fuzzy . FuzzyInteger ( low = <NUM_LIT> , high = <NUM_LIT> ) <EOL> score_midfield = fuzzy . FuzzyInteger ( low = <NUM_LIT> , high = <NUM_LIT> ) <EOL> score_offence", "gt": "= fuzzy . FuzzyInteger ( low = <NUM_LIT> , high = <NUM_LIT> )", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\"", "gt": ": model [ \"<STR_LIT>\" ] ,", "repo": "django-admin-site-search"}
{"input": "from factory import SubFactory , django , fuzzy <EOL> from dev . football . players . models import Player , PlayerAttributes <EOL> class PlayerFactory ( django . DjangoModelFactory ) : <EOL> name = fuzzy . FuzzyText ( ) <EOL> key = fuzzy . FuzzyText ( ) <EOL> class Meta : <EOL> model = Player <EOL> class PlayerAttributesFactory ( django . DjangoModelFactory ) : <EOL> player = SubFactory ( PlayerFactory ) <EOL> position = \"<STR_LIT>\" <EOL> age = fuzzy . FuzzyInteger ( low = <NUM_LIT> , high = <NUM_LIT> ) <EOL> nationality = \"<STR_LIT>\" <EOL> score_defence = fuzzy . FuzzyInteger ( low = <NUM_LIT> , high = <NUM_LIT> ) <EOL> score_midfield", "gt": "= fuzzy . FuzzyInteger ( low = <NUM_LIT> , high = <NUM_LIT> )", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results [ \"<STR_LIT>\" ] . append ( app_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> return JsonResponse ( { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } ) <EOL> def match_app ( self , query : str , name : str ) -> bool : <EOL> return query . lower ( ) in name . lower ( ) <EOL> def match_model ( <EOL> self , query : str , name : str , object_name : str , fields : List [ Field ] <EOL> ) -> bool : <EOL> _query = query . lower ( ) <EOL> if _query in name . lower ( ) or _query in object_name . lower ( ) : <EOL> return True <EOL> for field in fields : <EOL> verbose_name = getattr ( field , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> help_text = getattr ( field , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if _query in field . name or _query in verbose_name or _query in help_text : <EOL> return True <EOL> return False <EOL> def match_objects ( <EOL> self , query : str , model_class : Model , model_fields : List [ Field ] <EOL> ) -> QuerySet : <EOL> filters = Q ( ) <EOL> for field in model_fields : <EOL> filter_ = self . filter_field ( query , field ) <EOL> if filter_ : <EOL> filters |= filter_ <EOL> if filters : <EOL> results = model_class . objects . filter ( filters ) [ : <NUM_LIT> ] <EOL> else : <EOL> results = model_class . objects . none ( ) <EOL> return results <EOL> def", "gt": "filter_field ( self , query : str , field : Field ) -> Optional [ Q ] :", "repo": "django-admin-site-search"}
{"input": "from typing import List , Optional <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from django . db . models import CharField , Field , Model , Q , QuerySet <EOL> from django . http import JsonResponse <EOL> from django . urls import path <EOL> class AdminSiteSearchView : <EOL> site_search_path = \"<STR_LIT>\" <EOL> def get_urls ( self ) : <EOL> urlpatterns = super ( ) . get_urls ( ) <EOL> search = path ( <EOL> self . site_search_path , self . admin_view ( self . search ) , name = \"<STR_LIT>\" <EOL> ) <EOL> urlpatterns . insert ( <NUM_LIT> , search ) <EOL> return urlpatterns <EOL> def search ( self , request ) : <EOL> query = request . GET . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) <EOL> results = { \"<STR_LIT>\" : [ ] } <EOL> counts = { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } <EOL> errors = [ ] <EOL> if not query : <EOL> return JsonResponse ( <EOL> { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } <EOL> ) <EOL> app_list = self . get_app_list ( request ) <EOL> for app in app_list : <EOL> app_result = { <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] if app [ \"<STR_LIT>\" ] else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for model in app [ \"<STR_LIT>\" ] : <EOL> try : <EOL> can_view = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> can_add = model [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> if not can_view : <EOL> continue <EOL> model_class = self . get_model_class ( app [ \"<STR_LIT>\" ] , model ) <EOL> if not model_class : <EOL> continue <EOL> fields = model_class . _meta . get_fields ( ) <EOL> objects = self . match_objects ( query , model_class , fields ) <EOL> if not objects and not self . match_model ( <EOL> query , model [ \"<STR_LIT>\" ] , model [ \"<STR_LIT>\" ] , fields <EOL> ) : <EOL> continue <EOL> model_result = { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] if can_add else None , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> for obj in objects : <EOL> object_result = { <EOL> \"<STR_LIT>\" : str ( obj . pk ) , <EOL> \"<STR_LIT>\" : str ( obj ) , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> } <EOL> model_result [ \"<STR_LIT>\" ] . append ( object_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> app_result [ \"<STR_LIT>\" ] . append ( model_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> except Exception as ex : <EOL> if settings . DEBUG : <EOL> errors . append ( <EOL> { <EOL> \"<STR_LIT>\" : repr ( ex ) , <EOL> \"<STR_LIT>\" : str ( ex ) , <EOL> \"<STR_LIT>\" : app [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : model [ \"<STR_LIT>\" ] , <EOL> } <EOL> ) <EOL> continue <EOL> if app_result [ \"<STR_LIT>\" ] or self . match_app ( query , app [ \"<STR_LIT>\" ] ) : <EOL> results [ \"<STR_LIT>\" ] . append ( app_result ) <EOL> counts [ \"<STR_LIT>\" ] += <NUM_LIT> <EOL> return JsonResponse ( { \"<STR_LIT>\" : results , \"<STR_LIT>\" : counts , \"<STR_LIT>\" : errors } ) <EOL> def match_app ( self , query : str , name : str ) -> bool : <EOL> return query . lower ( ) in name . lower ( ) <EOL> def match_model ( <EOL> self , query : str , name : str , object_name : str , fields : List [ Field ] <EOL> ) -> bool : <EOL> _query = query . lower ( ) <EOL> if _query in name . lower ( ) or _query in object_name . lower ( ) : <EOL> return True <EOL> for field in fields : <EOL> verbose_name = getattr ( field , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> help_text", "gt": "= getattr ( field , \"<STR_LIT>\" , \"<STR_LIT>\" )", "repo": "django-admin-site-search"}
{"input": "from django . conf . urls import url <EOL> from django . contrib import admin <EOL> from django . urls import path , include , re_path <EOL> from django . views . static import serve <EOL> from django . views . generic import TemplateView <EOL> from score_server import settings <EOL> urlpatterns = [ <EOL> path ( '<STR_LIT>' , admin . site . urls ) , <EOL> path ( \"<STR_LIT>\" , include ( '<STR_LIT>' ) ) , <EOL> url ( r'<STR_LIT>' , serve , { \"<STR_LIT>\" : settings . MEDIA_ROOT } ) , <EOL> re_path", "gt": "( \"<STR_LIT>\" , TemplateView . as_view ( template_name = \"<STR_LIT>\" ) )", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random . shuffle ( file_names ) <EOL> imgs = [ ] <EOL> results = [ ] <EOL> outer_segmentation", "gt": "= OuterSegmentation ( )", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random . shuffle ( file_names ) <EOL> imgs = [ ] <EOL> results = [ ] <EOL> outer_segmentation = OuterSegmentation ( ) <EOL> for i in range ( <NUM_LIT> , len ( file_names ) , batch_size ) : <EOL> batch_file_name = file_names [ i : i + batch_size ] <EOL> for file_name in batch_file_name : <EOL> img_path = os . path . join ( folder , file_name ) <EOL> img = cv2 . imread ( img_path ) <EOL> imgs += [ img ] <EOL> results = outer_segmentation . get_segmentation ( imgs ) <EOL> for result in results : <EOL> for box in result . boxes : <EOL> cls_id = box . cls . cpu ( ) . numpy ( ) [ <NUM_LIT> ] <EOL> x1 , y1 , x2 , y2 = box . xyxy . cpu ( ) . numpy ( ) [ <NUM_LIT> ] <EOL> cls_name = CLS_ID_NAME_MAP [ cls_id ] <EOL> if cls_name == '<STR_LIT>' : <EOL> img = result . orig_img <EOL> img = img [ int ( y1 ) : int ( y2 ) , int ( x1 ) : int ( x2 ) ] <EOL> cv2", "gt": ". imwrite ( os . path . join ( save_folder , str ( random . randint ( <NUM_LIT> , <NUM_LIT> ) ) + '<STR_LIT>' ) , img )", "repo": "OCRAutoScore"}
{"input": "import paddleocr <EOL> import numpy as np <EOL> from PIL import Image <EOL> import torch <EOL> from transformers import CLIPProcessor , CLIPModel <EOL> debug = False <EOL> class model : <EOL> def __init__ ( self , language : str = \"<STR_LIT>\" ) : <EOL> self . ocr = paddleocr . PaddleOCR ( use_angle_cls = True , lang = language ) <EOL> self . device = torch . device ( \"<STR_LIT>\" if torch . cuda . is_available ( ) else \"<STR_LIT>\" ) <EOL> self . clip_model = CLIPModel . from_pretrained ( \"<STR_LIT>\" ) . to ( self . device ) <EOL> self . clip_processor = CLIPProcessor . from_pretrained ( \"<STR_LIT>\" , device = self . device ) <EOL> def recognize_text ( self , _img : Image ) : <EOL> img = np . array ( _img ) <EOL> result = self . ocr . ocr ( img ) <EOL> if debug : <EOL> print ( result ) <EOL> if len ( result [ <NUM_LIT> ] ) == <NUM_LIT> : <EOL> return None <EOL> else : <EOL> location = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> text = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> return ( location , text ) <EOL> def judge_with_clip ( self , _answer : str , _predict : str , _img : Image ) : <EOL> image = _img <EOL> inputs = self . clip_processor ( text = [ f\"<STR_LIT>\" , f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , images = image , return_tensors = \"<STR_LIT>\" , padding = True ) <EOL> inputs . to ( self . device ) <EOL> outputs = self . clip_model ( ** inputs ) <EOL> logits_per_image = outputs . logits_per_image <EOL> probs = logits_per_image . softmax ( dim = <NUM_LIT> ) <EOL> if debug : <EOL> print ( probs ) <EOL> index = torch . argmax ( probs , dim = <NUM_LIT> ) <EOL> return index <EOL> if __name__ == \"<STR_LIT>\" : <EOL> debug = True <EOL> import paddle <EOL> print ( paddle . device . is_compiled_with_cuda ( ) ) <EOL> model = model ( ) <EOL> while True : <EOL> img_path = input ( \"<STR_LIT>\" ) <EOL> answer = input ( \"<STR_LIT>\" ) <EOL> img = Image . open ( img_path ) <EOL> predict = model . recognize_text ( img ) [ <NUM_LIT> ] <EOL> print", "gt": "( \"<STR_LIT>\" , predict )", "repo": "OCRAutoScore"}
{"input": "import paddleocr <EOL> import numpy as np <EOL> from PIL import Image <EOL> import torch <EOL> from transformers import CLIPProcessor , CLIPModel <EOL> debug = False <EOL> class model : <EOL> def __init__ ( self , language : str = \"<STR_LIT>\" ) : <EOL> self . ocr = paddleocr . PaddleOCR ( use_angle_cls = True , lang = language ) <EOL> self . device = torch . device ( \"<STR_LIT>\" if torch . cuda . is_available ( ) else \"<STR_LIT>\" ) <EOL> self . clip_model = CLIPModel . from_pretrained ( \"<STR_LIT>\" ) . to ( self . device ) <EOL> self . clip_processor = CLIPProcessor . from_pretrained ( \"<STR_LIT>\" , device = self . device ) <EOL> def recognize_text ( self , _img : Image ) : <EOL> img = np . array ( _img ) <EOL> result = self . ocr . ocr ( img ) <EOL> if debug : <EOL> print ( result ) <EOL> if len ( result [ <NUM_LIT> ] ) == <NUM_LIT> : <EOL> return None <EOL> else : <EOL> location = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> text = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> return ( location , text ) <EOL> def judge_with_clip ( self , _answer : str , _predict : str , _img : Image ) : <EOL> image = _img <EOL> inputs = self . clip_processor ( text = [ f\"<STR_LIT>\" , f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , images = image , return_tensors = \"<STR_LIT>\" , padding = True ) <EOL> inputs . to ( self . device ) <EOL> outputs = self . clip_model ( ** inputs ) <EOL> logits_per_image = outputs . logits_per_image <EOL> probs = logits_per_image . softmax ( dim = <NUM_LIT> ) <EOL> if debug : <EOL> print ( probs ) <EOL> index = torch . argmax ( probs , dim = <NUM_LIT> ) <EOL> return index <EOL> if __name__ == \"<STR_LIT>\" : <EOL> debug = True <EOL> import paddle <EOL> print", "gt": "( paddle . device . is_compiled_with_cuda ( ) )", "repo": "OCRAutoScore"}
{"input": "import paddleocr <EOL> import numpy as np <EOL> from PIL import Image <EOL> import torch <EOL> from transformers import CLIPProcessor , CLIPModel <EOL> debug = False <EOL> class model : <EOL> def __init__ ( self , language : str = \"<STR_LIT>\" ) : <EOL> self . ocr = paddleocr . PaddleOCR ( use_angle_cls = True , lang = language ) <EOL> self . device = torch . device ( \"<STR_LIT>\" if torch . cuda . is_available ( ) else \"<STR_LIT>\" ) <EOL> self . clip_model = CLIPModel . from_pretrained ( \"<STR_LIT>\" ) . to ( self . device ) <EOL> self . clip_processor = CLIPProcessor . from_pretrained ( \"<STR_LIT>\" , device = self . device ) <EOL> def recognize_text ( self , _img : Image ) : <EOL> img = np . array ( _img ) <EOL> result = self . ocr . ocr ( img ) <EOL> if debug : <EOL> print ( result ) <EOL> if len ( result [ <NUM_LIT> ] ) == <NUM_LIT> : <EOL> return None <EOL> else : <EOL> location = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> text = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> return ( location , text ) <EOL> def judge_with_clip ( self , _answer : str , _predict : str , _img : Image ) : <EOL> image = _img <EOL> inputs = self . clip_processor ( text = [ f\"<STR_LIT>\" , f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , images = image , return_tensors = \"<STR_LIT>\" , padding = True ) <EOL> inputs . to ( self . device ) <EOL> outputs = self . clip_model ( ** inputs ) <EOL> logits_per_image = outputs . logits_per_image <EOL> probs = logits_per_image . softmax ( dim = <NUM_LIT> ) <EOL> if debug : <EOL> print ( probs ) <EOL> index = torch . argmax ( probs , dim = <NUM_LIT> ) <EOL> return index <EOL> if __name__ == \"<STR_LIT>\" : <EOL> debug = True <EOL> import paddle <EOL> print ( paddle . device . is_compiled_with_cuda ( ) ) <EOL> model = model ( ) <EOL> while True : <EOL> img_path = input ( \"<STR_LIT>\" ) <EOL> answer", "gt": "= input ( \"<STR_LIT>\" )", "repo": "OCRAutoScore"}
{"input": "import paddleocr <EOL> import numpy as np <EOL> from PIL import Image <EOL> import torch <EOL> from transformers import CLIPProcessor , CLIPModel <EOL> debug = False <EOL> class model : <EOL> def __init__ ( self , language : str = \"<STR_LIT>\" ) : <EOL> self . ocr = paddleocr . PaddleOCR ( use_angle_cls = True , lang = language ) <EOL> self . device = torch . device ( \"<STR_LIT>\" if torch . cuda . is_available ( ) else \"<STR_LIT>\" ) <EOL> self . clip_model = CLIPModel . from_pretrained ( \"<STR_LIT>\" ) . to ( self . device ) <EOL> self . clip_processor = CLIPProcessor . from_pretrained ( \"<STR_LIT>\" , device = self . device ) <EOL> def recognize_text ( self , _img : Image ) : <EOL> img = np . array ( _img ) <EOL> result = self . ocr . ocr ( img ) <EOL> if debug : <EOL> print ( result ) <EOL> if len ( result [ <NUM_LIT> ] ) == <NUM_LIT> : <EOL> return None <EOL> else : <EOL> location = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> text = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> return ( location , text ) <EOL> def judge_with_clip ( self , _answer : str , _predict : str , _img : Image ) : <EOL> image = _img <EOL> inputs = self . clip_processor ( text = [ f\"<STR_LIT>\" , f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , images = image , return_tensors = \"<STR_LIT>\" , padding = True ) <EOL> inputs . to ( self . device ) <EOL> outputs = self . clip_model ( ** inputs ) <EOL> logits_per_image = outputs . logits_per_image <EOL> probs = logits_per_image . softmax ( dim = <NUM_LIT> ) <EOL> if debug : <EOL> print ( probs ) <EOL> index = torch . argmax ( probs , dim = <NUM_LIT> ) <EOL> return index <EOL> if __name__ == \"<STR_LIT>\" : <EOL> debug = True <EOL> import paddle <EOL> print ( paddle . device . is_compiled_with_cuda ( ) ) <EOL> model", "gt": "= model ( )", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random . shuffle ( file_names ) <EOL> imgs = [ ] <EOL> results = [ ] <EOL> outer_segmentation = OuterSegmentation ( ) <EOL> for i in range ( <NUM_LIT> , len ( file_names ) , batch_size ) : <EOL> batch_file_name = file_names [ i : i + batch_size ] <EOL> for file_name in batch_file_name : <EOL> img_path = os . path . join ( folder , file_name ) <EOL> img = cv2 . imread ( img_path ) <EOL> imgs", "gt": "+= [ img ]", "repo": "OCRAutoScore"}
{"input": "import paddleocr <EOL> import numpy as np <EOL> from PIL import Image <EOL> import torch <EOL> from transformers import CLIPProcessor , CLIPModel <EOL> debug = False <EOL> class model : <EOL> def __init__ ( self , language : str = \"<STR_LIT>\" ) : <EOL> self . ocr = paddleocr . PaddleOCR ( use_angle_cls = True , lang = language ) <EOL> self . device = torch . device ( \"<STR_LIT>\" if torch . cuda . is_available ( ) else \"<STR_LIT>\" ) <EOL> self . clip_model = CLIPModel . from_pretrained ( \"<STR_LIT>\" ) . to ( self . device ) <EOL> self . clip_processor = CLIPProcessor . from_pretrained ( \"<STR_LIT>\" , device = self . device ) <EOL> def recognize_text ( self , _img : Image ) : <EOL> img = np . array ( _img ) <EOL> result = self . ocr . ocr ( img ) <EOL> if debug : <EOL> print ( result ) <EOL> if len ( result [ <NUM_LIT> ] ) == <NUM_LIT> : <EOL> return None <EOL> else : <EOL> location = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> text = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> return ( location , text ) <EOL> def judge_with_clip ( self , _answer : str , _predict : str , _img : Image ) : <EOL> image = _img <EOL> inputs = self . clip_processor ( text = [ f\"<STR_LIT>\" , f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , images = image , return_tensors = \"<STR_LIT>\" , padding = True ) <EOL> inputs . to ( self . device ) <EOL> outputs = self . clip_model ( ** inputs ) <EOL> logits_per_image = outputs . logits_per_image <EOL> probs = logits_per_image . softmax ( dim = <NUM_LIT> ) <EOL> if debug : <EOL> print ( probs ) <EOL> index", "gt": "= torch . argmax ( probs , dim = <NUM_LIT> )", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random . shuffle ( file_names ) <EOL> imgs = [ ] <EOL> results = [ ] <EOL> outer_segmentation = OuterSegmentation ( ) <EOL> for i in range ( <NUM_LIT> , len ( file_names ) , batch_size ) : <EOL> batch_file_name = file_names [ i : i + batch_size ] <EOL> for file_name in batch_file_name : <EOL> img_path = os . path . join ( folder , file_name ) <EOL> img = cv2 . imread ( img_path ) <EOL> imgs += [ img ] <EOL> results = outer_segmentation . get_segmentation ( imgs ) <EOL> for result in results : <EOL> for box in result . boxes : <EOL> cls_id = box . cls . cpu ( ) . numpy ( ) [ <NUM_LIT> ] <EOL> x1 , y1 , x2 , y2 = box . xyxy . cpu ( ) . numpy ( ) [ <NUM_LIT> ] <EOL> cls_name = CLS_ID_NAME_MAP [ cls_id ] <EOL> if cls_name == '<STR_LIT>' : <EOL> img", "gt": "= result . orig_img", "repo": "OCRAutoScore"}
{"input": "import paddleocr <EOL> import numpy as np <EOL> from PIL import Image <EOL> import torch <EOL> from transformers import CLIPProcessor , CLIPModel <EOL> debug = False <EOL> class model : <EOL> def __init__ ( self , language : str = \"<STR_LIT>\" ) : <EOL> self . ocr = paddleocr . PaddleOCR ( use_angle_cls = True , lang = language ) <EOL> self . device = torch . device ( \"<STR_LIT>\" if torch . cuda . is_available ( ) else \"<STR_LIT>\" ) <EOL> self . clip_model = CLIPModel . from_pretrained ( \"<STR_LIT>\" ) . to ( self . device ) <EOL> self . clip_processor = CLIPProcessor . from_pretrained ( \"<STR_LIT>\" , device = self . device ) <EOL> def recognize_text ( self , _img : Image ) : <EOL> img = np . array ( _img ) <EOL> result = self . ocr . ocr ( img ) <EOL> if debug : <EOL> print ( result ) <EOL> if len ( result [ <NUM_LIT> ] ) == <NUM_LIT> : <EOL> return None <EOL> else : <EOL> location = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> text = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> return ( location , text ) <EOL> def judge_with_clip ( self , _answer : str , _predict : str , _img : Image ) : <EOL> image = _img <EOL> inputs = self . clip_processor ( text = [ f\"<STR_LIT>\" , f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , images = image , return_tensors = \"<STR_LIT>\" , padding = True ) <EOL> inputs . to ( self . device ) <EOL> outputs", "gt": "= self . clip_model ( ** inputs )", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random . shuffle ( file_names ) <EOL> imgs = [ ] <EOL> results = [ ] <EOL> outer_segmentation = OuterSegmentation ( ) <EOL> for i in range ( <NUM_LIT> , len ( file_names ) , batch_size ) : <EOL> batch_file_name = file_names [ i : i + batch_size ] <EOL> for file_name in batch_file_name : <EOL> img_path = os . path . join ( folder , file_name ) <EOL> img = cv2 . imread ( img_path ) <EOL> imgs += [ img ] <EOL> results = outer_segmentation . get_segmentation ( imgs ) <EOL> for result in results : <EOL> for box in result . boxes : <EOL> cls_id = box . cls . cpu ( ) . numpy ( ) [ <NUM_LIT> ] <EOL> x1 , y1 , x2 , y2 = box . xyxy . cpu ( ) . numpy ( ) [ <NUM_LIT> ] <EOL> cls_name = CLS_ID_NAME_MAP [ cls_id ] <EOL> if cls_name == '<STR_LIT>' : <EOL> img = result . orig_img <EOL> img", "gt": "= img [ int ( y1 ) : int ( y2 ) , int ( x1 ) : int ( x2 ) ]", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random . shuffle ( file_names ) <EOL> imgs = [ ] <EOL> results = [ ] <EOL> outer_segmentation = OuterSegmentation ( ) <EOL> for i in range ( <NUM_LIT> , len ( file_names ) , batch_size ) : <EOL> batch_file_name = file_names [ i : i + batch_size ] <EOL> for", "gt": "file_name in batch_file_name :", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random . shuffle ( file_names ) <EOL> imgs = [ ] <EOL> results = [ ] <EOL> outer_segmentation = OuterSegmentation ( ) <EOL> for i in range ( <NUM_LIT> , len ( file_names ) , batch_size ) : <EOL> batch_file_name = file_names [ i : i + batch_size ] <EOL> for file_name in batch_file_name : <EOL> img_path", "gt": "= os . path . join ( folder , file_name )", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random . shuffle ( file_names ) <EOL> imgs = [ ] <EOL> results = [ ] <EOL> outer_segmentation = OuterSegmentation ( ) <EOL> for i in range ( <NUM_LIT> , len ( file_names ) , batch_size ) : <EOL> batch_file_name = file_names [ i : i + batch_size ] <EOL> for file_name in batch_file_name : <EOL> img_path = os . path . join ( folder , file_name ) <EOL> img = cv2 . imread ( img_path ) <EOL> imgs += [ img ] <EOL> results", "gt": "= outer_segmentation . get_segmentation ( imgs )", "repo": "OCRAutoScore"}
{"input": "import paddleocr <EOL> import numpy as np <EOL> from PIL import Image <EOL> import torch <EOL> from transformers import CLIPProcessor , CLIPModel <EOL> debug = False <EOL> class model : <EOL> def __init__ ( self , language : str = \"<STR_LIT>\" ) : <EOL> self . ocr = paddleocr . PaddleOCR ( use_angle_cls = True , lang = language ) <EOL> self . device = torch . device ( \"<STR_LIT>\" if torch . cuda . is_available ( ) else \"<STR_LIT>\" ) <EOL> self . clip_model = CLIPModel . from_pretrained ( \"<STR_LIT>\" ) . to ( self . device ) <EOL> self . clip_processor = CLIPProcessor . from_pretrained ( \"<STR_LIT>\" , device = self . device ) <EOL> def recognize_text ( self , _img : Image ) : <EOL> img = np . array ( _img ) <EOL> result = self . ocr . ocr ( img ) <EOL> if debug : <EOL> print ( result ) <EOL> if len ( result [ <NUM_LIT> ] ) == <NUM_LIT> : <EOL> return None <EOL> else : <EOL> location = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> text = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> return ( location , text ) <EOL> def judge_with_clip ( self , _answer : str , _predict : str , _img : Image ) : <EOL> image = _img <EOL> inputs = self . clip_processor ( text = [ f\"<STR_LIT>\" , f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , images = image , return_tensors = \"<STR_LIT>\" , padding = True ) <EOL> inputs . to ( self . device ) <EOL> outputs = self . clip_model ( ** inputs ) <EOL> logits_per_image = outputs . logits_per_image <EOL> probs = logits_per_image . softmax ( dim = <NUM_LIT> ) <EOL> if debug : <EOL> print ( probs ) <EOL> index = torch . argmax ( probs , dim = <NUM_LIT> ) <EOL> return index <EOL> if __name__ == \"<STR_LIT>\" : <EOL> debug = True <EOL> import paddle <EOL> print ( paddle . device . is_compiled_with_cuda ( ) ) <EOL> model = model ( ) <EOL> while True : <EOL> img_path = input ( \"<STR_LIT>\" ) <EOL> answer = input ( \"<STR_LIT>\" ) <EOL> img = Image . open ( img_path ) <EOL> predict = model . recognize_text ( img ) [ <NUM_LIT> ] <EOL> print ( \"<STR_LIT>\" , predict ) <EOL> if ( predict != answer ) : <EOL> print", "gt": "( \"<STR_LIT>\" , answer )", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random . shuffle ( file_names ) <EOL> imgs = [ ] <EOL> results = [ ] <EOL> outer_segmentation = OuterSegmentation ( ) <EOL> for i in range ( <NUM_LIT> , len ( file_names ) , batch_size ) : <EOL> batch_file_name = file_names [ i : i + batch_size ] <EOL> for file_name in batch_file_name : <EOL> img_path = os . path . join ( folder , file_name ) <EOL> img = cv2 . imread ( img_path ) <EOL> imgs += [ img ] <EOL> results = outer_segmentation . get_segmentation ( imgs ) <EOL> for result in results : <EOL> for box in result . boxes : <EOL> cls_id", "gt": "= box . cls . cpu ( ) . numpy ( ) [ <NUM_LIT> ]", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random", "gt": ". shuffle ( file_names )", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random . shuffle ( file_names ) <EOL> imgs = [ ] <EOL> results = [ ] <EOL> outer_segmentation = OuterSegmentation ( ) <EOL> for", "gt": "i in range ( <NUM_LIT> , len ( file_names ) , batch_size ) :", "repo": "OCRAutoScore"}
{"input": "from django . conf . urls import url <EOL> from django . contrib import admin <EOL> from django . urls import path , include , re_path <EOL> from django . views . static import serve <EOL> from django . views . generic import TemplateView <EOL> from score_server import settings <EOL> urlpatterns = [ <EOL> path", "gt": "( '<STR_LIT>' , admin . site . urls ) ,", "repo": "OCRAutoScore"}
{"input": "import paddleocr <EOL> import numpy as np <EOL> from PIL import Image <EOL> import torch <EOL> from transformers import CLIPProcessor , CLIPModel <EOL> debug = False <EOL> class model : <EOL> def __init__ ( self , language : str = \"<STR_LIT>\" ) : <EOL> self . ocr = paddleocr . PaddleOCR ( use_angle_cls = True , lang = language ) <EOL> self . device = torch . device ( \"<STR_LIT>\" if torch . cuda . is_available ( ) else \"<STR_LIT>\" ) <EOL> self . clip_model = CLIPModel . from_pretrained ( \"<STR_LIT>\" ) . to ( self . device ) <EOL> self . clip_processor = CLIPProcessor . from_pretrained ( \"<STR_LIT>\" , device = self . device ) <EOL> def recognize_text ( self , _img : Image ) : <EOL> img = np . array ( _img ) <EOL> result = self . ocr . ocr ( img ) <EOL> if debug : <EOL> print ( result ) <EOL> if len ( result [ <NUM_LIT> ] ) == <NUM_LIT> : <EOL> return None <EOL> else : <EOL> location = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> text = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> return ( location , text ) <EOL> def judge_with_clip ( self , _answer : str , _predict : str , _img : Image ) : <EOL> image = _img <EOL> inputs = self . clip_processor ( text = [ f\"<STR_LIT>\" , f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , images = image , return_tensors = \"<STR_LIT>\" , padding = True ) <EOL> inputs . to ( self . device ) <EOL> outputs = self . clip_model ( ** inputs ) <EOL> logits_per_image = outputs . logits_per_image <EOL> probs = logits_per_image . softmax ( dim = <NUM_LIT> ) <EOL> if debug : <EOL> print ( probs ) <EOL> index = torch . argmax ( probs , dim = <NUM_LIT> ) <EOL> return index <EOL> if __name__ == \"<STR_LIT>\" : <EOL> debug = True <EOL> import paddle <EOL> print ( paddle . device . is_compiled_with_cuda ( ) ) <EOL> model = model ( ) <EOL> while True : <EOL> img_path = input ( \"<STR_LIT>\" ) <EOL> answer = input ( \"<STR_LIT>\" ) <EOL> img = Image . open ( img_path ) <EOL> predict = model . recognize_text ( img ) [ <NUM_LIT> ] <EOL> print ( \"<STR_LIT>\" , predict ) <EOL> if", "gt": "( predict != answer ) :", "repo": "OCRAutoScore"}
{"input": "import paddleocr <EOL> import numpy as np <EOL> from PIL import Image <EOL> import torch <EOL> from transformers import CLIPProcessor , CLIPModel <EOL> debug = False <EOL> class model : <EOL> def __init__ ( self , language : str = \"<STR_LIT>\" ) : <EOL> self . ocr = paddleocr . PaddleOCR ( use_angle_cls = True , lang = language ) <EOL> self . device = torch . device ( \"<STR_LIT>\" if torch . cuda . is_available ( ) else \"<STR_LIT>\" ) <EOL> self . clip_model = CLIPModel . from_pretrained ( \"<STR_LIT>\" ) . to ( self . device ) <EOL> self . clip_processor = CLIPProcessor . from_pretrained ( \"<STR_LIT>\" , device = self . device ) <EOL> def recognize_text ( self , _img : Image ) : <EOL> img = np . array ( _img ) <EOL> result = self . ocr . ocr ( img ) <EOL> if debug : <EOL> print ( result ) <EOL> if len ( result [ <NUM_LIT> ] ) == <NUM_LIT> : <EOL> return None <EOL> else : <EOL> location = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> text = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> return ( location , text ) <EOL> def judge_with_clip ( self , _answer : str , _predict : str , _img : Image ) : <EOL> image = _img <EOL> inputs = self . clip_processor ( text = [ f\"<STR_LIT>\" , f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , images = image , return_tensors = \"<STR_LIT>\" , padding = True ) <EOL> inputs . to ( self . device ) <EOL> outputs = self . clip_model ( ** inputs ) <EOL> logits_per_image = outputs . logits_per_image <EOL> probs = logits_per_image . softmax ( dim = <NUM_LIT> ) <EOL> if debug : <EOL> print ( probs ) <EOL> index = torch . argmax ( probs , dim = <NUM_LIT> ) <EOL> return index <EOL> if", "gt": "__name__ == \"<STR_LIT>\" :", "repo": "OCRAutoScore"}
{"input": "from django . conf . urls import url <EOL> from django . contrib import admin <EOL> from django . urls import path , include , re_path <EOL> from django . views . static import serve <EOL> from django . views . generic import TemplateView <EOL> from score_server import settings <EOL> urlpatterns = [ <EOL> path ( '<STR_LIT>' , admin . site . urls ) , <EOL> path ( \"<STR_LIT>\" , include ( '<STR_LIT>' ) ) , <EOL> url", "gt": "( r'<STR_LIT>' , serve , { \"<STR_LIT>\" : settings . MEDIA_ROOT } ) ,", "repo": "OCRAutoScore"}
{"input": "from ultralytics import YOLO <EOL> import os <EOL> import cv2 <EOL> import random <EOL> CLS_ID_NAME_MAP = { <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT> : '<STR_LIT>' <EOL> } <EOL> class OuterSegmentation : <EOL> def __init__ ( self ) : <EOL> self . model = YOLO ( model = '<STR_LIT>' ) <EOL> def get_segmentation ( self , img ) : <EOL> results = self . model . predict ( source = img , imgsz = <NUM_LIT> , save = False ) <EOL> return results <EOL> if __name__ == '<STR_LIT>' : <EOL> debug = True <EOL> folder = '<STR_LIT>' <EOL> file_names = os . listdir ( folder ) <EOL> save_folder = '<STR_LIT>' <EOL> if not os . path . isdir ( save_folder ) : <EOL> os . mkdir ( save_folder ) <EOL> batch_size = <NUM_LIT> <EOL> random . shuffle ( file_names ) <EOL> imgs = [ ] <EOL> results = [ ] <EOL> outer_segmentation = OuterSegmentation ( ) <EOL> for i in range ( <NUM_LIT> , len ( file_names ) , batch_size ) : <EOL> batch_file_name = file_names [ i : i + batch_size ] <EOL> for file_name in batch_file_name : <EOL> img_path = os . path . join ( folder , file_name ) <EOL> img = cv2 . imread ( img_path ) <EOL> imgs += [ img ] <EOL> results = outer_segmentation . get_segmentation ( imgs ) <EOL> for result in results : <EOL> for box in result . boxes : <EOL> cls_id = box . cls . cpu ( ) . numpy ( ) [ <NUM_LIT> ] <EOL> x1 , y1 , x2 , y2 = box . xyxy . cpu ( ) . numpy ( ) [ <NUM_LIT> ] <EOL> cls_name", "gt": "= CLS_ID_NAME_MAP [ cls_id ]", "repo": "OCRAutoScore"}
{"input": "import paddleocr <EOL> import numpy as np <EOL> from PIL import Image <EOL> import torch <EOL> from transformers import CLIPProcessor , CLIPModel <EOL> debug = False <EOL> class model : <EOL> def __init__ ( self , language : str = \"<STR_LIT>\" ) : <EOL> self . ocr = paddleocr . PaddleOCR ( use_angle_cls = True , lang = language ) <EOL> self . device = torch . device ( \"<STR_LIT>\" if torch . cuda . is_available ( ) else \"<STR_LIT>\" ) <EOL> self . clip_model = CLIPModel . from_pretrained ( \"<STR_LIT>\" ) . to ( self . device ) <EOL> self . clip_processor = CLIPProcessor . from_pretrained ( \"<STR_LIT>\" , device = self . device ) <EOL> def recognize_text ( self , _img : Image ) : <EOL> img = np . array ( _img ) <EOL> result = self . ocr . ocr ( img ) <EOL> if debug : <EOL> print ( result ) <EOL> if len ( result [ <NUM_LIT> ] ) == <NUM_LIT> : <EOL> return None <EOL> else : <EOL> location = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> text = result [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] [ <NUM_LIT> ] <EOL> return ( location , text ) <EOL> def judge_with_clip ( self , _answer : str , _predict : str , _img : Image ) : <EOL> image = _img <EOL> inputs = self . clip_processor ( text = [ f\"<STR_LIT>\" , f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , images = image , return_tensors = \"<STR_LIT>\" , padding = True ) <EOL> inputs . to ( self . device ) <EOL> outputs = self . clip_model ( ** inputs ) <EOL> logits_per_image = outputs . logits_per_image <EOL> probs = logits_per_image . softmax ( dim = <NUM_LIT> ) <EOL> if debug : <EOL> print ( probs ) <EOL> index = torch . argmax ( probs , dim = <NUM_LIT> ) <EOL> return index <EOL> if __name__ == \"<STR_LIT>\" : <EOL> debug = True <EOL> import paddle <EOL> print ( paddle . device . is_compiled_with_cuda ( ) ) <EOL> model = model ( ) <EOL> while True : <EOL> img_path = input ( \"<STR_LIT>\" ) <EOL> answer = input ( \"<STR_LIT>\" ) <EOL> img = Image . open ( img_path ) <EOL> predict", "gt": "= model . recognize_text ( img ) [ <NUM_LIT> ]", "repo": "OCRAutoScore"}
{"input": "import json <EOL> import logging <EOL> import os <EOL> import django <EOL> from django . db . models import QuerySet <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from django . core . management . base import BaseCommand <EOL> from application . settings import BASE_DIR <EOL> from dvadmin . system . models import Menu , Users , Dept , Role , ApiWhiteList , Dictionary , SystemConfig <EOL> from dvadmin . system . fixtures . initSerializer import UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def serializer_data ( self , serializer , query_set : QuerySet ) : <EOL> serializer = serializer ( query_set , many = True ) <EOL> data = json . loads ( json . dumps ( serializer . data , ensure_ascii = False ) ) <EOL> with open ( os . path . join ( BASE_DIR , f'<STR_LIT>' ) , '<STR_LIT>' ) as f : <EOL> json . dump ( data , f , indent = <NUM_LIT> , ensure_ascii = False ) <EOL> return <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" , type = str , help = \"<STR_LIT>\" ) <EOL> def generate_users ( self ) : <EOL> self . serializer_data ( UsersInitSerializer , Users . objects . all ( ) ) <EOL> def generate_role ( self ) : <EOL> self . serializer_data ( RoleInitSerializer , Role . objects . all ( ) ) <EOL> def generate_dept ( self ) : <EOL> self . serializer_data ( DeptInitSerializer , Dept . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_menu ( self ) : <EOL> self . serializer_data ( MenuInitSerializer , Menu . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_api_white_list ( self ) : <EOL> self . serializer_data ( ApiWhiteListInitSerializer , ApiWhiteList . objects . all ( ) ) <EOL> def generate_dictionary ( self ) : <EOL> self . serializer_data ( DictionaryInitSerializer , Dictionary . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_system_config ( self ) : <EOL> self . serializer_data ( SystemConfigInitSerializer , SystemConfig . objects . filter ( parent_id__isnull = True ) ) <EOL> def handle ( self , * args , ** options ) : <EOL> generate_name = options . get ( '<STR_LIT>' ) <EOL> generate_name_dict = { <EOL> \"<STR_LIT>\" : self . generate_users , <EOL> \"<STR_LIT>\" : self . generate_role , <EOL> \"<STR_LIT>\" : self . generate_dept , <EOL> \"<STR_LIT>\" : self . generate_menu , <EOL> \"<STR_LIT>\" : self . generate_api_white_list , <EOL> \"<STR_LIT>\" : self . generate_dictionary , <EOL> \"<STR_LIT>\" : self . generate_system_config , <EOL> } <EOL> if not generate_name : <EOL> for ele in generate_name_dict . keys ( ) : <EOL> generate_name_dict [ ele ] ( ) <EOL> return <EOL> for generate_name in generate_name : <EOL> if generate_name not in generate_name_dict : <EOL> print ( f\"<STR_LIT>\" ) <EOL> raise", "gt": "Exception ( f\"<STR_LIT>\" )", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def refresh_dictionary ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> def refresh_system_config ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> def get_dictionary_config ( schema_name = None ) : <EOL> if not settings . DICTIONARY_CONFIG : <EOL> refresh_dictionary ( ) <EOL> if is_tenants_mode ( ) : <EOL> dictionary_config = settings . DICTIONARY_CONFIG [ schema_name or connection . tenant . schema_name ] <EOL> else : <EOL> dictionary_config = settings . DICTIONARY_CONFIG <EOL> return dictionary_config or { } <EOL> def", "gt": "get_dictionary_values ( key , schema_name = None ) :", "repo": "django-vue3-admin"}
{"input": "import json <EOL> import logging <EOL> import os <EOL> import django <EOL> from django . db . models import QuerySet <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from django . core . management . base import BaseCommand <EOL> from application . settings import BASE_DIR <EOL> from dvadmin . system . models import Menu , Users , Dept , Role , ApiWhiteList , Dictionary , SystemConfig <EOL> from dvadmin . system . fixtures . initSerializer import UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def serializer_data ( self , serializer , query_set : QuerySet ) : <EOL> serializer = serializer ( query_set , many = True ) <EOL> data = json . loads ( json . dumps ( serializer . data , ensure_ascii = False ) ) <EOL> with open ( os . path . join ( BASE_DIR , f'<STR_LIT>' ) , '<STR_LIT>' ) as f : <EOL> json . dump ( data , f , indent = <NUM_LIT> , ensure_ascii = False ) <EOL> return <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" , type = str , help = \"<STR_LIT>\" ) <EOL> def generate_users ( self ) : <EOL> self . serializer_data ( UsersInitSerializer , Users . objects . all ( ) ) <EOL> def generate_role ( self ) : <EOL> self . serializer_data ( RoleInitSerializer , Role . objects . all ( ) ) <EOL> def generate_dept ( self ) : <EOL> self . serializer_data ( DeptInitSerializer , Dept . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_menu ( self ) : <EOL> self . serializer_data ( MenuInitSerializer , Menu . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_api_white_list ( self ) : <EOL> self . serializer_data ( ApiWhiteListInitSerializer , ApiWhiteList . objects . all ( ) ) <EOL> def generate_dictionary ( self ) : <EOL> self . serializer_data ( DictionaryInitSerializer , Dictionary . objects . filter ( parent_id__isnull = True ) ) <EOL> def", "gt": "generate_system_config ( self ) :", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def refresh_dictionary ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> def refresh_system_config ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> def get_dictionary_config ( schema_name = None ) : <EOL> if not settings . DICTIONARY_CONFIG : <EOL> refresh_dictionary ( ) <EOL> if is_tenants_mode ( ) : <EOL> dictionary_config = settings . DICTIONARY_CONFIG [ schema_name or connection . tenant . schema_name ] <EOL> else : <EOL> dictionary_config = settings . DICTIONARY_CONFIG <EOL> return dictionary_config or { } <EOL> def get_dictionary_values ( key , schema_name = None ) : <EOL> dictionary_config = get_dictionary_config ( schema_name ) <EOL> return dictionary_config . get ( key ) <EOL> def get_dictionary_label ( key , name , schema_name = None ) : <EOL> children = get_dictionary_values ( key , schema_name ) or [ ] <EOL> for ele in children : <EOL> if ele . get ( \"<STR_LIT>\" ) == str ( name ) : <EOL> return ele . get ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> def get_system_config ( schema_name = None ) : <EOL> if not settings . SYSTEM_CONFIG : <EOL> refresh_system_config ( ) <EOL> if is_tenants_mode ( ) : <EOL> dictionary_config = settings . SYSTEM_CONFIG [ schema_name or connection . tenant . schema_name ] <EOL> else : <EOL> dictionary_config = settings . SYSTEM_CONFIG <EOL> return dictionary_config or { } <EOL> def get_system_config_values ( key , schema_name = None ) : <EOL> system_config", "gt": "= get_system_config ( schema_name )", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> except", "gt": "Exception as e :", "repo": "django-vue3-admin"}
{"input": "import json <EOL> import logging <EOL> import os <EOL> import django <EOL> from django . db . models import QuerySet <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from django . core . management . base import BaseCommand <EOL> from application . settings import BASE_DIR <EOL> from dvadmin . system . models import Menu , Users , Dept , Role , ApiWhiteList , Dictionary , SystemConfig <EOL> from dvadmin . system . fixtures . initSerializer import UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def serializer_data ( self , serializer , query_set : QuerySet ) : <EOL> serializer = serializer ( query_set , many = True ) <EOL> data = json . loads ( json . dumps ( serializer . data , ensure_ascii = False ) ) <EOL> with open ( os . path . join ( BASE_DIR , f'<STR_LIT>' ) , '<STR_LIT>' ) as f : <EOL> json . dump ( data , f , indent = <NUM_LIT> , ensure_ascii = False ) <EOL> return <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" , type = str , help = \"<STR_LIT>\" ) <EOL> def generate_users ( self ) : <EOL> self . serializer_data ( UsersInitSerializer , Users . objects . all ( ) ) <EOL> def generate_role ( self ) : <EOL> self . serializer_data ( RoleInitSerializer , Role . objects . all ( ) ) <EOL> def generate_dept ( self ) : <EOL> self . serializer_data ( DeptInitSerializer , Dept . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_menu ( self ) : <EOL> self . serializer_data ( MenuInitSerializer , Menu . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_api_white_list ( self ) : <EOL> self . serializer_data ( ApiWhiteListInitSerializer , ApiWhiteList . objects . all ( ) ) <EOL> def generate_dictionary ( self ) : <EOL> self", "gt": ". serializer_data ( DictionaryInitSerializer , Dictionary . objects . filter ( parent_id__isnull = True ) )", "repo": "django-vue3-admin"}
{"input": "import os <EOL> from git . repo import Repo <EOL> from git . repo . fun import is_git_dir <EOL> class GitRepository ( object ) : <EOL> def __init__ ( self , local_path , repo_url , branch = '<STR_LIT>' ) : <EOL> self . local_path = local_path <EOL> self . repo_url = repo_url <EOL> self . repo = None <EOL> self . initial ( self . repo_url , branch ) <EOL> def initial ( self , repo_url , branch ) : <EOL> if not os . path . exists ( self . local_path ) : <EOL> os . makedirs ( self . local_path ) <EOL> git_local_path = os . path . join ( self . local_path , '<STR_LIT>' ) <EOL> if not is_git_dir ( git_local_path ) : <EOL> self . repo = Repo . clone_from ( repo_url , to_path = self . local_path , branch = branch ) <EOL> else : <EOL> self . repo = Repo ( self . local_path ) <EOL> def pull ( self ) : <EOL> self . repo . git . pull ( ) <EOL> def branches ( self ) : <EOL> branches = self . repo . remote ( ) . refs <EOL> return", "gt": "[ item . remote_head for item in branches if item . remote_head not in [ '<STR_LIT>' , ] ]", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def refresh_dictionary ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> def refresh_system_config ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> def get_dictionary_config ( schema_name = None ) : <EOL> if not settings . DICTIONARY_CONFIG : <EOL> refresh_dictionary ( ) <EOL> if is_tenants_mode ( ) : <EOL> dictionary_config", "gt": "= settings . DICTIONARY_CONFIG [ schema_name or connection . tenant . schema_name ]", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def refresh_dictionary ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> def refresh_system_config ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for", "gt": "tenant in get_tenant_model ( ) . objects . filter ( ) :", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def refresh_dictionary ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> def refresh_system_config ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> def get_dictionary_config ( schema_name = None ) : <EOL> if not settings . DICTIONARY_CONFIG : <EOL> refresh_dictionary ( ) <EOL> if is_tenants_mode ( ) : <EOL> dictionary_config = settings . DICTIONARY_CONFIG [ schema_name or connection . tenant . schema_name ] <EOL> else : <EOL> dictionary_config = settings . DICTIONARY_CONFIG <EOL> return dictionary_config or { } <EOL> def get_dictionary_values ( key , schema_name = None ) : <EOL> dictionary_config = get_dictionary_config ( schema_name ) <EOL> return dictionary_config . get ( key ) <EOL> def get_dictionary_label ( key , name , schema_name = None ) : <EOL> children = get_dictionary_values ( key , schema_name ) or [ ] <EOL> for ele in children : <EOL> if ele . get ( \"<STR_LIT>\" ) == str ( name ) : <EOL> return ele . get ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> def get_system_config ( schema_name = None ) : <EOL> if", "gt": "not settings . SYSTEM_CONFIG :", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def refresh_dictionary ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> def refresh_system_config ( ) : <EOL> if", "gt": "is_tenants_mode ( ) :", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def refresh_dictionary ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> def refresh_system_config ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings", "gt": ". SYSTEM_CONFIG = _get_all_system_config ( )", "repo": "django-vue3-admin"}
{"input": "import os <EOL> from git . repo import Repo <EOL> from git . repo . fun import is_git_dir <EOL> class GitRepository ( object ) : <EOL> def __init__ ( self , local_path , repo_url , branch = '<STR_LIT>' ) : <EOL> self . local_path = local_path <EOL> self . repo_url = repo_url <EOL> self . repo = None <EOL> self . initial ( self . repo_url , branch ) <EOL> def initial ( self , repo_url , branch ) : <EOL> if not os . path . exists ( self . local_path ) : <EOL> os . makedirs ( self . local_path ) <EOL> git_local_path = os . path . join ( self . local_path , '<STR_LIT>' ) <EOL> if not is_git_dir ( git_local_path ) : <EOL> self . repo = Repo . clone_from ( repo_url , to_path = self . local_path , branch = branch ) <EOL> else : <EOL> self . repo = Repo ( self . local_path ) <EOL> def pull ( self ) : <EOL> self . repo . git . pull ( ) <EOL> def branches ( self ) : <EOL> branches = self . repo . remote ( ) . refs <EOL> return [ item . remote_head for item in branches if item . remote_head not in [ '<STR_LIT>' , ] ] <EOL> def commits ( self ) : <EOL> commit_log = self . repo . git . log ( '<STR_LIT>' , <EOL> max_count = <NUM_LIT> , <EOL> date = '<STR_LIT>' ) <EOL> log_list = commit_log . split ( \"<STR_LIT>\" ) <EOL> return [ eval ( item ) for item in log_list ] <EOL> def tags ( self ) : <EOL> return [ tag . name for tag in self . repo . tags ] <EOL> def tags_exists ( self , tag ) : <EOL> return tag in self . tags ( ) <EOL> def change_to_branch ( self , branch ) : <EOL> self . repo . git . checkout ( branch ) <EOL> def change_to_commit ( self , branch , commit ) : <EOL> self . change_to_branch ( branch = branch ) <EOL> self", "gt": ". repo . git . reset ( '<STR_LIT>' , commit )", "repo": "django-vue3-admin"}
{"input": "import json <EOL> import os <EOL> import django <EOL> import pypinyin <EOL> from django . core . management import BaseCommand <EOL> from django . db import connection <EOL> from application import dispatch <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from application . settings import BASE_DIR <EOL> from dvadmin . system . models import Area <EOL> area_code_list = [ ] <EOL> def area_list ( code_list , pcode = None , depth = <NUM_LIT> ) : <EOL> for code_dict in code_list : <EOL> code = code_dict . get ( '<STR_LIT>' , None ) <EOL> name = code_dict . get ( '<STR_LIT>' , None ) <EOL> children = code_dict . get ( '<STR_LIT>' , None ) <EOL> pinyin = '<STR_LIT>' . join ( [ '<STR_LIT>' . join ( i ) for i in pypinyin . pinyin ( name , style = pypinyin . NORMAL ) ] ) <EOL> area_code_list . append ( <EOL> { <EOL> \"<STR_LIT>\" : name , <EOL> \"<STR_LIT>\" : code , <EOL> \"<STR_LIT>\" : depth , <EOL> \"<STR_LIT>\" : pinyin , <EOL> \"<STR_LIT>\" : pinyin [ <NUM_LIT> ] . upper ( ) if pinyin else \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : pcode , <EOL> } <EOL> ) <EOL> if children : <EOL> area_list ( code_list = children , pcode = code , depth = depth + <NUM_LIT> ) <EOL> def", "gt": "main ( ) :", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def refresh_dictionary ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> def refresh_system_config ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> def", "gt": "get_dictionary_config ( schema_name = None ) :", "repo": "django-vue3-admin"}
{"input": "import json <EOL> import os <EOL> import django <EOL> import pypinyin <EOL> from django . core . management import BaseCommand <EOL> from django . db import connection <EOL> from application import dispatch <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from application . settings import BASE_DIR <EOL> from dvadmin . system . models import Area <EOL> area_code_list = [ ] <EOL> def area_list ( code_list , pcode = None , depth = <NUM_LIT> ) : <EOL> for code_dict in code_list : <EOL> code = code_dict . get ( '<STR_LIT>' , None ) <EOL> name = code_dict . get ( '<STR_LIT>' , None ) <EOL> children = code_dict . get ( '<STR_LIT>' , None ) <EOL> pinyin = '<STR_LIT>' . join ( [ '<STR_LIT>' . join ( i ) for i in pypinyin . pinyin ( name , style = pypinyin . NORMAL ) ] ) <EOL> area_code_list . append ( <EOL> { <EOL> \"<STR_LIT>\" : name , <EOL> \"<STR_LIT>\" : code , <EOL> \"<STR_LIT>\" : depth , <EOL> \"<STR_LIT>\" : pinyin , <EOL> \"<STR_LIT>\" : pinyin [ <NUM_LIT> ] . upper ( ) if pinyin else \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : pcode , <EOL> } <EOL> ) <EOL> if children : <EOL> area_list ( code_list = children , pcode = code , depth = depth + <NUM_LIT> ) <EOL> def main ( ) : <EOL> with open ( os . path . join ( BASE_DIR , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' , encoding = \"<STR_LIT>\" ) as load_f : <EOL> code_list", "gt": "= json . load ( load_f )", "repo": "django-vue3-admin"}
{"input": "import json <EOL> import logging <EOL> import os <EOL> import django <EOL> from django . db . models import QuerySet <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from django . core . management . base import BaseCommand <EOL> from application . settings import BASE_DIR <EOL> from dvadmin . system . models import Menu , Users , Dept , Role , ApiWhiteList , Dictionary , SystemConfig <EOL> from dvadmin . system . fixtures . initSerializer import UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def serializer_data ( self , serializer , query_set : QuerySet ) : <EOL> serializer = serializer ( query_set , many = True ) <EOL> data = json . loads ( json . dumps ( serializer . data , ensure_ascii = False ) ) <EOL> with open ( os . path . join ( BASE_DIR , f'<STR_LIT>' ) , '<STR_LIT>' ) as f : <EOL> json . dump ( data , f , indent = <NUM_LIT> , ensure_ascii = False ) <EOL> return <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" , type = str , help = \"<STR_LIT>\" ) <EOL> def generate_users ( self ) : <EOL> self . serializer_data ( UsersInitSerializer , Users . objects . all ( ) ) <EOL> def generate_role ( self ) : <EOL> self . serializer_data ( RoleInitSerializer , Role . objects . all ( ) ) <EOL> def generate_dept ( self ) : <EOL> self . serializer_data ( DeptInitSerializer , Dept . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_menu ( self ) : <EOL> self . serializer_data ( MenuInitSerializer , Menu . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_api_white_list ( self ) : <EOL> self . serializer_data ( ApiWhiteListInitSerializer , ApiWhiteList . objects . all ( ) ) <EOL> def generate_dictionary ( self ) : <EOL> self . serializer_data ( DictionaryInitSerializer , Dictionary . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_system_config ( self ) : <EOL> self . serializer_data ( SystemConfigInitSerializer , SystemConfig . objects . filter ( parent_id__isnull = True ) ) <EOL> def handle ( self , * args , ** options ) : <EOL> generate_name = options . get ( '<STR_LIT>' ) <EOL> generate_name_dict = { <EOL> \"<STR_LIT>\" : self . generate_users , <EOL> \"<STR_LIT>\" : self . generate_role , <EOL> \"<STR_LIT>\" : self . generate_dept , <EOL> \"<STR_LIT>\" : self . generate_menu , <EOL> \"<STR_LIT>\" : self . generate_api_white_list , <EOL> \"<STR_LIT>\" : self . generate_dictionary , <EOL> \"<STR_LIT>\" : self . generate_system_config , <EOL> } <EOL> if not generate_name : <EOL> for ele in generate_name_dict . keys ( ) : <EOL> generate_name_dict", "gt": "[ ele ] ( )", "repo": "django-vue3-admin"}
{"input": "import os <EOL> from git . repo import Repo <EOL> from git . repo . fun import is_git_dir <EOL> class GitRepository ( object ) : <EOL> def __init__ ( self , local_path , repo_url , branch = '<STR_LIT>' ) : <EOL> self . local_path = local_path <EOL> self . repo_url = repo_url <EOL> self . repo = None <EOL> self . initial ( self . repo_url , branch ) <EOL> def initial ( self , repo_url , branch ) : <EOL> if not os . path . exists ( self . local_path ) : <EOL> os . makedirs ( self . local_path ) <EOL> git_local_path = os . path . join ( self . local_path , '<STR_LIT>' ) <EOL> if not is_git_dir ( git_local_path ) : <EOL> self . repo = Repo . clone_from ( repo_url , to_path = self . local_path , branch = branch ) <EOL> else : <EOL> self . repo = Repo ( self . local_path ) <EOL> def pull ( self ) : <EOL> self . repo . git . pull ( ) <EOL> def branches ( self ) : <EOL> branches = self . repo . remote ( ) . refs <EOL> return [ item . remote_head for item in branches if item . remote_head not in [ '<STR_LIT>' , ] ] <EOL> def commits ( self ) : <EOL> commit_log = self . repo . git . log ( '<STR_LIT>' , <EOL> max_count = <NUM_LIT> , <EOL> date = '<STR_LIT>' ) <EOL> log_list = commit_log . split ( \"<STR_LIT>\" ) <EOL> return [ eval ( item ) for item in log_list ] <EOL> def tags ( self ) : <EOL> return [ tag . name for tag in self . repo . tags ] <EOL> def tags_exists ( self , tag ) : <EOL> return tag in self . tags ( ) <EOL> def", "gt": "change_to_branch ( self , branch ) :", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with", "gt": "tenant_context ( tenant ) :", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def refresh_dictionary ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> def refresh_system_config ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> def get_dictionary_config ( schema_name = None ) : <EOL> if not settings . DICTIONARY_CONFIG : <EOL> refresh_dictionary ( ) <EOL> if is_tenants_mode ( ) : <EOL> dictionary_config = settings . DICTIONARY_CONFIG [ schema_name or connection . tenant . schema_name ] <EOL> else : <EOL> dictionary_config = settings . DICTIONARY_CONFIG <EOL> return dictionary_config or { } <EOL> def get_dictionary_values ( key , schema_name = None ) : <EOL> dictionary_config", "gt": "= get_dictionary_config ( schema_name )", "repo": "django-vue3-admin"}
{"input": "from django . conf import settings <EOL> from django . db import connection <EOL> def is_tenants_mode ( ) : <EOL> return hasattr ( connection , \"<STR_LIT>\" ) and connection . tenant . schema_name <EOL> def _get_all_dictionary ( ) : <EOL> from dvadmin . system . models import Dictionary <EOL> queryset = Dictionary . objects . filter ( status = True , is_value = False ) <EOL> data = [ ] <EOL> for instance in queryset : <EOL> data . append ( <EOL> { <EOL> \"<STR_LIT>\" : instance . id , <EOL> \"<STR_LIT>\" : instance . value , <EOL> \"<STR_LIT>\" : list ( <EOL> Dictionary . objects . filter ( parent = instance . id ) <EOL> . filter ( status = <NUM_LIT> ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ) , <EOL> } <EOL> ) <EOL> return { ele . get ( \"<STR_LIT>\" ) : ele for ele in data } <EOL> def _get_all_system_config ( ) : <EOL> data = { } <EOL> from dvadmin . system . models import SystemConfig <EOL> system_config_obj = ( <EOL> SystemConfig . objects . filter ( parent_id__isnull = False ) <EOL> . values ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> . order_by ( \"<STR_LIT>\" ) <EOL> ) <EOL> for system_config in system_config_obj : <EOL> value = system_config . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> value = value [ <NUM_LIT> ] . get ( \"<STR_LIT>\" ) <EOL> if value and system_config . get ( \"<STR_LIT>\" ) == <NUM_LIT> : <EOL> new_value = [ ] <EOL> for ele in value : <EOL> new_value . append ( { <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ele . get ( '<STR_LIT>' ) , <EOL> } ) <EOL> new_value . sort ( key = lambda s : s [ \"<STR_LIT>\" ] ) <EOL> value = new_value <EOL> data [ f\"<STR_LIT>\" ] = value <EOL> return data <EOL> def init_dictionary ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def init_system_config ( ) : <EOL> try : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> except Exception as e : <EOL> print ( \"<STR_LIT>\" ) <EOL> return <EOL> def refresh_dictionary ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . DICTIONARY_CONFIG [ connection . tenant . schema_name ] = _get_all_dictionary ( ) <EOL> else : <EOL> settings . DICTIONARY_CONFIG = _get_all_dictionary ( ) <EOL> def refresh_system_config ( ) : <EOL> if is_tenants_mode ( ) : <EOL> from django_tenants . utils import tenant_context , get_tenant_model <EOL> for tenant in get_tenant_model ( ) . objects . filter ( ) : <EOL> with tenant_context ( tenant ) : <EOL> settings . SYSTEM_CONFIG [ connection . tenant . schema_name ] = _get_all_system_config ( ) <EOL> else : <EOL> settings . SYSTEM_CONFIG = _get_all_system_config ( ) <EOL> def get_dictionary_config ( schema_name = None ) : <EOL> if not settings . DICTIONARY_CONFIG : <EOL> refresh_dictionary ( ) <EOL> if is_tenants_mode ( ) : <EOL> dictionary_config = settings . DICTIONARY_CONFIG [ schema_name or connection . tenant . schema_name ] <EOL> else : <EOL> dictionary_config = settings . DICTIONARY_CONFIG <EOL> return dictionary_config or { } <EOL> def get_dictionary_values ( key , schema_name = None ) : <EOL> dictionary_config = get_dictionary_config ( schema_name ) <EOL> return dictionary_config . get ( key ) <EOL> def get_dictionary_label ( key , name , schema_name = None ) : <EOL> children = get_dictionary_values ( key , schema_name ) or [ ] <EOL> for ele in children : <EOL> if ele . get ( \"<STR_LIT>\" ) == str ( name ) : <EOL> return ele . get ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> def get_system_config ( schema_name = None ) : <EOL> if not settings . SYSTEM_CONFIG : <EOL> refresh_system_config ( ) <EOL> if is_tenants_mode ( ) : <EOL> dictionary_config = settings . SYSTEM_CONFIG [ schema_name or connection . tenant . schema_name ] <EOL> else : <EOL> dictionary_config = settings . SYSTEM_CONFIG <EOL> return dictionary_config or { } <EOL> def get_system_config_values ( key , schema_name = None ) : <EOL> system_config = get_system_config ( schema_name ) <EOL> return", "gt": "system_config . get ( key )", "repo": "django-vue3-admin"}
{"input": "import json <EOL> import logging <EOL> import os <EOL> import django <EOL> from django . db . models import QuerySet <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from django . core . management . base import BaseCommand <EOL> from application . settings import BASE_DIR <EOL> from dvadmin . system . models import Menu , Users , Dept , Role , ApiWhiteList , Dictionary , SystemConfig <EOL> from dvadmin . system . fixtures . initSerializer import UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def serializer_data ( self , serializer , query_set : QuerySet ) : <EOL> serializer = serializer ( query_set , many = True ) <EOL> data = json . loads ( json . dumps ( serializer . data , ensure_ascii = False ) ) <EOL> with open ( os . path . join ( BASE_DIR , f'<STR_LIT>' ) , '<STR_LIT>' ) as f : <EOL> json . dump ( data , f , indent = <NUM_LIT> , ensure_ascii = False ) <EOL> return <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" , type = str , help = \"<STR_LIT>\" ) <EOL> def generate_users ( self ) : <EOL> self . serializer_data ( UsersInitSerializer , Users . objects . all ( ) ) <EOL> def generate_role ( self ) : <EOL> self . serializer_data ( RoleInitSerializer , Role . objects . all ( ) ) <EOL> def generate_dept ( self ) : <EOL> self . serializer_data ( DeptInitSerializer , Dept . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_menu ( self ) : <EOL> self . serializer_data ( MenuInitSerializer , Menu . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_api_white_list ( self ) : <EOL> self . serializer_data ( ApiWhiteListInitSerializer , ApiWhiteList . objects . all ( ) ) <EOL> def generate_dictionary ( self ) : <EOL> self . serializer_data ( DictionaryInitSerializer , Dictionary . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_system_config ( self ) : <EOL> self . serializer_data ( SystemConfigInitSerializer , SystemConfig . objects . filter ( parent_id__isnull = True ) ) <EOL> def handle ( self , * args , ** options ) : <EOL> generate_name = options . get ( '<STR_LIT>' ) <EOL> generate_name_dict = { <EOL> \"<STR_LIT>\" : self . generate_users , <EOL> \"<STR_LIT>\" : self . generate_role , <EOL> \"<STR_LIT>\" : self . generate_dept , <EOL> \"<STR_LIT>\" : self . generate_menu , <EOL> \"<STR_LIT>\" : self . generate_api_white_list , <EOL> \"<STR_LIT>\" : self . generate_dictionary , <EOL> \"<STR_LIT>\" : self . generate_system_config , <EOL> } <EOL> if not generate_name : <EOL> for ele in generate_name_dict . keys ( ) : <EOL> generate_name_dict [ ele ] ( ) <EOL> return <EOL> for generate_name in generate_name : <EOL> if generate_name not in generate_name_dict : <EOL> print ( f\"<STR_LIT>\" ) <EOL> raise Exception ( f\"<STR_LIT>\" ) <EOL> generate_name_dict [ generate_name ] ( ) <EOL> return <EOL> if", "gt": "__name__ == '<STR_LIT>' :", "repo": "django-vue3-admin"}
{"input": "import os <EOL> from git . repo import Repo <EOL> from git . repo . fun import is_git_dir <EOL> class GitRepository ( object ) : <EOL> def __init__ ( self , local_path , repo_url , branch = '<STR_LIT>' ) : <EOL> self . local_path = local_path <EOL> self . repo_url = repo_url <EOL> self . repo = None <EOL> self . initial ( self . repo_url , branch ) <EOL> def initial ( self , repo_url , branch ) : <EOL> if not os . path . exists ( self . local_path ) : <EOL> os . makedirs ( self . local_path ) <EOL> git_local_path = os . path . join ( self . local_path , '<STR_LIT>' ) <EOL> if not is_git_dir ( git_local_path ) : <EOL> self . repo = Repo . clone_from ( repo_url , to_path = self . local_path , branch = branch ) <EOL> else : <EOL> self . repo = Repo ( self . local_path ) <EOL> def pull ( self ) : <EOL> self . repo . git . pull ( ) <EOL> def branches ( self ) : <EOL> branches = self . repo . remote ( ) . refs <EOL> return [ item . remote_head for item in branches if item . remote_head not in [ '<STR_LIT>' , ] ] <EOL> def commits ( self ) : <EOL> commit_log", "gt": "= self . repo . git . log ( '<STR_LIT>' ,", "repo": "django-vue3-admin"}
{"input": "import json <EOL> import logging <EOL> import os <EOL> import django <EOL> from django . db . models import QuerySet <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> django . setup ( ) <EOL> from django . core . management . base import BaseCommand <EOL> from application . settings import BASE_DIR <EOL> from dvadmin . system . models import Menu , Users , Dept , Role , ApiWhiteList , Dictionary , SystemConfig <EOL> from dvadmin . system . fixtures . initSerializer import UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> def serializer_data ( self , serializer , query_set : QuerySet ) : <EOL> serializer = serializer ( query_set , many = True ) <EOL> data = json . loads ( json . dumps ( serializer . data , ensure_ascii = False ) ) <EOL> with open ( os . path . join ( BASE_DIR , f'<STR_LIT>' ) , '<STR_LIT>' ) as f : <EOL> json . dump ( data , f , indent = <NUM_LIT> , ensure_ascii = False ) <EOL> return <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" , type = str , help = \"<STR_LIT>\" ) <EOL> def generate_users ( self ) : <EOL> self . serializer_data ( UsersInitSerializer , Users . objects . all ( ) ) <EOL> def generate_role ( self ) : <EOL> self . serializer_data ( RoleInitSerializer , Role . objects . all ( ) ) <EOL> def generate_dept ( self ) : <EOL> self . serializer_data ( DeptInitSerializer , Dept . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_menu ( self ) : <EOL> self . serializer_data ( MenuInitSerializer , Menu . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_api_white_list ( self ) : <EOL> self . serializer_data ( ApiWhiteListInitSerializer , ApiWhiteList . objects . all ( ) ) <EOL> def generate_dictionary ( self ) : <EOL> self . serializer_data ( DictionaryInitSerializer , Dictionary . objects . filter ( parent_id__isnull = True ) ) <EOL> def generate_system_config ( self ) : <EOL> self . serializer_data ( SystemConfigInitSerializer , SystemConfig . objects . filter ( parent_id__isnull = True ) ) <EOL> def handle ( self , * args , ** options ) : <EOL> generate_name = options . get ( '<STR_LIT>' ) <EOL> generate_name_dict = { <EOL> \"<STR_LIT>\" : self . generate_users , <EOL> \"<STR_LIT>\" : self . generate_role , <EOL> \"<STR_LIT>\" : self . generate_dept , <EOL> \"<STR_LIT>\" : self . generate_menu , <EOL> \"<STR_LIT>\" : self . generate_api_white_list , <EOL> \"<STR_LIT>\" : self . generate_dictionary , <EOL> \"<STR_LIT>\" : self . generate_system_config , <EOL> } <EOL> if not generate_name : <EOL> for", "gt": "ele in generate_name_dict . keys ( ) :", "repo": "django-vue3-admin"}
{"input": "import os <EOL> from git . repo import Repo <EOL> from git . repo . fun import is_git_dir <EOL> class GitRepository ( object ) : <EOL> def __init__ ( self , local_path , repo_url , branch = '<STR_LIT>' ) : <EOL> self . local_path = local_path <EOL> self . repo_url = repo_url <EOL> self . repo = None <EOL> self . initial ( self . repo_url , branch ) <EOL> def initial ( self , repo_url , branch ) : <EOL> if not os . path . exists ( self . local_path ) : <EOL> os . makedirs ( self . local_path ) <EOL> git_local_path = os . path . join ( self . local_path , '<STR_LIT>' ) <EOL> if not is_git_dir ( git_local_path ) : <EOL> self . repo = Repo . clone_from ( repo_url , to_path = self . local_path , branch = branch ) <EOL> else : <EOL> self . repo = Repo ( self . local_path ) <EOL> def pull ( self ) : <EOL> self . repo . git . pull ( ) <EOL> def branches ( self ) : <EOL> branches = self . repo . remote ( ) . refs <EOL> return [ item . remote_head for item in branches if item . remote_head not in [ '<STR_LIT>' , ] ] <EOL> def", "gt": "commits ( self ) :", "repo": "django-vue3-admin"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file . parent . mkdir ( parents = True , exist_ok = True ) <EOL> output_file . write_text ( response . text ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = extension . get ( \"<STR_LIT>\" ) , <EOL> ) <EOL> ) <EOL> def resolve_filepath ( self ) -> Path : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> except cappa . Exit : <EOL> pyproject_path = None <EOL> if self . output : <EOL> return self . output if self . output . name . endswith ( \"<STR_LIT>\" ) else self . output / f\"<STR_LIT>\" <EOL> if self . output is None and pyproject_path : <EOL> falco_config = read_falco_config ( pyproject_path = pyproject_path ) <EOL> htmx_config = Htmx . read_from_config ( falco_config = falco_config ) <EOL> htmx_filepath , _ = htmx_config <EOL> return", "gt": "htmx_filepath . parent / f\"<STR_LIT>\"", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file . parent . mkdir ( parents = True , exist_ok = True ) <EOL> output_file . write_text ( response . text ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = extension . get ( \"<STR_LIT>\" ) , <EOL> ) <EOL> ) <EOL> def resolve_filepath ( self ) -> Path : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> except cappa . Exit : <EOL> pyproject_path = None <EOL> if self . output : <EOL> return self . output if self . output . name . endswith ( \"<STR_LIT>\" ) else self . output / f\"<STR_LIT>\" <EOL> if self . output is None and pyproject_path : <EOL> falco_config = read_falco_config ( pyproject_path = pyproject_path ) <EOL> htmx_config = Htmx . read_from_config ( falco_config = falco_config ) <EOL> htmx_filepath , _ = htmx_config <EOL> return htmx_filepath . parent / f\"<STR_LIT>\" <EOL> return Path ( f\"<STR_LIT>\" ) <EOL> def list_all ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> table = Table ( <EOL> title = \"<STR_LIT>\" , <EOL> caption = \"<STR_LIT>\" , <EOL> show_lines = True , <EOL> ) <EOL> table . add_column ( \"<STR_LIT>\" , style = \"<STR_LIT>\" ) <EOL> table . add_column ( \"<STR_LIT>\" , style = \"<STR_LIT>\" ) <EOL> for name , metadata in extensions . items ( ) : <EOL> table . add_row ( name , metadata . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> console = Console ( ) <EOL> console . print ( table ) <EOL> @ classmethod <EOL> def read_registry ( cls ) : <EOL> with network_request_with_progress ( REGISTRY_URL , \"<STR_LIT>\" ) as response : <EOL> import time <EOL> time . sleep ( <NUM_LIT> ) <EOL> return", "gt": "response . json ( )", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file", "gt": ". parent . mkdir ( parents = True , exist_ok = True )", "repo": "falco"}
{"input": "from demo . core . utils import paginate_queryset <EOL> from django . http import HttpRequest <EOL> from django . http import HttpResponse <EOL> from django . shortcuts import get_object_or_404 <EOL> from django . shortcuts import redirect <EOL> from django . template . response import TemplateResponse <EOL> from django . views . decorators . http import require_http_methods <EOL> from . forms import ProductForm <EOL> from . models import Product <EOL> def product_list ( request : HttpRequest ) : <EOL> products = Product . objects . all ( ) <EOL> template_name = \"<STR_LIT>\" if request . htmx else \"<STR_LIT>\" <EOL> return TemplateResponse ( <EOL> request , <EOL> template_name , <EOL> context = { \"<STR_LIT>\" : paginate_queryset ( request , products ) } , <EOL> ) <EOL> def product_detail ( request : HttpRequest , pk : int ) : <EOL> product = get_object_or_404 ( Product . objects , pk = pk ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : product } , <EOL> ) <EOL> def product_create ( request : HttpRequest ) : <EOL> form = ProductForm ( request . POST or None ) <EOL> if request . method == \"<STR_LIT>\" and form . is_valid ( ) : <EOL> form . save ( ) <EOL> return redirect ( \"<STR_LIT>\" ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : form } , <EOL> ) <EOL> def product_update ( request : HttpRequest , pk : int ) : <EOL> product = get_object_or_404 ( Product . objects , pk = pk ) <EOL> form", "gt": "= ProductForm ( request . POST or None , instance = product )", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file . parent . mkdir ( parents = True , exist_ok = True ) <EOL> output_file . write_text ( response . text ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = extension . get ( \"<STR_LIT>\" ) , <EOL> ) <EOL> ) <EOL> def resolve_filepath ( self ) -> Path : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> except cappa . Exit : <EOL> pyproject_path = None <EOL> if self . output : <EOL> return self . output if self . output . name . endswith ( \"<STR_LIT>\" ) else self . output / f\"<STR_LIT>\" <EOL> if self . output is None and pyproject_path : <EOL> falco_config = read_falco_config ( pyproject_path = pyproject_path ) <EOL> htmx_config = Htmx . read_from_config ( falco_config = falco_config ) <EOL> htmx_filepath , _ = htmx_config <EOL> return htmx_filepath . parent / f\"<STR_LIT>\" <EOL> return Path ( f\"<STR_LIT>\" ) <EOL> def list_all ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> table = Table ( <EOL> title = \"<STR_LIT>\" , <EOL> caption = \"<STR_LIT>\" , <EOL> show_lines = True , <EOL> ) <EOL> table . add_column ( \"<STR_LIT>\" , style = \"<STR_LIT>\" ) <EOL> table . add_column ( \"<STR_LIT>\" , style = \"<STR_LIT>\" ) <EOL> for name , metadata in extensions . items ( ) : <EOL> table . add_row ( name , metadata . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> console", "gt": "= Console ( )", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file . parent . mkdir ( parents = True , exist_ok = True ) <EOL> output_file . write_text ( response . text ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = extension . get ( \"<STR_LIT>\" ) , <EOL> ) <EOL> ) <EOL> def resolve_filepath ( self ) -> Path : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> except cappa . Exit : <EOL> pyproject_path = None <EOL> if self . output : <EOL> return self . output if self . output . name . endswith ( \"<STR_LIT>\" ) else self . output / f\"<STR_LIT>\" <EOL> if self . output is None and pyproject_path : <EOL> falco_config = read_falco_config ( pyproject_path = pyproject_path ) <EOL> htmx_config = Htmx . read_from_config ( falco_config = falco_config ) <EOL> htmx_filepath , _ = htmx_config <EOL> return htmx_filepath . parent / f\"<STR_LIT>\" <EOL> return Path ( f\"<STR_LIT>\" ) <EOL> def list_all ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> table = Table ( <EOL> title = \"<STR_LIT>\" , <EOL> caption = \"<STR_LIT>\" , <EOL> show_lines = True , <EOL> ) <EOL> table . add_column ( \"<STR_LIT>\" , style = \"<STR_LIT>\" ) <EOL> table . add_column ( \"<STR_LIT>\" , style = \"<STR_LIT>\" ) <EOL> for name , metadata in extensions . items ( ) : <EOL> table . add_row ( name , metadata . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> console = Console ( ) <EOL> console . print ( table ) <EOL> @ classmethod <EOL> def", "gt": "read_registry ( cls ) :", "repo": "falco"}
{"input": "from django . forms import ModelForm <EOL> from . models import Product <EOL> class ProductForm ( ModelForm ) : <EOL> class Meta : <EOL> model = Product <EOL> fields", "gt": "= ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" )", "repo": "falco"}
{"input": "from demo . core . utils import paginate_queryset <EOL> from django . http import HttpRequest <EOL> from django . http import HttpResponse <EOL> from django . shortcuts import get_object_or_404 <EOL> from django . shortcuts import redirect <EOL> from django . template . response import TemplateResponse <EOL> from django . views . decorators . http import require_http_methods <EOL> from . forms import ProductForm <EOL> from . models import Product <EOL> def product_list ( request : HttpRequest ) : <EOL> products = Product . objects . all ( ) <EOL> template_name = \"<STR_LIT>\" if request . htmx else \"<STR_LIT>\" <EOL> return TemplateResponse ( <EOL> request , <EOL> template_name , <EOL> context = { \"<STR_LIT>\" : paginate_queryset ( request , products ) } , <EOL> ) <EOL> def product_detail ( request : HttpRequest , pk : int ) : <EOL> product = get_object_or_404 ( Product . objects , pk = pk ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : product } , <EOL> ) <EOL> def product_create ( request : HttpRequest ) : <EOL> form = ProductForm ( request . POST or None ) <EOL> if request . method == \"<STR_LIT>\" and form . is_valid ( ) : <EOL> form . save ( ) <EOL> return redirect ( \"<STR_LIT>\" ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : form } , <EOL> ) <EOL> def", "gt": "product_update ( request : HttpRequest , pk : int ) :", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file . parent . mkdir ( parents = True , exist_ok = True ) <EOL> output_file . write_text ( response . text ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = extension . get ( \"<STR_LIT>\" ) , <EOL> ) <EOL> ) <EOL> def resolve_filepath ( self ) -> Path : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> except cappa . Exit : <EOL> pyproject_path = None <EOL> if self . output : <EOL> return self . output if self . output . name . endswith ( \"<STR_LIT>\" ) else self . output / f\"<STR_LIT>\" <EOL> if self . output is None and pyproject_path : <EOL> falco_config = read_falco_config ( pyproject_path = pyproject_path ) <EOL> htmx_config = Htmx . read_from_config ( falco_config = falco_config ) <EOL> htmx_filepath , _ = htmx_config <EOL> return htmx_filepath . parent / f\"<STR_LIT>\" <EOL> return Path ( f\"<STR_LIT>\" ) <EOL> def list_all ( self ) : <EOL> extensions", "gt": "= self . read_registry ( )", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file . parent . mkdir ( parents = True , exist_ok = True ) <EOL> output_file . write_text ( response . text ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = extension . get ( \"<STR_LIT>\" ) , <EOL> ) <EOL> ) <EOL> def resolve_filepath ( self ) -> Path : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> except cappa . Exit : <EOL> pyproject_path = None <EOL> if self . output : <EOL> return self . output if self . output . name . endswith ( \"<STR_LIT>\" ) else self . output / f\"<STR_LIT>\" <EOL> if self . output is None and pyproject_path : <EOL> falco_config = read_falco_config ( pyproject_path = pyproject_path ) <EOL> htmx_config = Htmx . read_from_config ( falco_config = falco_config ) <EOL> htmx_filepath , _ = htmx_config <EOL> return htmx_filepath . parent / f\"<STR_LIT>\" <EOL> return Path ( f\"<STR_LIT>\" ) <EOL> def list_all ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> table = Table ( <EOL> title = \"<STR_LIT>\" , <EOL> caption = \"<STR_LIT>\" , <EOL> show_lines = True , <EOL> ) <EOL> table . add_column ( \"<STR_LIT>\" , style = \"<STR_LIT>\" ) <EOL> table", "gt": ". add_column ( \"<STR_LIT>\" , style = \"<STR_LIT>\" )", "repo": "falco"}
{"input": "from demo . core . utils import paginate_queryset <EOL> from django . http import HttpRequest <EOL> from django . http import HttpResponse <EOL> from django . shortcuts import get_object_or_404 <EOL> from django . shortcuts import redirect <EOL> from django . template . response import TemplateResponse <EOL> from django . views . decorators . http import require_http_methods <EOL> from . forms import ProductForm <EOL> from . models import Product <EOL> def product_list ( request : HttpRequest ) : <EOL> products = Product . objects . all ( ) <EOL> template_name = \"<STR_LIT>\" if request . htmx else \"<STR_LIT>\" <EOL> return TemplateResponse ( <EOL> request , <EOL> template_name , <EOL> context = { \"<STR_LIT>\" : paginate_queryset ( request , products ) } , <EOL> ) <EOL> def product_detail ( request : HttpRequest , pk : int ) : <EOL> product = get_object_or_404 ( Product . objects , pk = pk ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : product } , <EOL> ) <EOL> def product_create ( request : HttpRequest ) : <EOL> form = ProductForm ( request . POST or None ) <EOL> if request . method == \"<STR_LIT>\" and form . is_valid ( ) : <EOL> form . save ( ) <EOL> return redirect ( \"<STR_LIT>\" ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : form } , <EOL> ) <EOL> def product_update ( request : HttpRequest , pk : int ) : <EOL> product = get_object_or_404 ( Product . objects , pk = pk ) <EOL> form = ProductForm ( request . POST or None , instance = product ) <EOL> if request . method == \"<STR_LIT>\" and form . is_valid ( ) : <EOL> form . save ( ) <EOL> return", "gt": "redirect ( \"<STR_LIT>\" , pk = pk )", "repo": "falco"}
{"input": "import cappa <EOL> from falco . commands import Htmx <EOL> from falco . commands import HtmxExtension <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands import ModelCRUD <EOL> from falco . commands import ResetMigrations <EOL> from falco . commands import RmMigrations <EOL> from falco . commands import StartApp <EOL> from falco . commands import StartProject <EOL> from falco . commands import SyncDotenv <EOL> from falco . commands import Work <EOL> @ cappa . command ( <EOL> help = \"<STR_LIT>\" , <EOL> ) <EOL> class Falco : <EOL> subcommand : cappa . Subcommands [ <EOL> StartProject <EOL> | StartApp <EOL> | ModelCRUD <EOL> | InstallCrudUtils <EOL> | Htmx <EOL> | HtmxExtension <EOL> | Work <EOL> | SyncDotenv <EOL> | RmMigrations <EOL> | ResetMigrations <EOL> ] <EOL> def main ( ) : <EOL> cappa", "gt": ". invoke ( Falco )", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file", "gt": "= self . resolve_filepath ( )", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file . parent . mkdir ( parents = True , exist_ok = True ) <EOL> output_file . write_text ( response . text ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = extension . get ( \"<STR_LIT>\" ) , <EOL> ) <EOL> ) <EOL> def resolve_filepath ( self ) -> Path : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> except cappa . Exit : <EOL> pyproject_path = None <EOL> if self . output : <EOL> return self . output if self . output . name . endswith ( \"<STR_LIT>\" ) else self . output / f\"<STR_LIT>\" <EOL> if self . output is None and pyproject_path : <EOL> falco_config = read_falco_config ( pyproject_path = pyproject_path ) <EOL> htmx_config = Htmx . read_from_config ( falco_config = falco_config ) <EOL> htmx_filepath , _ = htmx_config <EOL> return htmx_filepath . parent / f\"<STR_LIT>\" <EOL> return Path ( f\"<STR_LIT>\" ) <EOL> def list_all ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> table = Table ( <EOL> title = \"<STR_LIT>\" , <EOL> caption = \"<STR_LIT>\" , <EOL> show_lines = True , <EOL> ) <EOL> table . add_column ( \"<STR_LIT>\" , style = \"<STR_LIT>\" ) <EOL> table . add_column ( \"<STR_LIT>\" , style = \"<STR_LIT>\" ) <EOL> for name , metadata in extensions . items ( ) : <EOL> table . add_row ( name , metadata . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> console = Console ( ) <EOL> console . print ( table ) <EOL> @ classmethod <EOL> def read_registry ( cls ) : <EOL> with", "gt": "network_request_with_progress ( REGISTRY_URL , \"<STR_LIT>\" ) as response :", "repo": "falco"}
{"input": "from demo . core . utils import paginate_queryset <EOL> from django . http import HttpRequest <EOL> from django . http import HttpResponse <EOL> from django . shortcuts import get_object_or_404 <EOL> from django . shortcuts import redirect <EOL> from django . template . response import TemplateResponse <EOL> from django . views . decorators . http import require_http_methods <EOL> from . forms import ProductForm <EOL> from . models import Product <EOL> def product_list ( request : HttpRequest ) : <EOL> products = Product . objects . all ( ) <EOL> template_name = \"<STR_LIT>\" if request . htmx else \"<STR_LIT>\" <EOL> return TemplateResponse ( <EOL> request , <EOL> template_name , <EOL> context = { \"<STR_LIT>\" : paginate_queryset ( request , products ) } , <EOL> ) <EOL> def product_detail ( request : HttpRequest , pk : int ) : <EOL> product = get_object_or_404 ( Product . objects , pk = pk ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : product } , <EOL> ) <EOL> def product_create ( request : HttpRequest ) : <EOL> form", "gt": "= ProductForm ( request . POST or None )", "repo": "falco"}
{"input": "from demo . core . utils import paginate_queryset <EOL> from django . http import HttpRequest <EOL> from django . http import HttpResponse <EOL> from django . shortcuts import get_object_or_404 <EOL> from django . shortcuts import redirect <EOL> from django . template . response import TemplateResponse <EOL> from django . views . decorators . http import require_http_methods <EOL> from . forms import ProductForm <EOL> from . models import Product <EOL> def product_list ( request : HttpRequest ) : <EOL> products = Product . objects . all ( ) <EOL> template_name = \"<STR_LIT>\" if request . htmx else \"<STR_LIT>\" <EOL> return TemplateResponse ( <EOL> request , <EOL> template_name , <EOL> context = { \"<STR_LIT>\" : paginate_queryset ( request , products ) } , <EOL> ) <EOL> def product_detail ( request : HttpRequest , pk : int ) : <EOL> product = get_object_or_404 ( Product . objects , pk = pk ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : product } , <EOL> ) <EOL> def product_create ( request : HttpRequest ) : <EOL> form = ProductForm ( request . POST or None ) <EOL> if request . method == \"<STR_LIT>\" and form . is_valid ( ) : <EOL> form . save ( ) <EOL> return redirect ( \"<STR_LIT>\" ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : form } , <EOL> ) <EOL> def product_update ( request : HttpRequest , pk : int ) : <EOL> product = get_object_or_404 ( Product . objects , pk = pk ) <EOL> form = ProductForm ( request . POST or None , instance = product ) <EOL> if request . method == \"<STR_LIT>\" and form . is_valid ( ) : <EOL> form . save ( ) <EOL> return redirect ( \"<STR_LIT>\" , pk = pk ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : product , \"<STR_LIT>\" : form } , <EOL> ) <EOL> @ require_http_methods ( [ \"<STR_LIT>\" ] ) <EOL> def", "gt": "product_delete ( _ : HttpRequest , pk : int ) :", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url", "gt": "= extension . get ( \"<STR_LIT>\" )", "repo": "falco"}
{"input": "import cappa <EOL> from falco . commands import Htmx <EOL> from falco . commands import HtmxExtension <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands import ModelCRUD <EOL> from falco . commands import ResetMigrations <EOL> from falco . commands import RmMigrations <EOL> from falco . commands import StartApp <EOL> from falco . commands import StartProject <EOL> from falco . commands import SyncDotenv <EOL> from falco . commands import Work <EOL> @ cappa . command ( <EOL> help = \"<STR_LIT>\" , <EOL> ) <EOL> class Falco : <EOL> subcommand", "gt": ": cappa . Subcommands [", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file . parent . mkdir ( parents = True , exist_ok = True ) <EOL> output_file . write_text ( response . text ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = extension . get ( \"<STR_LIT>\" ) , <EOL> ) <EOL> ) <EOL> def resolve_filepath ( self ) -> Path : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> except cappa . Exit : <EOL> pyproject_path = None <EOL> if self . output : <EOL> return self . output if self . output . name . endswith ( \"<STR_LIT>\" ) else self . output / f\"<STR_LIT>\" <EOL> if self . output is None and pyproject_path : <EOL> falco_config = read_falco_config ( pyproject_path = pyproject_path ) <EOL> htmx_config = Htmx . read_from_config ( falco_config = falco_config ) <EOL> htmx_filepath , _ = htmx_config <EOL> return htmx_filepath . parent / f\"<STR_LIT>\" <EOL> return Path ( f\"<STR_LIT>\" ) <EOL> def list_all ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> table = Table ( <EOL> title = \"<STR_LIT>\" , <EOL> caption = \"<STR_LIT>\" , <EOL> show_lines = True , <EOL> ) <EOL> table", "gt": ". add_column ( \"<STR_LIT>\" , style = \"<STR_LIT>\" )", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file . parent . mkdir ( parents = True , exist_ok = True ) <EOL> output_file . write_text ( response . text ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = extension . get ( \"<STR_LIT>\" ) , <EOL> ) <EOL> ) <EOL> def resolve_filepath ( self ) -> Path : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> except", "gt": "cappa . Exit :", "repo": "falco"}
{"input": "from demo . core . utils import paginate_queryset <EOL> from django . http import HttpRequest <EOL> from django . http import HttpResponse <EOL> from django . shortcuts import get_object_or_404 <EOL> from django . shortcuts import redirect <EOL> from django . template . response import TemplateResponse <EOL> from django . views . decorators . http import require_http_methods <EOL> from . forms import ProductForm <EOL> from . models import Product <EOL> def product_list ( request : HttpRequest ) : <EOL> products = Product . objects . all ( ) <EOL> template_name = \"<STR_LIT>\" if request . htmx else \"<STR_LIT>\" <EOL> return TemplateResponse ( <EOL> request , <EOL> template_name , <EOL> context = { \"<STR_LIT>\" : paginate_queryset ( request , products ) } , <EOL> ) <EOL> def product_detail ( request : HttpRequest , pk : int ) : <EOL> product = get_object_or_404 ( Product . objects , pk = pk ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : product } , <EOL> ) <EOL> def product_create ( request : HttpRequest ) : <EOL> form = ProductForm ( request . POST or None ) <EOL> if request . method == \"<STR_LIT>\" and form . is_valid ( ) : <EOL> form . save ( ) <EOL> return redirect ( \"<STR_LIT>\" ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : form } , <EOL> ) <EOL> def product_update ( request : HttpRequest , pk : int ) : <EOL> product = get_object_or_404 ( Product . objects , pk = pk ) <EOL> form = ProductForm ( request . POST or None , instance = product ) <EOL> if request . method == \"<STR_LIT>\" and form . is_valid ( ) : <EOL> form . save ( ) <EOL> return redirect ( \"<STR_LIT>\" , pk = pk ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : product , \"<STR_LIT>\" : form } , <EOL> ) <EOL> @", "gt": "require_http_methods ( [ \"<STR_LIT>\" ] )", "repo": "falco"}
{"input": "from demo . core . utils import paginate_queryset <EOL> from django . http import HttpRequest <EOL> from django . http import HttpResponse <EOL> from django . shortcuts import get_object_or_404 <EOL> from django . shortcuts import redirect <EOL> from django . template . response import TemplateResponse <EOL> from django . views . decorators . http import require_http_methods <EOL> from . forms import ProductForm <EOL> from . models import Product <EOL> def product_list ( request : HttpRequest ) : <EOL> products = Product . objects . all ( ) <EOL> template_name = \"<STR_LIT>\" if request . htmx else \"<STR_LIT>\" <EOL> return TemplateResponse ( <EOL> request , <EOL> template_name , <EOL> context = { \"<STR_LIT>\" : paginate_queryset ( request , products ) } , <EOL> ) <EOL> def product_detail ( request : HttpRequest , pk : int ) : <EOL> product = get_object_or_404 ( Product . objects , pk = pk ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context = { \"<STR_LIT>\" : product } , <EOL> ) <EOL> def product_create ( request : HttpRequest ) : <EOL> form = ProductForm ( request . POST or None ) <EOL> if request . method == \"<STR_LIT>\" and form . is_valid ( ) : <EOL> form . save ( ) <EOL> return redirect ( \"<STR_LIT>\" ) <EOL> return TemplateResponse ( <EOL> request , <EOL> \"<STR_LIT>\" , <EOL> context", "gt": "= { \"<STR_LIT>\" : form } ,", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file . parent . mkdir ( parents = True , exist_ok = True ) <EOL> output_file . write_text ( response . text ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = extension . get ( \"<STR_LIT>\" ) , <EOL> ) <EOL> ) <EOL> def resolve_filepath ( self ) -> Path : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> except cappa . Exit : <EOL> pyproject_path = None <EOL> if", "gt": "self . output :", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with simple_progress ( f\"<STR_LIT>\" ) : <EOL> download_url = extension . get ( \"<STR_LIT>\" ) <EOL> response = httpx . get ( download_url , follow_redirects = True ) <EOL> output_file = self . resolve_filepath ( ) <EOL> output_file . parent . mkdir ( parents = True , exist_ok = True ) <EOL> output_file . write_text ( response . text ) <EOL> rich_print ( <EOL> Panel ( <EOL> f\"<STR_LIT>\" , <EOL> subtitle = extension . get ( \"<STR_LIT>\" ) , <EOL> ) <EOL> ) <EOL> def resolve_filepath ( self ) -> Path : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> except cappa . Exit : <EOL> pyproject_path = None <EOL> if self . output : <EOL> return self . output if self . output . name . endswith ( \"<STR_LIT>\" ) else self . output / f\"<STR_LIT>\" <EOL> if self . output is None and pyproject_path : <EOL> falco_config = read_falco_config ( pyproject_path = pyproject_path ) <EOL> htmx_config = Htmx . read_from_config ( falco_config = falco_config ) <EOL> htmx_filepath", "gt": ", _ = htmx_config", "repo": "falco"}
{"input": "from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . console import Console <EOL> from rich . panel import Panel <EOL> from rich . table import Table <EOL> from . htmx import Htmx <EOL> REGISTRY_URL = \"<STR_LIT>\" <EOL> @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) <EOL> class HtmxExtension : <EOL> name : Annotated [ <EOL> str | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> output : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( <EOL> default = None , <EOL> help = \"<STR_LIT>\" , <EOL> short = \"<STR_LIT>\" , <EOL> long = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self ) -> None : <EOL> if self . name : <EOL> self . download ( ) <EOL> else : <EOL> self . list_all ( ) <EOL> def download ( self ) : <EOL> extensions = self . read_registry ( ) <EOL> extension = extensions . get ( self . name ) <EOL> if not extension : <EOL> msg = f\"<STR_LIT>\" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> with", "gt": "simple_progress ( f\"<STR_LIT>\" ) :", "repo": "falco"}
{"input": "import django . contrib . postgres . fields <EOL> from django . db import models , migrations <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field", "gt": "= django . contrib . postgres . fields . ArrayField (", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> from django . http import HttpResponse <EOL> class HealthCheckMiddleware : <EOL> def __init__ ( self , get_response ) : <EOL> self", "gt": ". get_response = get_response", "repo": "deprem-yardim-backend"}
{"input": "import environ <EOL> from . base import * <EOL> env = environ . Env ( ) <EOL> DEBUG = False <EOL> AWS_LB_HOST = env ( \"<STR_LIT>\" ) <EOL> ALLOWED_HOSTS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> AWS_LB_HOST , <EOL> ] <EOL> CORS_ORIGIN_ALLOW_ALL = True <EOL> CSRF_TRUSTED_ORIGINS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> DATABASE_ROUTERS = [ \"<STR_LIT>\" ] <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : True , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\"", "gt": ": env ( \"<STR_LIT>\" ) ,", "repo": "deprem-yardim-backend"}
{"input": "import environ <EOL> from . base import * <EOL> env = environ . Env ( ) <EOL> DEBUG = False <EOL> AWS_LB_HOST = env ( \"<STR_LIT>\" ) <EOL> ALLOWED_HOSTS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> AWS_LB_HOST , <EOL> ] <EOL> CORS_ORIGIN_ALLOW_ALL = True <EOL> CSRF_TRUSTED_ORIGINS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> DATABASE_ROUTERS = [ \"<STR_LIT>\" ] <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : True , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\"", "gt": ": env ( \"<STR_LIT>\" ) ,", "repo": "deprem-yardim-backend"}
{"input": "import environ <EOL> from . base import * <EOL> env = environ . Env ( ) <EOL> DEBUG = False <EOL> AWS_LB_HOST = env ( \"<STR_LIT>\" ) <EOL> ALLOWED_HOSTS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> AWS_LB_HOST , <EOL> ] <EOL> CORS_ORIGIN_ALLOW_ALL = True <EOL> CSRF_TRUSTED_ORIGINS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> DATABASE_ROUTERS = [ \"<STR_LIT>\" ] <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : True , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> } <EOL> CACHES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ <EOL> env ( \"<STR_LIT>\" ) , <EOL> ] , <EOL> } <EOL> } <EOL> CACHE_MIDDLEWARE_ALIAS = \"<STR_LIT>\" <EOL> CACHE_MIDDLEWARE_SECONDS", "gt": "= <NUM_LIT> * <NUM_LIT>", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> import requests <EOL> class TY_BFF : <EOL> def __init__ ( self , api_url ) : <EOL> self . session = requests . session ( ) <EOL> self . api_url = api_url <EOL> def request ( self , address ) : <EOL> response = self . session . get ( self . api_url , params = { \"<STR_LIT>\" : address . lower ( ) } ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return self . response ( response . json ( ) , address ) <EOL> else : <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } <EOL> def response ( self , response , address ) : <EOL> if geolocation_results := response . get ( \"<STR_LIT>\" , [ ] ) : <EOL> geolocation = geolocation_results [ <NUM_LIT> ] <EOL> geometry = geolocation [ \"<STR_LIT>\" ] <EOL> location = geometry . get ( \"<STR_LIT>\" , { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> viewport = geometry . get ( <EOL> \"<STR_LIT>\" , <EOL> { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> } , <EOL> ) <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\"", "gt": ": location [ \"<STR_LIT>\" ] ,", "repo": "deprem-yardim-backend"}
{"input": "import environ <EOL> from . base import * <EOL> env = environ . Env ( ) <EOL> DEBUG = False <EOL> AWS_LB_HOST = env ( \"<STR_LIT>\" ) <EOL> ALLOWED_HOSTS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> AWS_LB_HOST , <EOL> ] <EOL> CORS_ORIGIN_ALLOW_ALL = True <EOL> CSRF_TRUSTED_ORIGINS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> DATABASE_ROUTERS = [ \"<STR_LIT>\" ] <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : True , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\"", "gt": ": env ( \"<STR_LIT>\" ) ,", "repo": "deprem-yardim-backend"}
{"input": "import environ <EOL> from . base import * <EOL> env = environ . Env ( ) <EOL> DEBUG = False <EOL> AWS_LB_HOST = env ( \"<STR_LIT>\" ) <EOL> ALLOWED_HOSTS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> AWS_LB_HOST , <EOL> ] <EOL> CORS_ORIGIN_ALLOW_ALL = True <EOL> CSRF_TRUSTED_ORIGINS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> DATABASE_ROUTERS = [ \"<STR_LIT>\" ] <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : True , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\"", "gt": ": env ( \"<STR_LIT>\" ) ,", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> import requests <EOL> class TY_BFF : <EOL> def __init__ ( self , api_url ) : <EOL> self . session = requests . session ( ) <EOL> self . api_url = api_url <EOL> def request ( self , address ) : <EOL> response = self . session . get ( self . api_url , params = { \"<STR_LIT>\" : address . lower ( ) } ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return self . response ( response . json ( ) , address ) <EOL> else : <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } <EOL> def response ( self , response , address ) : <EOL> if geolocation_results := response . get ( \"<STR_LIT>\" , [ ] ) : <EOL> geolocation = geolocation_results [ <NUM_LIT> ] <EOL> geometry = geolocation [ \"<STR_LIT>\" ] <EOL> location = geometry . get ( \"<STR_LIT>\" , { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> viewport = geometry . get ( <EOL> \"<STR_LIT>\" , <EOL> { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> } , <EOL> ) <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : location [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : location [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\"", "gt": ": viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] ,", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> import requests <EOL> class TY_BFF : <EOL> def __init__ ( self , api_url ) : <EOL> self . session = requests . session ( ) <EOL> self . api_url = api_url <EOL> def request ( self , address ) : <EOL> response = self . session . get ( self . api_url , params = { \"<STR_LIT>\" : address . lower ( ) } ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return self . response ( response . json ( ) , address ) <EOL> else : <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } <EOL> def response ( self , response , address ) : <EOL> if geolocation_results := response . get ( \"<STR_LIT>\" , [ ] ) : <EOL> geolocation = geolocation_results [ <NUM_LIT> ] <EOL> geometry = geolocation [ \"<STR_LIT>\" ] <EOL> location = geometry . get ( \"<STR_LIT>\" , { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> viewport = geometry . get ( <EOL> \"<STR_LIT>\" , <EOL> { <EOL> \"<STR_LIT>\"", "gt": ": { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } ,", "repo": "deprem-yardim-backend"}
{"input": "import environ <EOL> from . base import * <EOL> env = environ . Env ( ) <EOL> DEBUG = False <EOL> AWS_LB_HOST = env ( \"<STR_LIT>\" ) <EOL> ALLOWED_HOSTS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> AWS_LB_HOST , <EOL> ] <EOL> CORS_ORIGIN_ALLOW_ALL = True <EOL> CSRF_TRUSTED_ORIGINS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> DATABASE_ROUTERS = [ \"<STR_LIT>\" ] <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : True , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\"", "gt": ": env ( \"<STR_LIT>\" ) ,", "repo": "deprem-yardim-backend"}
{"input": "import environ <EOL> from . base import * <EOL> env = environ . Env ( ) <EOL> DEBUG = False <EOL> AWS_LB_HOST = env ( \"<STR_LIT>\" ) <EOL> ALLOWED_HOSTS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> AWS_LB_HOST , <EOL> ] <EOL> CORS_ORIGIN_ALLOW_ALL = True <EOL> CSRF_TRUSTED_ORIGINS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> DATABASE_ROUTERS = [ \"<STR_LIT>\" ] <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : True , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\"", "gt": ": env ( \"<STR_LIT>\" ) ,", "repo": "deprem-yardim-backend"}
{"input": "import environ <EOL> from . base import * <EOL> env = environ . Env ( ) <EOL> DEBUG = False <EOL> AWS_LB_HOST = env ( \"<STR_LIT>\" ) <EOL> ALLOWED_HOSTS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> AWS_LB_HOST , <EOL> ] <EOL> CORS_ORIGIN_ALLOW_ALL = True <EOL> CSRF_TRUSTED_ORIGINS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> DATABASE_ROUTERS = [ \"<STR_LIT>\" ] <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : True , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\"", "gt": ": env ( \"<STR_LIT>\" ) ,", "repo": "deprem-yardim-backend"}
{"input": "import environ <EOL> from . base import * <EOL> env = environ . Env ( ) <EOL> DEBUG = False <EOL> AWS_LB_HOST = env ( \"<STR_LIT>\" ) <EOL> ALLOWED_HOSTS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> AWS_LB_HOST , <EOL> ] <EOL> CORS_ORIGIN_ALLOW_ALL = True <EOL> CSRF_TRUSTED_ORIGINS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> DATABASE_ROUTERS = [ \"<STR_LIT>\" ] <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : True , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\"", "gt": ": env ( \"<STR_LIT>\" ) ,", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> from django . http import HttpResponse <EOL> class HealthCheckMiddleware : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return", "gt": "HttpResponse ( json . dumps ( { \"<STR_LIT>\" : \"<STR_LIT>\" } ) )", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> import requests <EOL> class TY_BFF : <EOL> def __init__ ( self , api_url ) : <EOL> self . session = requests . session ( ) <EOL> self . api_url = api_url <EOL> def request ( self , address ) : <EOL> response = self . session . get ( self . api_url , params = { \"<STR_LIT>\" : address . lower ( ) } ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return self . response ( response . json ( ) , address ) <EOL> else : <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } <EOL> def response ( self , response , address ) : <EOL> if geolocation_results := response . get ( \"<STR_LIT>\" , [ ] ) : <EOL> geolocation = geolocation_results [ <NUM_LIT> ] <EOL> geometry = geolocation [ \"<STR_LIT>\" ] <EOL> location = geometry . get ( \"<STR_LIT>\" , { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> viewport = geometry . get ( <EOL> \"<STR_LIT>\" , <EOL> { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> } , <EOL> ) <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : location [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : location [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\"", "gt": ": viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] ,", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> from django . http import HttpResponse <EOL> class HealthCheckMiddleware : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if request . path == \"<STR_LIT>\" : <EOL> return HttpResponse ( json . dumps ( { \"<STR_LIT>\" : \"<STR_LIT>\" } ) ) <EOL> return", "gt": "self . get_response ( request )", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> import requests <EOL> class TY_BFF : <EOL> def __init__ ( self , api_url ) : <EOL> self . session = requests . session ( ) <EOL> self . api_url = api_url <EOL> def request ( self , address ) : <EOL> response = self . session . get ( self . api_url , params = { \"<STR_LIT>\" : address . lower ( ) } ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return self . response ( response . json ( ) , address ) <EOL> else : <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } <EOL> def response ( self , response , address ) : <EOL> if geolocation_results := response . get ( \"<STR_LIT>\" , [ ] ) : <EOL> geolocation = geolocation_results [ <NUM_LIT> ] <EOL> geometry = geolocation [ \"<STR_LIT>\" ] <EOL> location = geometry . get ( \"<STR_LIT>\" , { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> viewport = geometry . get ( <EOL> \"<STR_LIT>\" , <EOL> { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> \"<STR_LIT>\"", "gt": ": { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } ,", "repo": "deprem-yardim-backend"}
{"input": "import environ <EOL> from . base import * <EOL> env = environ . Env ( ) <EOL> DEBUG = False <EOL> AWS_LB_HOST = env ( \"<STR_LIT>\" ) <EOL> ALLOWED_HOSTS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> AWS_LB_HOST , <EOL> ] <EOL> CORS_ORIGIN_ALLOW_ALL = True <EOL> CSRF_TRUSTED_ORIGINS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> DATABASE_ROUTERS = [ \"<STR_LIT>\" ] <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : True , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : env ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> } <EOL> CACHES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ <EOL> env", "gt": "( \"<STR_LIT>\" ) ,", "repo": "deprem-yardim-backend"}
{"input": "import django . contrib . postgres . fields <EOL> from django . db import models , migrations <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL> model_name = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> field = django . contrib . postgres . fields . ArrayField ( <EOL> base_field", "gt": "= models . FloatField ( default = <NUM_LIT> ) , null = True , size = None", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> import requests <EOL> class TY_BFF : <EOL> def __init__ ( self , api_url ) : <EOL> self . session = requests . session ( ) <EOL> self . api_url = api_url <EOL> def request ( self , address ) : <EOL> response = self . session . get ( self . api_url , params = { \"<STR_LIT>\" : address . lower ( ) } ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return self . response ( response . json ( ) , address ) <EOL> else : <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } <EOL> def response ( self , response , address ) : <EOL> if geolocation_results := response . get ( \"<STR_LIT>\" , [ ] ) : <EOL> geolocation = geolocation_results [ <NUM_LIT> ] <EOL> geometry = geolocation [ \"<STR_LIT>\" ] <EOL> location = geometry . get ( \"<STR_LIT>\" , { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> viewport = geometry . get ( <EOL> \"<STR_LIT>\" , <EOL> { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> } , <EOL> ) <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : location [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : location [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\"", "gt": ": viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] ,", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> import requests <EOL> class TY_BFF : <EOL> def __init__ ( self , api_url ) : <EOL> self . session = requests . session ( ) <EOL> self . api_url = api_url <EOL> def request ( self , address ) : <EOL> response = self . session . get ( self . api_url , params = { \"<STR_LIT>\" : address . lower ( ) } ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return self . response ( response . json ( ) , address ) <EOL> else : <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } <EOL> def response ( self , response , address ) : <EOL> if geolocation_results := response . get ( \"<STR_LIT>\" , [ ] ) : <EOL> geolocation = geolocation_results [ <NUM_LIT> ] <EOL> geometry = geolocation [ \"<STR_LIT>\" ] <EOL> location = geometry . get ( \"<STR_LIT>\" , { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> viewport = geometry . get ( <EOL> \"<STR_LIT>\" , <EOL> { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> } , <EOL> ) <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : location [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\"", "gt": ": location [ \"<STR_LIT>\" ] ,", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> from django . http import HttpResponse <EOL> class HealthCheckMiddleware : <EOL> def __init__ ( self , get_response ) : <EOL> self . get_response = get_response <EOL> def __call__ ( self , request ) : <EOL> if", "gt": "request . path == \"<STR_LIT>\" :", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> import requests <EOL> class TY_BFF : <EOL> def __init__ ( self , api_url ) : <EOL> self . session = requests . session ( ) <EOL> self . api_url = api_url <EOL> def request ( self , address ) : <EOL> response = self . session . get ( self . api_url , params = { \"<STR_LIT>\" : address . lower ( ) } ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return self . response ( response . json ( ) , address ) <EOL> else : <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } <EOL> def response ( self , response , address ) : <EOL> if geolocation_results := response . get ( \"<STR_LIT>\" , [ ] ) : <EOL> geolocation = geolocation_results [ <NUM_LIT> ] <EOL> geometry = geolocation [ \"<STR_LIT>\" ] <EOL> location = geometry . get ( \"<STR_LIT>\" , { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> viewport = geometry . get ( <EOL> \"<STR_LIT>\" , <EOL> { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> } , <EOL> ) <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : location [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : location [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\"", "gt": ": geolocation [ \"<STR_LIT>\" ] ,", "repo": "deprem-yardim-backend"}
{"input": "import json <EOL> import requests <EOL> class TY_BFF : <EOL> def __init__ ( self , api_url ) : <EOL> self . session = requests . session ( ) <EOL> self . api_url = api_url <EOL> def request ( self , address ) : <EOL> response = self . session . get ( self . api_url , params = { \"<STR_LIT>\" : address . lower ( ) } ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return self . response ( response . json ( ) , address ) <EOL> else : <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } <EOL> def response ( self , response , address ) : <EOL> if geolocation_results := response . get ( \"<STR_LIT>\" , [ ] ) : <EOL> geolocation = geolocation_results [ <NUM_LIT> ] <EOL> geometry = geolocation [ \"<STR_LIT>\" ] <EOL> location = geometry . get ( \"<STR_LIT>\" , { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> viewport = geometry . get ( <EOL> \"<STR_LIT>\" , <EOL> { <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> } , <EOL> ) <EOL> return { <EOL> \"<STR_LIT>\" : address , <EOL> \"<STR_LIT>\" : location [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : location [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\"", "gt": ": viewport [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] ,", "repo": "deprem-yardim-backend"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self . assertEqual ( first . conflict , second . conflict ) <EOL> def test_get_payloads_constant ( self ) : <EOL> payloads = Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , payloads ) <EOL> def test_get_payloads_callable ( self ) : <EOL> def get_payloads ( test_case ) : <EOL> return Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = get_payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , get_payloads ( self ) <EOL> ) <EOL> def test_get_payloads_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , Payloads ( ok = { } ) ) <EOL> def test_get_payloads_property ( self ) : <EOL> payloads = property ( lambda test_case : Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request", "gt": "= self . simulate_request ,", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self . assertEqual ( first . conflict , second . conflict ) <EOL> def test_get_payloads_constant ( self ) : <EOL> payloads = Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , payloads ) <EOL> def test_get_payloads_callable ( self ) : <EOL> def get_payloads ( test_case ) : <EOL> return Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = get_payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , get_payloads ( self ) <EOL> ) <EOL> def test_get_payloads_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , Payloads ( ok = { } ) ) <EOL> def test_get_payloads_property ( self ) : <EOL> payloads = property ( lambda test_case : Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> ) <EOL> def test_get_payloads_type_error ( self ) : <EOL> payloads = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_payloads ( self ) <EOL> def assertHeadersEqual ( self , first : Headers , second : Headers ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . forbidden , second . forbidden ) <EOL> self . assertEqual ( first . unauthorized , second . unauthorized ) <EOL> def test_get_headers_constant ( self ) : <EOL> headers = Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = headers , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , headers ) <EOL> def test_get_headers_callable ( self ) : <EOL> def", "gt": "get_headers ( test_case ) :", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self . assertEqual ( first . conflict , second . conflict ) <EOL> def test_get_payloads_constant ( self ) : <EOL> payloads = Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , payloads ) <EOL> def test_get_payloads_callable ( self ) : <EOL> def get_payloads ( test_case ) : <EOL> return Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = get_payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , get_payloads ( self ) <EOL> ) <EOL> def test_get_payloads_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , Payloads ( ok = { } ) ) <EOL> def test_get_payloads_property ( self ) : <EOL> payloads = property ( lambda test_case : Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> ) <EOL> def test_get_payloads_type_error ( self ) : <EOL> payloads = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_payloads ( self ) <EOL> def assertHeadersEqual ( self , first : Headers , second : Headers ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . forbidden , second . forbidden ) <EOL> self . assertEqual ( first . unauthorized , second . unauthorized ) <EOL> def test_get_headers_constant ( self ) : <EOL> headers = Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = headers , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , headers ) <EOL> def test_get_headers_callable ( self ) : <EOL> def get_headers ( test_case ) : <EOL> return Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = get_headers , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , get_headers ( self ) ) <EOL> def", "gt": "test_get_headers_none ( self ) :", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self . assertEqual ( first . conflict , second . conflict ) <EOL> def test_get_payloads_constant ( self ) : <EOL> payloads = Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , payloads ) <EOL> def test_get_payloads_callable ( self ) : <EOL> def get_payloads ( test_case ) : <EOL> return Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = get_payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , get_payloads ( self ) <EOL> ) <EOL> def test_get_payloads_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , Payloads ( ok = { } ) ) <EOL> def test_get_payloads_property ( self ) : <EOL> payloads", "gt": "= property ( lambda test_case : Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) )", "repo": "django-ninja-crud"}
{"input": "import abc <EOL> import http <EOL> import uuid <EOL> from typing import TYPE_CHECKING , Callable , Dict , List , Optional , Type , Union <EOL> import ninja <EOL> import ninja . signature <EOL> import pydantic <EOL> from django . db . models import Field , ForeignKey , Model <EOL> from ninja_crud . views . abstract_view import AbstractView <EOL> from ninja_crud . views . enums import HTTPMethod <EOL> if TYPE_CHECKING : <EOL> from ninja_crud . viewsets import ModelViewSet <EOL> class AbstractModelView ( AbstractView , abc . ABC ) : <EOL> def __init__ ( <EOL> self , <EOL> method : HTTPMethod , <EOL> path : str , <EOL> path_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> query_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> request_body : Optional [ Type [ ninja . Schema ] ] = None , <EOL> response_body : Union [ Type [ ninja . Schema ] , Type [ List [ ninja . Schema ] ] , None ] = None , <EOL> response_status : http . HTTPStatus = http . HTTPStatus . OK , <EOL> decorators : Optional [ List [ Callable ] ] = None , <EOL> router_kwargs : Optional [ Dict ] = None , <EOL> ) -> None : <EOL> super ( ) . __init__ ( <EOL> method = method , <EOL> path = path , <EOL> path_parameters = path_parameters , <EOL> query_parameters = query_parameters , <EOL> request_body = request_body , <EOL> response_body = response_body , <EOL> response_status = response_status , <EOL> decorators = decorators , <EOL> router_kwargs = router_kwargs , <EOL> ) <EOL> self . _model_viewset_class : Optional [ Type [ \"<STR_LIT>\" ] ] = None <EOL> @ property <EOL> def model_viewset_class ( self ) -> Type [ \"<STR_LIT>\" ] : <EOL> if self . _model_viewset_class is None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> return self . _model_viewset_class <EOL> @ model_viewset_class . setter <EOL> def model_viewset_class ( self , model_viewset_class : Type [ \"<STR_LIT>\" ] ) -> None : <EOL> if self . _model_viewset_class is not None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> self . _model_viewset_class = model_viewset_class <EOL> self . _inherit_model_viewset_class_attributes ( ) <EOL> if not self . path_parameters : <EOL> self . _infer_path_parameters_schema_class ( ) <EOL> def _inherit_model_viewset_class_attributes ( self ) -> None : <EOL> pass <EOL> def _infer_path_parameters_schema_class ( self ) : <EOL> path_parameter_names", "gt": "= ninja . signature . utils . get_path_param_names (", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self . assertEqual ( first . conflict , second . conflict ) <EOL> def test_get_payloads_constant ( self ) : <EOL> payloads = Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , payloads ) <EOL> def test_get_payloads_callable ( self ) : <EOL> def get_payloads ( test_case ) : <EOL> return Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = get_payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , get_payloads ( self ) <EOL> ) <EOL> def test_get_payloads_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request", "gt": "= self . simulate_request ,", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self . assertEqual ( first . conflict , second . conflict ) <EOL> def test_get_payloads_constant ( self ) : <EOL> payloads = Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , payloads ) <EOL> def test_get_payloads_callable ( self ) : <EOL> def get_payloads ( test_case ) : <EOL> return Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = get_payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , get_payloads ( self ) <EOL> ) <EOL> def test_get_payloads_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , Payloads ( ok = { } ) ) <EOL> def test_get_payloads_property ( self ) : <EOL> payloads = property ( lambda test_case : Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> ) <EOL> def test_get_payloads_type_error ( self ) : <EOL> payloads = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_payloads ( self ) <EOL> def assertHeadersEqual ( self , first : Headers , second : Headers ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . forbidden , second . forbidden ) <EOL> self . assertEqual ( first . unauthorized , second . unauthorized ) <EOL> def test_get_headers_constant ( self ) : <EOL> headers = Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = headers , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , headers ) <EOL> def test_get_headers_callable ( self ) : <EOL> def get_headers ( test_case ) : <EOL> return Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = get_headers , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , get_headers ( self ) ) <EOL> def test_get_headers_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self", "gt": ". assertHeadersEqual ( view_test_manager . get_headers ( self ) , Headers ( ok = { } ) )", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self . assertEqual ( first . conflict , second . conflict ) <EOL> def test_get_payloads_constant ( self ) : <EOL> payloads = Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , payloads ) <EOL> def test_get_payloads_callable ( self ) : <EOL> def get_payloads ( test_case ) : <EOL> return Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = get_payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , get_payloads ( self ) <EOL> ) <EOL> def test_get_payloads_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , Payloads ( ok = { } ) ) <EOL> def test_get_payloads_property ( self ) : <EOL> payloads = property ( lambda test_case : Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> ) <EOL> def test_get_payloads_type_error ( self ) : <EOL> payloads = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_payloads ( self ) <EOL> def assertHeadersEqual ( self , first : Headers , second : Headers ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . forbidden , second . forbidden ) <EOL> self . assertEqual ( first . unauthorized , second . unauthorized ) <EOL> def test_get_headers_constant ( self ) : <EOL> headers = Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = headers , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , headers ) <EOL> def test_get_headers_callable ( self ) : <EOL> def get_headers ( test_case ) : <EOL> return Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = get_headers , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , get_headers ( self ) ) <EOL> def test_get_headers_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , Headers ( ok = { } ) ) <EOL> def test_get_headers_property ( self ) : <EOL> headers = property ( lambda test_case : Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = headers , <EOL> ) <EOL> self . assertHeadersEqual ( <EOL> view_test_manager . get_headers ( self ) , Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> ) <EOL> def test_get_headers_type_error ( self ) : <EOL> headers = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request", "gt": "= self . simulate_request ,", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self", "gt": ". assertEqual ( first . conflict , second . conflict )", "repo": "django-ninja-crud"}
{"input": "from functools import wraps <EOL> from typing import List <EOL> from django . core . exceptions import PermissionDenied <EOL> from ninja import Router <EOL> from ninja_crud . views import ( <EOL> CreateModelView , <EOL> DeleteModelView , <EOL> ListModelView , <EOL> ReadModelView , <EOL> UpdateModelView , <EOL> ) <EOL> from ninja_crud . viewsets import ModelViewSet <EOL> from tests . test_app . models import Collection , Item <EOL> from tests . test_app . schemas import ( <EOL> CollectionFilter , <EOL> CollectionIn , <EOL> CollectionOut , <EOL> ItemIn , <EOL> ItemOut , <EOL> ) <EOL> router = Router ( ) <EOL> def user_is_creator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( request , * args , ** kwargs ) : <EOL> collection_id = getattr ( kwargs . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" , None ) <EOL> collection = Collection . objects . get ( id = collection_id ) <EOL> if collection . created_by != request . auth : <EOL> raise PermissionDenied ( ) <EOL> return func ( request , * args , ** kwargs ) <EOL> return wrapper <EOL> class CollectionViewSet ( ModelViewSet ) : <EOL> model = Collection <EOL> list_collections = ListModelView ( <EOL> response_body = List [ CollectionOut ] , query_parameters = CollectionFilter <EOL> ) <EOL> create_collection = CreateModelView ( <EOL> request_body = CollectionIn , <EOL> response_body = CollectionOut , <EOL> init_model = lambda request , path_parameters : Collection ( created_by = request . auth ) , <EOL> pre_save = lambda request , instance : instance . full_clean ( ) , <EOL> post_save = lambda request , instance : None , <EOL> ) <EOL> read_collection = ReadModelView ( response_body = CollectionOut ) <EOL> update_collection = UpdateModelView ( <EOL> request_body = CollectionIn , <EOL> response_body = CollectionOut , <EOL> decorators = [ user_is_creator ] , <EOL> ) <EOL> delete_collection = DeleteModelView ( <EOL> pre_delete = lambda request , instance : None , <EOL> post_delete = lambda request , instance : None , <EOL> decorators = [ user_is_creator ] , <EOL> ) <EOL> list_collection_items = ListModelView ( <EOL> path = \"<STR_LIT>\" , <EOL> get_queryset = lambda request , path_parameters : Item . objects . filter ( <EOL> collection_id = getattr ( path_parameters , \"<STR_LIT>\" , None ) <EOL> ) , <EOL> response_body = List [ ItemOut ] , <EOL> decorators", "gt": "= [ user_is_creator ] ,", "repo": "django-ninja-crud"}
{"input": "from functools import wraps <EOL> from typing import List <EOL> from django . core . exceptions import PermissionDenied <EOL> from ninja import Router <EOL> from ninja_crud . views import ( <EOL> CreateModelView , <EOL> DeleteModelView , <EOL> ListModelView , <EOL> ReadModelView , <EOL> UpdateModelView , <EOL> ) <EOL> from ninja_crud . viewsets import ModelViewSet <EOL> from tests . test_app . models import Collection , Item <EOL> from tests . test_app . schemas import ( <EOL> CollectionFilter , <EOL> CollectionIn , <EOL> CollectionOut , <EOL> ItemIn , <EOL> ItemOut , <EOL> ) <EOL> router = Router ( ) <EOL> def user_is_creator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( request , * args , ** kwargs ) : <EOL> collection_id = getattr ( kwargs . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" , None ) <EOL> collection = Collection . objects . get ( id = collection_id ) <EOL> if collection . created_by != request . auth : <EOL> raise PermissionDenied ( ) <EOL> return func ( request , * args , ** kwargs ) <EOL> return wrapper <EOL> class CollectionViewSet ( ModelViewSet ) : <EOL> model = Collection <EOL> list_collections = ListModelView ( <EOL> response_body = List [ CollectionOut ] , query_parameters = CollectionFilter <EOL> ) <EOL> create_collection = CreateModelView ( <EOL> request_body = CollectionIn , <EOL> response_body = CollectionOut , <EOL> init_model = lambda request , path_parameters : Collection ( created_by = request . auth ) , <EOL> pre_save = lambda request , instance : instance . full_clean ( ) , <EOL> post_save = lambda request , instance : None , <EOL> ) <EOL> read_collection = ReadModelView ( response_body = CollectionOut ) <EOL> update_collection = UpdateModelView ( <EOL> request_body = CollectionIn , <EOL> response_body = CollectionOut , <EOL> decorators = [ user_is_creator ] , <EOL> ) <EOL> delete_collection = DeleteModelView ( <EOL> pre_delete = lambda request , instance : None , <EOL> post_delete = lambda request , instance : None , <EOL> decorators = [ user_is_creator ] , <EOL> ) <EOL> list_collection_items = ListModelView ( <EOL> path = \"<STR_LIT>\" , <EOL> get_queryset = lambda request , path_parameters : Item . objects . filter ( <EOL> collection_id = getattr ( path_parameters , \"<STR_LIT>\" , None ) <EOL> ) , <EOL> response_body = List [ ItemOut ] , <EOL> decorators = [ user_is_creator ] , <EOL> ) <EOL> create_collection_item = CreateModelView ( <EOL> path = \"<STR_LIT>\" , <EOL> init_model = lambda request , path_parameters : Item ( <EOL> collection_id = getattr ( path_parameters , \"<STR_LIT>\" , None ) <EOL> ) , <EOL> request_body = ItemIn , <EOL> response_body = ItemOut , <EOL> pre_save = lambda request , instance : instance . full_clean ( ) , <EOL> post_save", "gt": "= lambda request , instance : None ,", "repo": "django-ninja-crud"}
{"input": "import abc <EOL> import http <EOL> import uuid <EOL> from typing import TYPE_CHECKING , Callable , Dict , List , Optional , Type , Union <EOL> import ninja <EOL> import ninja . signature <EOL> import pydantic <EOL> from django . db . models import Field , ForeignKey , Model <EOL> from ninja_crud . views . abstract_view import AbstractView <EOL> from ninja_crud . views . enums import HTTPMethod <EOL> if TYPE_CHECKING : <EOL> from ninja_crud . viewsets import ModelViewSet <EOL> class AbstractModelView ( AbstractView , abc . ABC ) : <EOL> def __init__ ( <EOL> self , <EOL> method : HTTPMethod , <EOL> path : str , <EOL> path_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> query_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> request_body : Optional [ Type [ ninja . Schema ] ] = None , <EOL> response_body : Union [ Type [ ninja . Schema ] , Type [ List [ ninja . Schema ] ] , None ] = None , <EOL> response_status : http . HTTPStatus = http . HTTPStatus . OK , <EOL> decorators : Optional [ List [ Callable ] ] = None , <EOL> router_kwargs : Optional [ Dict ] = None , <EOL> ) -> None : <EOL> super ( ) . __init__ ( <EOL> method = method , <EOL> path = path , <EOL> path_parameters = path_parameters , <EOL> query_parameters = query_parameters , <EOL> request_body = request_body , <EOL> response_body = response_body , <EOL> response_status = response_status , <EOL> decorators = decorators , <EOL> router_kwargs = router_kwargs , <EOL> ) <EOL> self . _model_viewset_class : Optional [ Type [ \"<STR_LIT>\" ] ] = None <EOL> @ property <EOL> def model_viewset_class ( self ) -> Type [ \"<STR_LIT>\" ] : <EOL> if self . _model_viewset_class is None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> return self . _model_viewset_class <EOL> @ model_viewset_class . setter <EOL> def model_viewset_class ( self , model_viewset_class : Type [ \"<STR_LIT>\" ] ) -> None : <EOL> if self . _model_viewset_class is not None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> self . _model_viewset_class = model_viewset_class <EOL> self . _inherit_model_viewset_class_attributes ( ) <EOL> if not self . path_parameters : <EOL> self . _infer_path_parameters_schema_class ( ) <EOL> def _inherit_model_viewset_class_attributes ( self ) -> None : <EOL> pass <EOL> def _infer_path_parameters_schema_class ( self ) : <EOL> path_parameter_names = ninja . signature . utils . get_path_param_names ( <EOL> path = self . path <EOL> ) <EOL> if not path_parameter_names : <EOL> return <EOL> path_parameter_field_definitions = { <EOL> path_parameter_name : ( <EOL> self . _infer_field_type ( <EOL> model_class = self . model_viewset_class . model , <EOL> field_name = path_parameter_name , <EOL> ) , <EOL> ... , <EOL> ) <EOL> for path_parameter_name in path_parameter_names <EOL> } <EOL> self . path_parameters = pydantic . create_model ( <EOL> __model_name = \"<STR_LIT>\" , ** path_parameter_field_definitions <EOL> ) <EOL> @ classmethod <EOL> def _infer_field_type ( cls , model_class : Type [ Model ] , field_name : str ) -> Type : <EOL> field : Field = model_class . _meta . get_field ( field_name ) <EOL> if isinstance ( field , ForeignKey ) and field_name == field . attname : <EOL> related_model_class : Type [ Model ] = field . related_model <EOL> return", "gt": "cls . _infer_field_type (", "repo": "django-ninja-crud"}
{"input": "import abc <EOL> import http <EOL> import uuid <EOL> from typing import TYPE_CHECKING , Callable , Dict , List , Optional , Type , Union <EOL> import ninja <EOL> import ninja . signature <EOL> import pydantic <EOL> from django . db . models import Field , ForeignKey , Model <EOL> from ninja_crud . views . abstract_view import AbstractView <EOL> from ninja_crud . views . enums import HTTPMethod <EOL> if TYPE_CHECKING : <EOL> from ninja_crud . viewsets import ModelViewSet <EOL> class AbstractModelView ( AbstractView , abc . ABC ) : <EOL> def __init__ ( <EOL> self , <EOL> method : HTTPMethod , <EOL> path : str , <EOL> path_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> query_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> request_body : Optional [ Type [ ninja . Schema ] ] = None , <EOL> response_body : Union [ Type [ ninja . Schema ] , Type [ List [ ninja . Schema ] ] , None ] = None , <EOL> response_status : http . HTTPStatus = http . HTTPStatus . OK , <EOL> decorators : Optional [ List [ Callable ] ] = None , <EOL> router_kwargs : Optional [ Dict ] = None , <EOL> ) -> None : <EOL> super ( ) . __init__ ( <EOL> method = method , <EOL> path = path , <EOL> path_parameters = path_parameters , <EOL> query_parameters = query_parameters , <EOL> request_body = request_body , <EOL> response_body = response_body , <EOL> response_status = response_status , <EOL> decorators = decorators , <EOL> router_kwargs = router_kwargs , <EOL> ) <EOL> self . _model_viewset_class : Optional [ Type [ \"<STR_LIT>\" ] ] = None <EOL> @ property <EOL> def model_viewset_class ( self ) -> Type [ \"<STR_LIT>\" ] : <EOL> if self . _model_viewset_class is None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> return self . _model_viewset_class <EOL> @ model_viewset_class . setter <EOL> def model_viewset_class ( self , model_viewset_class : Type [ \"<STR_LIT>\" ] ) -> None : <EOL> if self . _model_viewset_class is not None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> self . _model_viewset_class = model_viewset_class <EOL> self . _inherit_model_viewset_class_attributes ( ) <EOL> if not self . path_parameters : <EOL> self . _infer_path_parameters_schema_class ( ) <EOL> def _inherit_model_viewset_class_attributes ( self ) -> None : <EOL> pass <EOL> def _infer_path_parameters_schema_class ( self ) : <EOL> path_parameter_names = ninja . signature . utils . get_path_param_names ( <EOL> path = self . path <EOL> ) <EOL> if not path_parameter_names : <EOL> return <EOL> path_parameter_field_definitions = { <EOL> path_parameter_name : ( <EOL> self . _infer_field_type ( <EOL> model_class = self . model_viewset_class . model , <EOL> field_name = path_parameter_name , <EOL> ) , <EOL> ... , <EOL> ) <EOL> for path_parameter_name in path_parameter_names <EOL> } <EOL> self . path_parameters = pydantic . create_model ( <EOL> __model_name = \"<STR_LIT>\" , ** path_parameter_field_definitions <EOL> ) <EOL> @ classmethod <EOL> def _infer_field_type ( cls , model_class : Type [ Model ] , field_name : str ) -> Type : <EOL> field : Field = model_class . _meta . get_field ( field_name ) <EOL> if isinstance ( field , ForeignKey ) and field_name == field . attname : <EOL> related_model_class : Type [ Model ] = field . related_model <EOL> return cls . _infer_field_type ( <EOL> model_class = related_model_class , <EOL> field_name = related_model_class . _meta . pk . name , <EOL> ) <EOL> type_mapping = { <EOL> \"<STR_LIT>\" : int , <EOL> \"<STR_LIT>\" : int , <EOL> \"<STR_LIT>\" : int , <EOL> \"<STR_LIT>\" : int , <EOL> \"<STR_LIT>\" : int , <EOL> \"<STR_LIT>\" : int , <EOL> \"<STR_LIT>\" : int , <EOL> \"<STR_LIT>\" : int , <EOL> \"<STR_LIT>\" : int , <EOL> \"<STR_LIT>\"", "gt": ": uuid . UUID ,", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self . assertEqual ( first . conflict , second . conflict ) <EOL> def test_get_payloads_constant ( self ) : <EOL> payloads = Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , payloads ) <EOL> def test_get_payloads_callable ( self ) : <EOL> def get_payloads ( test_case ) : <EOL> return Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = get_payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , get_payloads ( self ) <EOL> ) <EOL> def test_get_payloads_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , Payloads ( ok = { } ) ) <EOL> def test_get_payloads_property ( self ) : <EOL> payloads = property ( lambda test_case : Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> ) <EOL> def test_get_payloads_type_error ( self ) : <EOL> payloads = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_payloads ( self ) <EOL> def assertHeadersEqual ( self , first : Headers , second : Headers ) : <EOL> self", "gt": ". assertEqual ( first . ok , second . ok )", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self . assertEqual ( first . conflict , second . conflict ) <EOL> def test_get_payloads_constant ( self ) : <EOL> payloads = Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , payloads ) <EOL> def", "gt": "test_get_payloads_callable ( self ) :", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self . assertEqual ( first . conflict , second . conflict ) <EOL> def test_get_payloads_constant ( self ) : <EOL> payloads = Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , payloads ) <EOL> def test_get_payloads_callable ( self ) : <EOL> def get_payloads ( test_case ) : <EOL> return Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = get_payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , get_payloads ( self ) <EOL> ) <EOL> def test_get_payloads_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , Payloads ( ok = { } ) ) <EOL> def test_get_payloads_property ( self ) : <EOL> payloads = property ( lambda test_case : Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> ) <EOL> def test_get_payloads_type_error ( self ) : <EOL> payloads = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_payloads ( self ) <EOL> def assertHeadersEqual ( self , first : Headers , second : Headers ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . forbidden , second . forbidden ) <EOL> self . assertEqual ( first . unauthorized , second . unauthorized ) <EOL> def test_get_headers_constant ( self ) : <EOL> headers = Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = headers , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , headers ) <EOL> def test_get_headers_callable ( self ) : <EOL> def get_headers ( test_case ) : <EOL> return Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = get_headers , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , get_headers ( self ) ) <EOL> def test_get_headers_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , Headers ( ok = { } ) ) <EOL> def test_get_headers_property ( self ) : <EOL> headers = property ( lambda test_case : Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = headers , <EOL> ) <EOL> self . assertHeadersEqual ( <EOL> view_test_manager . get_headers ( self ) , Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> ) <EOL> def test_get_headers_type_error ( self ) : <EOL> headers = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = headers , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager", "gt": ". get_headers ( self )", "repo": "django-ninja-crud"}
{"input": "import unittest <EOL> from typing import List <EOL> from unittest . mock import patch <EOL> from examples . models import Department <EOL> from examples . schemas import DepartmentOut <EOL> from ninja_crud . testing . views import ListModelViewTest <EOL> from ninja_crud . testing . viewsets import ModelViewSetTestCase <EOL> from ninja_crud . views import ListModelView <EOL> from ninja_crud . viewsets import ModelViewSet <EOL> class TestModelViewSetTestCase ( unittest . TestCase ) : <EOL> def test_get_associated_model_view_ok ( self ) : <EOL> class ExampleModelViewSet ( ModelViewSet ) : <EOL> model = Department <EOL> list_view = ListModelView ( response_body = List [ DepartmentOut ] ) <EOL> class TestExampleModelViewSet ( ModelViewSetTestCase ) : <EOL> test_list_view = ListModelViewTest ( ) <EOL> TestExampleModelViewSet . model_viewset_class = ExampleModelViewSet <EOL> associated_model_view = TestExampleModelViewSet . _get_associated_model_view ( <EOL> test_attr_name = \"<STR_LIT>\" , model_view_class = ListModelView <EOL> ) <EOL> self . assertEqual ( associated_model_view , ExampleModelViewSet . list_view ) <EOL> def test_get_associated_model_view_not_found ( self ) : <EOL> class ExampleModelViewSet ( ModelViewSet ) : <EOL> model = Department <EOL> class TestExampleModelViewSet ( ModelViewSetTestCase ) : <EOL> test_list_view = ListModelViewTest ( ) <EOL> TestExampleModelViewSet . model_viewset_class = ExampleModelViewSet <EOL> with self . assertRaises ( ValueError ) : <EOL> TestExampleModelViewSet . _get_associated_model_view ( <EOL> test_attr_name = \"<STR_LIT>\" , model_view_class = ListModelView <EOL> ) <EOL> def test_check_all_model_views_associated_ok ( self ) : <EOL> class ExampleModelViewSet ( ModelViewSet ) : <EOL> model = Department <EOL> list_view = ListModelView ( response_body = List [ DepartmentOut ] ) <EOL> class TestExampleModelViewSet ( ModelViewSetTestCase ) : <EOL> test_list_view = ListModelViewTest ( ) <EOL> TestExampleModelViewSet . model_viewset_class = ExampleModelViewSet <EOL> TestExampleModelViewSet . _check_all_model_views_associated ( <EOL> associated_model_views = [ ExampleModelViewSet . list_view ] <EOL> ) <EOL> def test_check_all_model_views_associated_not_found ( self ) : <EOL> class ExampleModelViewSet ( ModelViewSet ) : <EOL> model = Department <EOL> list_view = ListModelView ( response_body = List [ DepartmentOut ] ) <EOL> other_list_view = ListModelView ( response_body = List [ DepartmentOut ] ) <EOL> class TestExampleModelViewSet ( ModelViewSetTestCase ) : <EOL> test_list_view = ListModelViewTest ( ) <EOL> TestExampleModelViewSet . model_viewset_class = ExampleModelViewSet <EOL> with patch ( <EOL> \"<STR_LIT>\" <EOL> ) as mock_logger : <EOL> TestExampleModelViewSet . _check_all_model_views_associated ( <EOL> associated_model_views", "gt": "= [ ExampleModelViewSet . list_view ]", "repo": "django-ninja-crud"}
{"input": "import abc <EOL> import http <EOL> import uuid <EOL> from typing import TYPE_CHECKING , Callable , Dict , List , Optional , Type , Union <EOL> import ninja <EOL> import ninja . signature <EOL> import pydantic <EOL> from django . db . models import Field , ForeignKey , Model <EOL> from ninja_crud . views . abstract_view import AbstractView <EOL> from ninja_crud . views . enums import HTTPMethod <EOL> if TYPE_CHECKING : <EOL> from ninja_crud . viewsets import ModelViewSet <EOL> class AbstractModelView ( AbstractView , abc . ABC ) : <EOL> def __init__ ( <EOL> self , <EOL> method : HTTPMethod , <EOL> path : str , <EOL> path_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> query_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> request_body : Optional [ Type [ ninja . Schema ] ] = None , <EOL> response_body : Union [ Type [ ninja . Schema ] , Type [ List [ ninja . Schema ] ] , None ] = None , <EOL> response_status : http . HTTPStatus = http . HTTPStatus . OK , <EOL> decorators : Optional [ List [ Callable ] ] = None , <EOL> router_kwargs : Optional [ Dict ] = None , <EOL> ) -> None : <EOL> super ( ) . __init__ ( <EOL> method = method , <EOL> path = path , <EOL> path_parameters = path_parameters , <EOL> query_parameters = query_parameters , <EOL> request_body = request_body , <EOL> response_body = response_body , <EOL> response_status = response_status , <EOL> decorators = decorators , <EOL> router_kwargs = router_kwargs , <EOL> ) <EOL> self . _model_viewset_class : Optional [ Type [ \"<STR_LIT>\" ] ] = None <EOL> @ property <EOL> def model_viewset_class ( self ) -> Type [ \"<STR_LIT>\" ] : <EOL> if self . _model_viewset_class is None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> return self . _model_viewset_class <EOL> @ model_viewset_class . setter <EOL> def model_viewset_class ( self , model_viewset_class : Type [ \"<STR_LIT>\" ] ) -> None : <EOL> if self . _model_viewset_class is not None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> self . _model_viewset_class = model_viewset_class <EOL> self . _inherit_model_viewset_class_attributes ( ) <EOL> if not self . path_parameters : <EOL> self . _infer_path_parameters_schema_class ( ) <EOL> def _inherit_model_viewset_class_attributes ( self ) -> None : <EOL> pass <EOL> def _infer_path_parameters_schema_class ( self ) : <EOL> path_parameter_names = ninja . signature . utils . get_path_param_names ( <EOL> path = self . path <EOL> ) <EOL> if not path_parameter_names : <EOL> return <EOL> path_parameter_field_definitions = { <EOL> path_parameter_name : ( <EOL> self . _infer_field_type ( <EOL> model_class = self . model_viewset_class . model , <EOL> field_name = path_parameter_name , <EOL> ) , <EOL> ... , <EOL> ) <EOL> for path_parameter_name in path_parameter_names <EOL> } <EOL> self . path_parameters = pydantic . create_model ( <EOL> __model_name = \"<STR_LIT>\" , ** path_parameter_field_definitions <EOL> ) <EOL> @ classmethod <EOL> def _infer_field_type ( cls , model_class : Type [ Model ] , field_name : str ) -> Type : <EOL> field : Field = model_class . _meta . get_field ( field_name ) <EOL> if", "gt": "isinstance ( field , ForeignKey ) and field_name == field . attname :", "repo": "django-ninja-crud"}
{"input": "import abc <EOL> import http <EOL> import uuid <EOL> from typing import TYPE_CHECKING , Callable , Dict , List , Optional , Type , Union <EOL> import ninja <EOL> import ninja . signature <EOL> import pydantic <EOL> from django . db . models import Field , ForeignKey , Model <EOL> from ninja_crud . views . abstract_view import AbstractView <EOL> from ninja_crud . views . enums import HTTPMethod <EOL> if TYPE_CHECKING : <EOL> from ninja_crud . viewsets import ModelViewSet <EOL> class AbstractModelView ( AbstractView , abc . ABC ) : <EOL> def __init__ ( <EOL> self , <EOL> method : HTTPMethod , <EOL> path : str , <EOL> path_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> query_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> request_body : Optional [ Type [ ninja . Schema ] ] = None , <EOL> response_body : Union [ Type [ ninja . Schema ] , Type [ List [ ninja . Schema ] ] , None ] = None , <EOL> response_status : http . HTTPStatus = http . HTTPStatus . OK , <EOL> decorators : Optional [ List [ Callable ] ] = None , <EOL> router_kwargs : Optional [ Dict ] = None , <EOL> ) -> None : <EOL> super ( ) . __init__ ( <EOL> method = method , <EOL> path = path , <EOL> path_parameters = path_parameters , <EOL> query_parameters = query_parameters , <EOL> request_body = request_body , <EOL> response_body = response_body , <EOL> response_status = response_status , <EOL> decorators = decorators , <EOL> router_kwargs = router_kwargs , <EOL> ) <EOL> self . _model_viewset_class : Optional [ Type [ \"<STR_LIT>\" ] ] = None <EOL> @ property <EOL> def model_viewset_class ( self ) -> Type [ \"<STR_LIT>\" ] : <EOL> if self . _model_viewset_class is None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> return self . _model_viewset_class <EOL> @ model_viewset_class . setter <EOL> def model_viewset_class ( self , model_viewset_class : Type [ \"<STR_LIT>\" ] ) -> None : <EOL> if self . _model_viewset_class is not None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> self . _model_viewset_class = model_viewset_class <EOL> self . _inherit_model_viewset_class_attributes ( ) <EOL> if not self . path_parameters : <EOL> self", "gt": ". _infer_path_parameters_schema_class ( )", "repo": "django-ninja-crud"}
{"input": "import abc <EOL> import http <EOL> import uuid <EOL> from typing import TYPE_CHECKING , Callable , Dict , List , Optional , Type , Union <EOL> import ninja <EOL> import ninja . signature <EOL> import pydantic <EOL> from django . db . models import Field , ForeignKey , Model <EOL> from ninja_crud . views . abstract_view import AbstractView <EOL> from ninja_crud . views . enums import HTTPMethod <EOL> if TYPE_CHECKING : <EOL> from ninja_crud . viewsets import ModelViewSet <EOL> class AbstractModelView ( AbstractView , abc . ABC ) : <EOL> def __init__ ( <EOL> self , <EOL> method : HTTPMethod , <EOL> path : str , <EOL> path_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> query_parameters : Optional [ Type [ ninja . Schema ] ] = None , <EOL> request_body : Optional [ Type [ ninja . Schema ] ] = None , <EOL> response_body : Union [ Type [ ninja . Schema ] , Type [ List [ ninja . Schema ] ] , None ] = None , <EOL> response_status : http . HTTPStatus = http . HTTPStatus . OK , <EOL> decorators : Optional [ List [ Callable ] ] = None , <EOL> router_kwargs : Optional [ Dict ] = None , <EOL> ) -> None : <EOL> super ( ) . __init__ ( <EOL> method = method , <EOL> path = path , <EOL> path_parameters = path_parameters , <EOL> query_parameters = query_parameters , <EOL> request_body = request_body , <EOL> response_body = response_body , <EOL> response_status = response_status , <EOL> decorators = decorators , <EOL> router_kwargs = router_kwargs , <EOL> ) <EOL> self . _model_viewset_class : Optional [ Type [ \"<STR_LIT>\" ] ] = None <EOL> @ property <EOL> def model_viewset_class ( self ) -> Type [ \"<STR_LIT>\" ] : <EOL> if self . _model_viewset_class is None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> return self . _model_viewset_class <EOL> @ model_viewset_class . setter <EOL> def model_viewset_class ( self , model_viewset_class : Type [ \"<STR_LIT>\" ] ) -> None : <EOL> if self . _model_viewset_class is not None : <EOL> raise ValueError ( <EOL> f\"<STR_LIT>\" <EOL> ) <EOL> self . _model_viewset_class = model_viewset_class <EOL> self . _inherit_model_viewset_class_attributes ( ) <EOL> if not self . path_parameters : <EOL> self . _infer_path_parameters_schema_class ( ) <EOL> def _inherit_model_viewset_class_attributes ( self ) -> None : <EOL> pass <EOL> def _infer_path_parameters_schema_class ( self ) : <EOL> path_parameter_names = ninja . signature . utils . get_path_param_names ( <EOL> path = self . path <EOL> ) <EOL> if not path_parameter_names : <EOL> return <EOL> path_parameter_field_definitions = { <EOL> path_parameter_name : ( <EOL> self . _infer_field_type ( <EOL> model_class = self . model_viewset_class . model , <EOL> field_name = path_parameter_name , <EOL> ) , <EOL> ... , <EOL> ) <EOL> for path_parameter_name in path_parameter_names <EOL> } <EOL> self . path_parameters = pydantic . create_model ( <EOL> __model_name", "gt": "= \"<STR_LIT>\" , ** path_parameter_field_definitions", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> self . assertEqual ( first . conflict , second . conflict ) <EOL> def test_get_payloads_constant ( self ) : <EOL> payloads = Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , payloads ) <EOL> def test_get_payloads_callable ( self ) : <EOL> def get_payloads ( test_case ) : <EOL> return Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = get_payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , get_payloads ( self ) <EOL> ) <EOL> def test_get_payloads_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPayloadsEqual ( view_test_manager . get_payloads ( self ) , Payloads ( ok = { } ) ) <EOL> def test_get_payloads_property ( self ) : <EOL> payloads = property ( lambda test_case : Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> self . assertPayloadsEqual ( <EOL> view_test_manager . get_payloads ( self ) , Payloads ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> ) <EOL> def test_get_payloads_type_error ( self ) : <EOL> payloads = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> payloads = payloads , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_payloads ( self ) <EOL> def assertHeadersEqual ( self , first : Headers , second : Headers ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . forbidden , second . forbidden ) <EOL> self . assertEqual ( first . unauthorized , second . unauthorized ) <EOL> def test_get_headers_constant ( self ) : <EOL> headers = Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> headers = headers , <EOL> ) <EOL> self . assertHeadersEqual ( view_test_manager . get_headers ( self ) , headers ) <EOL> def test_get_headers_callable ( self ) : <EOL> def get_headers ( test_case ) : <EOL> return", "gt": "Headers ( ok = { \"<STR_LIT>\" : \"<STR_LIT>\" } )", "repo": "django-ninja-crud"}
{"input": "from functools import wraps <EOL> from typing import List <EOL> from django . core . exceptions import PermissionDenied <EOL> from ninja import Router <EOL> from ninja_crud . views import ( <EOL> CreateModelView , <EOL> DeleteModelView , <EOL> ListModelView , <EOL> ReadModelView , <EOL> UpdateModelView , <EOL> ) <EOL> from ninja_crud . viewsets import ModelViewSet <EOL> from tests . test_app . models import Collection , Item <EOL> from tests . test_app . schemas import ( <EOL> CollectionFilter , <EOL> CollectionIn , <EOL> CollectionOut , <EOL> ItemIn , <EOL> ItemOut , <EOL> ) <EOL> router = Router ( ) <EOL> def user_is_creator ( func ) : <EOL> @ wraps ( func ) <EOL> def wrapper ( request , * args , ** kwargs ) : <EOL> collection_id = getattr ( kwargs . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" , None ) <EOL> collection = Collection . objects . get ( id = collection_id ) <EOL> if collection . created_by != request . auth : <EOL> raise PermissionDenied ( ) <EOL> return func ( request , * args , ** kwargs ) <EOL> return wrapper <EOL> class CollectionViewSet ( ModelViewSet ) : <EOL> model = Collection <EOL> list_collections = ListModelView ( <EOL> response_body = List [ CollectionOut ] , query_parameters = CollectionFilter <EOL> ) <EOL> create_collection = CreateModelView ( <EOL> request_body = CollectionIn , <EOL> response_body = CollectionOut , <EOL> init_model = lambda request , path_parameters : Collection ( created_by = request . auth ) , <EOL> pre_save = lambda request , instance : instance . full_clean ( ) , <EOL> post_save = lambda request , instance : None , <EOL> ) <EOL> read_collection = ReadModelView ( response_body = CollectionOut ) <EOL> update_collection = UpdateModelView ( <EOL> request_body = CollectionIn , <EOL> response_body = CollectionOut , <EOL> decorators = [ user_is_creator ] , <EOL> ) <EOL> delete_collection = DeleteModelView ( <EOL> pre_delete = lambda request , instance : None , <EOL> post_delete = lambda request , instance : None , <EOL> decorators = [ user_is_creator ] , <EOL> ) <EOL> list_collection_items = ListModelView ( <EOL> path = \"<STR_LIT>\" , <EOL> get_queryset = lambda request , path_parameters : Item . objects . filter ( <EOL> collection_id = getattr ( path_parameters , \"<STR_LIT>\" , None ) <EOL> ) , <EOL> response_body", "gt": "= List [ ItemOut ] ,", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager", "gt": ". get_query_parameters ( self )", "repo": "django-ninja-crud"}
{"input": "SECRET_KEY = \"<STR_LIT>\" <EOL> INSTALLED_APPS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> DATABASES = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> } <EOL> DEFAULT_AUTO_FIELD = \"<STR_LIT>\" <EOL> ROOT_URLCONF = \"<STR_LIT>\" <EOL> ALLOWED_HOSTS = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> TEMPLATES = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : { } , <EOL> } , <EOL> ] <EOL> LOGGING = { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\"", "gt": ": [ \"<STR_LIT>\" ] ,", "repo": "django-ninja-crud"}
{"input": "import django . test <EOL> from django . http import HttpResponse <EOL> from ninja_crud . testing . core import ViewTestManager <EOL> from ninja_crud . testing . core . components import ( <EOL> Headers , <EOL> PathParameters , <EOL> Payloads , <EOL> QueryParameters , <EOL> ) <EOL> class TestViewTestManager ( django . test . TestCase ) : <EOL> def assertPathParametersEqual ( self , first : PathParameters , second : PathParameters ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . not_found , second . not_found ) <EOL> @ staticmethod <EOL> def simulate_request ( <EOL> path_parameters : dict , <EOL> query_parameters : dict , <EOL> request_headers : dict , <EOL> request_body : dict , <EOL> ) -> HttpResponse : <EOL> return HttpResponse ( ) <EOL> def test_simulate_request ( self ) : <EOL> self . assertIsInstance ( self . simulate_request ( { } , { } , { } , { } ) , HttpResponse ) <EOL> def test_get_path_parameters_constant ( self ) : <EOL> path_parameters = PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , path_parameters <EOL> ) <EOL> def test_get_path_parameters_callable ( self ) : <EOL> def get_path_parameters ( test_case ) : <EOL> return PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = get_path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , get_path_parameters ( self ) <EOL> ) <EOL> def test_get_path_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { } ) <EOL> ) <EOL> def test_get_path_parameters_property ( self ) : <EOL> path_parameters = property ( lambda test_case : PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> self . assertPathParametersEqual ( <EOL> view_test_manager . get_path_parameters ( self ) , PathParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> ) <EOL> def test_get_path_parameters_type_error ( self ) : <EOL> path_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> path_parameters = path_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_path_parameters ( self ) <EOL> def assertQueryParametersEqual ( <EOL> self , first : QueryParameters , second : QueryParameters <EOL> ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self . assertEqual ( first . bad_request , second . bad_request ) <EOL> def test_get_query_parameters_constant ( self ) : <EOL> query_parameters = QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , query_parameters <EOL> ) <EOL> def test_get_query_parameters_callable ( self ) : <EOL> def get_query_parameters ( test_case ) : <EOL> return QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = get_query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , get_query_parameters ( self ) <EOL> ) <EOL> def test_get_query_parameters_none ( self ) : <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , QueryParameters ( ok = { } ) <EOL> ) <EOL> def test_get_query_parameters_property ( self ) : <EOL> query_parameters = property ( lambda test_case : QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) ) <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> self . assertQueryParametersEqual ( <EOL> view_test_manager . get_query_parameters ( self ) , <EOL> QueryParameters ( ok = { \"<STR_LIT>\" : <NUM_LIT> } ) , <EOL> ) <EOL> def test_get_query_parameters_type_error ( self ) : <EOL> query_parameters = \"<STR_LIT>\" <EOL> view_test_manager = ViewTestManager ( <EOL> simulate_request = self . simulate_request , <EOL> query_parameters = query_parameters , <EOL> ) <EOL> with self . assertRaises ( TypeError ) : <EOL> view_test_manager . get_query_parameters ( self ) <EOL> def assertPayloadsEqual ( self , first : Payloads , second : Payloads ) : <EOL> self . assertEqual ( first . ok , second . ok ) <EOL> self", "gt": ". assertEqual ( first . bad_request , second . bad_request )", "repo": "django-ninja-crud"}
